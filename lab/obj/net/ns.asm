
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 bd e3 00 00       	call   80e3ee <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	55                   	push   %ebp
  800034:	89 e5                	mov    %esp,%ebp
  800036:	83 ec 14             	sub    $0x14,%esp
  800039:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  80003c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800042:	50                   	push   %eax
  800043:	e8 b2 a4 00 00       	call   80a4fa <thread_wakeup>
}
  800048:	83 c4 10             	add    $0x10,%esp
  80004b:	c9                   	leave  
  80004c:	c3                   	ret    

0080004d <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  80004d:	55                   	push   %ebp
  80004e:	89 e5                	mov    %esp,%ebp
  800050:	53                   	push   %ebx
  800051:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800054:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800057:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800059:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  80005c:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80005f:	50                   	push   %eax
  800060:	68 94 00 80 00       	push   $0x800094
  800065:	51                   	push   %ecx
  800066:	6a 00                	push   $0x0
  800068:	e8 fb a4 00 00       	call   80a568 <thread_create>
	if (r < 0)
  80006d:	83 c4 10             	add    $0x10,%esp
  800070:	85 c0                	test   %eax,%eax
  800072:	79 1b                	jns    80008f <start_timer+0x42>
		panic("cannot create timer thread: %s", e2s(r));
  800074:	83 ec 0c             	sub    $0xc,%esp
  800077:	50                   	push   %eax
  800078:	e8 1c a8 00 00       	call   80a899 <e2s>
  80007d:	50                   	push   %eax
  80007e:	68 e0 0b 81 00       	push   $0x810be0
  800083:	6a 7a                	push   $0x7a
  800085:	68 15 0d 81 00       	push   $0x810d15
  80008a:	e8 bf e3 00 00       	call   80e44e <_panic>
}
  80008f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800092:	c9                   	leave  
  800093:	c3                   	ret    

00800094 <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  800094:	55                   	push   %ebp
  800095:	89 e5                	mov    %esp,%ebp
  800097:	56                   	push   %esi
  800098:	53                   	push   %ebx
	struct timer_thread *t = (struct timer_thread *) arg;
  800099:	8b 75 08             	mov    0x8(%ebp),%esi

	for (;;) {
		uint32_t cur = sys_time_msec();
  80009c:	e8 ff ef 00 00       	call   80f0a0 <sys_time_msec>
  8000a1:	89 c3                	mov    %eax,%ebx

		lwip_core_lock();
  8000a3:	e8 19 a4 00 00       	call   80a4c1 <lwip_core_lock>
		t->func();
  8000a8:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000ab:	e8 16 a4 00 00       	call   80a4c6 <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  8000b0:	83 ec 04             	sub    $0x4,%esp
  8000b3:	03 1e                	add    (%esi),%ebx
  8000b5:	53                   	push   %ebx
  8000b6:	6a 00                	push   $0x0
  8000b8:	6a 00                	push   $0x0
  8000ba:	e8 52 a6 00 00       	call   80a711 <thread_wait>
  8000bf:	83 c4 10             	add    $0x10,%esp
  8000c2:	eb d8                	jmp    80009c <net_timer+0x8>

008000c4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000c4:	55                   	push   %ebp
  8000c5:	89 e5                	mov    %esp,%ebp
  8000c7:	57                   	push   %edi
  8000c8:	56                   	push   %esi
  8000c9:	53                   	push   %ebx
  8000ca:	83 ec 7c             	sub    $0x7c,%esp
  8000cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000d0:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  8000d3:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000d6:	0f 87 0b 01 00 00    	ja     8001e7 <serve_thread+0x123>
  8000dc:	8b 03                	mov    (%ebx),%eax
  8000de:	ff 24 85 c0 0d 81 00 	jmp    *0x810dc0(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000e5:	8b 46 04             	mov    0x4(%esi),%eax
  8000e8:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000eb:	83 ec 04             	sub    $0x4,%esp
  8000ee:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000f1:	50                   	push   %eax
  8000f2:	8d 45 84             	lea    -0x7c(%ebp),%eax
  8000f5:	50                   	push   %eax
  8000f6:	ff 36                	pushl  (%esi)
  8000f8:	e8 e5 0d 00 00       	call   800ee2 <lwip_accept>
  8000fd:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  8000ff:	83 c4 0c             	add    $0xc,%esp
  800102:	6a 14                	push   $0x14
  800104:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800107:	50                   	push   %eax
  800108:	56                   	push   %esi
  800109:	e8 30 eb 00 00       	call   80ec3e <memmove>
  80010e:	83 c4 10             	add    $0x10,%esp
  800111:	e9 ec 00 00 00       	jmp    800202 <serve_thread+0x13e>
		break;
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800116:	83 ec 04             	sub    $0x4,%esp
  800119:	ff 76 14             	pushl  0x14(%esi)
  80011c:	8d 46 04             	lea    0x4(%esi),%eax
  80011f:	50                   	push   %eax
  800120:	ff 36                	pushl  (%esi)
  800122:	e8 6a 0f 00 00       	call   801091 <lwip_bind>
  800127:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  800129:	83 c4 10             	add    $0x10,%esp
  80012c:	e9 d1 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800131:	83 ec 08             	sub    $0x8,%esp
  800134:	ff 76 04             	pushl  0x4(%esi)
  800137:	ff 36                	pushl  (%esi)
  800139:	e8 56 1a 00 00       	call   801b94 <lwip_shutdown>
  80013e:	89 c7                	mov    %eax,%edi
		break;
  800140:	83 c4 10             	add    $0x10,%esp
  800143:	e9 ba 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  800148:	83 ec 0c             	sub    $0xc,%esp
  80014b:	ff 36                	pushl  (%esi)
  80014d:	e8 f5 0f 00 00       	call   801147 <lwip_close>
  800152:	89 c7                	mov    %eax,%edi
		break;
  800154:	83 c4 10             	add    $0x10,%esp
  800157:	e9 a6 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80015c:	83 ec 04             	sub    $0x4,%esp
  80015f:	ff 76 14             	pushl  0x14(%esi)
  800162:	8d 46 04             	lea    0x4(%esi),%eax
  800165:	50                   	push   %eax
  800166:	ff 36                	pushl  (%esi)
  800168:	e8 63 10 00 00       	call   8011d0 <lwip_connect>
  80016d:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  80016f:	83 c4 10             	add    $0x10,%esp
  800172:	e9 8b 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  800177:	83 ec 08             	sub    $0x8,%esp
  80017a:	ff 76 04             	pushl  0x4(%esi)
  80017d:	ff 36                	pushl  (%esi)
  80017f:	e8 02 11 00 00       	call   801286 <lwip_listen>
  800184:	89 c7                	mov    %eax,%edi
		break;
  800186:	83 c4 10             	add    $0x10,%esp
  800189:	eb 77                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  80018b:	ff 76 08             	pushl  0x8(%esi)
  80018e:	ff 76 04             	pushl  0x4(%esi)
  800191:	56                   	push   %esi
  800192:	ff 36                	pushl  (%esi)
  800194:	e8 c3 13 00 00       	call   80155c <lwip_recv>
  800199:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  80019b:	83 c4 10             	add    $0x10,%esp
  80019e:	eb 62                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001a0:	ff 76 08             	pushl  0x8(%esi)
  8001a3:	ff 76 04             	pushl  0x4(%esi)
  8001a6:	8d 46 0c             	lea    0xc(%esi),%eax
  8001a9:	50                   	push   %eax
  8001aa:	ff 36                	pushl  (%esi)
  8001ac:	e8 15 15 00 00       	call   8016c6 <lwip_send>
  8001b1:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  8001b3:	83 c4 10             	add    $0x10,%esp
  8001b6:	eb 4a                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8001b8:	83 ec 04             	sub    $0x4,%esp
  8001bb:	ff 76 08             	pushl  0x8(%esi)
  8001be:	ff 76 04             	pushl  0x4(%esi)
  8001c1:	ff 36                	pushl  (%esi)
  8001c3:	e8 91 15 00 00       	call   801759 <lwip_socket>
  8001c8:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  8001ca:	83 c4 10             	add    $0x10,%esp
  8001cd:	eb 33                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  8001cf:	83 ec 08             	sub    $0x8,%esp
  8001d2:	56                   	push   %esi
  8001d3:	68 00 b2 b3 00       	push   $0xb3b200
  8001d8:	e8 ab a7 00 00       	call   80a988 <jif_input>
		r = 0;
		break;
  8001dd:	83 c4 10             	add    $0x10,%esp
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
				req->socket.req_protocol);
		break;
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
		r = 0;
  8001e0:	bf 00 00 00 00       	mov    $0x0,%edi
		break;
  8001e5:	eb 3d                	jmp    800224 <serve_thread+0x160>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  8001e7:	83 ec 04             	sub    $0x4,%esp
  8001ea:	56                   	push   %esi
  8001eb:	ff 73 04             	pushl  0x4(%ebx)
  8001ee:	68 00 0c 81 00       	push   $0x810c00
  8001f3:	e8 2f e3 00 00       	call   80e527 <cprintf>
		r = -E_INVAL;
		break;
  8001f8:	83 c4 10             	add    $0x10,%esp
		jif_input(&nif, (void *)&req->pkt);
		r = 0;
		break;
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
  8001fb:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		break;
  800200:	eb 22                	jmp    800224 <serve_thread+0x160>
	}

	if (r == -1) {
  800202:	83 ff ff             	cmp    $0xffffffff,%edi
  800205:	75 1d                	jne    800224 <serve_thread+0x160>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800207:	ff 33                	pushl  (%ebx)
  800209:	68 20 0d 81 00       	push   $0x810d20
  80020e:	6a 64                	push   $0x64
  800210:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800213:	56                   	push   %esi
  800214:	e8 40 e8 00 00       	call   80ea59 <snprintf>
		perror(buf);
  800219:	89 34 24             	mov    %esi,(%esp)
  80021c:	e8 54 a6 00 00       	call   80a875 <perror>
  800221:	83 c4 10             	add    $0x10,%esp
	}

	if (args->reqno != NSREQ_INPUT)
  800224:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800227:	74 10                	je     800239 <serve_thread+0x175>
		ipc_send(args->whom, r, 0, 0);
  800229:	6a 00                	push   $0x0
  80022b:	6a 00                	push   $0x0
  80022d:	57                   	push   %edi
  80022e:	ff 73 04             	pushl  0x4(%ebx)
  800231:	e8 04 f2 00 00       	call   80f43a <ipc_send>
  800236:	83 c4 10             	add    $0x10,%esp

	put_buffer(args->req);
  800239:	8b 53 08             	mov    0x8(%ebx),%edx
}

static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  80023c:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  800242:	c1 e8 0c             	shr    $0xc,%eax
  800245:	c6 80 00 50 81 00 00 	movb   $0x0,0x815000(%eax)

	if (args->reqno != NSREQ_INPUT)
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
	sys_page_unmap(0, (void*) args->req);
  80024c:	83 ec 08             	sub    $0x8,%esp
  80024f:	52                   	push   %edx
  800250:	6a 00                	push   $0x0
  800252:	e8 dd ec 00 00       	call   80ef34 <sys_page_unmap>
	free(args);
  800257:	89 1c 24             	mov    %ebx,(%esp)
  80025a:	e8 cd fe 00 00       	call   81012c <free>
}
  80025f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800262:	5b                   	pop    %ebx
  800263:	5e                   	pop    %esi
  800264:	5f                   	pop    %edi
  800265:	5d                   	pop    %ebp
  800266:	c3                   	ret    

00800267 <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800267:	55                   	push   %ebp
  800268:	89 e5                	mov    %esp,%ebp
  80026a:	56                   	push   %esi
  80026b:	53                   	push   %ebx
  80026c:	83 ec 10             	sub    $0x10,%esp
  80026f:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  800272:	e8 4a a2 00 00       	call   80a4c1 <lwip_core_lock>

	uint32_t done = 0;
  800277:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  80027e:	83 ec 08             	sub    $0x8,%esp
  800281:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  800284:	53                   	push   %ebx
  800285:	68 33 00 80 00       	push   $0x800033
  80028a:	e8 c3 21 00 00       	call   802452 <tcpip_init>
	lwip_core_unlock();
  80028f:	e8 32 a2 00 00       	call   80a4c6 <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  800294:	83 c4 0c             	add    $0xc,%esp
  800297:	6a ff                	push   $0xffffffff
  800299:	6a 00                	push   $0x0
  80029b:	53                   	push   %ebx
  80029c:	e8 70 a4 00 00       	call   80a711 <thread_wait>
	lwip_core_lock();
  8002a1:	e8 1b a2 00 00       	call   80a4c1 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  8002a6:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002a9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002af:	8b 45 10             	mov    0x10(%ebp),%eax
  8002b2:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002b5:	83 c4 0c             	add    $0xc,%esp
  8002b8:	68 78 65 80 00       	push   $0x806578
  8002bd:	68 7c aa 80 00       	push   $0x80aa7c
  8002c2:	68 14 50 81 00       	push   $0x815014
  8002c7:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002ca:	50                   	push   %eax
  8002cb:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002ce:	50                   	push   %eax
  8002cf:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002d2:	50                   	push   %eax
  8002d3:	68 00 b2 b3 00       	push   $0xb3b200
  8002d8:	e8 5d 43 00 00       	call   80463a <netif_add>
  8002dd:	83 c4 20             	add    $0x20,%esp
  8002e0:	85 c0                	test   %eax,%eax
  8002e2:	75 14                	jne    8002f8 <serve_init+0x91>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  8002e4:	83 ec 04             	sub    $0x4,%esp
  8002e7:	68 24 0c 81 00       	push   $0x810c24
  8002ec:	6a 5c                	push   $0x5c
  8002ee:	68 15 0d 81 00       	push   $0x810d15
  8002f3:	e8 56 e1 00 00       	call   80e44e <_panic>

	netif_set_default(nif);
  8002f8:	83 ec 0c             	sub    $0xc,%esp
  8002fb:	68 00 b2 b3 00       	push   $0xb3b200
  800300:	e8 eb 43 00 00       	call   8046f0 <netif_set_default>
	netif_set_up(nif);
  800305:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  80030c:	e8 ec 43 00 00       	call   8046fd <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  800311:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800318:	b9 2f 0d 81 00       	mov    $0x810d2f,%ecx
  80031d:	ba 45 94 80 00       	mov    $0x809445,%edx
  800322:	b8 34 50 81 00       	mov    $0x815034,%eax
  800327:	e8 21 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  80032c:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  800333:	b9 39 0d 81 00       	mov    $0x810d39,%ecx
  800338:	ba f6 56 80 00       	mov    $0x8056f6,%edx
  80033d:	b8 28 50 81 00       	mov    $0x815028,%eax
  800342:	e8 06 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800347:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  80034e:	b9 45 0d 81 00       	mov    $0x810d45,%ecx
  800353:	ba f0 5c 80 00       	mov    $0x805cf0,%edx
  800358:	b8 1c 50 81 00       	mov    $0x81501c,%eax
  80035d:	e8 eb fc ff ff       	call   80004d <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800362:	89 34 24             	mov    %esi,(%esp)
  800365:	e8 d3 72 00 00       	call   80763d <inet_ntoa>
  80036a:	50                   	push   %eax
  80036b:	0f b6 05 2a b2 b3 00 	movzbl 0xb3b22a,%eax
  800372:	50                   	push   %eax
  800373:	0f b6 05 29 b2 b3 00 	movzbl 0xb3b229,%eax
  80037a:	50                   	push   %eax
  80037b:	0f b6 05 28 b2 b3 00 	movzbl 0xb3b228,%eax
  800382:	50                   	push   %eax
  800383:	0f b6 05 27 b2 b3 00 	movzbl 0xb3b227,%eax
  80038a:	50                   	push   %eax
  80038b:	0f b6 05 26 b2 b3 00 	movzbl 0xb3b226,%eax
  800392:	50                   	push   %eax
  800393:	0f b6 05 25 b2 b3 00 	movzbl 0xb3b225,%eax
  80039a:	50                   	push   %eax
  80039b:	68 44 0c 81 00       	push   $0x810c44
  8003a0:	e8 82 e1 00 00       	call   80e527 <cprintf>
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  8003a5:	83 c4 30             	add    $0x30,%esp
  8003a8:	e8 19 a1 00 00       	call   80a4c6 <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  8003ad:	83 ec 0c             	sub    $0xc,%esp
  8003b0:	68 51 0d 81 00       	push   $0x810d51
  8003b5:	e8 6d e1 00 00       	call   80e527 <cprintf>
}
  8003ba:	83 c4 10             	add    $0x10,%esp
  8003bd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003c0:	5b                   	pop    %ebx
  8003c1:	5e                   	pop    %esi
  8003c2:	5d                   	pop    %ebp
  8003c3:	c3                   	ret    

008003c4 <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  8003c4:	55                   	push   %ebp
  8003c5:	89 e5                	mov    %esp,%ebp
  8003c7:	57                   	push   %edi
  8003c8:	56                   	push   %esi
  8003c9:	53                   	push   %ebx
  8003ca:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003cd:	8d 7d e0             	lea    -0x20(%ebp),%edi

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8003d0:	bb 00 00 00 00       	mov    $0x0,%ebx
  8003d5:	eb 08                	jmp    8003df <serve+0x1b>
			thread_yield();
  8003d7:	e8 b2 a2 00 00       	call   80a68e <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8003dc:	83 c3 01             	add    $0x1,%ebx
  8003df:	e8 35 a1 00 00       	call   80a519 <thread_wakeups_pending>
  8003e4:	85 c0                	test   %eax,%eax
  8003e6:	74 05                	je     8003ed <serve+0x29>
  8003e8:	83 fb 1f             	cmp    $0x1f,%ebx
  8003eb:	7e ea                	jle    8003d7 <serve+0x13>
			thread_yield();

		perm = 0;
  8003ed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8003f4:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8003f9:	80 b8 00 50 81 00 00 	cmpb   $0x0,0x815000(%eax)
  800400:	74 0a                	je     80040c <serve+0x48>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  800402:	83 c0 01             	add    $0x1,%eax
  800405:	83 f8 14             	cmp    $0x14,%eax
  800408:	75 ef                	jne    8003f9 <serve+0x35>
  80040a:	eb 05                	jmp    800411 <serve+0x4d>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  80040c:	83 f8 14             	cmp    $0x14,%eax
  80040f:	75 14                	jne    800425 <serve+0x61>
		panic("NS: buffer overflow");
  800411:	83 ec 04             	sub    $0x4,%esp
  800414:	68 6a 0d 81 00       	push   $0x810d6a
  800419:	6a 3f                	push   $0x3f
  80041b:	68 15 0d 81 00       	push   $0x810d15
  800420:	e8 29 e0 00 00       	call   80e44e <_panic>
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  800425:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  80042b:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  80042e:	c6 80 00 50 81 00 01 	movb   $0x1,0x815000(%eax)
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800435:	83 ec 04             	sub    $0x4,%esp
  800438:	57                   	push   %edi
  800439:	53                   	push   %ebx
  80043a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80043d:	50                   	push   %eax
  80043e:	e8 90 ef 00 00       	call   80f3d3 <ipc_recv>
  800443:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800445:	83 c4 10             	add    $0x10,%esp
  800448:	83 f8 0c             	cmp    $0xc,%eax
  80044b:	75 5e                	jne    8004ab <serve+0xe7>
			process_timer(whom);
  80044d:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800450:	3b 35 18 50 81 00    	cmp    0x815018,%esi
  800456:	74 13                	je     80046b <serve+0xa7>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  800458:	83 ec 08             	sub    $0x8,%esp
  80045b:	56                   	push   %esi
  80045c:	68 80 0c 81 00       	push   $0x810c80
  800461:	e8 c1 e0 00 00       	call   80e527 <cprintf>
  800466:	83 c4 10             	add    $0x10,%esp
  800469:	eb 2b                	jmp    800496 <serve+0xd2>
		return;
	}

	start = sys_time_msec();
  80046b:	e8 30 ec 00 00       	call   80f0a0 <sys_time_msec>
  800470:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800473:	e8 16 a2 00 00       	call   80a68e <thread_yield>
	now = sys_time_msec();
  800478:	e8 23 ec 00 00       	call   80f0a0 <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  80047d:	6a 00                	push   $0x0
  80047f:	6a 00                	push   $0x0
  800481:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800484:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  80048a:	29 c2                	sub    %eax,%edx
  80048c:	52                   	push   %edx
  80048d:	56                   	push   %esi
  80048e:	e8 a7 ef 00 00       	call   80f43a <ipc_send>
  800493:	83 c4 10             	add    $0x10,%esp
}

static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  800496:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  80049c:	c1 eb 0c             	shr    $0xc,%ebx
  80049f:	c6 83 00 50 81 00 00 	movb   $0x0,0x815000(%ebx)

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
			continue;
  8004a6:	e9 25 ff ff ff       	jmp    8003d0 <serve+0xc>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  8004ab:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  8004af:	75 18                	jne    8004c9 <serve+0x105>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  8004b1:	83 ec 08             	sub    $0x8,%esp
  8004b4:	ff 75 e4             	pushl  -0x1c(%ebp)
  8004b7:	68 bc 0c 81 00       	push   $0x810cbc
  8004bc:	e8 66 e0 00 00       	call   80e527 <cprintf>
			continue; // just leave it hanging...
  8004c1:	83 c4 10             	add    $0x10,%esp
  8004c4:	e9 07 ff ff ff       	jmp    8003d0 <serve+0xc>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  8004c9:	83 ec 0c             	sub    $0xc,%esp
  8004cc:	6a 0c                	push   $0xc
  8004ce:	e8 07 fd 00 00       	call   8101da <malloc>
		if (!args)
  8004d3:	83 c4 10             	add    $0x10,%esp
  8004d6:	85 c0                	test   %eax,%eax
  8004d8:	75 17                	jne    8004f1 <serve+0x12d>
			panic("could not allocate thread args structure");
  8004da:	83 ec 04             	sub    $0x4,%esp
  8004dd:	68 ec 0c 81 00       	push   $0x810cec
  8004e2:	68 27 01 00 00       	push   $0x127
  8004e7:	68 15 0d 81 00       	push   $0x810d15
  8004ec:	e8 5d df 00 00       	call   80e44e <_panic>

		args->reqno = reqno;
  8004f1:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  8004f3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8004f6:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8004f9:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8004fc:	50                   	push   %eax
  8004fd:	68 c4 00 80 00       	push   $0x8000c4
  800502:	68 7e 0d 81 00       	push   $0x810d7e
  800507:	6a 00                	push   $0x0
  800509:	e8 5a a0 00 00       	call   80a568 <thread_create>
		thread_yield(); // let the thread created run
  80050e:	e8 7b a1 00 00       	call   80a68e <thread_yield>
  800513:	83 c4 10             	add    $0x10,%esp
  800516:	e9 b5 fe ff ff       	jmp    8003d0 <serve+0xc>

0080051b <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  80051b:	55                   	push   %ebp
  80051c:	89 e5                	mov    %esp,%ebp
  80051e:	56                   	push   %esi
  80051f:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  800520:	83 ec 0c             	sub    $0xc,%esp
  800523:	68 8b 0d 81 00       	push   $0x810d8b
  800528:	e8 c2 73 00 00       	call   8078ef <inet_addr>
  80052d:	89 c6                	mov    %eax,%esi
  80052f:	c7 04 24 94 0d 81 00 	movl   $0x810d94,(%esp)
  800536:	e8 b4 73 00 00       	call   8078ef <inet_addr>
  80053b:	89 c3                	mov    %eax,%ebx
  80053d:	c7 04 24 a2 0d 81 00 	movl   $0x810da2,(%esp)
  800544:	e8 a6 73 00 00       	call   8078ef <inet_addr>
  800549:	83 c4 0c             	add    $0xc,%esp
  80054c:	56                   	push   %esi
  80054d:	53                   	push   %ebx
  80054e:	50                   	push   %eax
  80054f:	e8 13 fd ff ff       	call   800267 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800554:	e8 6b fe ff ff       	call   8003c4 <serve>

00800559 <umain>:
}

void
umain(int argc, char **argv)
{
  800559:	55                   	push   %ebp
  80055a:	89 e5                	mov    %esp,%ebp
  80055c:	53                   	push   %ebx
  80055d:	83 ec 04             	sub    $0x4,%esp
	envid_t ns_envid = sys_getenvid();
  800560:	e8 0c e9 00 00       	call   80ee71 <sys_getenvid>
  800565:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800567:	c7 05 e8 42 81 00 1d 	movl   $0x81371d,0x8142e8
  80056e:	37 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800571:	e8 a6 ec 00 00       	call   80f21c <fork>
  800576:	a3 18 50 81 00       	mov    %eax,0x815018
	if (timer_envid < 0)
  80057b:	85 c0                	test   %eax,%eax
  80057d:	79 17                	jns    800596 <umain+0x3d>
		panic("error forking");
  80057f:	83 ec 04             	sub    $0x4,%esp
  800582:	68 ac 0d 81 00       	push   $0x810dac
  800587:	68 44 01 00 00       	push   $0x144
  80058c:	68 15 0d 81 00       	push   $0x810d15
  800591:	e8 b8 de 00 00       	call   80e44e <_panic>
	else if (timer_envid == 0) {
  800596:	85 c0                	test   %eax,%eax
  800598:	75 16                	jne    8005b0 <umain+0x57>
		timer(ns_envid, TIMER_INTERVAL);
  80059a:	83 ec 08             	sub    $0x8,%esp
  80059d:	68 fa 00 00 00       	push   $0xfa
  8005a2:	53                   	push   %ebx
  8005a3:	e8 96 00 00 00       	call   80063e <timer>
		return;
  8005a8:	83 c4 10             	add    $0x10,%esp
  8005ab:	e9 89 00 00 00       	jmp    800639 <umain+0xe0>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8005b0:	e8 67 ec 00 00       	call   80f21c <fork>
	if (input_envid < 0)
  8005b5:	85 c0                	test   %eax,%eax
  8005b7:	79 17                	jns    8005d0 <umain+0x77>
		panic("error forking");
  8005b9:	83 ec 04             	sub    $0x4,%esp
  8005bc:	68 ac 0d 81 00       	push   $0x810dac
  8005c1:	68 4e 01 00 00       	push   $0x14e
  8005c6:	68 15 0d 81 00       	push   $0x810d15
  8005cb:	e8 7e de 00 00       	call   80e44e <_panic>
	else if (input_envid == 0) {
  8005d0:	85 c0                	test   %eax,%eax
  8005d2:	75 0e                	jne    8005e2 <umain+0x89>
		input(ns_envid);
  8005d4:	83 ec 0c             	sub    $0xc,%esp
  8005d7:	53                   	push   %ebx
  8005d8:	e8 50 01 00 00       	call   80072d <input>
		return;
  8005dd:	83 c4 10             	add    $0x10,%esp
  8005e0:	eb 57                	jmp    800639 <umain+0xe0>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005e2:	e8 35 ec 00 00       	call   80f21c <fork>
  8005e7:	a3 14 50 81 00       	mov    %eax,0x815014
	if (output_envid < 0)
  8005ec:	85 c0                	test   %eax,%eax
  8005ee:	79 17                	jns    800607 <umain+0xae>
		panic("error forking");
  8005f0:	83 ec 04             	sub    $0x4,%esp
  8005f3:	68 ac 0d 81 00       	push   $0x810dac
  8005f8:	68 58 01 00 00       	push   $0x158
  8005fd:	68 15 0d 81 00       	push   $0x810d15
  800602:	e8 47 de 00 00       	call   80e44e <_panic>
	else if (output_envid == 0) {
  800607:	85 c0                	test   %eax,%eax
  800609:	75 0e                	jne    800619 <umain+0xc0>
		output(ns_envid);
  80060b:	83 ec 0c             	sub    $0xc,%esp
  80060e:	53                   	push   %ebx
  80060f:	e8 8a 01 00 00       	call   80079e <output>
		return;
  800614:	83 c4 10             	add    $0x10,%esp
  800617:	eb 20                	jmp    800639 <umain+0xe0>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  800619:	e8 ad 9e 00 00       	call   80a4cb <thread_init>
	thread_create(0, "main", tmain, 0);
  80061e:	6a 00                	push   $0x0
  800620:	68 1b 05 80 00       	push   $0x80051b
  800625:	68 ba 0d 81 00       	push   $0x810dba
  80062a:	6a 00                	push   $0x0
  80062c:	e8 37 9f 00 00       	call   80a568 <thread_create>
	thread_yield();
  800631:	e8 58 a0 00 00       	call   80a68e <thread_yield>
  800636:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  800639:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80063c:	c9                   	leave  
  80063d:	c3                   	ret    

0080063e <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  80063e:	55                   	push   %ebp
  80063f:	89 e5                	mov    %esp,%ebp
  800641:	57                   	push   %edi
  800642:	56                   	push   %esi
  800643:	53                   	push   %ebx
  800644:	83 ec 1c             	sub    $0x1c,%esp
  800647:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80064a:	e8 51 ea 00 00       	call   80f0a0 <sys_time_msec>
  80064f:	03 45 0c             	add    0xc(%ebp),%eax
  800652:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  800654:	c7 05 e8 42 81 00 ec 	movl   $0x810dec,0x8142e8
  80065b:	0d 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80065e:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  800661:	eb 05                	jmp    800668 <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
  800663:	e8 28 e8 00 00       	call   80ee90 <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  800668:	e8 33 ea 00 00       	call   80f0a0 <sys_time_msec>
  80066d:	89 c2                	mov    %eax,%edx
  80066f:	85 c0                	test   %eax,%eax
  800671:	78 04                	js     800677 <timer+0x39>
  800673:	39 c3                	cmp    %eax,%ebx
  800675:	77 ec                	ja     800663 <timer+0x25>
			sys_yield();
		}
		if (r < 0)
  800677:	85 c0                	test   %eax,%eax
  800679:	79 12                	jns    80068d <timer+0x4f>
			panic("sys_time_msec: %e", r);
  80067b:	52                   	push   %edx
  80067c:	68 f5 0d 81 00       	push   $0x810df5
  800681:	6a 0f                	push   $0xf
  800683:	68 07 0e 81 00       	push   $0x810e07
  800688:	e8 c1 dd 00 00       	call   80e44e <_panic>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  80068d:	6a 00                	push   $0x0
  80068f:	6a 00                	push   $0x0
  800691:	6a 0c                	push   $0xc
  800693:	56                   	push   %esi
  800694:	e8 a1 ed 00 00       	call   80f43a <ipc_send>
  800699:	83 c4 10             	add    $0x10,%esp

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80069c:	83 ec 04             	sub    $0x4,%esp
  80069f:	6a 00                	push   $0x0
  8006a1:	6a 00                	push   $0x0
  8006a3:	57                   	push   %edi
  8006a4:	e8 2a ed 00 00       	call   80f3d3 <ipc_recv>
  8006a9:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8006ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8006ae:	83 c4 10             	add    $0x10,%esp
  8006b1:	39 f0                	cmp    %esi,%eax
  8006b3:	74 13                	je     8006c8 <timer+0x8a>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8006b5:	83 ec 08             	sub    $0x8,%esp
  8006b8:	50                   	push   %eax
  8006b9:	68 14 0e 81 00       	push   $0x810e14
  8006be:	e8 64 de 00 00       	call   80e527 <cprintf>
				continue;
  8006c3:	83 c4 10             	add    $0x10,%esp
  8006c6:	eb d4                	jmp    80069c <timer+0x5e>
			}

			stop = sys_time_msec() + to;
  8006c8:	e8 d3 e9 00 00       	call   80f0a0 <sys_time_msec>
  8006cd:	01 c3                	add    %eax,%ebx
  8006cf:	eb 97                	jmp    800668 <timer+0x2a>

008006d1 <sleep>:
extern union Nsipc nsipcbuf;


void
sleep(int msec)
{
  8006d1:	55                   	push   %ebp
  8006d2:	89 e5                	mov    %esp,%ebp
  8006d4:	53                   	push   %ebx
  8006d5:	83 ec 04             	sub    $0x4,%esp
    unsigned now = sys_time_msec();
  8006d8:	e8 c3 e9 00 00       	call   80f0a0 <sys_time_msec>
    unsigned end = now + msec;
  8006dd:	89 c3                	mov    %eax,%ebx
  8006df:	03 5d 08             	add    0x8(%ebp),%ebx

    if ((int)now < 0 && (int)now > -MAXERROR)
  8006e2:	89 c2                	mov    %eax,%edx
  8006e4:	c1 ea 1f             	shr    $0x1f,%edx
  8006e7:	84 d2                	test   %dl,%dl
  8006e9:	74 17                	je     800702 <sleep+0x31>
  8006eb:	83 f8 f1             	cmp    $0xfffffff1,%eax
  8006ee:	7c 12                	jl     800702 <sleep+0x31>
        panic("sys_time_msec: %e", (int)now);
  8006f0:	50                   	push   %eax
  8006f1:	68 f5 0d 81 00       	push   $0x810df5
  8006f6:	6a 0d                	push   $0xd
  8006f8:	68 4f 0e 81 00       	push   $0x810e4f
  8006fd:	e8 4c dd 00 00       	call   80e44e <_panic>
    if (end < now)
  800702:	39 d8                	cmp    %ebx,%eax
  800704:	76 19                	jbe    80071f <sleep+0x4e>
        panic("sleep: wrap");
  800706:	83 ec 04             	sub    $0x4,%esp
  800709:	68 5b 0e 81 00       	push   $0x810e5b
  80070e:	6a 0f                	push   $0xf
  800710:	68 4f 0e 81 00       	push   $0x810e4f
  800715:	e8 34 dd 00 00       	call   80e44e <_panic>

    while (sys_time_msec() < end)
        sys_yield();
  80071a:	e8 71 e7 00 00       	call   80ee90 <sys_yield>
    if ((int)now < 0 && (int)now > -MAXERROR)
        panic("sys_time_msec: %e", (int)now);
    if (end < now)
        panic("sleep: wrap");

    while (sys_time_msec() < end)
  80071f:	e8 7c e9 00 00       	call   80f0a0 <sys_time_msec>
  800724:	39 c3                	cmp    %eax,%ebx
  800726:	77 f2                	ja     80071a <sleep+0x49>
        sys_yield();
}
  800728:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80072b:	c9                   	leave  
  80072c:	c3                   	ret    

0080072d <input>:

void
input(envid_t ns_envid)
{
  80072d:	55                   	push   %ebp
  80072e:	89 e5                	mov    %esp,%ebp
  800730:	57                   	push   %edi
  800731:	56                   	push   %esi
  800732:	53                   	push   %ebx
  800733:	81 ec 0c 06 00 00    	sub    $0x60c,%esp
  800739:	8b 7d 08             	mov    0x8(%ebp),%edi
	binaryname = "ns_input";
  80073c:	c7 05 e8 42 81 00 67 	movl   $0x810e67,0x8142e8
  800743:	0e 81 00 
	size_t len;
    char rev_buf[1520];
    size_t i = 0;
    while(1) {

        while (sys_e1000_try_recv(rev_buf, &len) < 0) {
  800746:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  800749:	8d 9d f4 f9 ff ff    	lea    -0x60c(%ebp),%ebx
  80074f:	eb 05                	jmp    800756 <input+0x29>
            sys_yield();    
  800751:	e8 3a e7 00 00       	call   80ee90 <sys_yield>
	size_t len;
    char rev_buf[1520];
    size_t i = 0;
    while(1) {

        while (sys_e1000_try_recv(rev_buf, &len) < 0) {
  800756:	83 ec 08             	sub    $0x8,%esp
  800759:	56                   	push   %esi
  80075a:	53                   	push   %ebx
  80075b:	e8 a1 e9 00 00       	call   80f101 <sys_e1000_try_recv>
  800760:	83 c4 10             	add    $0x10,%esp
  800763:	85 c0                	test   %eax,%eax
  800765:	78 ea                	js     800751 <input+0x24>
            sys_yield();    
        }

        memcpy(nsipcbuf.pkt.jp_data, rev_buf, len);
  800767:	83 ec 04             	sub    $0x4,%esp
  80076a:	ff 75 e4             	pushl  -0x1c(%ebp)
  80076d:	53                   	push   %ebx
  80076e:	68 04 d0 b3 00       	push   $0xb3d004
  800773:	e8 2e e5 00 00       	call   80eca6 <memcpy>
        nsipcbuf.pkt.jp_len = len;
  800778:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80077b:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
        
        ipc_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_P|PTE_U);
  800780:	6a 05                	push   $0x5
  800782:	68 00 d0 b3 00       	push   $0xb3d000
  800787:	6a 0a                	push   $0xa
  800789:	57                   	push   %edi
  80078a:	e8 ab ec 00 00       	call   80f43a <ipc_send>
        sleep(50);
  80078f:	83 c4 14             	add    $0x14,%esp
  800792:	6a 32                	push   $0x32
  800794:	e8 38 ff ff ff       	call   8006d1 <sleep>
    }
  800799:	83 c4 10             	add    $0x10,%esp
  80079c:	eb b8                	jmp    800756 <input+0x29>

0080079e <output>:



void
output(envid_t ns_envid)
{
  80079e:	55                   	push   %ebp
  80079f:	89 e5                	mov    %esp,%ebp
  8007a1:	56                   	push   %esi
  8007a2:	53                   	push   %ebx
  8007a3:	83 ec 10             	sub    $0x10,%esp
	binaryname = "ns_output";
  8007a6:	c7 05 e8 42 81 00 70 	movl   $0x810e70,0x8142e8
  8007ad:	0e 81 00 
	uint32_t whom;
    int perm;
    int32_t req;

    while (1) {
        req = ipc_recv((envid_t *)&whom, &nsipcbuf, &perm);
  8007b0:	8d 75 f0             	lea    -0x10(%ebp),%esi
  8007b3:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8007b6:	83 ec 04             	sub    $0x4,%esp
  8007b9:	56                   	push   %esi
  8007ba:	68 00 d0 b3 00       	push   $0xb3d000
  8007bf:	53                   	push   %ebx
  8007c0:	e8 0e ec 00 00       	call   80f3d3 <ipc_recv>
        if (req != NSREQ_OUTPUT) {
  8007c5:	83 c4 10             	add    $0x10,%esp
  8007c8:	83 f8 0b             	cmp    $0xb,%eax
  8007cb:	75 e9                	jne    8007b6 <output+0x18>
  8007cd:	eb 05                	jmp    8007d4 <output+0x36>
            continue;
        }
        while (sys_e1000_try_send(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len) < 0) {
            sys_yield();
  8007cf:	e8 bc e6 00 00       	call   80ee90 <sys_yield>
    while (1) {
        req = ipc_recv((envid_t *)&whom, &nsipcbuf, &perm);
        if (req != NSREQ_OUTPUT) {
            continue;
        }
        while (sys_e1000_try_send(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len) < 0) {
  8007d4:	83 ec 08             	sub    $0x8,%esp
  8007d7:	ff 35 00 d0 b3 00    	pushl  0xb3d000
  8007dd:	68 04 d0 b3 00       	push   $0xb3d004
  8007e2:	e8 d8 e8 00 00       	call   80f0bf <sys_e1000_try_send>
  8007e7:	83 c4 10             	add    $0x10,%esp
  8007ea:	85 c0                	test   %eax,%eax
  8007ec:	78 e1                	js     8007cf <output+0x31>
  8007ee:	eb c6                	jmp    8007b6 <output+0x18>

008007f0 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  8007f0:	55                   	push   %ebp
  8007f1:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  8007f3:	83 f8 1f             	cmp    $0x1f,%eax
  8007f6:	76 11                	jbe    800809 <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  8007f8:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  8007ff:	00 00 00 
    return NULL;
  800802:	b8 00 00 00 00       	mov    $0x0,%eax
  800807:	eb 30                	jmp    800839 <get_socket+0x49>
  }

  sock = &sockets[s];
  800809:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  800810:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  800813:	8d 0c 8d 60 50 81 00 	lea    0x815060(,%ecx,4),%ecx

  if (!sock->conn) {
  80081a:	01 c2                	add    %eax,%edx
  80081c:	83 3c 95 60 50 81 00 	cmpl   $0x0,0x815060(,%edx,4)
  800823:	00 
  800824:	75 11                	jne    800837 <get_socket+0x47>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  800826:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  80082d:	00 00 00 
    return NULL;
  800830:	b8 00 00 00 00       	mov    $0x0,%eax
  800835:	eb 02                	jmp    800839 <get_socket+0x49>
  }

  return sock;
  800837:	89 c8                	mov    %ecx,%eax
}
  800839:	5d                   	pop    %ebp
  80083a:	c3                   	ret    

0080083b <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  80083b:	55                   	push   %ebp
  80083c:	89 e5                	mov    %esp,%ebp
  80083e:	57                   	push   %edi
  80083f:	56                   	push   %esi
  800840:	53                   	push   %ebx
  800841:	83 ec 40             	sub    $0x40,%esp
  800844:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800847:	89 55 cc             	mov    %edx,-0x34(%ebp)
  80084a:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  80084d:	6a 04                	push   $0x4
  80084f:	6a 00                	push   $0x0
  800851:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800854:	50                   	push   %eax
  800855:	e8 97 e3 00 00       	call   80ebf1 <memset>
  FD_ZERO(&lwriteset);
  80085a:	83 c4 0c             	add    $0xc,%esp
  80085d:	6a 04                	push   $0x4
  80085f:	6a 00                	push   $0x0
  800861:	8d 45 e0             	lea    -0x20(%ebp),%eax
  800864:	50                   	push   %eax
  800865:	e8 87 e3 00 00       	call   80ebf1 <memset>
  FD_ZERO(&lexceptset);
  80086a:	83 c4 0c             	add    $0xc,%esp
  80086d:	6a 04                	push   $0x4
  80086f:	6a 00                	push   $0x0
  800871:	8d 45 dc             	lea    -0x24(%ebp),%eax
  800874:	50                   	push   %eax
  800875:	e8 77 e3 00 00       	call   80ebf1 <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  80087a:	83 c4 10             	add    $0x10,%esp
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  int i, nready = 0;
  80087d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800884:	bf 00 00 00 00       	mov    $0x0,%edi
  800889:	e9 80 00 00 00       	jmp    80090e <lwip_selscan+0xd3>
    if (FD_ISSET(i, readset)) {
  80088e:	8d 5f 07             	lea    0x7(%edi),%ebx
  800891:	85 ff                	test   %edi,%edi
  800893:	0f 49 df             	cmovns %edi,%ebx
  800896:	c1 fb 03             	sar    $0x3,%ebx
  800899:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  80089c:	89 fe                	mov    %edi,%esi
  80089e:	83 e6 07             	and    $0x7,%esi
  8008a1:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8008a4:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8008a8:	0f a3 f0             	bt     %esi,%eax
  8008ab:	73 2c                	jae    8008d9 <lwip_selscan+0x9e>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  8008ad:	89 f8                	mov    %edi,%eax
  8008af:	e8 3c ff ff ff       	call   8007f0 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8008b4:	85 c0                	test   %eax,%eax
  8008b6:	74 21                	je     8008d9 <lwip_selscan+0x9e>
  8008b8:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8008bc:	75 07                	jne    8008c5 <lwip_selscan+0x8a>
  8008be:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8008c3:	74 14                	je     8008d9 <lwip_selscan+0x9e>
        FD_SET(i, &lreadset);
  8008c5:	b8 01 00 00 00       	mov    $0x1,%eax
  8008ca:	89 f1                	mov    %esi,%ecx
  8008cc:	d3 e0                	shl    %cl,%eax
  8008ce:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8008d1:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  8008d5:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  8008d9:	8b 45 c8             	mov    -0x38(%ebp),%eax
  8008dc:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8008e0:	0f a3 f0             	bt     %esi,%eax
  8008e3:	73 26                	jae    80090b <lwip_selscan+0xd0>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  8008e5:	89 f8                	mov    %edi,%eax
  8008e7:	e8 04 ff ff ff       	call   8007f0 <get_socket>
      if (p_sock && p_sock->sendevent) {
  8008ec:	85 c0                	test   %eax,%eax
  8008ee:	74 1b                	je     80090b <lwip_selscan+0xd0>
  8008f0:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  8008f5:	74 14                	je     80090b <lwip_selscan+0xd0>
        FD_SET(i, &lwriteset);
  8008f7:	b8 01 00 00 00       	mov    $0x1,%eax
  8008fc:	89 f1                	mov    %esi,%ecx
  8008fe:	d3 e0                	shl    %cl,%eax
  800900:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800903:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  800907:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  80090b:	83 c7 01             	add    $0x1,%edi
  80090e:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  800911:	0f 8c 77 ff ff ff    	jl     80088e <lwip_selscan+0x53>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  800917:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80091a:	8b 55 cc             	mov    -0x34(%ebp),%edx
  80091d:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  80091f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800922:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  800925:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  800927:	83 ec 04             	sub    $0x4,%esp
  80092a:	6a 04                	push   $0x4
  80092c:	6a 00                	push   $0x0
  80092e:	ff 75 08             	pushl  0x8(%ebp)
  800931:	e8 bb e2 00 00       	call   80ebf1 <memset>
  
  return nready;
}
  800936:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  800939:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80093c:	5b                   	pop    %ebx
  80093d:	5e                   	pop    %esi
  80093e:	5f                   	pop    %edi
  80093f:	5d                   	pop    %ebp
  800940:	c3                   	ret    

00800941 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800941:	55                   	push   %ebp
  800942:	89 e5                	mov    %esp,%ebp
  800944:	57                   	push   %edi
  800945:	56                   	push   %esi
  800946:	53                   	push   %ebx
  800947:	83 ec 3c             	sub    $0x3c,%esp
  80094a:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  80094d:	89 cf                	mov    %ecx,%edi
  80094f:	8b 75 08             	mov    0x8(%ebp),%esi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800952:	e8 99 fe ff ff       	call   8007f0 <get_socket>
  if (!sock)
  800957:	85 c0                	test   %eax,%eax
  800959:	0f 84 80 00 00 00    	je     8009df <lwip_getaddrname+0x9e>
  80095f:	89 c3                	mov    %eax,%ebx
    return -1;

  memset(&sin, 0, sizeof(sin));
  800961:	83 ec 04             	sub    $0x4,%esp
  800964:	6a 10                	push   $0x10
  800966:	6a 00                	push   $0x0
  800968:	8d 45 d8             	lea    -0x28(%ebp),%eax
  80096b:	50                   	push   %eax
  80096c:	e8 80 e2 00 00       	call   80ebf1 <memset>
  sin.sin_len = sizeof(sin);
  800971:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  800975:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  800979:	89 f0                	mov    %esi,%eax
  80097b:	0f b6 f0             	movzbl %al,%esi
  80097e:	56                   	push   %esi
  80097f:	8d 45 da             	lea    -0x26(%ebp),%eax
  800982:	50                   	push   %eax
  800983:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  800986:	50                   	push   %eax
  800987:	ff 33                	pushl  (%ebx)
  800989:	e8 f0 a2 00 00       	call   80ac7e <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  80098e:	83 c4 14             	add    $0x14,%esp
  800991:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  800995:	50                   	push   %eax
  800996:	e8 3b 6d 00 00       	call   8076d6 <htons>
  80099b:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  80099f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8009a2:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  8009a5:	83 c4 10             	add    $0x10,%esp
  8009a8:	83 3f 10             	cmpl   $0x10,(%edi)
  8009ab:	76 06                	jbe    8009b3 <lwip_getaddrname+0x72>
    *namelen = sizeof(sin);
  8009ad:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(name, &sin, *namelen);
  8009b3:	83 ec 04             	sub    $0x4,%esp
  8009b6:	ff 37                	pushl  (%edi)
  8009b8:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8009bb:	50                   	push   %eax
  8009bc:	ff 75 c4             	pushl  -0x3c(%ebp)
  8009bf:	e8 e2 e2 00 00       	call   80eca6 <memcpy>
  sock_set_errno(sock, 0);
  8009c4:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8009cb:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8009d2:	00 00 00 
  return 0;
  8009d5:	83 c4 10             	add    $0x10,%esp
  8009d8:	b8 00 00 00 00       	mov    $0x0,%eax
  8009dd:	eb 05                	jmp    8009e4 <lwip_getaddrname+0xa3>
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  if (!sock)
    return -1;
  8009df:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    *namelen = sizeof(sin);

  SMEMCPY(name, &sin, *namelen);
  sock_set_errno(sock, 0);
  return 0;
}
  8009e4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8009e7:	5b                   	pop    %ebx
  8009e8:	5e                   	pop    %esi
  8009e9:	5f                   	pop    %edi
  8009ea:	5d                   	pop    %ebp
  8009eb:	c3                   	ret    

008009ec <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  8009ec:	55                   	push   %ebp
  8009ed:	89 e5                	mov    %esp,%ebp
  8009ef:	57                   	push   %edi
  8009f0:	56                   	push   %esi
  8009f1:	53                   	push   %ebx
  8009f2:	83 ec 1c             	sub    $0x1c,%esp
  8009f5:	8b 7d 08             	mov    0x8(%ebp),%edi
  8009f8:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  8009fb:	85 ff                	test   %edi,%edi
  8009fd:	0f 84 81 01 00 00    	je     800b84 <event_callback+0x198>
    s = conn->socket;
  800a03:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  800a06:	85 db                	test   %ebx,%ebx
  800a08:	79 49                	jns    800a53 <event_callback+0x67>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  800a0a:	83 ec 0c             	sub    $0xc,%esp
  800a0d:	ff 35 44 50 81 00    	pushl  0x815044
  800a13:	e8 ca 46 00 00       	call   8050e2 <sys_sem_wait>
      if (conn->socket < 0) {
  800a18:	8b 47 1c             	mov    0x1c(%edi),%eax
  800a1b:	83 c4 10             	add    $0x10,%esp
  800a1e:	85 c0                	test   %eax,%eax
  800a20:	79 20                	jns    800a42 <event_callback+0x56>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800a22:	85 f6                	test   %esi,%esi
  800a24:	75 06                	jne    800a2c <event_callback+0x40>
          conn->socket--;
  800a26:	83 e8 01             	sub    $0x1,%eax
  800a29:	89 47 1c             	mov    %eax,0x1c(%edi)
        }
        sys_sem_signal(socksem);
  800a2c:	83 ec 0c             	sub    $0xc,%esp
  800a2f:	ff 35 44 50 81 00    	pushl  0x815044
  800a35:	e8 9e 95 00 00       	call   809fd8 <sys_sem_signal>
        return;
  800a3a:	83 c4 10             	add    $0x10,%esp
  800a3d:	e9 42 01 00 00       	jmp    800b84 <event_callback+0x198>
      }
      sys_sem_signal(socksem);
  800a42:	83 ec 0c             	sub    $0xc,%esp
  800a45:	ff 35 44 50 81 00    	pushl  0x815044
  800a4b:	e8 88 95 00 00       	call   809fd8 <sys_sem_signal>
  800a50:	83 c4 10             	add    $0x10,%esp
    }

    sock = get_socket(s);
  800a53:	89 d8                	mov    %ebx,%eax
  800a55:	e8 96 fd ff ff       	call   8007f0 <get_socket>
  800a5a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  800a5d:	85 c0                	test   %eax,%eax
  800a5f:	0f 84 1f 01 00 00    	je     800b84 <event_callback+0x198>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  800a65:	83 ec 0c             	sub    $0xc,%esp
  800a68:	ff 35 40 50 81 00    	pushl  0x815040
  800a6e:	e8 6f 46 00 00       	call   8050e2 <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  800a73:	83 c4 10             	add    $0x10,%esp
  800a76:	83 fe 01             	cmp    $0x1,%esi
  800a79:	74 1b                	je     800a96 <event_callback+0xaa>
  800a7b:	83 fe 01             	cmp    $0x1,%esi
  800a7e:	72 0c                	jb     800a8c <event_callback+0xa0>
  800a80:	83 fe 02             	cmp    $0x2,%esi
  800a83:	74 1b                	je     800aa0 <event_callback+0xb4>
  800a85:	83 fe 03             	cmp    $0x3,%esi
  800a88:	74 21                	je     800aab <event_callback+0xbf>
  800a8a:	eb 2a                	jmp    800ab6 <event_callback+0xca>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  800a8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a8f:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  800a94:	eb 37                	jmp    800acd <event_callback+0xe1>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  800a96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a99:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  800a9e:	eb 2d                	jmp    800acd <event_callback+0xe1>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  800aa0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800aa3:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  800aa9:	eb 22                	jmp    800acd <event_callback+0xe1>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  800aab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800aae:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  800ab4:	eb 17                	jmp    800acd <event_callback+0xe1>
    default:
      LWIP_ASSERT("unknown event", 0);
  800ab6:	83 ec 04             	sub    $0x4,%esp
  800ab9:	68 7a 0e 81 00       	push   $0x810e7a
  800abe:	68 17 04 00 00       	push   $0x417
  800ac3:	68 88 0e 81 00       	push   $0x810e88
  800ac8:	e8 81 d9 00 00       	call   80e44e <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  800acd:	83 ec 0c             	sub    $0xc,%esp
  800ad0:	ff 35 40 50 81 00    	pushl  0x815040
  800ad6:	e8 fd 94 00 00       	call   809fd8 <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800adb:	8d 73 07             	lea    0x7(%ebx),%esi
  800ade:	83 c4 10             	add    $0x10,%esp
  800ae1:	85 db                	test   %ebx,%ebx
  800ae3:	0f 49 f3             	cmovns %ebx,%esi
  800ae6:	c1 fe 03             	sar    $0x3,%esi
  800ae9:	89 d9                	mov    %ebx,%ecx
  800aeb:	83 e1 07             	and    $0x7,%ecx
  800aee:	bf 01 00 00 00       	mov    $0x1,%edi
  800af3:	d3 e7                	shl    %cl,%edi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  800af5:	83 ec 0c             	sub    $0xc,%esp
  800af8:	ff 35 40 50 81 00    	pushl  0x815040
  800afe:	e8 df 45 00 00       	call   8050e2 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800b03:	8b 1d 48 50 81 00    	mov    0x815048,%ebx
  800b09:	83 c4 10             	add    $0x10,%esp
  800b0c:	eb 3a                	jmp    800b48 <event_callback+0x15c>
      if (scb->sem_signalled == 0) {
  800b0e:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800b12:	75 32                	jne    800b46 <event_callback+0x15a>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800b14:	8b 43 04             	mov    0x4(%ebx),%eax
  800b17:	85 c0                	test   %eax,%eax
  800b19:	74 12                	je     800b2d <event_callback+0x141>
  800b1b:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800b1f:	85 f8                	test   %edi,%eax
  800b21:	74 0a                	je     800b2d <event_callback+0x141>
          if (sock->rcvevent)
  800b23:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b26:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800b2b:	75 21                	jne    800b4e <event_callback+0x162>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800b2d:	8b 43 08             	mov    0x8(%ebx),%eax
  800b30:	85 c0                	test   %eax,%eax
  800b32:	74 12                	je     800b46 <event_callback+0x15a>
  800b34:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800b38:	85 f8                	test   %edi,%eax
  800b3a:	74 0a                	je     800b46 <event_callback+0x15a>
          if (sock->sendevent)
  800b3c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b3f:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800b44:	75 08                	jne    800b4e <event_callback+0x162>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  800b46:	8b 1b                	mov    (%ebx),%ebx
  800b48:	85 db                	test   %ebx,%ebx
  800b4a:	75 c2                	jne    800b0e <event_callback+0x122>
  800b4c:	eb 25                	jmp    800b73 <event_callback+0x187>
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
      scb->sem_signalled = 1;
  800b4e:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800b55:	83 ec 0c             	sub    $0xc,%esp
  800b58:	ff 35 40 50 81 00    	pushl  0x815040
  800b5e:	e8 75 94 00 00       	call   809fd8 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800b63:	83 c4 04             	add    $0x4,%esp
  800b66:	ff 73 14             	pushl  0x14(%ebx)
  800b69:	e8 6a 94 00 00       	call   809fd8 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  800b6e:	83 c4 10             	add    $0x10,%esp
  800b71:	eb 82                	jmp    800af5 <event_callback+0x109>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  800b73:	83 ec 0c             	sub    $0xc,%esp
  800b76:	ff 35 40 50 81 00    	pushl  0x815040
  800b7c:	e8 57 94 00 00       	call   809fd8 <sys_sem_signal>
      break;
  800b81:	83 c4 10             	add    $0x10,%esp
    }
  }
}
  800b84:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800b87:	5b                   	pop    %ebx
  800b88:	5e                   	pop    %esi
  800b89:	5f                   	pop    %edi
  800b8a:	5d                   	pop    %ebp
  800b8b:	c3                   	ret    

00800b8c <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  800b8c:	55                   	push   %ebp
  800b8d:	89 e5                	mov    %esp,%ebp
  800b8f:	56                   	push   %esi
  800b90:	53                   	push   %ebx
  800b91:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  800b93:	83 ec 0c             	sub    $0xc,%esp
  800b96:	ff 35 44 50 81 00    	pushl  0x815044
  800b9c:	e8 41 45 00 00       	call   8050e2 <sys_sem_wait>
  800ba1:	b8 60 50 81 00       	mov    $0x815060,%eax
  800ba6:	83 c4 10             	add    $0x10,%esp

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800ba9:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800bae:	83 38 00             	cmpl   $0x0,(%eax)
  800bb1:	75 59                	jne    800c0c <alloc_socket+0x80>
      sockets[i].conn       = newconn;
  800bb3:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  800bb6:	c1 e2 02             	shl    $0x2,%edx
  800bb9:	89 b2 60 50 81 00    	mov    %esi,0x815060(%edx)
      sockets[i].lastdata   = NULL;
  800bbf:	c7 82 64 50 81 00 00 	movl   $0x0,0x815064(%edx)
  800bc6:	00 00 00 
      sockets[i].lastoffset = 0;
  800bc9:	66 c7 82 68 50 81 00 	movw   $0x0,0x815068(%edx)
  800bd0:	00 00 
      sockets[i].rcvevent   = 0;
  800bd2:	66 c7 82 6a 50 81 00 	movw   $0x0,0x81506a(%edx)
  800bd9:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800bdb:	66 c7 82 6c 50 81 00 	movw   $0x1,0x81506c(%edx)
  800be2:	01 00 
      sockets[i].flags      = 0;
  800be4:	66 c7 82 6e 50 81 00 	movw   $0x0,0x81506e(%edx)
  800beb:	00 00 
      sockets[i].err        = 0;
  800bed:	c7 82 70 50 81 00 00 	movl   $0x0,0x815070(%edx)
  800bf4:	00 00 00 
      sys_sem_signal(socksem);
  800bf7:	83 ec 0c             	sub    $0xc,%esp
  800bfa:	ff 35 44 50 81 00    	pushl  0x815044
  800c00:	e8 d3 93 00 00       	call   809fd8 <sys_sem_signal>
      return i;
  800c05:	83 c4 10             	add    $0x10,%esp
  800c08:	89 d8                	mov    %ebx,%eax
  800c0a:	eb 21                	jmp    800c2d <alloc_socket+0xa1>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800c0c:	83 c3 01             	add    $0x1,%ebx
  800c0f:	83 c0 14             	add    $0x14,%eax
  800c12:	83 fb 20             	cmp    $0x20,%ebx
  800c15:	75 97                	jne    800bae <alloc_socket+0x22>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  800c17:	83 ec 0c             	sub    $0xc,%esp
  800c1a:	ff 35 44 50 81 00    	pushl  0x815044
  800c20:	e8 b3 93 00 00       	call   809fd8 <sys_sem_signal>
  return -1;
  800c25:	83 c4 10             	add    $0x10,%esp
  800c28:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  800c2d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800c30:	5b                   	pop    %ebx
  800c31:	5e                   	pop    %esi
  800c32:	5d                   	pop    %ebp
  800c33:	c3                   	ret    

00800c34 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800c34:	55                   	push   %ebp
  800c35:	89 e5                	mov    %esp,%ebp
  800c37:	53                   	push   %ebx
  800c38:	83 ec 04             	sub    $0x4,%esp
  800c3b:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800c3e:	85 c0                	test   %eax,%eax
  800c40:	75 17                	jne    800c59 <lwip_getsockopt_internal+0x25>
  800c42:	83 ec 04             	sub    $0x4,%esp
  800c45:	68 9f 0e 81 00       	push   $0x810e9f
  800c4a:	68 38 05 00 00       	push   $0x538
  800c4f:	68 88 0e 81 00       	push   $0x810e88
  800c54:	e8 f5 d7 00 00       	call   80e44e <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800c59:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800c5b:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800c5e:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800c61:	8b 40 08             	mov    0x8(%eax),%eax
  800c64:	83 f8 06             	cmp    $0x6,%eax
  800c67:	0f 84 09 01 00 00    	je     800d76 <lwip_getsockopt_internal+0x142>
  800c6d:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800c72:	74 0d                	je     800c81 <lwip_getsockopt_internal+0x4d>
  800c74:	85 c0                	test   %eax,%eax
  800c76:	0f 85 26 01 00 00    	jne    800da2 <lwip_getsockopt_internal+0x16e>
  800c7c:	e9 d1 00 00 00       	jmp    800d52 <lwip_getsockopt_internal+0x11e>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800c81:	83 fa 20             	cmp    $0x20,%edx
  800c84:	74 37                	je     800cbd <lwip_getsockopt_internal+0x89>
  800c86:	83 fa 20             	cmp    $0x20,%edx
  800c89:	7f 10                	jg     800c9b <lwip_getsockopt_internal+0x67>
  800c8b:	83 fa 02             	cmp    $0x2,%edx
  800c8e:	74 2d                	je     800cbd <lwip_getsockopt_internal+0x89>
  800c90:	83 fa 08             	cmp    $0x8,%edx
  800c93:	0f 85 09 01 00 00    	jne    800da2 <lwip_getsockopt_internal+0x16e>
  800c99:	eb 22                	jmp    800cbd <lwip_getsockopt_internal+0x89>
  800c9b:	81 fa 08 10 00 00    	cmp    $0x1008,%edx
  800ca1:	74 2c                	je     800ccf <lwip_getsockopt_internal+0x9b>
  800ca3:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800ca9:	0f 84 93 00 00 00    	je     800d42 <lwip_getsockopt_internal+0x10e>
  800caf:	81 fa 07 10 00 00    	cmp    $0x1007,%edx
  800cb5:	0f 85 e7 00 00 00    	jne    800da2 <lwip_getsockopt_internal+0x16e>
  800cbb:	eb 4f                	jmp    800d0c <lwip_getsockopt_internal+0xd8>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800cbd:	8b 01                	mov    (%ecx),%eax
  800cbf:	8b 40 08             	mov    0x8(%eax),%eax
  800cc2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800cc6:	21 c2                	and    %eax,%edx
  800cc8:	89 13                	mov    %edx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  800cca:	e9 d3 00 00 00       	jmp    800da2 <lwip_getsockopt_internal+0x16e>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800ccf:	8b 01                	mov    (%ecx),%eax
  800cd1:	8b 10                	mov    (%eax),%edx
  800cd3:	89 d0                	mov    %edx,%eax
  800cd5:	25 f0 00 00 00       	and    $0xf0,%eax
  800cda:	83 f8 20             	cmp    $0x20,%eax
  800cdd:	74 22                	je     800d01 <lwip_getsockopt_internal+0xcd>
  800cdf:	83 f8 40             	cmp    $0x40,%eax
  800ce2:	74 12                	je     800cf6 <lwip_getsockopt_internal+0xc2>
  800ce4:	83 f8 10             	cmp    $0x10,%eax
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
        break;
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  800ce7:	b8 01 00 00 00       	mov    $0x1,%eax
  800cec:	0f 44 d0             	cmove  %eax,%edx
  800cef:	89 13                	mov    %edx,(%ebx)
  800cf1:	e9 ac 00 00 00       	jmp    800da2 <lwip_getsockopt_internal+0x16e>
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  800cf6:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  800cfc:	e9 a1 00 00 00       	jmp    800da2 <lwip_getsockopt_internal+0x16e>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  800d01:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  800d07:	e9 96 00 00 00       	jmp    800da2 <lwip_getsockopt_internal+0x16e>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  800d0c:	83 79 10 00          	cmpl   $0x0,0x10(%ecx)
  800d10:	75 22                	jne    800d34 <lwip_getsockopt_internal+0x100>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800d12:	8b 01                	mov    (%ecx),%eax
  800d14:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800d18:	f7 d8                	neg    %eax
  800d1a:	ba 05 00 00 00       	mov    $0x5,%edx
  800d1f:	83 f8 0e             	cmp    $0xe,%eax
  800d22:	77 07                	ja     800d2b <lwip_getsockopt_internal+0xf7>
  800d24:	8b 14 85 40 0f 81 00 	mov    0x810f40(,%eax,4),%edx
  800d2b:	89 51 10             	mov    %edx,0x10(%ecx)
  800d2e:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
      } 
      *(int *)optval = sock->err;
  800d34:	8b 41 10             	mov    0x10(%ecx),%eax
  800d37:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  800d39:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  800d40:	eb 60                	jmp    800da2 <lwip_getsockopt_internal+0x16e>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800d42:	8b 01                	mov    (%ecx),%eax
  800d44:	8b 40 08             	mov    0x8(%eax),%eax
  800d47:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  800d4b:	83 e0 01             	and    $0x1,%eax
  800d4e:	89 03                	mov    %eax,(%ebx)
      break;
  800d50:	eb 50                	jmp    800da2 <lwip_getsockopt_internal+0x16e>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800d52:	83 fa 01             	cmp    $0x1,%edx
  800d55:	74 12                	je     800d69 <lwip_getsockopt_internal+0x135>
  800d57:	83 fa 02             	cmp    $0x2,%edx
  800d5a:	75 46                	jne    800da2 <lwip_getsockopt_internal+0x16e>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800d5c:	8b 01                	mov    (%ecx),%eax
  800d5e:	8b 40 08             	mov    0x8(%eax),%eax
  800d61:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  800d65:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  800d67:	eb 39                	jmp    800da2 <lwip_getsockopt_internal+0x16e>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  800d69:	8b 01                	mov    (%ecx),%eax
  800d6b:	8b 40 08             	mov    0x8(%eax),%eax
  800d6e:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  800d72:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  800d74:	eb 2c                	jmp    800da2 <lwip_getsockopt_internal+0x16e>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800d76:	83 fa 01             	cmp    $0x1,%edx
  800d79:	74 07                	je     800d82 <lwip_getsockopt_internal+0x14e>
  800d7b:	83 fa 02             	cmp    $0x2,%edx
  800d7e:	74 15                	je     800d95 <lwip_getsockopt_internal+0x161>
  800d80:	eb 20                	jmp    800da2 <lwip_getsockopt_internal+0x16e>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800d82:	8b 01                	mov    (%ecx),%eax
  800d84:	8b 40 08             	mov    0x8(%eax),%eax
  800d87:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  800d8b:	83 e0 40             	and    $0x40,%eax
  800d8e:	0f b6 c0             	movzbl %al,%eax
  800d91:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  800d93:	eb 0d                	jmp    800da2 <lwip_getsockopt_internal+0x16e>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800d95:	8b 01                	mov    (%ecx),%eax
  800d97:	8b 40 08             	mov    0x8(%eax),%eax
  800d9a:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  800da0:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800da2:	83 ec 0c             	sub    $0xc,%esp
  800da5:	8b 01                	mov    (%ecx),%eax
  800da7:	ff 70 10             	pushl  0x10(%eax)
  800daa:	e8 29 92 00 00       	call   809fd8 <sys_sem_signal>
}
  800daf:	83 c4 10             	add    $0x10,%esp
  800db2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800db5:	c9                   	leave  
  800db6:	c3                   	ret    

00800db7 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800db7:	55                   	push   %ebp
  800db8:	89 e5                	mov    %esp,%ebp
  800dba:	53                   	push   %ebx
  800dbb:	83 ec 04             	sub    $0x4,%esp
  800dbe:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800dc1:	85 c0                	test   %eax,%eax
  800dc3:	75 17                	jne    800ddc <lwip_setsockopt_internal+0x25>
  800dc5:	83 ec 04             	sub    $0x4,%esp
  800dc8:	68 9f 0e 81 00       	push   $0x810e9f
  800dcd:	68 ae 06 00 00       	push   $0x6ae
  800dd2:	68 88 0e 81 00       	push   $0x810e88
  800dd7:	e8 72 d6 00 00       	call   80e44e <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800ddc:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800dde:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800de1:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800de4:	8b 40 08             	mov    0x8(%eax),%eax
  800de7:	83 f8 06             	cmp    $0x6,%eax
  800dea:	0f 84 81 00 00 00    	je     800e71 <lwip_setsockopt_internal+0xba>
  800df0:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800df5:	74 0a                	je     800e01 <lwip_setsockopt_internal+0x4a>
  800df7:	85 c0                	test   %eax,%eax
  800df9:	0f 85 a6 00 00 00    	jne    800ea5 <lwip_setsockopt_internal+0xee>
  800dff:	eb 4e                	jmp    800e4f <lwip_setsockopt_internal+0x98>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800e01:	83 fa 20             	cmp    $0x20,%edx
  800e04:	74 11                	je     800e17 <lwip_setsockopt_internal+0x60>
  800e06:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800e0c:	74 26                	je     800e34 <lwip_setsockopt_internal+0x7d>
  800e0e:	83 fa 08             	cmp    $0x8,%edx
  800e11:	0f 85 8e 00 00 00    	jne    800ea5 <lwip_setsockopt_internal+0xee>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  800e17:	83 3b 00             	cmpl   $0x0,(%ebx)
  800e1a:	74 0b                	je     800e27 <lwip_setsockopt_internal+0x70>
        sock->conn->pcb.ip->so_options |= optname;
  800e1c:	8b 01                	mov    (%ecx),%eax
  800e1e:	8b 40 08             	mov    0x8(%eax),%eax
  800e21:	66 09 50 08          	or     %dx,0x8(%eax)
  800e25:	eb 7e                	jmp    800ea5 <lwip_setsockopt_internal+0xee>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  800e27:	8b 01                	mov    (%ecx),%eax
  800e29:	8b 40 08             	mov    0x8(%eax),%eax
  800e2c:	f7 d2                	not    %edx
  800e2e:	66 21 50 08          	and    %dx,0x8(%eax)
  800e32:	eb 71                	jmp    800ea5 <lwip_setsockopt_internal+0xee>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  800e34:	83 3b 00             	cmpl   $0x0,(%ebx)
  800e37:	74 0b                	je     800e44 <lwip_setsockopt_internal+0x8d>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800e39:	8b 01                	mov    (%ecx),%eax
  800e3b:	8b 40 08             	mov    0x8(%eax),%eax
  800e3e:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800e42:	eb 61                	jmp    800ea5 <lwip_setsockopt_internal+0xee>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800e44:	8b 01                	mov    (%ecx),%eax
  800e46:	8b 40 08             	mov    0x8(%eax),%eax
  800e49:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800e4d:	eb 56                	jmp    800ea5 <lwip_setsockopt_internal+0xee>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800e4f:	83 fa 01             	cmp    $0x1,%edx
  800e52:	74 11                	je     800e65 <lwip_setsockopt_internal+0xae>
  800e54:	83 fa 02             	cmp    $0x2,%edx
  800e57:	75 4c                	jne    800ea5 <lwip_setsockopt_internal+0xee>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800e59:	8b 01                	mov    (%ecx),%eax
  800e5b:	8b 40 08             	mov    0x8(%eax),%eax
  800e5e:	8b 13                	mov    (%ebx),%edx
  800e60:	88 50 0b             	mov    %dl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  800e63:	eb 40                	jmp    800ea5 <lwip_setsockopt_internal+0xee>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800e65:	8b 01                	mov    (%ecx),%eax
  800e67:	8b 40 08             	mov    0x8(%eax),%eax
  800e6a:	8b 13                	mov    (%ebx),%edx
  800e6c:	88 50 0a             	mov    %dl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  800e6f:	eb 34                	jmp    800ea5 <lwip_setsockopt_internal+0xee>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800e71:	83 fa 01             	cmp    $0x1,%edx
  800e74:	74 07                	je     800e7d <lwip_setsockopt_internal+0xc6>
  800e76:	83 fa 02             	cmp    $0x2,%edx
  800e79:	74 1d                	je     800e98 <lwip_setsockopt_internal+0xe1>
  800e7b:	eb 28                	jmp    800ea5 <lwip_setsockopt_internal+0xee>
    case TCP_NODELAY:
      if (*(int*)optval) {
  800e7d:	83 3b 00             	cmpl   $0x0,(%ebx)
  800e80:	74 0b                	je     800e8d <lwip_setsockopt_internal+0xd6>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800e82:	8b 01                	mov    (%ecx),%eax
  800e84:	8b 40 08             	mov    0x8(%eax),%eax
  800e87:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800e8b:	eb 18                	jmp    800ea5 <lwip_setsockopt_internal+0xee>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800e8d:	8b 01                	mov    (%ecx),%eax
  800e8f:	8b 40 08             	mov    0x8(%eax),%eax
  800e92:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800e96:	eb 0d                	jmp    800ea5 <lwip_setsockopt_internal+0xee>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800e98:	8b 01                	mov    (%ecx),%eax
  800e9a:	8b 40 08             	mov    0x8(%eax),%eax
  800e9d:	8b 13                	mov    (%ebx),%edx
  800e9f:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800ea5:	83 ec 0c             	sub    $0xc,%esp
  800ea8:	8b 01                	mov    (%ecx),%eax
  800eaa:	ff 70 10             	pushl  0x10(%eax)
  800ead:	e8 26 91 00 00       	call   809fd8 <sys_sem_signal>
}
  800eb2:	83 c4 10             	add    $0x10,%esp
  800eb5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800eb8:	c9                   	leave  
  800eb9:	c3                   	ret    

00800eba <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  800eba:	55                   	push   %ebp
  800ebb:	89 e5                	mov    %esp,%ebp
  800ebd:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800ec0:	6a 01                	push   $0x1
  800ec2:	e8 65 8e 00 00       	call   809d2c <sys_sem_new>
  800ec7:	a3 44 50 81 00       	mov    %eax,0x815044
  selectsem = sys_sem_new(1);
  800ecc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  800ed3:	e8 54 8e 00 00       	call   809d2c <sys_sem_new>
  800ed8:	a3 40 50 81 00       	mov    %eax,0x815040
}
  800edd:	83 c4 10             	add    $0x10,%esp
  800ee0:	c9                   	leave  
  800ee1:	c3                   	ret    

00800ee2 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  800ee2:	55                   	push   %ebp
  800ee3:	89 e5                	mov    %esp,%ebp
  800ee5:	57                   	push   %edi
  800ee6:	56                   	push   %esi
  800ee7:	53                   	push   %ebx
  800ee8:	83 ec 3c             	sub    $0x3c,%esp
  800eeb:	8b 7d 10             	mov    0x10(%ebp),%edi
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  800eee:	8b 45 08             	mov    0x8(%ebp),%eax
  800ef1:	e8 fa f8 ff ff       	call   8007f0 <get_socket>
  if (!sock)
  800ef6:	85 c0                	test   %eax,%eax
  800ef8:	0f 84 86 01 00 00    	je     801084 <lwip_accept+0x1a2>
  800efe:	89 c6                	mov    %eax,%esi
    return -1;

  newconn = netconn_accept(sock->conn);
  800f00:	83 ec 0c             	sub    $0xc,%esp
  800f03:	ff 30                	pushl  (%eax)
  800f05:	e8 2a 9f 00 00       	call   80ae34 <netconn_accept>
  800f0a:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  800f0c:	83 c4 10             	add    $0x10,%esp
  800f0f:	85 c0                	test   %eax,%eax
  800f11:	75 2c                	jne    800f3f <lwip_accept+0x5d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  800f13:	8b 06                	mov    (%esi),%eax
  800f15:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800f19:	f7 d8                	neg    %eax
  800f1b:	ba 05 00 00 00       	mov    $0x5,%edx
  800f20:	83 f8 0e             	cmp    $0xe,%eax
  800f23:	77 07                	ja     800f2c <lwip_accept+0x4a>
  800f25:	8b 14 85 40 0f 81 00 	mov    0x810f40(,%eax,4),%edx
  800f2c:	89 56 10             	mov    %edx,0x10(%esi)
  800f2f:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800f35:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800f3a:	e9 4a 01 00 00       	jmp    801089 <lwip_accept+0x1a7>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  800f3f:	6a 00                	push   $0x0
  800f41:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  800f44:	50                   	push   %eax
  800f45:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800f48:	50                   	push   %eax
  800f49:	53                   	push   %ebx
  800f4a:	e8 2f 9d 00 00       	call   80ac7e <netconn_getaddr>
  800f4f:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  800f52:	83 c4 10             	add    $0x10,%esp
  800f55:	84 c0                	test   %al,%al
  800f57:	74 36                	je     800f8f <lwip_accept+0xad>
    netconn_delete(newconn);
  800f59:	83 ec 0c             	sub    $0xc,%esp
  800f5c:	53                   	push   %ebx
  800f5d:	e8 b4 9c 00 00       	call   80ac16 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  800f62:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  800f66:	f7 d8                	neg    %eax
  800f68:	83 c4 10             	add    $0x10,%esp
  800f6b:	ba 05 00 00 00       	mov    $0x5,%edx
  800f70:	83 f8 0e             	cmp    $0xe,%eax
  800f73:	77 07                	ja     800f7c <lwip_accept+0x9a>
  800f75:	8b 14 85 40 0f 81 00 	mov    0x810f40(,%eax,4),%edx
  800f7c:	89 56 10             	mov    %edx,0x10(%esi)
  800f7f:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800f85:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800f8a:	e9 fa 00 00 00       	jmp    801089 <lwip_accept+0x1a7>
  }

  memset(&sin, 0, sizeof(sin));
  800f8f:	83 ec 04             	sub    $0x4,%esp
  800f92:	6a 10                	push   $0x10
  800f94:	6a 00                	push   $0x0
  800f96:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800f99:	50                   	push   %eax
  800f9a:	e8 52 dc 00 00       	call   80ebf1 <memset>
  sin.sin_len = sizeof(sin);
  800f9f:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  800fa3:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  800fa7:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  800fab:	89 04 24             	mov    %eax,(%esp)
  800fae:	e8 23 67 00 00       	call   8076d6 <htons>
  800fb3:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800fb7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800fba:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  800fbd:	83 c4 10             	add    $0x10,%esp
  800fc0:	83 3f 10             	cmpl   $0x10,(%edi)
  800fc3:	76 06                	jbe    800fcb <lwip_accept+0xe9>
    *addrlen = sizeof(sin);
  800fc5:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(addr, &sin, *addrlen);
  800fcb:	83 ec 04             	sub    $0x4,%esp
  800fce:	ff 37                	pushl  (%edi)
  800fd0:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800fd3:	50                   	push   %eax
  800fd4:	ff 75 0c             	pushl  0xc(%ebp)
  800fd7:	e8 ca dc 00 00       	call   80eca6 <memcpy>

  newsock = alloc_socket(newconn);
  800fdc:	89 d8                	mov    %ebx,%eax
  800fde:	e8 a9 fb ff ff       	call   800b8c <alloc_socket>
  800fe3:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  800fe5:	83 c4 10             	add    $0x10,%esp
  800fe8:	83 f8 ff             	cmp    $0xffffffff,%eax
  800feb:	75 24                	jne    801011 <lwip_accept+0x12f>
    netconn_delete(newconn);
  800fed:	83 ec 0c             	sub    $0xc,%esp
  800ff0:	53                   	push   %ebx
  800ff1:	e8 20 9c 00 00       	call   80ac16 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  800ff6:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  800ffd:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  801004:	00 00 00 
    return -1;
  801007:	83 c4 10             	add    $0x10,%esp
  80100a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80100f:	eb 78                	jmp    801089 <lwip_accept+0x1a7>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  801011:	83 f8 1f             	cmp    $0x1f,%eax
  801014:	76 17                	jbe    80102d <lwip_accept+0x14b>
  801016:	83 ec 04             	sub    $0x4,%esp
  801019:	68 ab 0e 81 00       	push   $0x810eab
  80101e:	68 25 01 00 00       	push   $0x125
  801023:	68 88 0e 81 00       	push   $0x810e88
  801028:	e8 21 d4 00 00       	call   80e44e <_panic>
  newconn->callback = event_callback;
  80102d:	c7 43 2c ec 09 80 00 	movl   $0x8009ec,0x2c(%ebx)
  nsock = &sockets[newsock];
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);

  sys_sem_wait(socksem);
  801034:	83 ec 0c             	sub    $0xc,%esp
  801037:	ff 35 44 50 81 00    	pushl  0x815044
  80103d:	e8 a0 40 00 00       	call   8050e2 <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  801042:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  801045:	8d 14 85 60 50 81 00 	lea    0x815060(,%eax,4),%edx
  80104c:	0f b7 42 0a          	movzwl 0xa(%edx),%eax
  801050:	83 e8 01             	sub    $0x1,%eax
  801053:	66 2b 43 1c          	sub    0x1c(%ebx),%ax
  801057:	66 89 42 0a          	mov    %ax,0xa(%edx)
  newconn->socket = newsock;
  80105b:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  80105e:	83 c4 04             	add    $0x4,%esp
  801061:	ff 35 44 50 81 00    	pushl  0x815044
  801067:	e8 6c 8f 00 00       	call   809fd8 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  80106c:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  801073:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80107a:	00 00 00 
  return newsock;
  80107d:	83 c4 10             	add    $0x10,%esp
  801080:	89 f8                	mov    %edi,%eax
  801082:	eb 05                	jmp    801089 <lwip_accept+0x1a7>
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  if (!sock)
    return -1;
  801084:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  return newsock;
}
  801089:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80108c:	5b                   	pop    %ebx
  80108d:	5e                   	pop    %esi
  80108e:	5f                   	pop    %edi
  80108f:	5d                   	pop    %ebp
  801090:	c3                   	ret    

00801091 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  801091:	55                   	push   %ebp
  801092:	89 e5                	mov    %esp,%ebp
  801094:	56                   	push   %esi
  801095:	53                   	push   %ebx
  801096:	83 ec 10             	sub    $0x10,%esp
  801099:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  80109c:	8b 45 08             	mov    0x8(%ebp),%eax
  80109f:	e8 4c f7 ff ff       	call   8007f0 <get_socket>
  if (!sock)
  8010a4:	85 c0                	test   %eax,%eax
  8010a6:	0f 84 8f 00 00 00    	je     80113b <lwip_bind+0xaa>
  8010ac:	89 c3                	mov    %eax,%ebx
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8010ae:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  8010b2:	75 06                	jne    8010ba <lwip_bind+0x29>
  8010b4:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8010b8:	74 17                	je     8010d1 <lwip_bind+0x40>
  8010ba:	83 ec 04             	sub    $0x4,%esp
  8010bd:	68 c0 0e 81 00       	push   $0x810ec0
  8010c2:	68 4a 01 00 00       	push   $0x14a
  8010c7:	68 88 0e 81 00       	push   $0x810e88
  8010cc:	e8 7d d3 00 00       	call   80e44e <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8010d1:	8b 46 04             	mov    0x4(%esi),%eax
  8010d4:	89 45 f4             	mov    %eax,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  8010d7:	83 ec 0c             	sub    $0xc,%esp
  8010da:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8010de:	50                   	push   %eax
  8010df:	e8 ff 65 00 00       	call   8076e3 <ntohs>
  8010e4:	83 c4 0c             	add    $0xc,%esp
  8010e7:	0f b7 c0             	movzwl %ax,%eax
  8010ea:	50                   	push   %eax
  8010eb:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8010ee:	50                   	push   %eax
  8010ef:	ff 33                	pushl  (%ebx)
  8010f1:	e8 14 9c 00 00       	call   80ad0a <netconn_bind>

  if (err != ERR_OK) {
  8010f6:	83 c4 10             	add    $0x10,%esp
  8010f9:	84 c0                	test   %al,%al
  8010fb:	74 26                	je     801123 <lwip_bind+0x92>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8010fd:	0f be c0             	movsbl %al,%eax
  801100:	f7 d8                	neg    %eax
  801102:	ba 05 00 00 00       	mov    $0x5,%edx
  801107:	83 f8 0e             	cmp    $0xe,%eax
  80110a:	77 07                	ja     801113 <lwip_bind+0x82>
  80110c:	8b 14 85 40 0f 81 00 	mov    0x810f40(,%eax,4),%edx
  801113:	89 53 10             	mov    %edx,0x10(%ebx)
  801116:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  80111c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801121:	eb 1d                	jmp    801140 <lwip_bind+0xaf>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  801123:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80112a:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801131:	00 00 00 
  return 0;
  801134:	b8 00 00 00 00       	mov    $0x0,%eax
  801139:	eb 05                	jmp    801140 <lwip_bind+0xaf>
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  80113b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  801140:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801143:	5b                   	pop    %ebx
  801144:	5e                   	pop    %esi
  801145:	5d                   	pop    %ebp
  801146:	c3                   	ret    

00801147 <lwip_close>:

int
lwip_close(int s)
{
  801147:	55                   	push   %ebp
  801148:	89 e5                	mov    %esp,%ebp
  80114a:	53                   	push   %ebx
  80114b:	83 ec 04             	sub    $0x4,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  80114e:	8b 45 08             	mov    0x8(%ebp),%eax
  801151:	e8 9a f6 ff ff       	call   8007f0 <get_socket>
  if (!sock) {
  801156:	85 c0                	test   %eax,%eax
  801158:	74 6c                	je     8011c6 <lwip_close+0x7f>
  80115a:	89 c3                	mov    %eax,%ebx
    return -1;
  }

  netconn_delete(sock->conn);
  80115c:	83 ec 0c             	sub    $0xc,%esp
  80115f:	ff 30                	pushl  (%eax)
  801161:	e8 b0 9a 00 00       	call   80ac16 <netconn_delete>

  sys_sem_wait(socksem);
  801166:	83 c4 04             	add    $0x4,%esp
  801169:	ff 35 44 50 81 00    	pushl  0x815044
  80116f:	e8 6e 3f 00 00       	call   8050e2 <sys_sem_wait>
  if (sock->lastdata) {
  801174:	8b 43 04             	mov    0x4(%ebx),%eax
  801177:	83 c4 10             	add    $0x10,%esp
  80117a:	85 c0                	test   %eax,%eax
  80117c:	74 0c                	je     80118a <lwip_close+0x43>
    netbuf_delete(sock->lastdata);
  80117e:	83 ec 0c             	sub    $0xc,%esp
  801181:	50                   	push   %eax
  801182:	e8 6c 13 00 00       	call   8024f3 <netbuf_delete>
  801187:	83 c4 10             	add    $0x10,%esp
  }
  sock->lastdata   = NULL;
  80118a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  801191:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  801197:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  80119d:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8011a4:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8011ab:	00 00 00 
  sys_sem_signal(socksem);
  8011ae:	83 ec 0c             	sub    $0xc,%esp
  8011b1:	ff 35 44 50 81 00    	pushl  0x815044
  8011b7:	e8 1c 8e 00 00       	call   809fd8 <sys_sem_signal>
  return 0;
  8011bc:	83 c4 10             	add    $0x10,%esp
  8011bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8011c4:	eb 05                	jmp    8011cb <lwip_close+0x84>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  if (!sock) {
    return -1;
  8011c6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  sock->lastoffset = 0;
  sock->conn       = NULL;
  sock_set_errno(sock, 0);
  sys_sem_signal(socksem);
  return 0;
}
  8011cb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8011ce:	c9                   	leave  
  8011cf:	c3                   	ret    

008011d0 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8011d0:	55                   	push   %ebp
  8011d1:	89 e5                	mov    %esp,%ebp
  8011d3:	56                   	push   %esi
  8011d4:	53                   	push   %ebx
  8011d5:	83 ec 10             	sub    $0x10,%esp
  8011d8:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  8011db:	8b 45 08             	mov    0x8(%ebp),%eax
  8011de:	e8 0d f6 ff ff       	call   8007f0 <get_socket>
  if (!sock)
  8011e3:	85 c0                	test   %eax,%eax
  8011e5:	0f 84 8f 00 00 00    	je     80127a <lwip_connect+0xaa>
  8011eb:	89 c3                	mov    %eax,%ebx
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8011ed:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  8011f1:	75 06                	jne    8011f9 <lwip_connect+0x29>
  8011f3:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8011f7:	74 17                	je     801210 <lwip_connect+0x40>
  8011f9:	83 ec 04             	sub    $0x4,%esp
  8011fc:	68 db 0e 81 00       	push   $0x810edb
  801201:	68 86 01 00 00       	push   $0x186
  801206:	68 88 0e 81 00       	push   $0x810e88
  80120b:	e8 3e d2 00 00       	call   80e44e <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801210:	8b 46 04             	mov    0x4(%esi),%eax
  801213:	89 45 f4             	mov    %eax,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  801216:	83 ec 0c             	sub    $0xc,%esp
  801219:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80121d:	50                   	push   %eax
  80121e:	e8 c0 64 00 00       	call   8076e3 <ntohs>
  801223:	83 c4 0c             	add    $0xc,%esp
  801226:	0f b7 c0             	movzwl %ax,%eax
  801229:	50                   	push   %eax
  80122a:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80122d:	50                   	push   %eax
  80122e:	ff 33                	pushl  (%ebx)
  801230:	e8 26 9b 00 00       	call   80ad5b <netconn_connect>
  }

  if (err != ERR_OK) {
  801235:	83 c4 10             	add    $0x10,%esp
  801238:	84 c0                	test   %al,%al
  80123a:	74 26                	je     801262 <lwip_connect+0x92>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80123c:	0f be c0             	movsbl %al,%eax
  80123f:	f7 d8                	neg    %eax
  801241:	ba 05 00 00 00       	mov    $0x5,%edx
  801246:	83 f8 0e             	cmp    $0xe,%eax
  801249:	77 07                	ja     801252 <lwip_connect+0x82>
  80124b:	8b 14 85 40 0f 81 00 	mov    0x810f40(,%eax,4),%edx
  801252:	89 53 10             	mov    %edx,0x10(%ebx)
  801255:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  80125b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801260:	eb 1d                	jmp    80127f <lwip_connect+0xaf>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  801262:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801269:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801270:	00 00 00 
  return 0;
  801273:	b8 00 00 00 00       	mov    $0x0,%eax
  801278:	eb 05                	jmp    80127f <lwip_connect+0xaf>
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  80127a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  80127f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801282:	5b                   	pop    %ebx
  801283:	5e                   	pop    %esi
  801284:	5d                   	pop    %ebp
  801285:	c3                   	ret    

00801286 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  801286:	55                   	push   %ebp
  801287:	89 e5                	mov    %esp,%ebp
  801289:	56                   	push   %esi
  80128a:	53                   	push   %ebx
  80128b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  80128e:	8b 45 08             	mov    0x8(%ebp),%eax
  801291:	e8 5a f5 ff ff       	call   8007f0 <get_socket>
  if (!sock)
  801296:	85 c0                	test   %eax,%eax
  801298:	74 6d                	je     801307 <lwip_listen+0x81>
  80129a:	89 c6                	mov    %eax,%esi
  80129c:	85 db                	test   %ebx,%ebx
  80129e:	b8 00 00 00 00       	mov    $0x0,%eax
  8012a3:	0f 48 d8             	cmovs  %eax,%ebx
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  8012a6:	83 ec 08             	sub    $0x8,%esp
  8012a9:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  8012af:	b8 ff 00 00 00       	mov    $0xff,%eax
  8012b4:	0f 4f d8             	cmovg  %eax,%ebx
  8012b7:	0f b6 db             	movzbl %bl,%ebx
  8012ba:	53                   	push   %ebx
  8012bb:	ff 36                	pushl  (%esi)
  8012bd:	e8 2e 9b 00 00       	call   80adf0 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  8012c2:	83 c4 10             	add    $0x10,%esp
  8012c5:	84 c0                	test   %al,%al
  8012c7:	74 26                	je     8012ef <lwip_listen+0x69>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8012c9:	0f be c0             	movsbl %al,%eax
  8012cc:	f7 d8                	neg    %eax
  8012ce:	ba 05 00 00 00       	mov    $0x5,%edx
  8012d3:	83 f8 0e             	cmp    $0xe,%eax
  8012d6:	77 07                	ja     8012df <lwip_listen+0x59>
  8012d8:	8b 14 85 40 0f 81 00 	mov    0x810f40(,%eax,4),%edx
  8012df:	89 56 10             	mov    %edx,0x10(%esi)
  8012e2:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  8012e8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012ed:	eb 1d                	jmp    80130c <lwip_listen+0x86>
  }

  sock_set_errno(sock, 0);
  8012ef:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8012f6:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8012fd:	00 00 00 
  return 0;
  801300:	b8 00 00 00 00       	mov    $0x0,%eax
  801305:	eb 05                	jmp    80130c <lwip_listen+0x86>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  if (!sock)
    return -1;
  801307:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  }

  sock_set_errno(sock, 0);
  return 0;
}
  80130c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80130f:	5b                   	pop    %ebx
  801310:	5e                   	pop    %esi
  801311:	5d                   	pop    %ebp
  801312:	c3                   	ret    

00801313 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  801313:	55                   	push   %ebp
  801314:	89 e5                	mov    %esp,%ebp
  801316:	57                   	push   %edi
  801317:	56                   	push   %esi
  801318:	53                   	push   %ebx
  801319:	83 ec 4c             	sub    $0x4c,%esp
  80131c:	8b 5d 14             	mov    0x14(%ebp),%ebx
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  80131f:	8b 45 08             	mov    0x8(%ebp),%eax
  801322:	e8 c9 f4 ff ff       	call   8007f0 <get_socket>
  if (!sock)
  801327:	85 c0                	test   %eax,%eax
  801329:	0f 84 04 02 00 00    	je     801533 <lwip_recvfrom+0x220>
  80132f:	89 c7                	mov    %eax,%edi
  801331:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  801337:	89 d8                	mov    %ebx,%eax
  801339:	83 e0 08             	and    $0x8,%eax
  80133c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  80133f:	83 e3 01             	and    $0x1,%ebx
  801342:	89 5d b8             	mov    %ebx,-0x48(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  801345:	8b 77 04             	mov    0x4(%edi),%esi
  801348:	85 f6                	test   %esi,%esi
  80134a:	0f 85 80 00 00 00    	jne    8013d0 <lwip_recvfrom+0xbd>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  801350:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801354:	75 06                	jne    80135c <lwip_recvfrom+0x49>
  801356:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  80135a:	74 22                	je     80137e <lwip_recvfrom+0x6b>
  80135c:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  801361:	75 1b                	jne    80137e <lwip_recvfrom+0x6b>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  801363:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  80136a:	c7 05 e0 b1 b3 00 0b 	movl   $0xb,0xb3b1e0
  801371:	00 00 00 
        return -1;
  801374:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801379:	e9 ba 01 00 00       	jmp    801538 <lwip_recvfrom+0x225>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  80137e:	83 ec 0c             	sub    $0xc,%esp
  801381:	ff 37                	pushl  (%edi)
  801383:	e8 1e 9b 00 00       	call   80aea6 <netconn_recv>
  801388:	89 c6                	mov    %eax,%esi
  80138a:	89 47 04             	mov    %eax,0x4(%edi)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  80138d:	83 c4 10             	add    $0x10,%esp
  801390:	85 c0                	test   %eax,%eax
  801392:	75 3c                	jne    8013d0 <lwip_recvfrom+0xbd>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  801394:	8b 17                	mov    (%edi),%edx
  801396:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  80139a:	74 0b                	je     8013a7 <lwip_recvfrom+0x94>
  80139c:	b8 6e 00 00 00       	mov    $0x6e,%eax
  8013a1:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  8013a5:	74 17                	je     8013be <lwip_recvfrom+0xab>
  8013a7:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  8013ab:	f7 da                	neg    %edx
  8013ad:	b8 05 00 00 00       	mov    $0x5,%eax
  8013b2:	83 fa 0e             	cmp    $0xe,%edx
  8013b5:	77 07                	ja     8013be <lwip_recvfrom+0xab>
  8013b7:	8b 04 95 40 0f 81 00 	mov    0x810f40(,%edx,4),%eax
  8013be:	89 47 10             	mov    %eax,0x10(%edi)
  8013c1:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
        return 0;
  8013c6:	b8 00 00 00 00       	mov    $0x0,%eax
  8013cb:	e9 68 01 00 00       	jmp    801538 <lwip_recvfrom+0x225>
      }
    }

    buflen = netbuf_len(buf);
  8013d0:	8b 16                	mov    (%esi),%edx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  8013d2:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8013d6:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  8013da:	29 c3                	sub    %eax,%ebx

    if (len > buflen) {
  8013dc:	0f b7 cb             	movzwl %bx,%ecx
  8013df:	89 4d bc             	mov    %ecx,-0x44(%ebp)
      copylen = buflen;
    } else {
      copylen = len;
  8013e2:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  8013e5:	66 0f 4e 5d 10       	cmovle 0x10(%ebp),%bx
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  8013ea:	0f b7 cb             	movzwl %bx,%ecx
  8013ed:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  8013f0:	0f b7 c0             	movzwl %ax,%eax
  8013f3:	50                   	push   %eax
  8013f4:	51                   	push   %ecx
  8013f5:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  8013f9:	03 45 0c             	add    0xc(%ebp),%eax
  8013fc:	50                   	push   %eax
  8013fd:	52                   	push   %edx
  8013fe:	e8 72 3b 00 00       	call   804f75 <pbuf_copy_partial>

    off += copylen;
  801403:	66 01 5d c4          	add    %bx,-0x3c(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801407:	83 c4 04             	add    $0x4,%esp
  80140a:	ff 37                	pushl  (%edi)
  80140c:	e8 45 98 00 00       	call   80ac56 <netconn_type>
  801411:	83 c4 10             	add    $0x10,%esp
      len -= copylen;
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
        done = 1;
      }
    } else {
      done = 1;
  801414:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);

    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801418:	83 f8 10             	cmp    $0x10,%eax
  80141b:	75 1d                	jne    80143a <lwip_recvfrom+0x127>
      len -= copylen;
  80141d:	8b 45 c0             	mov    -0x40(%ebp),%eax
  801420:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  801423:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801427:	7e 11                	jle    80143a <lwip_recvfrom+0x127>
  801429:	8b 06                	mov    (%esi),%eax
  80142b:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  80142f:	75 09                	jne    80143a <lwip_recvfrom+0x127>
        done = 1;
  801431:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  801436:	0f 94 45 c7          	sete   -0x39(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  80143a:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  80143e:	75 3d                	jne    80147d <lwip_recvfrom+0x16a>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  801440:	8b 07                	mov    (%edi),%eax
  801442:	83 38 10             	cmpl   $0x10,(%eax)
  801445:	75 13                	jne    80145a <lwip_recvfrom+0x147>
  801447:	8b 45 bc             	mov    -0x44(%ebp),%eax
  80144a:	2b 45 c0             	sub    -0x40(%ebp),%eax
  80144d:	85 c0                	test   %eax,%eax
  80144f:	7e 09                	jle    80145a <lwip_recvfrom+0x147>
        sock->lastdata = buf;
  801451:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  801454:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  801458:	eb 19                	jmp    801473 <lwip_recvfrom+0x160>
      } else {
        sock->lastdata = NULL;
  80145a:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  801461:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  801467:	83 ec 0c             	sub    $0xc,%esp
  80146a:	56                   	push   %esi
  80146b:	e8 83 10 00 00       	call   8024f3 <netbuf_delete>
  801470:	83 c4 10             	add    $0x10,%esp
      }
    } else {
      done = 1;
    }
  } while (!done);
  801473:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  801477:	0f 84 c8 fe ff ff    	je     801345 <lwip_recvfrom+0x32>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  80147d:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801481:	0f 84 95 00 00 00    	je     80151c <lwip_recvfrom+0x209>
  801487:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80148b:	0f 84 8b 00 00 00    	je     80151c <lwip_recvfrom+0x209>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801491:	83 ec 0c             	sub    $0xc,%esp
  801494:	ff 37                	pushl  (%edi)
  801496:	e8 bb 97 00 00       	call   80ac56 <netconn_type>
  80149b:	83 c4 10             	add    $0x10,%esp
  80149e:	83 f8 10             	cmp    $0x10,%eax
  8014a1:	75 19                	jne    8014bc <lwip_recvfrom+0x1a9>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
      netconn_getaddr(sock->conn, addr, &port, 0);
  8014a3:	6a 00                	push   $0x0
  8014a5:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  8014a8:	50                   	push   %eax
  8014a9:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8014ac:	50                   	push   %eax
  8014ad:	ff 37                	pushl  (%edi)
  8014af:	e8 ca 97 00 00       	call   80ac7e <netconn_getaddr>
  8014b4:	83 c4 10             	add    $0x10,%esp
  /* Check to see from where the data was.*/
  if (from && fromlen) {
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  8014b7:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  8014ba:	eb 0b                	jmp    8014c7 <lwip_recvfrom+0x1b4>
      netconn_getaddr(sock->conn, addr, &port, 0);
    } else {
      addr = netbuf_fromaddr(buf);
  8014bc:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  8014bf:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8014c3:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  8014c7:	83 ec 04             	sub    $0x4,%esp
  8014ca:	6a 10                	push   $0x10
  8014cc:	6a 00                	push   $0x0
  8014ce:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8014d1:	50                   	push   %eax
  8014d2:	e8 1a d7 00 00       	call   80ebf1 <memset>
    sin.sin_len = sizeof(sin);
  8014d7:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  8014db:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  8014df:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8014e3:	89 04 24             	mov    %eax,(%esp)
  8014e6:	e8 eb 61 00 00       	call   8076d6 <htons>
  8014eb:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  8014ef:	8b 03                	mov    (%ebx),%eax
  8014f1:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  8014f4:	83 c4 10             	add    $0x10,%esp
  8014f7:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8014fa:	83 38 10             	cmpl   $0x10,(%eax)
  8014fd:	76 06                	jbe    801505 <lwip_recvfrom+0x1f2>
      *fromlen = sizeof(sin);
  8014ff:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

    SMEMCPY(from, &sin, *fromlen);
  801505:	83 ec 04             	sub    $0x4,%esp
  801508:	8b 45 1c             	mov    0x1c(%ebp),%eax
  80150b:	ff 30                	pushl  (%eax)
  80150d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801510:	50                   	push   %eax
  801511:	ff 75 18             	pushl  0x18(%ebp)
  801514:	e8 8d d7 00 00       	call   80eca6 <memcpy>
  801519:	83 c4 10             	add    $0x10,%esp
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  80151c:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  801523:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80152a:	00 00 00 
  return off;
  80152d:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  801531:	eb 05                	jmp    801538 <lwip_recvfrom+0x225>
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  if (!sock)
    return -1;
  801533:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  return off;
}
  801538:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80153b:	5b                   	pop    %ebx
  80153c:	5e                   	pop    %esi
  80153d:	5f                   	pop    %edi
  80153e:	5d                   	pop    %ebp
  80153f:	c3                   	ret    

00801540 <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  801540:	55                   	push   %ebp
  801541:	89 e5                	mov    %esp,%ebp
  801543:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  801546:	6a 00                	push   $0x0
  801548:	6a 00                	push   $0x0
  80154a:	6a 00                	push   $0x0
  80154c:	ff 75 10             	pushl  0x10(%ebp)
  80154f:	ff 75 0c             	pushl  0xc(%ebp)
  801552:	ff 75 08             	pushl  0x8(%ebp)
  801555:	e8 b9 fd ff ff       	call   801313 <lwip_recvfrom>
}
  80155a:	c9                   	leave  
  80155b:	c3                   	ret    

0080155c <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  80155c:	55                   	push   %ebp
  80155d:	89 e5                	mov    %esp,%ebp
  80155f:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  801562:	6a 00                	push   $0x0
  801564:	6a 00                	push   $0x0
  801566:	ff 75 14             	pushl  0x14(%ebp)
  801569:	ff 75 10             	pushl  0x10(%ebp)
  80156c:	ff 75 0c             	pushl  0xc(%ebp)
  80156f:	ff 75 08             	pushl  0x8(%ebp)
  801572:	e8 9c fd ff ff       	call   801313 <lwip_recvfrom>
}
  801577:	c9                   	leave  
  801578:	c3                   	ret    

00801579 <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  801579:	55                   	push   %ebp
  80157a:	89 e5                	mov    %esp,%ebp
  80157c:	57                   	push   %edi
  80157d:	56                   	push   %esi
  80157e:	53                   	push   %ebx
  80157f:	83 ec 2c             	sub    $0x2c,%esp
  801582:	8b 5d 10             	mov    0x10(%ebp),%ebx
  801585:	8b 75 18             	mov    0x18(%ebp),%esi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  801588:	8b 45 08             	mov    0x8(%ebp),%eax
  80158b:	e8 60 f2 ff ff       	call   8007f0 <get_socket>
  if (!sock)
  801590:	85 c0                	test   %eax,%eax
  801592:	0f 84 21 01 00 00    	je     8016b9 <lwip_sendto+0x140>
  801598:	89 c7                	mov    %eax,%edi
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  80159a:	8b 00                	mov    (%eax),%eax
  80159c:	83 38 10             	cmpl   $0x10,(%eax)
  80159f:	75 17                	jne    8015b8 <lwip_sendto+0x3f>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  8015a1:	ff 75 14             	pushl  0x14(%ebp)
  8015a4:	53                   	push   %ebx
  8015a5:	ff 75 0c             	pushl  0xc(%ebp)
  8015a8:	ff 75 08             	pushl  0x8(%ebp)
  8015ab:	e8 16 01 00 00       	call   8016c6 <lwip_send>
  8015b0:	83 c4 10             	add    $0x10,%esp
  8015b3:	e9 06 01 00 00       	jmp    8016be <lwip_sendto+0x145>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8015b8:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  8015be:	76 17                	jbe    8015d7 <lwip_sendto+0x5e>
  8015c0:	83 ec 04             	sub    $0x4,%esp
  8015c3:	68 18 0f 81 00       	push   $0x810f18
  8015c8:	68 97 02 00 00       	push   $0x297
  8015cd:	68 88 0e 81 00       	push   $0x810e88
  8015d2:	e8 77 ce 00 00       	call   80e44e <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8015d7:	85 f6                	test   %esi,%esi
  8015d9:	75 06                	jne    8015e1 <lwip_sendto+0x68>
  8015db:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8015df:	74 23                	je     801604 <lwip_sendto+0x8b>
  8015e1:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8015e5:	75 06                	jne    8015ed <lwip_sendto+0x74>
  8015e7:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8015eb:	74 17                	je     801604 <lwip_sendto+0x8b>
  8015ed:	83 ec 04             	sub    $0x4,%esp
  8015f0:	68 f9 0e 81 00       	push   $0x810ef9
  8015f5:	68 9b 02 00 00       	push   $0x29b
  8015fa:	68 88 0e 81 00       	push   $0x810e88
  8015ff:	e8 4a ce 00 00       	call   80e44e <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  801604:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80160b:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  801612:	85 f6                	test   %esi,%esi
  801614:	74 22                	je     801638 <lwip_sendto+0xbf>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  801616:	8b 46 04             	mov    0x4(%esi),%eax
  801619:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  80161c:	83 ec 0c             	sub    $0xc,%esp
  80161f:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801623:	50                   	push   %eax
  801624:	e8 ba 60 00 00       	call   8076e3 <ntohs>
    buf.addr         = &remote_addr;
  801629:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80162c:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  80162f:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  801633:	83 c4 10             	add    $0x10,%esp
  801636:	eb 14                	jmp    80164c <lwip_sendto+0xd3>
  } else {
    remote_addr.addr = 0;
  801638:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  80163f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  801646:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  80164c:	83 ec 04             	sub    $0x4,%esp
  80164f:	0f b7 c3             	movzwl %bx,%eax
  801652:	50                   	push   %eax
  801653:	ff 75 0c             	pushl  0xc(%ebp)
  801656:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801659:	50                   	push   %eax
  80165a:	e8 96 0f 00 00       	call   8025f5 <netbuf_ref>
  80165f:	0f be f0             	movsbl %al,%esi
  801662:	83 c4 10             	add    $0x10,%esp
  801665:	85 f6                	test   %esi,%esi
  801667:	75 14                	jne    80167d <lwip_sendto+0x104>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  801669:	83 ec 08             	sub    $0x8,%esp
  80166c:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80166f:	50                   	push   %eax
  801670:	ff 37                	pushl  (%edi)
  801672:	e8 d1 99 00 00       	call   80b048 <netconn_send>
  801677:	0f be f0             	movsbl %al,%esi
  80167a:	83 c4 10             	add    $0x10,%esp
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  80167d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  801680:	85 c0                	test   %eax,%eax
  801682:	74 0c                	je     801690 <lwip_sendto+0x117>
    pbuf_free(buf.p);
  801684:	83 ec 0c             	sub    $0xc,%esp
  801687:	50                   	push   %eax
  801688:	e8 98 31 00 00       	call   804825 <pbuf_free>
  80168d:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  801690:	89 f2                	mov    %esi,%edx
  801692:	f7 da                	neg    %edx
  801694:	b8 05 00 00 00       	mov    $0x5,%eax
  801699:	83 fa 0e             	cmp    $0xe,%edx
  80169c:	77 07                	ja     8016a5 <lwip_sendto+0x12c>
  80169e:	8b 04 95 40 0f 81 00 	mov    0x810f40(,%edx,4),%eax
  8016a5:	89 47 10             	mov    %eax,0x10(%edi)
  8016a8:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return (err==ERR_OK?size:-1);
  8016ad:	85 f6                	test   %esi,%esi
  8016af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8016b4:	0f 44 c3             	cmove  %ebx,%eax
  8016b7:	eb 05                	jmp    8016be <lwip_sendto+0x145>
  u16_t remote_port;
#endif

  sock = get_socket(s);
  if (!sock)
    return -1;
  8016b9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    pbuf_free(buf.p);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  8016be:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8016c1:	5b                   	pop    %ebx
  8016c2:	5e                   	pop    %esi
  8016c3:	5f                   	pop    %edi
  8016c4:	5d                   	pop    %ebp
  8016c5:	c3                   	ret    

008016c6 <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  8016c6:	55                   	push   %ebp
  8016c7:	89 e5                	mov    %esp,%ebp
  8016c9:	57                   	push   %edi
  8016ca:	56                   	push   %esi
  8016cb:	53                   	push   %ebx
  8016cc:	83 ec 0c             	sub    $0xc,%esp
  8016cf:	8b 7d 08             	mov    0x8(%ebp),%edi
  8016d2:	8b 5d 10             	mov    0x10(%ebp),%ebx
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  8016d5:	89 f8                	mov    %edi,%eax
  8016d7:	e8 14 f1 ff ff       	call   8007f0 <get_socket>
  if (!sock)
  8016dc:	85 c0                	test   %eax,%eax
  8016de:	74 6c                	je     80174c <lwip_send+0x86>
  8016e0:	89 c6                	mov    %eax,%esi
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  8016e2:	8b 10                	mov    (%eax),%edx
  8016e4:	83 3a 10             	cmpl   $0x10,(%edx)
  8016e7:	74 19                	je     801702 <lwip_send+0x3c>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  8016e9:	83 ec 08             	sub    $0x8,%esp
  8016ec:	6a 00                	push   $0x0
  8016ee:	6a 00                	push   $0x0
  8016f0:	ff 75 14             	pushl  0x14(%ebp)
  8016f3:	53                   	push   %ebx
  8016f4:	ff 75 0c             	pushl  0xc(%ebp)
  8016f7:	57                   	push   %edi
  8016f8:	e8 7c fe ff ff       	call   801579 <lwip_sendto>
  8016fd:	83 c4 20             	add    $0x20,%esp
  801700:	eb 4f                	jmp    801751 <lwip_send+0x8b>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  801702:	8b 45 14             	mov    0x14(%ebp),%eax
  801705:	83 e0 10             	and    $0x10,%eax
  801708:	83 f8 01             	cmp    $0x1,%eax
  80170b:	19 c0                	sbb    %eax,%eax
  80170d:	83 e0 fe             	and    $0xfffffffe,%eax
  801710:	83 c0 03             	add    $0x3,%eax
  801713:	50                   	push   %eax
  801714:	53                   	push   %ebx
  801715:	ff 75 0c             	pushl  0xc(%ebp)
  801718:	52                   	push   %edx
  801719:	e8 a6 99 00 00       	call   80b0c4 <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  80171e:	0f be d0             	movsbl %al,%edx
  801721:	f7 da                	neg    %edx
  801723:	83 c4 10             	add    $0x10,%esp
  801726:	b9 05 00 00 00       	mov    $0x5,%ecx
  80172b:	83 fa 0e             	cmp    $0xe,%edx
  80172e:	77 07                	ja     801737 <lwip_send+0x71>
  801730:	8b 0c 95 40 0f 81 00 	mov    0x810f40(,%edx,4),%ecx
  801737:	89 4e 10             	mov    %ecx,0x10(%esi)
  80173a:	89 0d e0 b1 b3 00    	mov    %ecx,0xb3b1e0
  return (err==ERR_OK?size:-1);
  801740:	84 c0                	test   %al,%al
  801742:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801747:	0f 44 c3             	cmove  %ebx,%eax
  80174a:	eb 05                	jmp    801751 <lwip_send+0x8b>
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  if (!sock)
    return -1;
  80174c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  801751:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801754:	5b                   	pop    %ebx
  801755:	5e                   	pop    %esi
  801756:	5f                   	pop    %edi
  801757:	5d                   	pop    %ebp
  801758:	c3                   	ret    

00801759 <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  801759:	55                   	push   %ebp
  80175a:	89 e5                	mov    %esp,%ebp
  80175c:	53                   	push   %ebx
  80175d:	83 ec 04             	sub    $0x4,%esp
  801760:	8b 45 0c             	mov    0xc(%ebp),%eax
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  801763:	83 f8 02             	cmp    $0x2,%eax
  801766:	74 27                	je     80178f <lwip_socket+0x36>
  801768:	83 f8 03             	cmp    $0x3,%eax
  80176b:	74 07                	je     801774 <lwip_socket+0x1b>
  80176d:	83 f8 01             	cmp    $0x1,%eax
  801770:	75 5c                	jne    8017ce <lwip_socket+0x75>
  801772:	eb 42                	jmp    8017b6 <lwip_socket+0x5d>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  801774:	83 ec 04             	sub    $0x4,%esp
  801777:	68 ec 09 80 00       	push   $0x8009ec
  80177c:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  801780:	50                   	push   %eax
  801781:	6a 40                	push   $0x40
  801783:	e8 a0 93 00 00       	call   80ab28 <netconn_new_with_proto_and_callback>
  801788:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  80178a:	83 c4 10             	add    $0x10,%esp
  80178d:	eb 50                	jmp    8017df <lwip_socket+0x86>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  80178f:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  801796:	0f 94 c0             	sete   %al
  801799:	0f b6 c0             	movzbl %al,%eax
  80179c:	83 c0 20             	add    $0x20,%eax
  80179f:	83 ec 04             	sub    $0x4,%esp
  8017a2:	68 ec 09 80 00       	push   $0x8009ec
  8017a7:	6a 00                	push   $0x0
  8017a9:	50                   	push   %eax
  8017aa:	e8 79 93 00 00       	call   80ab28 <netconn_new_with_proto_and_callback>
  8017af:	89 c3                	mov    %eax,%ebx
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8017b1:	83 c4 10             	add    $0x10,%esp
  8017b4:	eb 29                	jmp    8017df <lwip_socket+0x86>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8017b6:	83 ec 04             	sub    $0x4,%esp
  8017b9:	68 ec 09 80 00       	push   $0x8009ec
  8017be:	6a 00                	push   $0x0
  8017c0:	6a 10                	push   $0x10
  8017c2:	e8 61 93 00 00       	call   80ab28 <netconn_new_with_proto_and_callback>
  8017c7:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8017c9:	83 c4 10             	add    $0x10,%esp
  8017cc:	eb 11                	jmp    8017df <lwip_socket+0x86>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  8017ce:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  8017d5:	00 00 00 
    return -1;
  8017d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8017dd:	eb 4b                	jmp    80182a <lwip_socket+0xd1>
  }

  if (!conn) {
  8017df:	85 db                	test   %ebx,%ebx
  8017e1:	75 11                	jne    8017f4 <lwip_socket+0x9b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  8017e3:	c7 05 e0 b1 b3 00 69 	movl   $0x69,0xb3b1e0
  8017ea:	00 00 00 
    return -1;
  8017ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8017f2:	eb 36                	jmp    80182a <lwip_socket+0xd1>
  }

  i = alloc_socket(conn);
  8017f4:	89 d8                	mov    %ebx,%eax
  8017f6:	e8 91 f3 ff ff       	call   800b8c <alloc_socket>

  if (i == -1) {
  8017fb:	83 f8 ff             	cmp    $0xffffffff,%eax
  8017fe:	75 1d                	jne    80181d <lwip_socket+0xc4>
    netconn_delete(conn);
  801800:	83 ec 0c             	sub    $0xc,%esp
  801803:	53                   	push   %ebx
  801804:	e8 0d 94 00 00       	call   80ac16 <netconn_delete>
    set_errno(ENFILE);
  801809:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  801810:	00 00 00 
    return -1;
  801813:	83 c4 10             	add    $0x10,%esp
  801816:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80181b:	eb 0d                	jmp    80182a <lwip_socket+0xd1>
  }
  conn->socket = i;
  80181d:	89 43 1c             	mov    %eax,0x1c(%ebx)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  801820:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801827:	00 00 00 
  return i;
}
  80182a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80182d:	c9                   	leave  
  80182e:	c3                   	ret    

0080182f <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  80182f:	55                   	push   %ebp
  801830:	89 e5                	mov    %esp,%ebp
  801832:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  801835:	6a 00                	push   $0x0
  801837:	ff 75 10             	pushl  0x10(%ebp)
  80183a:	ff 75 0c             	pushl  0xc(%ebp)
  80183d:	ff 75 08             	pushl  0x8(%ebp)
  801840:	e8 81 fe ff ff       	call   8016c6 <lwip_send>
}
  801845:	c9                   	leave  
  801846:	c3                   	ret    

00801847 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  801847:	55                   	push   %ebp
  801848:	89 e5                	mov    %esp,%ebp
  80184a:	57                   	push   %edi
  80184b:	56                   	push   %esi
  80184c:	53                   	push   %ebx
  80184d:	83 ec 58             	sub    $0x58,%esp
  801850:	8b 7d 0c             	mov    0xc(%ebp),%edi
  801853:	8b 75 10             	mov    0x10(%ebp),%esi
  801856:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  801859:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  801860:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  801863:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  801866:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  801869:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  801870:	ff 35 40 50 81 00    	pushl  0x815040
  801876:	e8 67 38 00 00       	call   8050e2 <sys_sem_wait>

  if (readset)
  80187b:	83 c4 10             	add    $0x10,%esp
  80187e:	85 ff                	test   %edi,%edi
  801880:	74 07                	je     801889 <lwip_select+0x42>
    lreadset = *readset;
  801882:	8b 07                	mov    (%edi),%eax
  801884:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801887:	eb 13                	jmp    80189c <lwip_select+0x55>
  else
    FD_ZERO(&lreadset);
  801889:	83 ec 04             	sub    $0x4,%esp
  80188c:	6a 04                	push   $0x4
  80188e:	6a 00                	push   $0x0
  801890:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801893:	50                   	push   %eax
  801894:	e8 58 d3 00 00       	call   80ebf1 <memset>
  801899:	83 c4 10             	add    $0x10,%esp
  if (writeset)
  80189c:	85 f6                	test   %esi,%esi
  80189e:	74 07                	je     8018a7 <lwip_select+0x60>
    lwriteset = *writeset;
  8018a0:	8b 06                	mov    (%esi),%eax
  8018a2:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8018a5:	eb 13                	jmp    8018ba <lwip_select+0x73>
  else
    FD_ZERO(&lwriteset);
  8018a7:	83 ec 04             	sub    $0x4,%esp
  8018aa:	6a 04                	push   $0x4
  8018ac:	6a 00                	push   $0x0
  8018ae:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8018b1:	50                   	push   %eax
  8018b2:	e8 3a d3 00 00       	call   80ebf1 <memset>
  8018b7:	83 c4 10             	add    $0x10,%esp
  if (exceptset)
  8018ba:	85 db                	test   %ebx,%ebx
  8018bc:	74 07                	je     8018c5 <lwip_select+0x7e>
    lexceptset = *exceptset;
  8018be:	8b 03                	mov    (%ebx),%eax
  8018c0:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8018c3:	eb 13                	jmp    8018d8 <lwip_select+0x91>
  else
    FD_ZERO(&lexceptset);
  8018c5:	83 ec 04             	sub    $0x4,%esp
  8018c8:	6a 04                	push   $0x4
  8018ca:	6a 00                	push   $0x0
  8018cc:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8018cf:	50                   	push   %eax
  8018d0:	e8 1c d3 00 00       	call   80ebf1 <memset>
  8018d5:	83 c4 10             	add    $0x10,%esp

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8018d8:	83 ec 0c             	sub    $0xc,%esp
  8018db:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8018de:	50                   	push   %eax
  8018df:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  8018e2:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8018e5:	8b 45 08             	mov    0x8(%ebp),%eax
  8018e8:	e8 4e ef ff ff       	call   80083b <lwip_selscan>
  8018ed:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  8018f0:	83 c4 10             	add    $0x10,%esp
  8018f3:	85 c0                	test   %eax,%eax
  8018f5:	0f 85 b5 01 00 00    	jne    801ab0 <lwip_select+0x269>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  8018fb:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8018ff:	0f 84 4f 02 00 00    	je     801b54 <lwip_select+0x30d>
  801905:	8b 45 18             	mov    0x18(%ebp),%eax
  801908:	83 38 00             	cmpl   $0x0,(%eax)
  80190b:	0f 85 dd 01 00 00    	jne    801aee <lwip_select+0x2a7>
  801911:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  801915:	0f 85 d3 01 00 00    	jne    801aee <lwip_select+0x2a7>
      sys_sem_signal(selectsem);
  80191b:	83 ec 0c             	sub    $0xc,%esp
  80191e:	ff 35 40 50 81 00    	pushl  0x815040
  801924:	e8 af 86 00 00       	call   809fd8 <sys_sem_signal>
      if (readset)
  801929:	83 c4 10             	add    $0x10,%esp
  80192c:	85 ff                	test   %edi,%edi
  80192e:	74 10                	je     801940 <lwip_select+0xf9>
        FD_ZERO(readset);
  801930:	83 ec 04             	sub    $0x4,%esp
  801933:	6a 04                	push   $0x4
  801935:	6a 00                	push   $0x0
  801937:	57                   	push   %edi
  801938:	e8 b4 d2 00 00       	call   80ebf1 <memset>
  80193d:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801940:	85 f6                	test   %esi,%esi
  801942:	74 10                	je     801954 <lwip_select+0x10d>
        FD_ZERO(writeset);
  801944:	83 ec 04             	sub    $0x4,%esp
  801947:	6a 04                	push   $0x4
  801949:	6a 00                	push   $0x0
  80194b:	56                   	push   %esi
  80194c:	e8 a0 d2 00 00       	call   80ebf1 <memset>
  801951:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801954:	85 db                	test   %ebx,%ebx
  801956:	74 10                	je     801968 <lwip_select+0x121>
        FD_ZERO(exceptset);
  801958:	83 ec 04             	sub    $0x4,%esp
  80195b:	6a 04                	push   $0x4
  80195d:	6a 00                	push   $0x0
  80195f:	53                   	push   %ebx
  801960:	e8 8c d2 00 00       	call   80ebf1 <memset>
  801965:	83 c4 10             	add    $0x10,%esp
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  801968:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80196f:	00 00 00 
  
      return 0;
  801972:	b8 00 00 00 00       	mov    $0x0,%eax
  801977:	e9 10 02 00 00       	jmp    801b8c <lwip_select+0x345>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  80197c:	83 ec 08             	sub    $0x8,%esp
  80197f:	52                   	push   %edx
  801980:	ff 75 d8             	pushl  -0x28(%ebp)
  801983:	e8 19 39 00 00       	call   8052a1 <sys_sem_wait_timeout>
  801988:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  80198b:	83 c4 04             	add    $0x4,%esp
  80198e:	ff 35 40 50 81 00    	pushl  0x815040
  801994:	e8 49 37 00 00       	call   8050e2 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  801999:	a1 48 50 81 00       	mov    0x815048,%eax
  80199e:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  8019a1:	83 c4 10             	add    $0x10,%esp
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  8019a4:	89 d1                	mov    %edx,%ecx
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
  8019a6:	39 d0                	cmp    %edx,%eax
  8019a8:	75 19                	jne    8019c3 <lwip_select+0x17c>
      select_cb_list = select_cb.next;
  8019aa:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  8019ad:	a3 48 50 81 00       	mov    %eax,0x815048
  8019b2:	eb 13                	jmp    8019c7 <lwip_select+0x180>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  8019b4:	8b 10                	mov    (%eax),%edx
  8019b6:	39 ca                	cmp    %ecx,%edx
  8019b8:	75 07                	jne    8019c1 <lwip_select+0x17a>
          p_selcb->next = select_cb.next;
  8019ba:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  8019bd:	89 10                	mov    %edx,(%eax)
          break;
  8019bf:	eb 06                	jmp    8019c7 <lwip_select+0x180>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8019c1:	89 d0                	mov    %edx,%eax
  8019c3:	85 c0                	test   %eax,%eax
  8019c5:	75 ed                	jne    8019b4 <lwip_select+0x16d>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  8019c7:	83 ec 0c             	sub    $0xc,%esp
  8019ca:	ff 35 40 50 81 00    	pushl  0x815040
  8019d0:	e8 03 86 00 00       	call   809fd8 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  8019d5:	83 c4 04             	add    $0x4,%esp
  8019d8:	ff 75 d8             	pushl  -0x28(%ebp)
  8019db:	e8 cd 83 00 00       	call   809dad <sys_sem_free>
    if (i == 0)  {
  8019e0:	83 c4 10             	add    $0x10,%esp
  8019e3:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8019e7:	75 50                	jne    801a39 <lwip_select+0x1f2>
      /* Timeout */
      if (readset)
  8019e9:	85 ff                	test   %edi,%edi
  8019eb:	74 10                	je     8019fd <lwip_select+0x1b6>
        FD_ZERO(readset);
  8019ed:	83 ec 04             	sub    $0x4,%esp
  8019f0:	6a 04                	push   $0x4
  8019f2:	6a 00                	push   $0x0
  8019f4:	57                   	push   %edi
  8019f5:	e8 f7 d1 00 00       	call   80ebf1 <memset>
  8019fa:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  8019fd:	85 f6                	test   %esi,%esi
  8019ff:	74 10                	je     801a11 <lwip_select+0x1ca>
        FD_ZERO(writeset);
  801a01:	83 ec 04             	sub    $0x4,%esp
  801a04:	6a 04                	push   $0x4
  801a06:	6a 00                	push   $0x0
  801a08:	56                   	push   %esi
  801a09:	e8 e3 d1 00 00       	call   80ebf1 <memset>
  801a0e:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801a11:	85 db                	test   %ebx,%ebx
  801a13:	74 10                	je     801a25 <lwip_select+0x1de>
        FD_ZERO(exceptset);
  801a15:	83 ec 04             	sub    $0x4,%esp
  801a18:	6a 04                	push   $0x4
  801a1a:	6a 00                	push   $0x0
  801a1c:	53                   	push   %ebx
  801a1d:	e8 cf d1 00 00       	call   80ebf1 <memset>
  801a22:	83 c4 10             	add    $0x10,%esp
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  801a25:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801a2c:	00 00 00 
  
      return 0;
  801a2f:	b8 00 00 00 00       	mov    $0x0,%eax
  801a34:	e9 53 01 00 00       	jmp    801b8c <lwip_select+0x345>
    }
    
    if (readset)
  801a39:	85 ff                	test   %edi,%edi
  801a3b:	74 07                	je     801a44 <lwip_select+0x1fd>
      lreadset = *readset;
  801a3d:	8b 07                	mov    (%edi),%eax
  801a3f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801a42:	eb 13                	jmp    801a57 <lwip_select+0x210>
    else
      FD_ZERO(&lreadset);
  801a44:	83 ec 04             	sub    $0x4,%esp
  801a47:	6a 04                	push   $0x4
  801a49:	6a 00                	push   $0x0
  801a4b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801a4e:	50                   	push   %eax
  801a4f:	e8 9d d1 00 00       	call   80ebf1 <memset>
  801a54:	83 c4 10             	add    $0x10,%esp
    if (writeset)
  801a57:	85 f6                	test   %esi,%esi
  801a59:	74 07                	je     801a62 <lwip_select+0x21b>
      lwriteset = *writeset;
  801a5b:	8b 06                	mov    (%esi),%eax
  801a5d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801a60:	eb 13                	jmp    801a75 <lwip_select+0x22e>
    else
      FD_ZERO(&lwriteset);
  801a62:	83 ec 04             	sub    $0x4,%esp
  801a65:	6a 04                	push   $0x4
  801a67:	6a 00                	push   $0x0
  801a69:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801a6c:	50                   	push   %eax
  801a6d:	e8 7f d1 00 00       	call   80ebf1 <memset>
  801a72:	83 c4 10             	add    $0x10,%esp
    if (exceptset)
  801a75:	85 db                	test   %ebx,%ebx
  801a77:	74 07                	je     801a80 <lwip_select+0x239>
      lexceptset = *exceptset;
  801a79:	8b 03                	mov    (%ebx),%eax
  801a7b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801a7e:	eb 13                	jmp    801a93 <lwip_select+0x24c>
    else
      FD_ZERO(&lexceptset);
  801a80:	83 ec 04             	sub    $0x4,%esp
  801a83:	6a 04                	push   $0x4
  801a85:	6a 00                	push   $0x0
  801a87:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a8a:	50                   	push   %eax
  801a8b:	e8 61 d1 00 00       	call   80ebf1 <memset>
  801a90:	83 c4 10             	add    $0x10,%esp
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801a93:	83 ec 0c             	sub    $0xc,%esp
  801a96:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a99:	50                   	push   %eax
  801a9a:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801a9d:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801aa0:	8b 45 08             	mov    0x8(%ebp),%eax
  801aa3:	e8 93 ed ff ff       	call   80083b <lwip_selscan>
  801aa8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801aab:	83 c4 10             	add    $0x10,%esp
  801aae:	eb 11                	jmp    801ac1 <lwip_select+0x27a>
  } else
    sys_sem_signal(selectsem);
  801ab0:	83 ec 0c             	sub    $0xc,%esp
  801ab3:	ff 35 40 50 81 00    	pushl  0x815040
  801ab9:	e8 1a 85 00 00       	call   809fd8 <sys_sem_signal>
  801abe:	83 c4 10             	add    $0x10,%esp
  
  if (readset)
  801ac1:	85 ff                	test   %edi,%edi
  801ac3:	74 05                	je     801aca <lwip_select+0x283>
    *readset = lreadset;
  801ac5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801ac8:	89 07                	mov    %eax,(%edi)
  if (writeset)
  801aca:	85 f6                	test   %esi,%esi
  801acc:	74 05                	je     801ad3 <lwip_select+0x28c>
    *writeset = lwriteset;
  801ace:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801ad1:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801ad3:	85 db                	test   %ebx,%ebx
  801ad5:	74 05                	je     801adc <lwip_select+0x295>
    *exceptset = lexceptset;
  801ad7:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801ada:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  801adc:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801ae3:	00 00 00 
  
  return nready;
  801ae6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801ae9:	e9 9e 00 00 00       	jmp    801b8c <lwip_select+0x345>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801aee:	83 ec 0c             	sub    $0xc,%esp
  801af1:	6a 00                	push   $0x0
  801af3:	e8 34 82 00 00       	call   809d2c <sys_sem_new>
  801af8:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801afb:	a1 48 50 81 00       	mov    0x815048,%eax
  801b00:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801b03:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801b06:	a3 48 50 81 00       	mov    %eax,0x815048
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801b0b:	83 c4 04             	add    $0x4,%esp
  801b0e:	ff 35 40 50 81 00    	pushl  0x815040
  801b14:	e8 bf 84 00 00       	call   809fd8 <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801b19:	8b 45 18             	mov    0x18(%ebp),%eax
  801b1c:	8b 40 04             	mov    0x4(%eax),%eax
  801b1f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801b22:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  801b28:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  801b2d:	89 c8                	mov    %ecx,%eax
  801b2f:	f7 ea                	imul   %edx
  801b31:	c1 fa 06             	sar    $0x6,%edx
  801b34:	c1 f9 1f             	sar    $0x1f,%ecx
  801b37:	29 ca                	sub    %ecx,%edx
  801b39:	8b 45 18             	mov    0x18(%ebp),%eax
  801b3c:	69 00 e8 03 00 00    	imul   $0x3e8,(%eax),%eax
      if(msectimeout == 0)
  801b42:	83 c4 10             	add    $0x10,%esp
  801b45:	01 c2                	add    %eax,%edx
        msectimeout = 1;
  801b47:	b8 01 00 00 00       	mov    $0x1,%eax
  801b4c:	0f 44 d0             	cmove  %eax,%edx
  801b4f:	e9 28 fe ff ff       	jmp    80197c <lwip_select+0x135>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801b54:	83 ec 0c             	sub    $0xc,%esp
  801b57:	6a 00                	push   $0x0
  801b59:	e8 ce 81 00 00       	call   809d2c <sys_sem_new>
  801b5e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801b61:	a1 48 50 81 00       	mov    0x815048,%eax
  801b66:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801b69:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801b6c:	a3 48 50 81 00       	mov    %eax,0x815048
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801b71:	83 c4 04             	add    $0x4,%esp
  801b74:	ff 35 40 50 81 00    	pushl  0x815040
  801b7a:	e8 59 84 00 00       	call   809fd8 <sys_sem_signal>
  801b7f:	83 c4 10             	add    $0x10,%esp
    
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
  801b82:	ba 00 00 00 00       	mov    $0x0,%edx
  801b87:	e9 f0 fd ff ff       	jmp    80197c <lwip_select+0x135>
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  
  return nready;
}
  801b8c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801b8f:	5b                   	pop    %ebx
  801b90:	5e                   	pop    %esi
  801b91:	5f                   	pop    %edi
  801b92:	5d                   	pop    %ebp
  801b93:	c3                   	ret    

00801b94 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  801b94:	55                   	push   %ebp
  801b95:	89 e5                	mov    %esp,%ebp
  801b97:	83 ec 14             	sub    $0x14,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801b9a:	ff 75 08             	pushl  0x8(%ebp)
  801b9d:	e8 a5 f5 ff ff       	call   801147 <lwip_close>
}
  801ba2:	c9                   	leave  
  801ba3:	c3                   	ret    

00801ba4 <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  801ba4:	55                   	push   %ebp
  801ba5:	89 e5                	mov    %esp,%ebp
  801ba7:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801baa:	6a 00                	push   $0x0
  801bac:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801baf:	8b 55 0c             	mov    0xc(%ebp),%edx
  801bb2:	8b 45 08             	mov    0x8(%ebp),%eax
  801bb5:	e8 87 ed ff ff       	call   800941 <lwip_getaddrname>
}
  801bba:	c9                   	leave  
  801bbb:	c3                   	ret    

00801bbc <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  801bbc:	55                   	push   %ebp
  801bbd:	89 e5                	mov    %esp,%ebp
  801bbf:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801bc2:	6a 01                	push   $0x1
  801bc4:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801bc7:	8b 55 0c             	mov    0xc(%ebp),%edx
  801bca:	8b 45 08             	mov    0x8(%ebp),%eax
  801bcd:	e8 6f ed ff ff       	call   800941 <lwip_getaddrname>
}
  801bd2:	c9                   	leave  
  801bd3:	c3                   	ret    

00801bd4 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  801bd4:	55                   	push   %ebp
  801bd5:	89 e5                	mov    %esp,%ebp
  801bd7:	57                   	push   %edi
  801bd8:	56                   	push   %esi
  801bd9:	53                   	push   %ebx
  801bda:	83 ec 2c             	sub    $0x2c,%esp
  801bdd:	8b 75 0c             	mov    0xc(%ebp),%esi
  801be0:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  801be3:	8b 45 08             	mov    0x8(%ebp),%eax
  801be6:	e8 05 ec ff ff       	call   8007f0 <get_socket>
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801beb:	85 c0                	test   %eax,%eax
  801bed:	0f 84 7c 01 00 00    	je     801d6f <lwip_getsockopt+0x19b>
  801bf3:	89 c3                	mov    %eax,%ebx
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  801bf5:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801bf9:	74 04                	je     801bff <lwip_getsockopt+0x2b>
  801bfb:	85 ff                	test   %edi,%edi
  801bfd:	75 1b                	jne    801c1a <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  801bff:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801c06:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801c0d:	00 00 00 
    return -1;
  801c10:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801c15:	e9 95 01 00 00       	jmp    801daf <lwip_getsockopt+0x1db>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801c1a:	83 fe 06             	cmp    $0x6,%esi
  801c1d:	0f 84 9c 00 00 00    	je     801cbf <lwip_getsockopt+0xeb>
  801c23:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801c29:	74 0f                	je     801c3a <lwip_getsockopt+0x66>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  801c2b:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801c30:	85 f6                	test   %esi,%esi
  801c32:	0f 85 c4 00 00 00    	jne    801cfc <lwip_getsockopt+0x128>
  801c38:	eb 6f                	jmp    801ca9 <lwip_getsockopt+0xd5>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801c3a:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801c3e:	74 39                	je     801c79 <lwip_getsockopt+0xa5>
  801c40:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801c44:	7f 12                	jg     801c58 <lwip_getsockopt+0x84>
  801c46:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  801c4a:	74 2d                	je     801c79 <lwip_getsockopt+0xa5>
  801c4c:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801c50:	0f 85 93 00 00 00    	jne    801ce9 <lwip_getsockopt+0x115>
  801c56:	eb 21                	jmp    801c79 <lwip_getsockopt+0xa5>
  801c58:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  801c5f:	0f 8c 84 00 00 00    	jl     801ce9 <lwip_getsockopt+0x115>
  801c65:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801c6c:	7e 0b                	jle    801c79 <lwip_getsockopt+0xa5>
  801c6e:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801c75:	74 10                	je     801c87 <lwip_getsockopt+0xb3>
  801c77:	eb 70                	jmp    801ce9 <lwip_getsockopt+0x115>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  801c79:	83 3f 03             	cmpl   $0x3,(%edi)
  801c7c:	0f 86 f4 00 00 00    	jbe    801d76 <lwip_getsockopt+0x1a2>
  801c82:	e9 8e 00 00 00       	jmp    801d15 <lwip_getsockopt+0x141>
      }
      break;

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801c87:	83 3f 04             	cmpl   $0x4,(%edi)
  801c8a:	19 c0                	sbb    %eax,%eax
  801c8c:	83 e0 16             	and    $0x16,%eax
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801c8f:	8b 13                	mov    (%ebx),%edx
  801c91:	83 3a 20             	cmpl   $0x20,(%edx)
  801c94:	0f 85 e3 00 00 00    	jne    801d7d <lwip_getsockopt+0x1a9>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801c9a:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801c9d:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801ca1:	0f 85 e0 00 00 00    	jne    801d87 <lwip_getsockopt+0x1b3>
  801ca7:	eb 53                	jmp    801cfc <lwip_getsockopt+0x128>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801ca9:	8b 45 10             	mov    0x10(%ebp),%eax
  801cac:	83 e8 01             	sub    $0x1,%eax
  801caf:	83 f8 01             	cmp    $0x1,%eax
  801cb2:	77 3c                	ja     801cf0 <lwip_getsockopt+0x11c>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  801cb4:	83 3f 03             	cmpl   $0x3,(%edi)
  801cb7:	0f 86 d4 00 00 00    	jbe    801d91 <lwip_getsockopt+0x1bd>
  801cbd:	eb 56                	jmp    801d15 <lwip_getsockopt+0x141>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  801cbf:	83 3f 03             	cmpl   $0x3,(%edi)
  801cc2:	0f 86 d3 00 00 00    	jbe    801d9b <lwip_getsockopt+0x1c7>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801cc8:	8b 10                	mov    (%eax),%edx
      return 0;
  801cca:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801ccf:	83 3a 10             	cmpl   $0x10,(%edx)
  801cd2:	0f 85 d7 00 00 00    	jne    801daf <lwip_getsockopt+0x1db>
      return 0;

    switch (optname) {
  801cd8:	8b 45 10             	mov    0x10(%ebp),%eax
  801cdb:	83 e8 01             	sub    $0x1,%eax
  801cde:	83 f8 01             	cmp    $0x1,%eax
  801ce1:	0f 87 be 00 00 00    	ja     801da5 <lwip_getsockopt+0x1d1>
  801ce7:	eb 0e                	jmp    801cf7 <lwip_getsockopt+0x123>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801ce9:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801cee:	eb 0c                	jmp    801cfc <lwip_getsockopt+0x128>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801cf0:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801cf5:	eb 05                	jmp    801cfc <lwip_getsockopt+0x128>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801cf7:	b8 00 00 00 00       	mov    $0x0,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  801cfc:	84 c0                	test   %al,%al
  801cfe:	74 15                	je     801d15 <lwip_getsockopt+0x141>
    sock_set_errno(sock, err);
  801d00:	0f be c0             	movsbl %al,%eax
  801d03:	89 43 10             	mov    %eax,0x10(%ebx)
  801d06:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801d0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d10:	e9 9a 00 00 00       	jmp    801daf <lwip_getsockopt+0x1db>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  801d15:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801d18:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801d1b:	8b 45 10             	mov    0x10(%ebp),%eax
  801d1e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801d21:	8b 45 14             	mov    0x14(%ebp),%eax
  801d24:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801d27:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  801d2a:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801d2e:	83 ec 04             	sub    $0x4,%esp
  801d31:	6a 01                	push   $0x1
  801d33:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801d36:	50                   	push   %eax
  801d37:	68 34 0c 80 00       	push   $0x800c34
  801d3c:	e8 d4 05 00 00       	call   802315 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801d41:	83 c4 08             	add    $0x8,%esp
  801d44:	6a 00                	push   $0x0
  801d46:	8b 03                	mov    (%ebx),%eax
  801d48:	ff 70 10             	pushl  0x10(%eax)
  801d4b:	e8 f6 82 00 00       	call   80a046 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  801d50:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  801d54:	0f be d0             	movsbl %al,%edx
  801d57:	89 53 10             	mov    %edx,0x10(%ebx)
  801d5a:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  return err ? -1 : 0;
  801d60:	83 c4 10             	add    $0x10,%esp
  801d63:	84 c0                	test   %al,%al
  801d65:	0f 95 c0             	setne  %al
  801d68:	0f b6 c0             	movzbl %al,%eax
  801d6b:	f7 d8                	neg    %eax
  801d6d:	eb 40                	jmp    801daf <lwip_getsockopt+0x1db>
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  801d6f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d74:	eb 39                	jmp    801daf <lwip_getsockopt+0x1db>
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801d76:	b8 16 00 00 00       	mov    $0x16,%eax
  801d7b:	eb 83                	jmp    801d00 <lwip_getsockopt+0x12c>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  801d7d:	b8 61 00 00 00       	mov    $0x61,%eax
  801d82:	e9 79 ff ff ff       	jmp    801d00 <lwip_getsockopt+0x12c>
  801d87:	b8 61 00 00 00       	mov    $0x61,%eax
  801d8c:	e9 6f ff ff ff       	jmp    801d00 <lwip_getsockopt+0x12c>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801d91:	b8 16 00 00 00       	mov    $0x16,%eax
  801d96:	e9 65 ff ff ff       	jmp    801d00 <lwip_getsockopt+0x12c>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
      err = EINVAL;
  801d9b:	b8 16 00 00 00       	mov    $0x16,%eax
  801da0:	e9 5b ff ff ff       	jmp    801d00 <lwip_getsockopt+0x12c>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801da5:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801daa:	e9 51 ff ff ff       	jmp    801d00 <lwip_getsockopt+0x12c>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  801daf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801db2:	5b                   	pop    %ebx
  801db3:	5e                   	pop    %esi
  801db4:	5f                   	pop    %edi
  801db5:	5d                   	pop    %ebp
  801db6:	c3                   	ret    

00801db7 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  801db7:	55                   	push   %ebp
  801db8:	89 e5                	mov    %esp,%ebp
  801dba:	57                   	push   %edi
  801dbb:	56                   	push   %esi
  801dbc:	53                   	push   %ebx
  801dbd:	83 ec 2c             	sub    $0x2c,%esp
  801dc0:	8b 75 0c             	mov    0xc(%ebp),%esi
  801dc3:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801dc6:	8b 45 08             	mov    0x8(%ebp),%eax
  801dc9:	e8 22 ea ff ff       	call   8007f0 <get_socket>
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801dce:	85 c0                	test   %eax,%eax
  801dd0:	0f 84 47 01 00 00    	je     801f1d <lwip_setsockopt+0x166>
  801dd6:	89 c3                	mov    %eax,%ebx
    return -1;

  if (NULL == optval) {
  801dd8:	85 ff                	test   %edi,%edi
  801dda:	75 1b                	jne    801df7 <lwip_setsockopt+0x40>
    sock_set_errno(sock, EFAULT);
  801ddc:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801de3:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801dea:	00 00 00 
    return -1;
  801ded:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801df2:	e9 63 01 00 00       	jmp    801f5a <lwip_setsockopt+0x1a3>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801df7:	83 fe 06             	cmp    $0x6,%esi
  801dfa:	74 7e                	je     801e7a <lwip_setsockopt+0xc3>
  801dfc:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801e02:	74 0f                	je     801e13 <lwip_setsockopt+0x5c>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  801e04:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801e09:	85 f6                	test   %esi,%esi
  801e0b:	0f 85 a0 00 00 00    	jne    801eb1 <lwip_setsockopt+0xfa>
  801e11:	eb 50                	jmp    801e63 <lwip_setsockopt+0xac>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801e13:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801e17:	74 18                	je     801e31 <lwip_setsockopt+0x7a>
  801e19:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801e20:	74 1e                	je     801e40 <lwip_setsockopt+0x89>
#endif /* LWIP_UDP */
      break;
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  801e22:	b8 5c 00 00 00       	mov    $0x5c,%eax
  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801e27:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801e2b:	0f 85 80 00 00 00    	jne    801eb1 <lwip_setsockopt+0xfa>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  801e31:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e35:	0f 86 e9 00 00 00    	jbe    801f24 <lwip_setsockopt+0x16d>
  801e3b:	e9 87 00 00 00       	jmp    801ec7 <lwip_setsockopt+0x110>
        err = EINVAL;
      }
      break;
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801e40:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801e44:	19 c0                	sbb    %eax,%eax
  801e46:	83 e0 16             	and    $0x16,%eax
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801e49:	8b 13                	mov    (%ebx),%edx
  801e4b:	83 3a 20             	cmpl   $0x20,(%edx)
  801e4e:	0f 85 d7 00 00 00    	jne    801f2b <lwip_setsockopt+0x174>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801e54:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801e57:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801e5b:	0f 85 d1 00 00 00    	jne    801f32 <lwip_setsockopt+0x17b>
  801e61:	eb 4e                	jmp    801eb1 <lwip_setsockopt+0xfa>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801e63:	8b 45 10             	mov    0x10(%ebp),%eax
  801e66:	83 e8 01             	sub    $0x1,%eax
  801e69:	83 f8 01             	cmp    $0x1,%eax
  801e6c:	77 37                	ja     801ea5 <lwip_setsockopt+0xee>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  801e6e:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e72:	0f 86 c4 00 00 00    	jbe    801f3c <lwip_setsockopt+0x185>
  801e78:	eb 4d                	jmp    801ec7 <lwip_setsockopt+0x110>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  801e7a:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e7e:	0f 86 c2 00 00 00    	jbe    801f46 <lwip_setsockopt+0x18f>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801e84:	8b 10                	mov    (%eax),%edx
      return 0;
  801e86:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801e8b:	83 3a 10             	cmpl   $0x10,(%edx)
  801e8e:	0f 85 c6 00 00 00    	jne    801f5a <lwip_setsockopt+0x1a3>
      return 0;

    switch (optname) {
  801e94:	8b 45 10             	mov    0x10(%ebp),%eax
  801e97:	83 e8 01             	sub    $0x1,%eax
  801e9a:	83 f8 01             	cmp    $0x1,%eax
  801e9d:	0f 87 ad 00 00 00    	ja     801f50 <lwip_setsockopt+0x199>
  801ea3:	eb 07                	jmp    801eac <lwip_setsockopt+0xf5>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  801ea5:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801eaa:	eb 05                	jmp    801eb1 <lwip_setsockopt+0xfa>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  801eac:	b8 00 00 00 00       	mov    $0x0,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  801eb1:	85 c0                	test   %eax,%eax
  801eb3:	74 12                	je     801ec7 <lwip_setsockopt+0x110>
    sock_set_errno(sock, err);
  801eb5:	89 43 10             	mov    %eax,0x10(%ebx)
  801eb8:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801ebd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801ec2:	e9 93 00 00 00       	jmp    801f5a <lwip_setsockopt+0x1a3>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  801ec7:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801eca:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801ecd:	8b 45 10             	mov    0x10(%ebp),%eax
  801ed0:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  801ed3:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  801ed6:	8d 45 18             	lea    0x18(%ebp),%eax
  801ed9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801edc:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  801ee0:	83 ec 04             	sub    $0x4,%esp
  801ee3:	6a 01                	push   $0x1
  801ee5:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801ee8:	50                   	push   %eax
  801ee9:	68 b7 0d 80 00       	push   $0x800db7
  801eee:	e8 22 04 00 00       	call   802315 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801ef3:	83 c4 08             	add    $0x8,%esp
  801ef6:	6a 00                	push   $0x0
  801ef8:	8b 03                	mov    (%ebx),%eax
  801efa:	ff 70 10             	pushl  0x10(%eax)
  801efd:	e8 44 81 00 00       	call   80a046 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  801f02:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  801f06:	89 43 10             	mov    %eax,0x10(%ebx)
  801f09:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return err ? -1 : 0;
  801f0e:	83 c4 10             	add    $0x10,%esp
  801f11:	85 c0                	test   %eax,%eax
  801f13:	0f 95 c0             	setne  %al
  801f16:	0f b6 c0             	movzbl %al,%eax
  801f19:	f7 d8                	neg    %eax
  801f1b:	eb 3d                	jmp    801f5a <lwip_setsockopt+0x1a3>
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  801f1d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f22:	eb 36                	jmp    801f5a <lwip_setsockopt+0x1a3>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801f24:	b8 16 00 00 00       	mov    $0x16,%eax
  801f29:	eb 8a                	jmp    801eb5 <lwip_setsockopt+0xfe>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  801f2b:	b8 61 00 00 00       	mov    $0x61,%eax
  801f30:	eb 83                	jmp    801eb5 <lwip_setsockopt+0xfe>
  801f32:	b8 61 00 00 00       	mov    $0x61,%eax
  801f37:	e9 79 ff ff ff       	jmp    801eb5 <lwip_setsockopt+0xfe>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801f3c:	b8 16 00 00 00       	mov    $0x16,%eax
  801f41:	e9 6f ff ff ff       	jmp    801eb5 <lwip_setsockopt+0xfe>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
      err = EINVAL;
  801f46:	b8 16 00 00 00       	mov    $0x16,%eax
  801f4b:	e9 65 ff ff ff       	jmp    801eb5 <lwip_setsockopt+0xfe>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  801f50:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f55:	e9 5b ff ff ff       	jmp    801eb5 <lwip_setsockopt+0xfe>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  801f5a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801f5d:	5b                   	pop    %ebx
  801f5e:	5e                   	pop    %esi
  801f5f:	5f                   	pop    %edi
  801f60:	5d                   	pop    %ebp
  801f61:	c3                   	ret    

00801f62 <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  801f62:	55                   	push   %ebp
  801f63:	89 e5                	mov    %esp,%ebp
  801f65:	56                   	push   %esi
  801f66:	53                   	push   %ebx
  801f67:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801f6a:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  801f6d:	8b 45 08             	mov    0x8(%ebp),%eax
  801f70:	e8 7b e8 ff ff       	call   8007f0 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  801f75:	85 c0                	test   %eax,%eax
  801f77:	0f 84 af 00 00 00    	je     80202c <lwip_ioctl+0xca>
    return -1;

  switch (cmd) {
  801f7d:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  801f83:	74 60                	je     801fe5 <lwip_ioctl+0x83>
  801f85:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  801f8b:	0f 85 83 00 00 00    	jne    802014 <lwip_ioctl+0xb2>
  case FIONREAD:
    if (!argp) {
  801f91:	85 f6                	test   %esi,%esi
  801f93:	75 1b                	jne    801fb0 <lwip_ioctl+0x4e>
      sock_set_errno(sock, EINVAL);
  801f95:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  801f9c:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801fa3:	00 00 00 
      return -1;
  801fa6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801fab:	e9 81 00 00 00       	jmp    802031 <lwip_ioctl+0xcf>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  801fb0:	8b 10                	mov    (%eax),%edx
  801fb2:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  801fb6:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  801fb9:	8b 48 04             	mov    0x4(%eax),%ecx
  801fbc:	85 c9                	test   %ecx,%ecx
  801fbe:	74 0d                	je     801fcd <lwip_ioctl+0x6b>
      buflen = netbuf_len(sock->lastdata);
  801fc0:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  801fc2:	66 03 51 08          	add    0x8(%ecx),%dx
  801fc6:	66 2b 50 08          	sub    0x8(%eax),%dx
  801fca:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  801fcd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801fd4:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801fdb:	00 00 00 
    return 0;
  801fde:	b8 00 00 00 00       	mov    $0x0,%eax
  801fe3:	eb 4c                	jmp    802031 <lwip_ioctl+0xcf>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  801fe5:	85 f6                	test   %esi,%esi
  801fe7:	74 0d                	je     801ff6 <lwip_ioctl+0x94>
  801fe9:	83 3e 00             	cmpl   $0x0,(%esi)
  801fec:	74 08                	je     801ff6 <lwip_ioctl+0x94>
      sock->flags |= O_NONBLOCK;
  801fee:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
  801ff4:	eb 06                	jmp    801ffc <lwip_ioctl+0x9a>
    else
      sock->flags &= ~O_NONBLOCK;
  801ff6:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  801ffc:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  802003:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80200a:	00 00 00 
    return 0;
  80200d:	b8 00 00 00 00       	mov    $0x0,%eax
  802012:	eb 1d                	jmp    802031 <lwip_ioctl+0xcf>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  802014:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  80201b:	c7 05 e0 b1 b3 00 26 	movl   $0x26,0xb3b1e0
  802022:	00 00 00 
    return -1;
  802025:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80202a:	eb 05                	jmp    802031 <lwip_ioctl+0xcf>
{
  struct lwip_socket *sock = get_socket(s);
  u16_t buflen = 0;

  if (!sock)
    return -1;
  80202c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  802031:	5b                   	pop    %ebx
  802032:	5e                   	pop    %esi
  802033:	5d                   	pop    %ebp
  802034:	c3                   	ret    

00802035 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  802035:	55                   	push   %ebp
  802036:	89 e5                	mov    %esp,%ebp
  802038:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  80203b:	e8 fe 40 00 00       	call   80613e <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  802040:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  802047:	75 09                	jne    802052 <tcpip_tcp_timer+0x1d>
  802049:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  802050:	74 19                	je     80206b <tcpip_tcp_timer+0x36>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  802052:	83 ec 04             	sub    $0x4,%esp
  802055:	6a 00                	push   $0x0
  802057:	68 35 20 80 00       	push   $0x802035
  80205c:	68 fa 00 00 00       	push   $0xfa
  802061:	e8 0a 31 00 00       	call   805170 <sys_timeout>
  802066:	83 c4 10             	add    $0x10,%esp
  802069:	eb 0a                	jmp    802075 <tcpip_tcp_timer+0x40>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  80206b:	c7 05 e0 52 81 00 00 	movl   $0x0,0x8152e0
  802072:	00 00 00 
  }
}
  802075:	c9                   	leave  
  802076:	c3                   	ret    

00802077 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  802077:	55                   	push   %ebp
  802078:	89 e5                	mov    %esp,%ebp
  80207a:	53                   	push   %ebx
  80207b:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80207e:	6a 00                	push   $0x0
  802080:	68 2d 22 80 00       	push   $0x80222d
  802085:	68 e8 03 00 00       	push   $0x3e8
  80208a:	e8 e1 30 00 00       	call   805170 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80208f:	83 c4 0c             	add    $0xc,%esp
  802092:	6a 00                	push   $0x0
  802094:	68 09 22 80 00       	push   $0x802209
  802099:	68 88 13 00 00       	push   $0x1388
  80209e:	e8 cd 30 00 00       	call   805170 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8020a3:	83 c4 0c             	add    $0xc,%esp
  8020a6:	6a 00                	push   $0x0
  8020a8:	68 e5 21 80 00       	push   $0x8021e5
  8020ad:	68 60 ea 00 00       	push   $0xea60
  8020b2:	e8 b9 30 00 00       	call   805170 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8020b7:	83 c4 0c             	add    $0xc,%esp
  8020ba:	6a 00                	push   $0x0
  8020bc:	68 c1 21 80 00       	push   $0x8021c1
  8020c1:	68 f4 01 00 00       	push   $0x1f4
  8020c6:	e8 a5 30 00 00       	call   805170 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  8020cb:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  8020d0:	83 c4 10             	add    $0x10,%esp
  8020d3:	85 c0                	test   %eax,%eax
  8020d5:	74 0e                	je     8020e5 <tcpip_thread+0x6e>
    tcpip_init_done(tcpip_init_done_arg);
  8020d7:	83 ec 0c             	sub    $0xc,%esp
  8020da:	ff 35 e4 52 81 00    	pushl  0x8152e4
  8020e0:	ff d0                	call   *%eax
  8020e2:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8020e5:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8020e8:	83 ec 08             	sub    $0x8,%esp
  8020eb:	53                   	push   %ebx
  8020ec:	ff 35 00 40 81 00    	pushl  0x814000
  8020f2:	e8 57 2f 00 00       	call   80504e <sys_mbox_fetch>
    switch (msg->type) {
  8020f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8020fa:	83 c4 10             	add    $0x10,%esp
  8020fd:	8b 02                	mov    (%edx),%eax
  8020ff:	83 f8 01             	cmp    $0x1,%eax
  802102:	74 22                	je     802126 <tcpip_thread+0xaf>
  802104:	83 f8 01             	cmp    $0x1,%eax
  802107:	72 0c                	jb     802115 <tcpip_thread+0x9e>
  802109:	83 f8 02             	cmp    $0x2,%eax
  80210c:	74 53                	je     802161 <tcpip_thread+0xea>
  80210e:	83 f8 03             	cmp    $0x3,%eax
  802111:	74 6c                	je     80217f <tcpip_thread+0x108>
  802113:	eb d3                	jmp    8020e8 <tcpip_thread+0x71>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  802115:	8b 42 08             	mov    0x8(%edx),%eax
  802118:	83 ec 0c             	sub    $0xc,%esp
  80211b:	8d 50 04             	lea    0x4(%eax),%edx
  80211e:	52                   	push   %edx
  80211f:	ff 10                	call   *(%eax)
      break;
  802121:	83 c4 10             	add    $0x10,%esp
  802124:	eb c2                	jmp    8020e8 <tcpip_thread+0x71>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  802126:	8b 42 0c             	mov    0xc(%edx),%eax
  802129:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  80212d:	74 11                	je     802140 <tcpip_thread+0xc9>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  80212f:	83 ec 08             	sub    $0x8,%esp
  802132:	50                   	push   %eax
  802133:	ff 72 08             	pushl  0x8(%edx)
  802136:	e8 4b 7a 00 00       	call   809b86 <ethernet_input>
  80213b:	83 c4 10             	add    $0x10,%esp
  80213e:	eb 0f                	jmp    80214f <tcpip_thread+0xd8>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  802140:	83 ec 08             	sub    $0x8,%esp
  802143:	50                   	push   %eax
  802144:	ff 72 08             	pushl  0x8(%edx)
  802147:	e8 2c 44 00 00       	call   806578 <ip_input>
  80214c:	83 c4 10             	add    $0x10,%esp
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  80214f:	83 ec 08             	sub    $0x8,%esp
  802152:	ff 75 f4             	pushl  -0xc(%ebp)
  802155:	6a 09                	push   $0x9
  802157:	e8 56 23 00 00       	call   8044b2 <memp_free>
      break;
  80215c:	83 c4 10             	add    $0x10,%esp
  80215f:	eb 87                	jmp    8020e8 <tcpip_thread+0x71>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  802161:	83 ec 0c             	sub    $0xc,%esp
  802164:	ff 72 0c             	pushl  0xc(%edx)
  802167:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  80216a:	83 c4 08             	add    $0x8,%esp
  80216d:	ff 75 f4             	pushl  -0xc(%ebp)
  802170:	6a 08                	push   $0x8
  802172:	e8 3b 23 00 00       	call   8044b2 <memp_free>
      break;
  802177:	83 c4 10             	add    $0x10,%esp
  80217a:	e9 69 ff ff ff       	jmp    8020e8 <tcpip_thread+0x71>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  80217f:	8b 42 08             	mov    0x8(%edx),%eax
  802182:	83 f8 ff             	cmp    $0xffffffff,%eax
  802185:	74 14                	je     80219b <tcpip_thread+0x124>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  802187:	83 ec 04             	sub    $0x4,%esp
  80218a:	ff 72 10             	pushl  0x10(%edx)
  80218d:	ff 72 0c             	pushl  0xc(%edx)
  802190:	50                   	push   %eax
  802191:	e8 da 2f 00 00       	call   805170 <sys_timeout>
  802196:	83 c4 10             	add    $0x10,%esp
  802199:	eb 11                	jmp    8021ac <tcpip_thread+0x135>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  80219b:	83 ec 08             	sub    $0x8,%esp
  80219e:	ff 72 10             	pushl  0x10(%edx)
  8021a1:	ff 72 0c             	pushl  0xc(%edx)
  8021a4:	e8 76 30 00 00       	call   80521f <sys_untimeout>
  8021a9:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8021ac:	83 ec 08             	sub    $0x8,%esp
  8021af:	ff 75 f4             	pushl  -0xc(%ebp)
  8021b2:	6a 08                	push   $0x8
  8021b4:	e8 f9 22 00 00       	call   8044b2 <memp_free>
      break;
  8021b9:	83 c4 10             	add    $0x10,%esp
  8021bc:	e9 27 ff ff ff       	jmp    8020e8 <tcpip_thread+0x71>

008021c1 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  8021c1:	55                   	push   %ebp
  8021c2:	89 e5                	mov    %esp,%ebp
  8021c4:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  8021c7:	e8 00 1b 00 00       	call   803ccc <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8021cc:	83 ec 04             	sub    $0x4,%esp
  8021cf:	6a 00                	push   $0x0
  8021d1:	68 c1 21 80 00       	push   $0x8021c1
  8021d6:	68 f4 01 00 00       	push   $0x1f4
  8021db:	e8 90 2f 00 00       	call   805170 <sys_timeout>
}
  8021e0:	83 c4 10             	add    $0x10,%esp
  8021e3:	c9                   	leave  
  8021e4:	c3                   	ret    

008021e5 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  8021e5:	55                   	push   %ebp
  8021e6:	89 e5                	mov    %esp,%ebp
  8021e8:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  8021eb:	e8 18 19 00 00       	call   803b08 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8021f0:	83 ec 04             	sub    $0x4,%esp
  8021f3:	6a 00                	push   $0x0
  8021f5:	68 e5 21 80 00       	push   $0x8021e5
  8021fa:	68 60 ea 00 00       	push   $0xea60
  8021ff:	e8 6c 2f 00 00       	call   805170 <sys_timeout>
}
  802204:	83 c4 10             	add    $0x10,%esp
  802207:	c9                   	leave  
  802208:	c3                   	ret    

00802209 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  802209:	55                   	push   %ebp
  80220a:	89 e5                	mov    %esp,%ebp
  80220c:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  80220f:	e8 31 72 00 00       	call   809445 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802214:	83 ec 04             	sub    $0x4,%esp
  802217:	6a 00                	push   $0x0
  802219:	68 09 22 80 00       	push   $0x802209
  80221e:	68 88 13 00 00       	push   $0x1388
  802223:	e8 48 2f 00 00       	call   805170 <sys_timeout>
}
  802228:	83 c4 10             	add    $0x10,%esp
  80222b:	c9                   	leave  
  80222c:	c3                   	ret    

0080222d <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  80222d:	55                   	push   %ebp
  80222e:	89 e5                	mov    %esp,%ebp
  802230:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  802233:	e8 09 4a 00 00       	call   806c41 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802238:	83 ec 04             	sub    $0x4,%esp
  80223b:	6a 00                	push   $0x0
  80223d:	68 2d 22 80 00       	push   $0x80222d
  802242:	68 e8 03 00 00       	push   $0x3e8
  802247:	e8 24 2f 00 00       	call   805170 <sys_timeout>
}
  80224c:	83 c4 10             	add    $0x10,%esp
  80224f:	c9                   	leave  
  802250:	c3                   	ret    

00802251 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  802251:	55                   	push   %ebp
  802252:	89 e5                	mov    %esp,%ebp
  802254:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  802257:	ff 75 08             	pushl  0x8(%ebp)
  80225a:	e8 c6 25 00 00       	call   804825 <pbuf_free>
}
  80225f:	83 c4 10             	add    $0x10,%esp
  802262:	c9                   	leave  
  802263:	c3                   	ret    

00802264 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  802264:	55                   	push   %ebp
  802265:	89 e5                	mov    %esp,%ebp
  802267:	83 ec 08             	sub    $0x8,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  80226a:	83 3d e0 52 81 00 00 	cmpl   $0x0,0x8152e0
  802271:	75 33                	jne    8022a6 <tcp_timer_needed+0x42>
  802273:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  80227a:	75 09                	jne    802285 <tcp_timer_needed+0x21>
  80227c:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  802283:	74 21                	je     8022a6 <tcp_timer_needed+0x42>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  802285:	c7 05 e0 52 81 00 01 	movl   $0x1,0x8152e0
  80228c:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80228f:	83 ec 04             	sub    $0x4,%esp
  802292:	6a 00                	push   $0x0
  802294:	68 35 20 80 00       	push   $0x802035
  802299:	68 fa 00 00 00       	push   $0xfa
  80229e:	e8 cd 2e 00 00       	call   805170 <sys_timeout>
  8022a3:	83 c4 10             	add    $0x10,%esp
  }
}
  8022a6:	c9                   	leave  
  8022a7:	c3                   	ret    

008022a8 <tcpip_input>:
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8022a8:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8022af:	74 54                	je     802305 <tcpip_input+0x5d>
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  8022b1:	55                   	push   %ebp
  8022b2:	89 e5                	mov    %esp,%ebp
  8022b4:	53                   	push   %ebx
  8022b5:	83 ec 10             	sub    $0x10,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  8022b8:	6a 09                	push   $0x9
  8022ba:	e8 9d 21 00 00       	call   80445c <memp_malloc>
  8022bf:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  8022c1:	83 c4 10             	add    $0x10,%esp
  8022c4:	85 c0                	test   %eax,%eax
  8022c6:	74 43                	je     80230b <tcpip_input+0x63>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  8022c8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  8022ce:	8b 45 08             	mov    0x8(%ebp),%eax
  8022d1:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8022d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8022d7:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8022da:	83 ec 08             	sub    $0x8,%esp
  8022dd:	53                   	push   %ebx
  8022de:	ff 35 00 40 81 00    	pushl  0x814000
  8022e4:	e8 6b 7e 00 00       	call   80a154 <sys_mbox_trypost>
  8022e9:	83 c4 10             	add    $0x10,%esp
  8022ec:	84 c0                	test   %al,%al
  8022ee:	74 20                	je     802310 <tcpip_input+0x68>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8022f0:	83 ec 08             	sub    $0x8,%esp
  8022f3:	53                   	push   %ebx
  8022f4:	6a 09                	push   $0x9
  8022f6:	e8 b7 21 00 00       	call   8044b2 <memp_free>
      return ERR_MEM;
  8022fb:	83 c4 10             	add    $0x10,%esp
  8022fe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802303:	eb 0b                	jmp    802310 <tcpip_input+0x68>
    }
    return ERR_OK;
  }
  return ERR_VAL;
  802305:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80230a:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
    if (msg == NULL) {
      return ERR_MEM;
  80230b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  802310:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802313:	c9                   	leave  
  802314:	c3                   	ret    

00802315 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  802315:	55                   	push   %ebp
  802316:	89 e5                	mov    %esp,%ebp
  802318:	56                   	push   %esi
  802319:	53                   	push   %ebx
  80231a:	8b 75 10             	mov    0x10(%ebp),%esi
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80231d:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802324:	74 6f                	je     802395 <tcpip_callback_with_block+0x80>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  802326:	83 ec 0c             	sub    $0xc,%esp
  802329:	6a 08                	push   $0x8
  80232b:	e8 2c 21 00 00       	call   80445c <memp_malloc>
  802330:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802332:	83 c4 10             	add    $0x10,%esp
  802335:	85 c0                	test   %eax,%eax
  802337:	74 63                	je     80239c <tcpip_callback_with_block+0x87>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  802339:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  80233f:	8b 45 08             	mov    0x8(%ebp),%eax
  802342:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  802345:	8b 45 0c             	mov    0xc(%ebp),%eax
  802348:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  80234b:	89 f0                	mov    %esi,%eax
  80234d:	84 c0                	test   %al,%al
  80234f:	74 19                	je     80236a <tcpip_callback_with_block+0x55>
      sys_mbox_post(mbox, msg);
  802351:	83 ec 08             	sub    $0x8,%esp
  802354:	53                   	push   %ebx
  802355:	ff 35 00 40 81 00    	pushl  0x814000
  80235b:	e8 b7 7e 00 00       	call   80a217 <sys_mbox_post>
  802360:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  802363:	b8 00 00 00 00       	mov    $0x0,%eax
  802368:	eb 37                	jmp    8023a1 <tcpip_callback_with_block+0x8c>
    msg->msg.cb.f = f;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(mbox, msg);
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80236a:	83 ec 08             	sub    $0x8,%esp
  80236d:	53                   	push   %ebx
  80236e:	ff 35 00 40 81 00    	pushl  0x814000
  802374:	e8 db 7d 00 00       	call   80a154 <sys_mbox_trypost>
  802379:	83 c4 10             	add    $0x10,%esp
  80237c:	84 c0                	test   %al,%al
  80237e:	74 21                	je     8023a1 <tcpip_callback_with_block+0x8c>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  802380:	83 ec 08             	sub    $0x8,%esp
  802383:	53                   	push   %ebx
  802384:	6a 08                	push   $0x8
  802386:	e8 27 21 00 00       	call   8044b2 <memp_free>
        return ERR_MEM;
  80238b:	83 c4 10             	add    $0x10,%esp
  80238e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802393:	eb 0c                	jmp    8023a1 <tcpip_callback_with_block+0x8c>
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
  802395:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80239a:	eb 05                	jmp    8023a1 <tcpip_callback_with_block+0x8c>
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  80239c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  8023a1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8023a4:	5b                   	pop    %ebx
  8023a5:	5e                   	pop    %esi
  8023a6:	5d                   	pop    %ebp
  8023a7:	c3                   	ret    

008023a8 <tcpip_timeout>:
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8023a8:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8023af:	74 45                	je     8023f6 <tcpip_timeout+0x4e>
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8023b1:	55                   	push   %ebp
  8023b2:	89 e5                	mov    %esp,%ebp
  8023b4:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8023b7:	6a 08                	push   $0x8
  8023b9:	e8 9e 20 00 00       	call   80445c <memp_malloc>
    if (msg == NULL) {
  8023be:	83 c4 10             	add    $0x10,%esp
  8023c1:	85 c0                	test   %eax,%eax
  8023c3:	74 37                	je     8023fc <tcpip_timeout+0x54>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  8023c5:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  8023cb:	8b 55 08             	mov    0x8(%ebp),%edx
  8023ce:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  8023d1:	8b 55 0c             	mov    0xc(%ebp),%edx
  8023d4:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  8023d7:	8b 55 10             	mov    0x10(%ebp),%edx
  8023da:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  8023dd:	83 ec 08             	sub    $0x8,%esp
  8023e0:	50                   	push   %eax
  8023e1:	ff 35 00 40 81 00    	pushl  0x814000
  8023e7:	e8 2b 7e 00 00       	call   80a217 <sys_mbox_post>
    return ERR_OK;
  8023ec:	83 c4 10             	add    $0x10,%esp
  8023ef:	b8 00 00 00 00       	mov    $0x0,%eax
  8023f4:	eb 0b                	jmp    802401 <tcpip_timeout+0x59>
  }
  return ERR_VAL;
  8023f6:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8023fb:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  8023fc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    msg->msg.tmo.arg = arg;
    sys_mbox_post(mbox, msg);
    return ERR_OK;
  }
  return ERR_VAL;
}
  802401:	c9                   	leave  
  802402:	c3                   	ret    

00802403 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  802403:	55                   	push   %ebp
  802404:	89 e5                	mov    %esp,%ebp
  802406:	53                   	push   %ebx
  802407:	83 ec 24             	sub    $0x24,%esp
  80240a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  80240d:	a1 00 40 81 00       	mov    0x814000,%eax
  802412:	83 f8 ff             	cmp    $0xffffffff,%eax
  802415:	74 31                	je     802448 <tcpip_apimsg+0x45>
    msg.type = TCPIP_MSG_API;
  802417:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  80241e:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802421:	83 ec 08             	sub    $0x8,%esp
  802424:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  802427:	52                   	push   %edx
  802428:	50                   	push   %eax
  802429:	e8 e9 7d 00 00       	call   80a217 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  80242e:	83 c4 08             	add    $0x8,%esp
  802431:	6a 00                	push   $0x0
  802433:	8b 43 04             	mov    0x4(%ebx),%eax
  802436:	ff 70 10             	pushl  0x10(%eax)
  802439:	e8 08 7c 00 00       	call   80a046 <sys_arch_sem_wait>
    return ERR_OK;
  80243e:	83 c4 10             	add    $0x10,%esp
  802441:	b8 00 00 00 00       	mov    $0x0,%eax
  802446:	eb 05                	jmp    80244d <tcpip_apimsg+0x4a>
  }
  return ERR_VAL;
  802448:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80244d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802450:	c9                   	leave  
  802451:	c3                   	ret    

00802452 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  802452:	55                   	push   %ebp
  802453:	89 e5                	mov    %esp,%ebp
  802455:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  802458:	e8 6f 03 00 00       	call   8027cc <lwip_init>

  tcpip_init_done = initfunc;
  80245d:	8b 45 08             	mov    0x8(%ebp),%eax
  802460:	a3 e8 52 81 00       	mov    %eax,0x8152e8
  tcpip_init_done_arg = arg;
  802465:	8b 45 0c             	mov    0xc(%ebp),%eax
  802468:	a3 e4 52 81 00       	mov    %eax,0x8152e4
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  80246d:	83 ec 0c             	sub    $0xc,%esp
  802470:	6a 00                	push   $0x0
  802472:	e8 5e 7a 00 00       	call   809ed5 <sys_mbox_new>
  802477:	a3 00 40 81 00       	mov    %eax,0x814000
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  80247c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  802483:	6a 00                	push   $0x0
  802485:	6a 00                	push   $0x0
  802487:	68 77 20 80 00       	push   $0x802077
  80248c:	68 7c 0f 81 00       	push   $0x810f7c
  802491:	e8 b2 7e 00 00       	call   80a348 <sys_thread_new>
}
  802496:	83 c4 20             	add    $0x20,%esp
  802499:	c9                   	leave  
  80249a:	c3                   	ret    

0080249b <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  80249b:	55                   	push   %ebp
  80249c:	89 e5                	mov    %esp,%ebp
  80249e:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8024a1:	6a 00                	push   $0x0
  8024a3:	ff 75 08             	pushl  0x8(%ebp)
  8024a6:	68 51 22 80 00       	push   $0x802251
  8024ab:	e8 65 fe ff ff       	call   802315 <tcpip_callback_with_block>
}
  8024b0:	c9                   	leave  
  8024b1:	c3                   	ret    

008024b2 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  8024b2:	55                   	push   %ebp
  8024b3:	89 e5                	mov    %esp,%ebp
  8024b5:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  8024b8:	6a 00                	push   $0x0
  8024ba:	ff 75 08             	pushl  0x8(%ebp)
  8024bd:	68 83 3f 80 00       	push   $0x803f83
  8024c2:	e8 4e fe ff ff       	call   802315 <tcpip_callback_with_block>
}
  8024c7:	c9                   	leave  
  8024c8:	c3                   	ret    

008024c9 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  8024c9:	55                   	push   %ebp
  8024ca:	89 e5                	mov    %esp,%ebp
  8024cc:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  8024cf:	6a 06                	push   $0x6
  8024d1:	e8 86 1f 00 00       	call   80445c <memp_malloc>
  if (buf != NULL) {
  8024d6:	83 c4 10             	add    $0x10,%esp
  8024d9:	85 c0                	test   %eax,%eax
  8024db:	74 14                	je     8024f1 <netbuf_new+0x28>
    buf->p = NULL;
  8024dd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  8024e3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  8024ea:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  8024f1:	c9                   	leave  
  8024f2:	c3                   	ret    

008024f3 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  8024f3:	55                   	push   %ebp
  8024f4:	89 e5                	mov    %esp,%ebp
  8024f6:	53                   	push   %ebx
  8024f7:	83 ec 04             	sub    $0x4,%esp
  8024fa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  8024fd:	85 db                	test   %ebx,%ebx
  8024ff:	74 2d                	je     80252e <netbuf_delete+0x3b>
    if (buf->p != NULL) {
  802501:	8b 03                	mov    (%ebx),%eax
  802503:	85 c0                	test   %eax,%eax
  802505:	74 19                	je     802520 <netbuf_delete+0x2d>
      pbuf_free(buf->p);
  802507:	83 ec 0c             	sub    $0xc,%esp
  80250a:	50                   	push   %eax
  80250b:	e8 15 23 00 00       	call   804825 <pbuf_free>
      buf->p = buf->ptr = NULL;
  802510:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802517:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80251d:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  802520:	83 ec 08             	sub    $0x8,%esp
  802523:	53                   	push   %ebx
  802524:	6a 06                	push   $0x6
  802526:	e8 87 1f 00 00       	call   8044b2 <memp_free>
  80252b:	83 c4 10             	add    $0x10,%esp
  }
}
  80252e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802531:	c9                   	leave  
  802532:	c3                   	ret    

00802533 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  802533:	55                   	push   %ebp
  802534:	89 e5                	mov    %esp,%ebp
  802536:	56                   	push   %esi
  802537:	53                   	push   %ebx
  802538:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80253b:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80253e:	85 db                	test   %ebx,%ebx
  802540:	75 14                	jne    802556 <netbuf_alloc+0x23>
  802542:	83 ec 04             	sub    $0x4,%esp
  802545:	68 89 0f 81 00       	push   $0x810f89
  80254a:	6a 63                	push   $0x63
  80254c:	68 a3 0f 81 00       	push   $0x810fa3
  802551:	e8 f8 be 00 00       	call   80e44e <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  802556:	8b 03                	mov    (%ebx),%eax
  802558:	85 c0                	test   %eax,%eax
  80255a:	74 0c                	je     802568 <netbuf_alloc+0x35>
    pbuf_free(buf->p);
  80255c:	83 ec 0c             	sub    $0xc,%esp
  80255f:	50                   	push   %eax
  802560:	e8 c0 22 00 00       	call   804825 <pbuf_free>
  802565:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  802568:	83 ec 04             	sub    $0x4,%esp
  80256b:	6a 00                	push   $0x0
  80256d:	0f b7 c6             	movzwl %si,%eax
  802570:	50                   	push   %eax
  802571:	6a 00                	push   $0x0
  802573:	e8 73 23 00 00       	call   8048eb <pbuf_alloc>
  802578:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  80257a:	83 c4 10             	add    $0x10,%esp
  80257d:	85 c0                	test   %eax,%eax
  80257f:	74 22                	je     8025a3 <netbuf_alloc+0x70>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  802581:	66 3b 70 0a          	cmp    0xa(%eax),%si
  802585:	76 14                	jbe    80259b <netbuf_alloc+0x68>
  802587:	83 ec 04             	sub    $0x4,%esp
  80258a:	68 70 10 81 00       	push   $0x811070
  80258f:	6a 6e                	push   $0x6e
  802591:	68 a3 0f 81 00       	push   $0x810fa3
  802596:	e8 b3 be 00 00       	call   80e44e <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  80259b:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  80259e:	8b 40 04             	mov    0x4(%eax),%eax
  8025a1:	eb 05                	jmp    8025a8 <netbuf_alloc+0x75>
  if (buf->p != NULL) {
    pbuf_free(buf->p);
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  if (buf->p == NULL) {
     return NULL;
  8025a3:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
  return buf->p->payload;
}
  8025a8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8025ab:	5b                   	pop    %ebx
  8025ac:	5e                   	pop    %esi
  8025ad:	5d                   	pop    %ebp
  8025ae:	c3                   	ret    

008025af <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8025af:	55                   	push   %ebp
  8025b0:	89 e5                	mov    %esp,%ebp
  8025b2:	53                   	push   %ebx
  8025b3:	83 ec 04             	sub    $0x4,%esp
  8025b6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8025b9:	85 db                	test   %ebx,%ebx
  8025bb:	75 14                	jne    8025d1 <netbuf_free+0x22>
  8025bd:	83 ec 04             	sub    $0x4,%esp
  8025c0:	68 b9 0f 81 00       	push   $0x810fb9
  8025c5:	6a 7b                	push   $0x7b
  8025c7:	68 a3 0f 81 00       	push   $0x810fa3
  8025cc:	e8 7d be 00 00       	call   80e44e <_panic>
  if (buf->p != NULL) {
  8025d1:	8b 03                	mov    (%ebx),%eax
  8025d3:	85 c0                	test   %eax,%eax
  8025d5:	74 0c                	je     8025e3 <netbuf_free+0x34>
    pbuf_free(buf->p);
  8025d7:	83 ec 0c             	sub    $0xc,%esp
  8025da:	50                   	push   %eax
  8025db:	e8 45 22 00 00       	call   804825 <pbuf_free>
  8025e0:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  8025e3:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8025ea:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8025f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8025f3:	c9                   	leave  
  8025f4:	c3                   	ret    

008025f5 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  8025f5:	55                   	push   %ebp
  8025f6:	89 e5                	mov    %esp,%ebp
  8025f8:	56                   	push   %esi
  8025f9:	53                   	push   %ebx
  8025fa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8025fd:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802600:	85 db                	test   %ebx,%ebx
  802602:	75 17                	jne    80261b <netbuf_ref+0x26>
  802604:	83 ec 04             	sub    $0x4,%esp
  802607:	68 d2 0f 81 00       	push   $0x810fd2
  80260c:	68 8e 00 00 00       	push   $0x8e
  802611:	68 a3 0f 81 00       	push   $0x810fa3
  802616:	e8 33 be 00 00       	call   80e44e <_panic>
  if (buf->p != NULL) {
  80261b:	8b 03                	mov    (%ebx),%eax
  80261d:	85 c0                	test   %eax,%eax
  80261f:	74 0c                	je     80262d <netbuf_ref+0x38>
    pbuf_free(buf->p);
  802621:	83 ec 0c             	sub    $0xc,%esp
  802624:	50                   	push   %eax
  802625:	e8 fb 21 00 00       	call   804825 <pbuf_free>
  80262a:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  80262d:	83 ec 04             	sub    $0x4,%esp
  802630:	6a 02                	push   $0x2
  802632:	6a 00                	push   $0x0
  802634:	6a 00                	push   $0x0
  802636:	e8 b0 22 00 00       	call   8048eb <pbuf_alloc>
  80263b:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  80263d:	83 c4 10             	add    $0x10,%esp
  802640:	85 c0                	test   %eax,%eax
  802642:	75 0e                	jne    802652 <netbuf_ref+0x5d>
    buf->ptr = NULL;
  802644:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  80264b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802650:	eb 1a                	jmp    80266c <netbuf_ref+0x77>
  }
  buf->p->payload = (void*)dataptr;
  802652:	8b 55 0c             	mov    0xc(%ebp),%edx
  802655:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  802658:	8b 03                	mov    (%ebx),%eax
  80265a:	66 89 70 08          	mov    %si,0x8(%eax)
  80265e:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  802662:	8b 03                	mov    (%ebx),%eax
  802664:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  802667:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80266c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80266f:	5b                   	pop    %ebx
  802670:	5e                   	pop    %esi
  802671:	5d                   	pop    %ebp
  802672:	c3                   	ret    

00802673 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  802673:	55                   	push   %ebp
  802674:	89 e5                	mov    %esp,%ebp
  802676:	56                   	push   %esi
  802677:	53                   	push   %ebx
  802678:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80267b:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  80267e:	85 db                	test   %ebx,%ebx
  802680:	75 17                	jne    802699 <netbuf_chain+0x26>
  802682:	83 ec 04             	sub    $0x4,%esp
  802685:	68 ea 0f 81 00       	push   $0x810fea
  80268a:	68 a6 00 00 00       	push   $0xa6
  80268f:	68 a3 0f 81 00       	push   $0x810fa3
  802694:	e8 b5 bd 00 00       	call   80e44e <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  802699:	85 f6                	test   %esi,%esi
  80269b:	75 17                	jne    8026b4 <netbuf_chain+0x41>
  80269d:	83 ec 04             	sub    $0x4,%esp
  8026a0:	68 03 10 81 00       	push   $0x811003
  8026a5:	68 a7 00 00 00       	push   $0xa7
  8026aa:	68 a3 0f 81 00       	push   $0x810fa3
  8026af:	e8 9a bd 00 00       	call   80e44e <_panic>
  pbuf_chain(head->p, tail->p);
  8026b4:	83 ec 08             	sub    $0x8,%esp
  8026b7:	ff 36                	pushl  (%esi)
  8026b9:	ff 33                	pushl  (%ebx)
  8026bb:	e8 59 26 00 00       	call   804d19 <pbuf_chain>
  head->ptr = head->p;
  8026c0:	8b 03                	mov    (%ebx),%eax
  8026c2:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  8026c5:	83 c4 08             	add    $0x8,%esp
  8026c8:	56                   	push   %esi
  8026c9:	6a 06                	push   $0x6
  8026cb:	e8 e2 1d 00 00       	call   8044b2 <memp_free>
}
  8026d0:	83 c4 10             	add    $0x10,%esp
  8026d3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8026d6:	5b                   	pop    %ebx
  8026d7:	5e                   	pop    %esi
  8026d8:	5d                   	pop    %ebp
  8026d9:	c3                   	ret    

008026da <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  8026da:	55                   	push   %ebp
  8026db:	89 e5                	mov    %esp,%ebp
  8026dd:	53                   	push   %ebx
  8026de:	83 ec 04             	sub    $0x4,%esp
  8026e1:	8b 45 08             	mov    0x8(%ebp),%eax
  8026e4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8026e7:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  8026ea:	85 c0                	test   %eax,%eax
  8026ec:	75 17                	jne    802705 <netbuf_data+0x2b>
  8026ee:	83 ec 04             	sub    $0x4,%esp
  8026f1:	68 1e 10 81 00       	push   $0x81101e
  8026f6:	68 b9 00 00 00       	push   $0xb9
  8026fb:	68 a3 0f 81 00       	push   $0x810fa3
  802700:	e8 49 bd 00 00       	call   80e44e <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802705:	85 c9                	test   %ecx,%ecx
  802707:	75 17                	jne    802720 <netbuf_data+0x46>
  802709:	83 ec 04             	sub    $0x4,%esp
  80270c:	68 37 10 81 00       	push   $0x811037
  802711:	68 ba 00 00 00       	push   $0xba
  802716:	68 a3 0f 81 00       	push   $0x810fa3
  80271b:	e8 2e bd 00 00       	call   80e44e <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802720:	85 d2                	test   %edx,%edx
  802722:	75 17                	jne    80273b <netbuf_data+0x61>
  802724:	83 ec 04             	sub    $0x4,%esp
  802727:	68 54 10 81 00       	push   $0x811054
  80272c:	68 bb 00 00 00       	push   $0xbb
  802731:	68 a3 0f 81 00       	push   $0x810fa3
  802736:	e8 13 bd 00 00       	call   80e44e <_panic>

  if (buf->ptr == NULL) {
  80273b:	8b 58 04             	mov    0x4(%eax),%ebx
  80273e:	85 db                	test   %ebx,%ebx
  802740:	74 16                	je     802758 <netbuf_data+0x7e>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802742:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802745:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  802747:	8b 40 04             	mov    0x4(%eax),%eax
  80274a:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  80274e:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  802751:	b8 00 00 00 00       	mov    $0x0,%eax
  802756:	eb 05                	jmp    80275d <netbuf_data+0x83>
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
    return ERR_BUF;
  802758:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  }
  *dataptr = buf->ptr->payload;
  *len = buf->ptr->len;
  return ERR_OK;
}
  80275d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802760:	c9                   	leave  
  802761:	c3                   	ret    

00802762 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  802762:	55                   	push   %ebp
  802763:	89 e5                	mov    %esp,%ebp
  802765:	83 ec 08             	sub    $0x8,%esp
  802768:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  80276b:	85 c0                	test   %eax,%eax
  80276d:	75 17                	jne    802786 <netbuf_next+0x24>
  80276f:	83 ec 04             	sub    $0x4,%esp
  802772:	68 b9 0f 81 00       	push   $0x810fb9
  802777:	68 d2 00 00 00       	push   $0xd2
  80277c:	68 a3 0f 81 00       	push   $0x810fa3
  802781:	e8 c8 bc 00 00       	call   80e44e <_panic>
  if (buf->ptr->next == NULL) {
  802786:	8b 50 04             	mov    0x4(%eax),%edx
  802789:	8b 12                	mov    (%edx),%edx
  80278b:	85 d2                	test   %edx,%edx
  80278d:	74 0b                	je     80279a <netbuf_next+0x38>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  80278f:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
  802792:	83 3a 00             	cmpl   $0x0,(%edx)
  802795:	0f 94 c0             	sete   %al
  802798:	eb 05                	jmp    80279f <netbuf_next+0x3d>
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  if (buf->ptr->next == NULL) {
    return -1;
  80279a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  buf->ptr = buf->ptr->next;
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  80279f:	c9                   	leave  
  8027a0:	c3                   	ret    

008027a1 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8027a1:	55                   	push   %ebp
  8027a2:	89 e5                	mov    %esp,%ebp
  8027a4:	83 ec 08             	sub    $0x8,%esp
  8027a7:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8027aa:	85 c0                	test   %eax,%eax
  8027ac:	75 17                	jne    8027c5 <netbuf_first+0x24>
  8027ae:	83 ec 04             	sub    $0x4,%esp
  8027b1:	68 b9 0f 81 00       	push   $0x810fb9
  8027b6:	68 e7 00 00 00       	push   $0xe7
  8027bb:	68 a3 0f 81 00       	push   $0x810fa3
  8027c0:	e8 89 bc 00 00       	call   80e44e <_panic>
  buf->ptr = buf->p;
  8027c5:	8b 10                	mov    (%eax),%edx
  8027c7:	89 50 04             	mov    %edx,0x4(%eax)
}
  8027ca:	c9                   	leave  
  8027cb:	c3                   	ret    

008027cc <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  8027cc:	55                   	push   %ebp
  8027cd:	89 e5                	mov    %esp,%ebp
  8027cf:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  8027d2:	e8 c0 74 00 00       	call   809c97 <sys_init>
  mem_init();
  8027d7:	e8 41 17 00 00       	call   803f1d <mem_init>
  memp_init();
  8027dc:	e8 24 1c 00 00       	call   804405 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  8027e1:	e8 d4 e6 ff ff       	call   800eba <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  8027e6:	c9                   	leave  
  8027e7:	c3                   	ret    

008027e8 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  8027e8:	55                   	push   %ebp
  8027e9:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  8027eb:	38 10                	cmp    %dl,(%eax)
  8027ed:	74 06                	je     8027f5 <dhcp_set_state+0xd>
    dhcp->state = new_state;
  8027ef:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  8027f1:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  8027f5:	5d                   	pop    %ebp
  8027f6:	c3                   	ret    

008027f7 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  8027f7:	55                   	push   %ebp
  8027f8:	89 e5                	mov    %esp,%ebp
  8027fa:	57                   	push   %edi
  8027fb:	56                   	push   %esi
  8027fc:	53                   	push   %ebx
  8027fd:	83 ec 08             	sub    $0x8,%esp
  802800:	89 45 ec             	mov    %eax,-0x14(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802803:	8b 70 14             	mov    0x14(%eax),%esi
  802806:	85 f6                	test   %esi,%esi
  802808:	0f 84 d5 00 00 00    	je     8028e3 <dhcp_get_option_ptr+0xec>
  80280e:	0f b7 78 18          	movzwl 0x18(%eax),%edi
  802812:	b9 00 00 00 00       	mov    $0x0,%ecx
  802817:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80281b:	b8 00 00 00 00       	mov    $0x0,%eax
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802820:	66 85 ff             	test   %di,%di
  802823:	0f 84 d2 00 00 00    	je     8028fb <dhcp_get_option_ptr+0x104>
  802829:	eb 2d                	jmp    802858 <dhcp_get_option_ptr+0x61>
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80282b:	80 fb 34             	cmp    $0x34,%bl
  80282e:	75 12                	jne    802842 <dhcp_get_option_ptr+0x4b>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  802830:	8d 41 02             	lea    0x2(%ecx),%eax
        overload = options[offset++];
  802833:	83 c1 03             	add    $0x3,%ecx
  802836:	0f b7 c0             	movzwl %ax,%eax
  802839:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  80283d:	88 45 f0             	mov    %al,-0x10(%ebp)
  802840:	eb 16                	jmp    802858 <dhcp_get_option_ptr+0x61>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  802842:	38 d3                	cmp    %dl,%bl
  802844:	0f 84 b1 00 00 00    	je     8028fb <dhcp_get_option_ptr+0x104>
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  80284a:	8d 41 01             	lea    0x1(%ecx),%eax
  80284d:	0f b7 c0             	movzwl %ax,%eax
  802850:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802854:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802858:	66 39 f9             	cmp    %di,%cx
  80285b:	73 0d                	jae    80286a <dhcp_get_option_ptr+0x73>
  80285d:	0f b7 c1             	movzwl %cx,%eax
  802860:	01 f0                	add    %esi,%eax
  802862:	0f b6 18             	movzbl (%eax),%ebx
  802865:	80 fb ff             	cmp    $0xff,%bl
  802868:	75 c1                	jne    80282b <dhcp_get_option_ptr+0x34>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  80286a:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
  80286e:	84 c0                	test   %al,%al
  802870:	74 78                	je     8028ea <dhcp_get_option_ptr+0xf3>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  802872:	3c 01                	cmp    $0x1,%al
  802874:	75 10                	jne    802886 <dhcp_get_option_ptr+0x8f>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  802876:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802879:	8b 58 10             	mov    0x10(%eax),%ebx
  80287c:	83 c3 6c             	add    $0x6c,%ebx
        field_len = DHCP_FILE_LEN;
  80287f:	be 80 00 00 00       	mov    $0x80,%esi
  802884:	eb 24                	jmp    8028aa <dhcp_get_option_ptr+0xb3>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  802886:	80 7d f0 02          	cmpb   $0x2,-0x10(%ebp)
  80288a:	75 10                	jne    80289c <dhcp_get_option_ptr+0xa5>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80288c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80288f:	8b 58 10             	mov    0x10(%eax),%ebx
  802892:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_SNAME_LEN;
  802895:	be 40 00 00 00       	mov    $0x40,%esi
  80289a:	eb 0e                	jmp    8028aa <dhcp_get_option_ptr+0xb3>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80289c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80289f:	8b 58 10             	mov    0x10(%eax),%ebx
  8028a2:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  8028a5:	be c0 00 00 00       	mov    $0xc0,%esi
      }
      offset = 0;
  8028aa:	b9 00 00 00 00       	mov    $0x0,%ecx
  8028af:	89 d7                	mov    %edx,%edi

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8028b1:	eb 14                	jmp    8028c7 <dhcp_get_option_ptr+0xd0>
        if (options[offset] == option_type) {
  8028b3:	89 f8                	mov    %edi,%eax
  8028b5:	38 d0                	cmp    %dl,%al
  8028b7:	74 3f                	je     8028f8 <dhcp_get_option_ptr+0x101>
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
          offset += 1 + options[offset];
  8028b9:	8d 41 01             	lea    0x1(%ecx),%eax
  8028bc:	0f b7 c0             	movzwl %ax,%eax
  8028bf:	0f b6 04 03          	movzbl (%ebx,%eax,1),%eax
  8028c3:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8028c7:	66 39 f1             	cmp    %si,%cx
  8028ca:	73 25                	jae    8028f1 <dhcp_get_option_ptr+0xfa>
  8028cc:	0f b7 c1             	movzwl %cx,%eax
  8028cf:	01 d8                	add    %ebx,%eax
  8028d1:	89 45 f0             	mov    %eax,-0x10(%ebp)
  8028d4:	0f b6 10             	movzbl (%eax),%edx
  8028d7:	80 fa ff             	cmp    $0xff,%dl
  8028da:	75 d7                	jne    8028b3 <dhcp_get_option_ptr+0xbc>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  8028dc:	b8 00 00 00 00       	mov    $0x0,%eax
  8028e1:	eb 18                	jmp    8028fb <dhcp_get_option_ptr+0x104>
  8028e3:	b8 00 00 00 00       	mov    $0x0,%eax
  8028e8:	eb 11                	jmp    8028fb <dhcp_get_option_ptr+0x104>
  8028ea:	b8 00 00 00 00       	mov    $0x0,%eax
  8028ef:	eb 0a                	jmp    8028fb <dhcp_get_option_ptr+0x104>
  8028f1:	b8 00 00 00 00       	mov    $0x0,%eax
  8028f6:	eb 03                	jmp    8028fb <dhcp_get_option_ptr+0x104>
  8028f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
  8028fb:	83 c4 08             	add    $0x8,%esp
  8028fe:	5b                   	pop    %ebx
  8028ff:	5e                   	pop    %esi
  802900:	5f                   	pop    %edi
  802901:	5d                   	pop    %ebp
  802902:	c3                   	ret    

00802903 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  802903:	55                   	push   %ebp
  802904:	89 e5                	mov    %esp,%ebp
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802906:	0f b6 10             	movzbl (%eax),%edx
  802909:	89 d1                	mov    %edx,%ecx
  80290b:	c1 e1 18             	shl    $0x18,%ecx
  80290e:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  802912:	c1 e2 10             	shl    $0x10,%edx
  802915:	09 ca                	or     %ecx,%edx
  802917:	0f b6 48 03          	movzbl 0x3(%eax),%ecx
  80291b:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 16;
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
  80291d:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  802921:	c1 e0 08             	shl    $0x8,%eax
  802924:	09 d0                	or     %edx,%eax
}
  802926:	5d                   	pop    %ebp
  802927:	c3                   	ret    

00802928 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  802928:	55                   	push   %ebp
  802929:	89 e5                	mov    %esp,%ebp
  80292b:	56                   	push   %esi
  80292c:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80292d:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802931:	66 83 f9 43          	cmp    $0x43,%cx
  802935:	76 17                	jbe    80294e <dhcp_option_byte+0x26>
  802937:	83 ec 04             	sub    $0x4,%esp
  80293a:	68 94 10 81 00       	push   $0x811094
  80293f:	68 65 04 00 00       	push   $0x465
  802944:	68 e2 13 81 00       	push   $0x8113e2
  802949:	e8 00 bb 00 00       	call   80e44e <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80294e:	8b 58 20             	mov    0x20(%eax),%ebx
  802951:	8d 71 01             	lea    0x1(%ecx),%esi
  802954:	66 89 70 24          	mov    %si,0x24(%eax)
  802958:	0f b7 c9             	movzwl %cx,%ecx
  80295b:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802962:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802965:	5b                   	pop    %ebx
  802966:	5e                   	pop    %esi
  802967:	5d                   	pop    %ebp
  802968:	c3                   	ret    

00802969 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  802969:	55                   	push   %ebp
  80296a:	89 e5                	mov    %esp,%ebp
  80296c:	57                   	push   %edi
  80296d:	56                   	push   %esi
  80296e:	53                   	push   %ebx
  80296f:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802972:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  802976:	0f b7 fb             	movzwl %bx,%edi
  802979:	0f b6 f1             	movzbl %cl,%esi
  80297c:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  802980:	83 fe 44             	cmp    $0x44,%esi
  802983:	76 17                	jbe    80299c <dhcp_option+0x33>
  802985:	83 ec 04             	sub    $0x4,%esp
  802988:	68 d0 10 81 00       	push   $0x8110d0
  80298d:	68 5a 04 00 00       	push   $0x45a
  802992:	68 e2 13 81 00       	push   $0x8113e2
  802997:	e8 b2 ba 00 00       	call   80e44e <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  80299c:	8b 70 20             	mov    0x20(%eax),%esi
  80299f:	8d 7b 01             	lea    0x1(%ebx),%edi
  8029a2:	66 89 78 24          	mov    %di,0x24(%eax)
  8029a6:	0f b7 db             	movzwl %bx,%ebx
  8029a9:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  8029b0:	8b 58 20             	mov    0x20(%eax),%ebx
  8029b3:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8029b7:	8d 72 01             	lea    0x1(%edx),%esi
  8029ba:	66 89 70 24          	mov    %si,0x24(%eax)
  8029be:	0f b7 d2             	movzwl %dx,%edx
  8029c1:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  8029c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8029cb:	5b                   	pop    %ebx
  8029cc:	5e                   	pop    %esi
  8029cd:	5f                   	pop    %edi
  8029ce:	5d                   	pop    %ebp
  8029cf:	c3                   	ret    

008029d0 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  8029d0:	55                   	push   %ebp
  8029d1:	89 e5                	mov    %esp,%ebp
  8029d3:	56                   	push   %esi
  8029d4:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  8029d5:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  8029d9:	0f b7 d9             	movzwl %cx,%ebx
  8029dc:	83 c3 02             	add    $0x2,%ebx
  8029df:	83 fb 44             	cmp    $0x44,%ebx
  8029e2:	76 17                	jbe    8029fb <dhcp_option_short+0x2b>
  8029e4:	83 ec 04             	sub    $0x4,%esp
  8029e7:	68 18 11 81 00       	push   $0x811118
  8029ec:	68 6c 04 00 00       	push   $0x46c
  8029f1:	68 e2 13 81 00       	push   $0x8113e2
  8029f6:	e8 53 ba 00 00       	call   80e44e <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  8029fb:	8d 71 01             	lea    0x1(%ecx),%esi
  8029fe:	66 89 70 24          	mov    %si,0x24(%eax)
  802a02:	0f b7 c9             	movzwl %cx,%ecx
  802a05:	89 d3                	mov    %edx,%ebx
  802a07:	66 c1 eb 08          	shr    $0x8,%bx
  802a0b:	8b 70 20             	mov    0x20(%eax),%esi
  802a0e:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802a15:	8b 58 20             	mov    0x20(%eax),%ebx
  802a18:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a1c:	8d 71 01             	lea    0x1(%ecx),%esi
  802a1f:	66 89 70 24          	mov    %si,0x24(%eax)
  802a23:	0f b7 c9             	movzwl %cx,%ecx
  802a26:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802a2d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802a30:	5b                   	pop    %ebx
  802a31:	5e                   	pop    %esi
  802a32:	5d                   	pop    %ebp
  802a33:	c3                   	ret    

00802a34 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  802a34:	55                   	push   %ebp
  802a35:	89 e5                	mov    %esp,%ebp
  802a37:	53                   	push   %ebx
  802a38:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802a3b:	85 c0                	test   %eax,%eax
  802a3d:	75 17                	jne    802a56 <dhcp_option_trailer+0x22>
  802a3f:	83 ec 04             	sub    $0x4,%esp
  802a42:	68 5c 11 81 00       	push   $0x81115c
  802a47:	68 80 05 00 00       	push   $0x580
  802a4c:	68 e2 13 81 00       	push   $0x8113e2
  802a51:	e8 f8 b9 00 00       	call   80e44e <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802a56:	8b 48 20             	mov    0x20(%eax),%ecx
  802a59:	85 c9                	test   %ecx,%ecx
  802a5b:	75 17                	jne    802a74 <dhcp_option_trailer+0x40>
  802a5d:	83 ec 04             	sub    $0x4,%esp
  802a60:	68 80 11 81 00       	push   $0x811180
  802a65:	68 81 05 00 00       	push   $0x581
  802a6a:	68 e2 13 81 00       	push   $0x8113e2
  802a6f:	e8 da b9 00 00       	call   80e44e <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a74:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802a78:	66 83 fa 43          	cmp    $0x43,%dx
  802a7c:	76 17                	jbe    802a95 <dhcp_option_trailer+0x61>
  802a7e:	83 ec 04             	sub    $0x4,%esp
  802a81:	68 ac 11 81 00       	push   $0x8111ac
  802a86:	68 82 05 00 00       	push   $0x582
  802a8b:	68 e2 13 81 00       	push   $0x8113e2
  802a90:	e8 b9 b9 00 00       	call   80e44e <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802a95:	8d 5a 01             	lea    0x1(%edx),%ebx
  802a98:	66 89 58 24          	mov    %bx,0x24(%eax)
  802a9c:	0f b7 d2             	movzwl %dx,%edx
  802a9f:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  802aa6:	ff 
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802aa7:	eb 2c                	jmp    802ad5 <dhcp_option_trailer+0xa1>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802aa9:	83 ec 04             	sub    $0x4,%esp
  802aac:	68 ac 11 81 00       	push   $0x8111ac
  802ab1:	68 87 05 00 00       	push   $0x587
  802ab6:	68 e2 13 81 00       	push   $0x8113e2
  802abb:	e8 8e b9 00 00       	call   80e44e <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802ac0:	8b 48 20             	mov    0x20(%eax),%ecx
  802ac3:	8d 5a 01             	lea    0x1(%edx),%ebx
  802ac6:	66 89 58 24          	mov    %bx,0x24(%eax)
  802aca:	0f b7 d2             	movzwl %dx,%edx
  802acd:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802ad4:	00 
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802ad5:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802ad9:	66 83 fa 43          	cmp    $0x43,%dx
  802add:	76 e1                	jbe    802ac0 <dhcp_option_trailer+0x8c>
  802adf:	f6 c2 03             	test   $0x3,%dl
  802ae2:	75 c5                	jne    802aa9 <dhcp_option_trailer+0x75>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  802ae4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802ae7:	c9                   	leave  
  802ae8:	c3                   	ret    

00802ae9 <dhcp_option_long>:
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  802ae9:	55                   	push   %ebp
  802aea:	89 e5                	mov    %esp,%ebp
  802aec:	56                   	push   %esi
  802aed:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802aee:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802af2:	0f b7 d9             	movzwl %cx,%ebx
  802af5:	83 c3 04             	add    $0x4,%ebx
  802af8:	83 fb 44             	cmp    $0x44,%ebx
  802afb:	76 17                	jbe    802b14 <dhcp_option_long+0x2b>
  802afd:	83 ec 04             	sub    $0x4,%esp
  802b00:	68 ec 11 81 00       	push   $0x8111ec
  802b05:	68 74 04 00 00       	push   $0x474
  802b0a:	68 e2 13 81 00       	push   $0x8113e2
  802b0f:	e8 3a b9 00 00       	call   80e44e <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802b14:	8d 71 01             	lea    0x1(%ecx),%esi
  802b17:	66 89 70 24          	mov    %si,0x24(%eax)
  802b1b:	0f b7 c9             	movzwl %cx,%ecx
  802b1e:	89 d3                	mov    %edx,%ebx
  802b20:	c1 eb 18             	shr    $0x18,%ebx
  802b23:	8b 70 20             	mov    0x20(%eax),%esi
  802b26:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802b2d:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b31:	8d 71 01             	lea    0x1(%ecx),%esi
  802b34:	66 89 70 24          	mov    %si,0x24(%eax)
  802b38:	0f b7 c9             	movzwl %cx,%ecx
  802b3b:	89 d3                	mov    %edx,%ebx
  802b3d:	c1 eb 10             	shr    $0x10,%ebx
  802b40:	8b 70 20             	mov    0x20(%eax),%esi
  802b43:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802b4a:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b4e:	8d 71 01             	lea    0x1(%ecx),%esi
  802b51:	66 89 70 24          	mov    %si,0x24(%eax)
  802b55:	0f b7 c9             	movzwl %cx,%ecx
  802b58:	0f b6 de             	movzbl %dh,%ebx
  802b5b:	8b 70 20             	mov    0x20(%eax),%esi
  802b5e:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802b65:	8b 58 20             	mov    0x20(%eax),%ebx
  802b68:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b6c:	8d 71 01             	lea    0x1(%ecx),%esi
  802b6f:	66 89 70 24          	mov    %si,0x24(%eax)
  802b73:	0f b7 c9             	movzwl %cx,%ecx
  802b76:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802b7d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802b80:	5b                   	pop    %ebx
  802b81:	5e                   	pop    %esi
  802b82:	5d                   	pop    %ebp
  802b83:	c3                   	ret    

00802b84 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  802b84:	55                   	push   %ebp
  802b85:	89 e5                	mov    %esp,%ebp
  802b87:	57                   	push   %edi
  802b88:	56                   	push   %esi
  802b89:	53                   	push   %ebx
  802b8a:	83 ec 1c             	sub    $0x1c,%esp
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802b8d:	85 c0                	test   %eax,%eax
  802b8f:	75 17                	jne    802ba8 <dhcp_create_request+0x24>
  802b91:	83 ec 04             	sub    $0x4,%esp
  802b94:	68 2c 12 81 00       	push   $0x81122c
  802b99:	68 2d 05 00 00       	push   $0x52d
  802b9e:	68 e2 13 81 00       	push   $0x8113e2
  802ba3:	e8 a6 b8 00 00       	call   80e44e <_panic>
  802ba8:	89 c7                	mov    %eax,%edi
  dhcp = netif->dhcp;
  802baa:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802bad:	85 db                	test   %ebx,%ebx
  802baf:	75 17                	jne    802bc8 <dhcp_create_request+0x44>
  802bb1:	83 ec 04             	sub    $0x4,%esp
  802bb4:	68 50 12 81 00       	push   $0x811250
  802bb9:	68 2f 05 00 00       	push   $0x52f
  802bbe:	68 e2 13 81 00       	push   $0x8113e2
  802bc3:	e8 86 b8 00 00       	call   80e44e <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802bc8:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802bcc:	74 17                	je     802be5 <dhcp_create_request+0x61>
  802bce:	83 ec 04             	sub    $0x4,%esp
  802bd1:	68 74 12 81 00       	push   $0x811274
  802bd6:	68 30 05 00 00       	push   $0x530
  802bdb:	68 e2 13 81 00       	push   $0x8113e2
  802be0:	e8 69 b8 00 00       	call   80e44e <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802be5:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802be9:	74 17                	je     802c02 <dhcp_create_request+0x7e>
  802beb:	83 ec 04             	sub    $0x4,%esp
  802bee:	68 a0 12 81 00       	push   $0x8112a0
  802bf3:	68 31 05 00 00       	push   $0x531
  802bf8:	68 e2 13 81 00       	push   $0x8113e2
  802bfd:	e8 4c b8 00 00       	call   80e44e <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802c02:	83 ec 04             	sub    $0x4,%esp
  802c05:	6a 00                	push   $0x0
  802c07:	68 34 01 00 00       	push   $0x134
  802c0c:	6a 00                	push   $0x0
  802c0e:	e8 d8 1c 00 00       	call   8048eb <pbuf_alloc>
  802c13:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802c16:	83 c4 10             	add    $0x10,%esp
  802c19:	85 c0                	test   %eax,%eax
  802c1b:	0f 84 37 01 00 00    	je     802d58 <dhcp_create_request+0x1d4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802c21:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802c27:	77 17                	ja     802c40 <dhcp_create_request+0xbc>
  802c29:	83 ec 04             	sub    $0x4,%esp
  802c2c:	68 cc 12 81 00       	push   $0x8112cc
  802c31:	68 38 05 00 00       	push   $0x538
  802c36:	68 e2 13 81 00       	push   $0x8113e2
  802c3b:	e8 0e b8 00 00       	call   80e44e <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  802c40:	8b 15 04 40 81 00    	mov    0x814004,%edx
  802c46:	8d 4a 01             	lea    0x1(%edx),%ecx
  802c49:	89 0d 04 40 81 00    	mov    %ecx,0x814004
  802c4f:	89 53 04             	mov    %edx,0x4(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802c52:	8b 40 04             	mov    0x4(%eax),%eax
  802c55:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802c58:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802c5b:	8b 43 20             	mov    0x20(%ebx),%eax
  802c5e:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802c62:	8b 43 20             	mov    0x20(%ebx),%eax
  802c65:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802c69:	8b 43 20             	mov    0x20(%ebx),%eax
  802c6c:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802c70:	8b 73 20             	mov    0x20(%ebx),%esi
  802c73:	83 ec 0c             	sub    $0xc,%esp
  802c76:	ff 73 04             	pushl  0x4(%ebx)
  802c79:	e8 72 4a 00 00       	call   8076f0 <htonl>
  802c7e:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  802c81:	8b 43 20             	mov    0x20(%ebx),%eax
  802c84:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802c8a:	8b 43 20             	mov    0x20(%ebx),%eax
  802c8d:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802c93:	8b 43 20             	mov    0x20(%ebx),%eax
  802c96:	8b 57 04             	mov    0x4(%edi),%edx
  802c99:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802c9c:	8b 43 20             	mov    0x20(%ebx),%eax
  802c9f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802ca6:	8b 43 20             	mov    0x20(%ebx),%eax
  802ca9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802cb0:	8b 43 20             	mov    0x20(%ebx),%eax
  802cb3:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802cba:	83 c4 10             	add    $0x10,%esp
  802cbd:	b8 00 00 00 00       	mov    $0x0,%eax
  802cc2:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802cc5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  802cc8:	8b 59 20             	mov    0x20(%ecx),%ebx
  802ccb:	89 c1                	mov    %eax,%ecx
  802ccd:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  802cd1:	ba 00 00 00 00       	mov    $0x0,%edx
  802cd6:	66 39 c6             	cmp    %ax,%si
  802cd9:	76 05                	jbe    802ce0 <dhcp_create_request+0x15c>
  802cdb:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  802ce0:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  802ce4:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802ce7:	83 f8 10             	cmp    $0x10,%eax
  802cea:	75 d9                	jne    802cc5 <dhcp_create_request+0x141>
  802cec:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  802cef:	b8 00 00 00 00       	mov    $0x0,%eax
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  802cf4:	8b 53 20             	mov    0x20(%ebx),%edx
  802cf7:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  802cfc:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802cff:	83 f8 40             	cmp    $0x40,%eax
  802d02:	75 f0                	jne    802cf4 <dhcp_create_request+0x170>
  802d04:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  802d09:	8b 53 20             	mov    0x20(%ebx),%edx
  802d0c:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  802d11:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802d14:	3d 80 00 00 00       	cmp    $0x80,%eax
  802d19:	75 ee                	jne    802d09 <dhcp_create_request+0x185>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802d1b:	8b 73 20             	mov    0x20(%ebx),%esi
  802d1e:	83 ec 0c             	sub    $0xc,%esp
  802d21:	68 63 53 82 63       	push   $0x63825363
  802d26:	e8 c5 49 00 00       	call   8076f0 <htonl>
  802d2b:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802d31:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802d37:	83 c4 10             	add    $0x10,%esp
  802d3a:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802d3f:	8b 53 20             	mov    0x20(%ebx),%edx
  802d42:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  802d49:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802d4c:	83 f8 44             	cmp    $0x44,%eax
  802d4f:	75 ee                	jne    802d3f <dhcp_create_request+0x1bb>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  802d51:	b8 00 00 00 00       	mov    $0x0,%eax
  802d56:	eb 05                	jmp    802d5d <dhcp_create_request+0x1d9>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  802d58:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  802d5d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802d60:	5b                   	pop    %ebx
  802d61:	5e                   	pop    %esi
  802d62:	5f                   	pop    %edi
  802d63:	5d                   	pop    %ebp
  802d64:	c3                   	ret    

00802d65 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  802d65:	55                   	push   %ebp
  802d66:	89 e5                	mov    %esp,%ebp
  802d68:	53                   	push   %ebx
  802d69:	83 ec 04             	sub    $0x4,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802d6c:	85 c0                	test   %eax,%eax
  802d6e:	75 17                	jne    802d87 <dhcp_delete_request+0x22>
  802d70:	83 ec 04             	sub    $0x4,%esp
  802d73:	68 10 13 81 00       	push   $0x811310
  802d78:	68 69 05 00 00       	push   $0x569
  802d7d:	68 e2 13 81 00       	push   $0x8113e2
  802d82:	e8 c7 b6 00 00       	call   80e44e <_panic>
  dhcp = netif->dhcp;
  802d87:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802d8a:	85 db                	test   %ebx,%ebx
  802d8c:	75 17                	jne    802da5 <dhcp_delete_request+0x40>
  802d8e:	83 ec 04             	sub    $0x4,%esp
  802d91:	68 34 13 81 00       	push   $0x811334
  802d96:	68 6b 05 00 00       	push   $0x56b
  802d9b:	68 e2 13 81 00       	push   $0x8113e2
  802da0:	e8 a9 b6 00 00       	call   80e44e <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802da5:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802da8:	85 c0                	test   %eax,%eax
  802daa:	75 17                	jne    802dc3 <dhcp_delete_request+0x5e>
  802dac:	83 ec 04             	sub    $0x4,%esp
  802daf:	68 58 13 81 00       	push   $0x811358
  802db4:	68 6c 05 00 00       	push   $0x56c
  802db9:	68 e2 13 81 00       	push   $0x8113e2
  802dbe:	e8 8b b6 00 00       	call   80e44e <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802dc3:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802dc7:	75 17                	jne    802de0 <dhcp_delete_request+0x7b>
  802dc9:	83 ec 04             	sub    $0x4,%esp
  802dcc:	68 84 13 81 00       	push   $0x811384
  802dd1:	68 6d 05 00 00       	push   $0x56d
  802dd6:	68 e2 13 81 00       	push   $0x8113e2
  802ddb:	e8 6e b6 00 00       	call   80e44e <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  802de0:	83 ec 0c             	sub    $0xc,%esp
  802de3:	50                   	push   %eax
  802de4:	e8 3c 1a 00 00       	call   804825 <pbuf_free>
  }
  dhcp->p_out = NULL;
  802de9:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802df0:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  802df7:	83 c4 10             	add    $0x10,%esp
  802dfa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802dfd:	c9                   	leave  
  802dfe:	c3                   	ret    

00802dff <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  802dff:	55                   	push   %ebp
  802e00:	89 e5                	mov    %esp,%ebp
  802e02:	57                   	push   %edi
  802e03:	56                   	push   %esi
  802e04:	53                   	push   %ebx
  802e05:	83 ec 0c             	sub    $0xc,%esp
  802e08:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802e0a:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802e0d:	ba 04 00 00 00       	mov    $0x4,%edx
  802e12:	89 d8                	mov    %ebx,%eax
  802e14:	e8 cf f9 ff ff       	call   8027e8 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  802e19:	89 f8                	mov    %edi,%eax
  802e1b:	e8 64 fd ff ff       	call   802b84 <dhcp_create_request>
  802e20:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802e22:	84 c0                	test   %al,%al
  802e24:	0f 85 89 00 00 00    	jne    802eb3 <dhcp_rebind+0xb4>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802e2a:	b9 01 00 00 00       	mov    $0x1,%ecx
  802e2f:	ba 35 00 00 00       	mov    $0x35,%edx
  802e34:	89 d8                	mov    %ebx,%eax
  802e36:	e8 2e fb ff ff       	call   802969 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802e3b:	ba 03 00 00 00       	mov    $0x3,%edx
  802e40:	89 d8                	mov    %ebx,%eax
  802e42:	e8 e1 fa ff ff       	call   802928 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802e47:	b9 02 00 00 00       	mov    $0x2,%ecx
  802e4c:	ba 39 00 00 00       	mov    $0x39,%edx
  802e51:	89 d8                	mov    %ebx,%eax
  802e53:	e8 11 fb ff ff       	call   802969 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802e58:	ba 40 02 00 00       	mov    $0x240,%edx
  802e5d:	89 d8                	mov    %ebx,%eax
  802e5f:	e8 6c fb ff ff       	call   8029d0 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  802e64:	89 d8                	mov    %ebx,%eax
  802e66:	e8 c9 fb ff ff       	call   802a34 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802e6b:	83 ec 08             	sub    $0x8,%esp
  802e6e:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802e72:	66 05 f0 00          	add    $0xf0,%ax
  802e76:	0f b7 c0             	movzwl %ax,%eax
  802e79:	50                   	push   %eax
  802e7a:	ff 73 1c             	pushl  0x1c(%ebx)
  802e7d:	e8 ec 1c 00 00       	call   804b6e <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802e82:	83 c4 0c             	add    $0xc,%esp
  802e85:	6a 43                	push   $0x43
  802e87:	68 a4 1c 81 00       	push   $0x811ca4
  802e8c:	ff 73 08             	pushl  0x8(%ebx)
  802e8f:	e8 f6 5f 00 00       	call   808e8a <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802e94:	89 3c 24             	mov    %edi,(%esp)
  802e97:	6a 43                	push   $0x43
  802e99:	68 a0 1c 81 00       	push   $0x811ca0
  802e9e:	ff 73 1c             	pushl  0x1c(%ebx)
  802ea1:	ff 73 08             	pushl  0x8(%ebx)
  802ea4:	e8 fb 5d 00 00       	call   808ca4 <udp_sendto_if>
    dhcp_delete_request(netif);
  802ea9:	83 c4 20             	add    $0x20,%esp
  802eac:	89 f8                	mov    %edi,%eax
  802eae:	e8 b2 fe ff ff       	call   802d65 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  802eb3:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802eb7:	83 c0 01             	add    $0x1,%eax
  802eba:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802ebd:	ba 10 27 00 00       	mov    $0x2710,%edx
  802ec2:	3c 09                	cmp    $0x9,%al
  802ec4:	77 08                	ja     802ece <dhcp_rebind+0xcf>
  802ec6:	0f b6 c0             	movzbl %al,%eax
  802ec9:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802ece:	0f b7 c2             	movzwl %dx,%eax
  802ed1:	05 f3 01 00 00       	add    $0x1f3,%eax
  802ed6:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  802edb:	f7 ea                	imul   %edx
  802edd:	c1 fa 05             	sar    $0x5,%edx
  802ee0:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  802ee4:	89 f0                	mov    %esi,%eax
  802ee6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802ee9:	5b                   	pop    %ebx
  802eea:	5e                   	pop    %esi
  802eeb:	5f                   	pop    %edi
  802eec:	5d                   	pop    %ebp
  802eed:	c3                   	ret    

00802eee <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  802eee:	55                   	push   %ebp
  802eef:	89 e5                	mov    %esp,%ebp
  802ef1:	57                   	push   %edi
  802ef2:	56                   	push   %esi
  802ef3:	53                   	push   %ebx
  802ef4:	83 ec 0c             	sub    $0xc,%esp
  802ef7:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802ef9:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  802efc:	a1 a4 1c 81 00       	mov    0x811ca4,%eax
  802f01:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  802f04:	89 f8                	mov    %edi,%eax
  802f06:	e8 79 fc ff ff       	call   802b84 <dhcp_create_request>
  802f0b:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802f0d:	84 c0                	test   %al,%al
  802f0f:	0f 85 d6 00 00 00    	jne    802feb <dhcp_discover+0xfd>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802f15:	b9 01 00 00 00       	mov    $0x1,%ecx
  802f1a:	ba 35 00 00 00       	mov    $0x35,%edx
  802f1f:	89 d8                	mov    %ebx,%eax
  802f21:	e8 43 fa ff ff       	call   802969 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  802f26:	ba 01 00 00 00       	mov    $0x1,%edx
  802f2b:	89 d8                	mov    %ebx,%eax
  802f2d:	e8 f6 f9 ff ff       	call   802928 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802f32:	b9 02 00 00 00       	mov    $0x2,%ecx
  802f37:	ba 39 00 00 00       	mov    $0x39,%edx
  802f3c:	89 d8                	mov    %ebx,%eax
  802f3e:	e8 26 fa ff ff       	call   802969 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802f43:	ba 40 02 00 00       	mov    $0x240,%edx
  802f48:	89 d8                	mov    %ebx,%eax
  802f4a:	e8 81 fa ff ff       	call   8029d0 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  802f4f:	b9 04 00 00 00       	mov    $0x4,%ecx
  802f54:	ba 37 00 00 00       	mov    $0x37,%edx
  802f59:	89 d8                	mov    %ebx,%eax
  802f5b:	e8 09 fa ff ff       	call   802969 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  802f60:	ba 01 00 00 00       	mov    $0x1,%edx
  802f65:	89 d8                	mov    %ebx,%eax
  802f67:	e8 bc f9 ff ff       	call   802928 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  802f6c:	ba 03 00 00 00       	mov    $0x3,%edx
  802f71:	89 d8                	mov    %ebx,%eax
  802f73:	e8 b0 f9 ff ff       	call   802928 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  802f78:	ba 1c 00 00 00       	mov    $0x1c,%edx
  802f7d:	89 d8                	mov    %ebx,%eax
  802f7f:	e8 a4 f9 ff ff       	call   802928 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  802f84:	ba 06 00 00 00       	mov    $0x6,%edx
  802f89:	89 d8                	mov    %ebx,%eax
  802f8b:	e8 98 f9 ff ff       	call   802928 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  802f90:	89 d8                	mov    %ebx,%eax
  802f92:	e8 9d fa ff ff       	call   802a34 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802f97:	83 ec 08             	sub    $0x8,%esp
  802f9a:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802f9e:	66 05 f0 00          	add    $0xf0,%ax
  802fa2:	0f b7 c0             	movzwl %ax,%eax
  802fa5:	50                   	push   %eax
  802fa6:	ff 73 1c             	pushl  0x1c(%ebx)
  802fa9:	e8 c0 1b 00 00       	call   804b6e <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802fae:	83 c4 0c             	add    $0xc,%esp
  802fb1:	6a 43                	push   $0x43
  802fb3:	68 a4 1c 81 00       	push   $0x811ca4
  802fb8:	ff 73 08             	pushl  0x8(%ebx)
  802fbb:	e8 ca 5e 00 00       	call   808e8a <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802fc0:	89 3c 24             	mov    %edi,(%esp)
  802fc3:	6a 43                	push   $0x43
  802fc5:	68 a0 1c 81 00       	push   $0x811ca0
  802fca:	ff 73 1c             	pushl  0x1c(%ebx)
  802fcd:	ff 73 08             	pushl  0x8(%ebx)
  802fd0:	e8 cf 5c 00 00       	call   808ca4 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  802fd5:	83 c4 20             	add    $0x20,%esp
  802fd8:	89 f8                	mov    %edi,%eax
  802fda:	e8 86 fd ff ff       	call   802d65 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  802fdf:	ba 06 00 00 00       	mov    $0x6,%edx
  802fe4:	89 d8                	mov    %ebx,%eax
  802fe6:	e8 fd f7 ff ff       	call   8027e8 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  802feb:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802fef:	83 c0 01             	add    $0x1,%eax
  802ff2:	88 43 01             	mov    %al,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  802ff5:	ba 10 27 00 00       	mov    $0x2710,%edx
  802ffa:	3c 03                	cmp    $0x3,%al
  802ffc:	77 0b                	ja     803009 <dhcp_discover+0x11b>
  802ffe:	0f b6 c0             	movzbl %al,%eax
  803001:	83 c0 01             	add    $0x1,%eax
  803004:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803009:	0f b7 c2             	movzwl %dx,%eax
  80300c:	05 f3 01 00 00       	add    $0x1f3,%eax
  803011:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  803016:	f7 ea                	imul   %edx
  803018:	c1 fa 05             	sar    $0x5,%edx
  80301b:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  80301f:	89 f0                	mov    %esi,%eax
  803021:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803024:	5b                   	pop    %ebx
  803025:	5e                   	pop    %esi
  803026:	5f                   	pop    %edi
  803027:	5d                   	pop    %ebp
  803028:	c3                   	ret    

00803029 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  803029:	55                   	push   %ebp
  80302a:	89 e5                	mov    %esp,%ebp
  80302c:	57                   	push   %edi
  80302d:	56                   	push   %esi
  80302e:	53                   	push   %ebx
  80302f:	83 ec 0c             	sub    $0xc,%esp
  803032:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803034:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803037:	e8 48 fb ff ff       	call   802b84 <dhcp_create_request>
  80303c:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  80303e:	84 c0                	test   %al,%al
  803040:	0f 85 20 01 00 00    	jne    803166 <dhcp_select+0x13d>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803046:	b9 01 00 00 00       	mov    $0x1,%ecx
  80304b:	ba 35 00 00 00       	mov    $0x35,%edx
  803050:	89 d8                	mov    %ebx,%eax
  803052:	e8 12 f9 ff ff       	call   802969 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803057:	ba 03 00 00 00       	mov    $0x3,%edx
  80305c:	89 d8                	mov    %ebx,%eax
  80305e:	e8 c5 f8 ff ff       	call   802928 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803063:	b9 02 00 00 00       	mov    $0x2,%ecx
  803068:	ba 39 00 00 00       	mov    $0x39,%edx
  80306d:	89 d8                	mov    %ebx,%eax
  80306f:	e8 f5 f8 ff ff       	call   802969 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803074:	ba 40 02 00 00       	mov    $0x240,%edx
  803079:	89 d8                	mov    %ebx,%eax
  80307b:	e8 50 f9 ff ff       	call   8029d0 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803080:	b9 04 00 00 00       	mov    $0x4,%ecx
  803085:	ba 32 00 00 00       	mov    $0x32,%edx
  80308a:	89 d8                	mov    %ebx,%eax
  80308c:	e8 d8 f8 ff ff       	call   802969 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803091:	83 ec 0c             	sub    $0xc,%esp
  803094:	ff 73 30             	pushl  0x30(%ebx)
  803097:	e8 75 48 00 00       	call   807911 <ntohl>
  80309c:	89 c2                	mov    %eax,%edx
  80309e:	89 d8                	mov    %ebx,%eax
  8030a0:	e8 44 fa ff ff       	call   802ae9 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8030a5:	b9 04 00 00 00       	mov    $0x4,%ecx
  8030aa:	ba 36 00 00 00       	mov    $0x36,%edx
  8030af:	89 d8                	mov    %ebx,%eax
  8030b1:	e8 b3 f8 ff ff       	call   802969 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  8030b6:	83 c4 04             	add    $0x4,%esp
  8030b9:	ff 73 2c             	pushl  0x2c(%ebx)
  8030bc:	e8 50 48 00 00       	call   807911 <ntohl>
  8030c1:	89 c2                	mov    %eax,%edx
  8030c3:	89 d8                	mov    %ebx,%eax
  8030c5:	e8 1f fa ff ff       	call   802ae9 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8030ca:	b9 04 00 00 00       	mov    $0x4,%ecx
  8030cf:	ba 37 00 00 00       	mov    $0x37,%edx
  8030d4:	89 d8                	mov    %ebx,%eax
  8030d6:	e8 8e f8 ff ff       	call   802969 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  8030db:	ba 01 00 00 00       	mov    $0x1,%edx
  8030e0:	89 d8                	mov    %ebx,%eax
  8030e2:	e8 41 f8 ff ff       	call   802928 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  8030e7:	ba 03 00 00 00       	mov    $0x3,%edx
  8030ec:	89 d8                	mov    %ebx,%eax
  8030ee:	e8 35 f8 ff ff       	call   802928 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  8030f3:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8030f8:	89 d8                	mov    %ebx,%eax
  8030fa:	e8 29 f8 ff ff       	call   802928 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8030ff:	ba 06 00 00 00       	mov    $0x6,%edx
  803104:	89 d8                	mov    %ebx,%eax
  803106:	e8 1d f8 ff ff       	call   802928 <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  80310b:	89 d8                	mov    %ebx,%eax
  80310d:	e8 22 f9 ff ff       	call   802a34 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803112:	83 c4 08             	add    $0x8,%esp
  803115:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803119:	66 05 f0 00          	add    $0xf0,%ax
  80311d:	0f b7 c0             	movzwl %ax,%eax
  803120:	50                   	push   %eax
  803121:	ff 73 1c             	pushl  0x1c(%ebx)
  803124:	e8 45 1a 00 00       	call   804b6e <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803129:	89 3c 24             	mov    %edi,(%esp)
  80312c:	6a 43                	push   $0x43
  80312e:	68 a0 1c 81 00       	push   $0x811ca0
  803133:	ff 73 1c             	pushl  0x1c(%ebx)
  803136:	ff 73 08             	pushl  0x8(%ebx)
  803139:	e8 66 5b 00 00       	call   808ca4 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80313e:	83 c4 1c             	add    $0x1c,%esp
  803141:	6a 43                	push   $0x43
  803143:	68 a4 1c 81 00       	push   $0x811ca4
  803148:	ff 73 08             	pushl  0x8(%ebx)
  80314b:	e8 3a 5d 00 00       	call   808e8a <udp_connect>
    dhcp_delete_request(netif);
  803150:	89 f8                	mov    %edi,%eax
  803152:	e8 0e fc ff ff       	call   802d65 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  803157:	ba 01 00 00 00       	mov    $0x1,%edx
  80315c:	89 d8                	mov    %ebx,%eax
  80315e:	e8 85 f6 ff ff       	call   8027e8 <dhcp_set_state>
  803163:	83 c4 10             	add    $0x10,%esp
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803166:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  80316a:	83 c0 01             	add    $0x1,%eax
  80316d:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  803170:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  803175:	3c 03                	cmp    $0x3,%al
  803177:	77 08                	ja     803181 <dhcp_select+0x158>
  803179:	0f b6 c0             	movzbl %al,%eax
  80317c:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803181:	0f b7 c2             	movzwl %dx,%eax
  803184:	05 f3 01 00 00       	add    $0x1f3,%eax
  803189:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80318e:	f7 ea                	imul   %edx
  803190:	c1 fa 05             	sar    $0x5,%edx
  803193:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803197:	89 f0                	mov    %esi,%eax
  803199:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80319c:	5b                   	pop    %ebx
  80319d:	5e                   	pop    %esi
  80319e:	5f                   	pop    %edi
  80319f:	5d                   	pop    %ebp
  8031a0:	c3                   	ret    

008031a1 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  8031a1:	55                   	push   %ebp
  8031a2:	89 e5                	mov    %esp,%ebp
  8031a4:	53                   	push   %ebx
  8031a5:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  8031a8:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8031ab:	6a 00                	push   $0x0
  8031ad:	8d 53 30             	lea    0x30(%ebx),%edx
  8031b0:	52                   	push   %edx
  8031b1:	50                   	push   %eax
  8031b2:	e8 9e 66 00 00       	call   809855 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  8031b7:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8031bb:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  8031c1:	ba 08 00 00 00       	mov    $0x8,%edx
  8031c6:	89 d8                	mov    %ebx,%eax
  8031c8:	e8 1b f6 ff ff       	call   8027e8 <dhcp_set_state>
}
  8031cd:	83 c4 10             	add    $0x10,%esp
  8031d0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8031d3:	c9                   	leave  
  8031d4:	c3                   	ret    

008031d5 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  8031d5:	55                   	push   %ebp
  8031d6:	89 e5                	mov    %esp,%ebp
  8031d8:	56                   	push   %esi
  8031d9:	53                   	push   %ebx
  8031da:	83 ec 10             	sub    $0x10,%esp
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  8031dd:	85 c0                	test   %eax,%eax
  8031df:	75 17                	jne    8031f8 <dhcp_bind+0x23>
  8031e1:	83 ec 04             	sub    $0x4,%esp
  8031e4:	68 f7 13 81 00       	push   $0x8113f7
  8031e9:	68 3d 03 00 00       	push   $0x33d
  8031ee:	68 e2 13 81 00       	push   $0x8113e2
  8031f3:	e8 56 b2 00 00       	call   80e44e <_panic>
  8031f8:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  8031fa:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  8031fd:	85 db                	test   %ebx,%ebx
  8031ff:	75 17                	jne    803218 <dhcp_bind+0x43>
  803201:	83 ec 04             	sub    $0x4,%esp
  803204:	68 10 14 81 00       	push   $0x811410
  803209:	68 3f 03 00 00       	push   $0x33f
  80320e:	68 e2 13 81 00       	push   $0x8113e2
  803213:	e8 36 b2 00 00       	call   80e44e <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  803218:	8b 53 50             	mov    0x50(%ebx),%edx
  80321b:	83 fa ff             	cmp    $0xffffffff,%edx
  80321e:	74 2c                	je     80324c <dhcp_bind+0x77>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803220:	83 c2 1e             	add    $0x1e,%edx
  803223:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803228:	89 d0                	mov    %edx,%eax
  80322a:	f7 e1                	mul    %ecx
  80322c:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  80322f:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  803235:	b8 ff ff 00 00       	mov    $0xffff,%eax
  80323a:	0f 47 d0             	cmova  %eax,%edx
  80323d:	66 85 d2             	test   %dx,%dx
  803240:	b8 01 00 00 00       	mov    $0x1,%eax
  803245:	0f 44 d0             	cmove  %eax,%edx
  803248:	66 89 53 28          	mov    %dx,0x28(%ebx)
      dhcp->t1_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80324c:	8b 53 54             	mov    0x54(%ebx),%edx
  80324f:	83 fa ff             	cmp    $0xffffffff,%edx
  803252:	74 2c                	je     803280 <dhcp_bind+0xab>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803254:	83 c2 1e             	add    $0x1e,%edx
  803257:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  80325c:	89 d0                	mov    %edx,%eax
  80325e:	f7 e1                	mul    %ecx
  803260:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  803263:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  803269:	b8 ff ff 00 00       	mov    $0xffff,%eax
  80326e:	0f 47 d0             	cmova  %eax,%edx
  803271:	66 85 d2             	test   %dx,%dx
  803274:	b8 01 00 00 00       	mov    $0x1,%eax
  803279:	0f 44 d0             	cmove  %eax,%edx
  80327c:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  803280:	83 fb cc             	cmp    $0xffffffcc,%ebx
  803283:	0f 84 c4 00 00 00    	je     80334d <dhcp_bind+0x178>
  803289:	8b 43 34             	mov    0x34(%ebx),%eax
  80328c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  80328f:	85 c0                	test   %eax,%eax
  803291:	75 55                	jne    8032e8 <dhcp_bind+0x113>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  803293:	83 ec 0c             	sub    $0xc,%esp
  803296:	6a 00                	push   $0x0
  803298:	e8 74 46 00 00       	call   807911 <ntohl>
  80329d:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  8032a0:	83 c4 10             	add    $0x10,%esp
  8032a3:	84 c0                	test   %al,%al
  8032a5:	78 15                	js     8032bc <dhcp_bind+0xe7>
      sn_mask.addr = htonl(0xff000000);
  8032a7:	83 ec 0c             	sub    $0xc,%esp
  8032aa:	68 00 00 00 ff       	push   $0xff000000
  8032af:	e8 3c 44 00 00       	call   8076f0 <htonl>
  8032b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8032b7:	83 c4 10             	add    $0x10,%esp
  8032ba:	eb 2c                	jmp    8032e8 <dhcp_bind+0x113>
    } else if (first_octet >= 192) {
  8032bc:	3c bf                	cmp    $0xbf,%al
  8032be:	76 15                	jbe    8032d5 <dhcp_bind+0x100>
      sn_mask.addr = htonl(0xffffff00);
  8032c0:	83 ec 0c             	sub    $0xc,%esp
  8032c3:	68 00 ff ff ff       	push   $0xffffff00
  8032c8:	e8 23 44 00 00       	call   8076f0 <htonl>
  8032cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8032d0:	83 c4 10             	add    $0x10,%esp
  8032d3:	eb 13                	jmp    8032e8 <dhcp_bind+0x113>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  8032d5:	83 ec 0c             	sub    $0xc,%esp
  8032d8:	68 00 00 ff ff       	push   $0xffff0000
  8032dd:	e8 0e 44 00 00       	call   8076f0 <htonl>
  8032e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8032e5:	83 c4 10             	add    $0x10,%esp
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8032e8:	83 fb c8             	cmp    $0xffffffc8,%ebx
  8032eb:	74 0a                	je     8032f7 <dhcp_bind+0x122>
  8032ed:	8b 43 38             	mov    0x38(%ebx),%eax
  8032f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  8032f3:	85 c0                	test   %eax,%eax
  8032f5:	75 19                	jne    803310 <dhcp_bind+0x13b>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  8032f7:	8b 43 30             	mov    0x30(%ebx),%eax
  8032fa:	23 45 f4             	and    -0xc(%ebp),%eax
  8032fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  803300:	83 ec 0c             	sub    $0xc,%esp
  803303:	6a 01                	push   $0x1
  803305:	e8 e6 43 00 00       	call   8076f0 <htonl>
  80330a:	09 45 f0             	or     %eax,-0x10(%ebp)
  80330d:	83 c4 10             	add    $0x10,%esp
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  803310:	83 ec 08             	sub    $0x8,%esp
  803313:	8d 43 30             	lea    0x30(%ebx),%eax
  803316:	50                   	push   %eax
  803317:	56                   	push   %esi
  803318:	e8 55 12 00 00       	call   804572 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  80331d:	83 c4 08             	add    $0x8,%esp
  803320:	8d 45 f4             	lea    -0xc(%ebp),%eax
  803323:	50                   	push   %eax
  803324:	56                   	push   %esi
  803325:	e8 ab 13 00 00       	call   8046d5 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  80332a:	83 c4 08             	add    $0x8,%esp
  80332d:	8d 45 f0             	lea    -0x10(%ebp),%eax
  803330:	50                   	push   %eax
  803331:	56                   	push   %esi
  803332:	e8 83 13 00 00       	call   8046ba <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  803337:	89 34 24             	mov    %esi,(%esp)
  80333a:	e8 be 13 00 00       	call   8046fd <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  80333f:	ba 0a 00 00 00       	mov    $0xa,%edx
  803344:	89 d8                	mov    %ebx,%eax
  803346:	e8 9d f4 ff ff       	call   8027e8 <dhcp_set_state>
}
  80334b:	eb 0c                	jmp    803359 <dhcp_bind+0x184>
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80334d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  803354:	e9 3a ff ff ff       	jmp    803293 <dhcp_bind+0xbe>
  netif_set_gw(netif, &gw_addr);
  /* bring the interface up */
  netif_set_up(netif);
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
}
  803359:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80335c:	5b                   	pop    %ebx
  80335d:	5e                   	pop    %esi
  80335e:	5d                   	pop    %ebp
  80335f:	c3                   	ret    

00803360 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  803360:	55                   	push   %ebp
  803361:	89 e5                	mov    %esp,%ebp
  803363:	53                   	push   %ebx
  803364:	83 ec 04             	sub    $0x4,%esp
  803367:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  803369:	8b 40 10             	mov    0x10(%eax),%eax
  80336c:	85 c0                	test   %eax,%eax
  80336e:	74 13                	je     803383 <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  803370:	83 ec 0c             	sub    $0xc,%esp
  803373:	50                   	push   %eax
  803374:	e8 0a 0c 00 00       	call   803f83 <mem_free>
    dhcp->msg_in = NULL;
  803379:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  803380:	83 c4 10             	add    $0x10,%esp
  }
  if (dhcp->options_in) {
  803383:	8b 43 14             	mov    0x14(%ebx),%eax
  803386:	85 c0                	test   %eax,%eax
  803388:	74 19                	je     8033a3 <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  80338a:	83 ec 0c             	sub    $0xc,%esp
  80338d:	50                   	push   %eax
  80338e:	e8 f0 0b 00 00       	call   803f83 <mem_free>
    dhcp->options_in = NULL;
  803393:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  80339a:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  8033a0:	83 c4 10             	add    $0x10,%esp
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  8033a3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8033a6:	c9                   	leave  
  8033a7:	c3                   	ret    

008033a8 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  8033a8:	55                   	push   %ebp
  8033a9:	89 e5                	mov    %esp,%ebp
  8033ab:	57                   	push   %edi
  8033ac:	56                   	push   %esi
  8033ad:	53                   	push   %ebx
  8033ae:	83 ec 1c             	sub    $0x1c,%esp
  8033b1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
  8033b4:	8b 73 20             	mov    0x20(%ebx),%esi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  8033b7:	8b 45 10             	mov    0x10(%ebp),%eax
  8033ba:	8b 48 04             	mov    0x4(%eax),%ecx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  8033bd:	89 46 0c             	mov    %eax,0xc(%esi)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  8033c0:	80 39 02             	cmpb   $0x2,(%ecx)
  8033c3:	0f 85 b8 03 00 00    	jne    803781 <dhcp_recv+0x3d9>
  8033c9:	0f b6 7b 24          	movzbl 0x24(%ebx),%edi
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8033cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8033d2:	eb 12                	jmp    8033e6 <dhcp_recv+0x3e>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  8033d4:	0f b6 54 03 25       	movzbl 0x25(%ebx,%eax,1),%edx
  8033d9:	83 c0 01             	add    $0x1,%eax
  8033dc:	3a 54 01 1b          	cmp    0x1b(%ecx,%eax,1),%dl
  8033e0:	0f 85 9b 03 00 00    	jne    803781 <dhcp_recv+0x3d9>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8033e6:	39 f8                	cmp    %edi,%eax
  8033e8:	75 ea                	jne    8033d4 <dhcp_recv+0x2c>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  8033ea:	83 ec 0c             	sub    $0xc,%esp
  8033ed:	ff 71 04             	pushl  0x4(%ecx)
  8033f0:	e8 1c 45 00 00       	call   807911 <ntohl>
  8033f5:	83 c4 10             	add    $0x10,%esp
  8033f8:	3b 46 04             	cmp    0x4(%esi),%eax
  8033fb:	0f 85 80 03 00 00    	jne    803781 <dhcp_recv+0x3d9>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  803401:	85 f6                	test   %esi,%esi
  803403:	75 17                	jne    80341c <dhcp_recv+0x74>
  803405:	83 ec 04             	sub    $0x4,%esp
  803408:	68 1b 14 81 00       	push   $0x81141b
  80340d:	68 89 04 00 00       	push   $0x489
  803412:	68 e2 13 81 00       	push   $0x8113e2
  803417:	e8 32 b0 00 00       	call   80e44e <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80341c:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
  803420:	75 17                	jne    803439 <dhcp_recv+0x91>
  803422:	83 ec 04             	sub    $0x4,%esp
  803425:	68 28 14 81 00       	push   $0x811428
  80342a:	68 8a 04 00 00       	push   $0x48a
  80342f:	68 e2 13 81 00       	push   $0x8113e2
  803434:	e8 15 b0 00 00       	call   80e44e <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  803439:	89 f0                	mov    %esi,%eax
  80343b:	e8 20 ff ff ff       	call   803360 <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  803440:	8b 46 0c             	mov    0xc(%esi),%eax
  803443:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  803447:	66 3d f0 00          	cmp    $0xf0,%ax
  80344b:	76 22                	jbe    80346f <dhcp_recv+0xc7>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80344d:	66 2d f0 00          	sub    $0xf0,%ax
  803451:	66 89 46 18          	mov    %ax,0x18(%esi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  803455:	83 ec 0c             	sub    $0xc,%esp
  803458:	0f b7 c0             	movzwl %ax,%eax
  80345b:	50                   	push   %eax
  80345c:	e8 d4 0d 00 00       	call   804235 <mem_malloc>
  803461:	89 46 14             	mov    %eax,0x14(%esi)
    if (dhcp->options_in == NULL) {
  803464:	83 c4 10             	add    $0x10,%esp
  803467:	85 c0                	test   %eax,%eax
  803469:	0f 84 12 03 00 00    	je     803781 <dhcp_recv+0x3d9>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80346f:	83 ec 0c             	sub    $0xc,%esp
  803472:	68 f0 00 00 00       	push   $0xf0
  803477:	e8 b9 0d 00 00       	call   804235 <mem_malloc>
  80347c:	89 46 10             	mov    %eax,0x10(%esi)
  if (dhcp->msg_in == NULL) {
  80347f:	83 c4 10             	add    $0x10,%esp
  803482:	85 c0                	test   %eax,%eax
  803484:	75 1a                	jne    8034a0 <dhcp_recv+0xf8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  803486:	83 ec 0c             	sub    $0xc,%esp
  803489:	ff 76 14             	pushl  0x14(%esi)
  80348c:	e8 f2 0a 00 00       	call   803f83 <mem_free>
    dhcp->options_in = NULL;
  803491:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
  803498:	83 c4 10             	add    $0x10,%esp
  80349b:	e9 e1 02 00 00       	jmp    803781 <dhcp_recv+0x3d9>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8034a0:	6a 00                	push   $0x0
  8034a2:	68 f0 00 00 00       	push   $0xf0
  8034a7:	50                   	push   %eax
  8034a8:	ff 76 0c             	pushl  0xc(%esi)
  8034ab:	e8 c5 1a 00 00       	call   804f75 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8034b0:	83 c4 10             	add    $0x10,%esp
  8034b3:	66 3d f0 00          	cmp    $0xf0,%ax
  8034b7:	74 17                	je     8034d0 <dhcp_recv+0x128>
  8034b9:	83 ec 04             	sub    $0x4,%esp
  8034bc:	68 b0 13 81 00       	push   $0x8113b0
  8034c1:	68 a0 04 00 00       	push   $0x4a0
  8034c6:	68 e2 13 81 00       	push   $0x8113e2
  8034cb:	e8 7e af 00 00       	call   80e44e <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  8034d0:	8b 46 14             	mov    0x14(%esi),%eax
  8034d3:	85 c0                	test   %eax,%eax
  8034d5:	0f 84 ba 02 00 00    	je     803795 <dhcp_recv+0x3ed>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8034db:	68 f0 00 00 00       	push   $0xf0
  8034e0:	0f b7 56 18          	movzwl 0x18(%esi),%edx
  8034e4:	52                   	push   %edx
  8034e5:	50                   	push   %eax
  8034e6:	ff 76 0c             	pushl  0xc(%esi)
  8034e9:	e8 87 1a 00 00       	call   804f75 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  8034ee:	83 c4 10             	add    $0x10,%esp
  8034f1:	66 3b 46 18          	cmp    0x18(%esi),%ax
  8034f5:	0f 84 9a 02 00 00    	je     803795 <dhcp_recv+0x3ed>
  8034fb:	83 ec 04             	sub    $0x4,%esp
  8034fe:	68 38 14 81 00       	push   $0x811438
  803503:	68 a7 04 00 00       	push   $0x4a7
  803508:	68 e2 13 81 00       	push   $0x8113e2
  80350d:	e8 3c af 00 00       	call   80e44e <_panic>
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  803512:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  803516:	3c 05                	cmp    $0x5,%al
  803518:	0f 85 a3 01 00 00    	jne    8036c1 <dhcp_recv+0x319>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  80351e:	0f b6 06             	movzbl (%esi),%eax
  803521:	3c 01                	cmp    $0x1,%al
  803523:	0f 85 7b 01 00 00    	jne    8036a4 <dhcp_recv+0x2fc>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803529:	8b 7b 20             	mov    0x20(%ebx),%edi
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  80352c:	c7 47 34 00 00 00 00 	movl   $0x0,0x34(%edi)
  dhcp->offered_gw_addr.addr = 0;
  803533:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  dhcp->offered_bc_addr.addr = 0;
  80353a:	c7 47 3c 00 00 00 00 	movl   $0x0,0x3c(%edi)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  803541:	ba 33 00 00 00       	mov    $0x33,%edx
  803546:	89 f8                	mov    %edi,%eax
  803548:	e8 aa f2 ff ff       	call   8027f7 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80354d:	85 c0                	test   %eax,%eax
  80354f:	74 0b                	je     80355c <dhcp_recv+0x1b4>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  803551:	83 c0 02             	add    $0x2,%eax
  803554:	e8 aa f3 ff ff       	call   802903 <dhcp_get_option_long>
  803559:	89 47 4c             	mov    %eax,0x4c(%edi)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  80355c:	ba 3a 00 00 00       	mov    $0x3a,%edx
  803561:	89 f8                	mov    %edi,%eax
  803563:	e8 8f f2 ff ff       	call   8027f7 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803568:	85 c0                	test   %eax,%eax
  80356a:	74 0d                	je     803579 <dhcp_recv+0x1d1>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  80356c:	83 c0 02             	add    $0x2,%eax
  80356f:	e8 8f f3 ff ff       	call   802903 <dhcp_get_option_long>
  803574:	89 47 50             	mov    %eax,0x50(%edi)
  803577:	eb 08                	jmp    803581 <dhcp_recv+0x1d9>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  803579:	8b 47 4c             	mov    0x4c(%edi),%eax
  80357c:	d1 e8                	shr    %eax
  80357e:	89 47 50             	mov    %eax,0x50(%edi)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  803581:	ba 3b 00 00 00       	mov    $0x3b,%edx
  803586:	89 f8                	mov    %edi,%eax
  803588:	e8 6a f2 ff ff       	call   8027f7 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80358d:	85 c0                	test   %eax,%eax
  80358f:	74 0d                	je     80359e <dhcp_recv+0x1f6>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  803591:	83 c0 02             	add    $0x2,%eax
  803594:	e8 6a f3 ff ff       	call   802903 <dhcp_get_option_long>
  803599:	89 47 54             	mov    %eax,0x54(%edi)
  80359c:	eb 06                	jmp    8035a4 <dhcp_recv+0x1fc>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  80359e:	8b 47 4c             	mov    0x4c(%edi),%eax
  8035a1:	89 47 54             	mov    %eax,0x54(%edi)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8035a4:	8b 47 10             	mov    0x10(%edi),%eax
  8035a7:	83 f8 f0             	cmp    $0xfffffff0,%eax
  8035aa:	74 05                	je     8035b1 <dhcp_recv+0x209>
  8035ac:	8b 40 10             	mov    0x10(%eax),%eax
  8035af:	eb 05                	jmp    8035b6 <dhcp_recv+0x20e>
  8035b1:	b8 00 00 00 00       	mov    $0x0,%eax
  8035b6:	89 47 30             	mov    %eax,0x30(%edi)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8035b9:	ba 01 00 00 00       	mov    $0x1,%edx
  8035be:	89 f8                	mov    %edi,%eax
  8035c0:	e8 32 f2 ff ff       	call   8027f7 <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  8035c5:	85 c0                	test   %eax,%eax
  8035c7:	74 17                	je     8035e0 <dhcp_recv+0x238>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8035c9:	83 c0 02             	add    $0x2,%eax
  8035cc:	e8 32 f3 ff ff       	call   802903 <dhcp_get_option_long>
  8035d1:	83 ec 0c             	sub    $0xc,%esp
  8035d4:	50                   	push   %eax
  8035d5:	e8 16 41 00 00       	call   8076f0 <htonl>
  8035da:	89 47 34             	mov    %eax,0x34(%edi)
  8035dd:	83 c4 10             	add    $0x10,%esp
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  8035e0:	ba 03 00 00 00       	mov    $0x3,%edx
  8035e5:	89 f8                	mov    %edi,%eax
  8035e7:	e8 0b f2 ff ff       	call   8027f7 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8035ec:	85 c0                	test   %eax,%eax
  8035ee:	74 17                	je     803607 <dhcp_recv+0x25f>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8035f0:	83 c0 02             	add    $0x2,%eax
  8035f3:	e8 0b f3 ff ff       	call   802903 <dhcp_get_option_long>
  8035f8:	83 ec 0c             	sub    $0xc,%esp
  8035fb:	50                   	push   %eax
  8035fc:	e8 ef 40 00 00       	call   8076f0 <htonl>
  803601:	89 47 38             	mov    %eax,0x38(%edi)
  803604:	83 c4 10             	add    $0x10,%esp
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  803607:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80360c:	89 f8                	mov    %edi,%eax
  80360e:	e8 e4 f1 ff ff       	call   8027f7 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803613:	85 c0                	test   %eax,%eax
  803615:	74 17                	je     80362e <dhcp_recv+0x286>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803617:	83 c0 02             	add    $0x2,%eax
  80361a:	e8 e4 f2 ff ff       	call   802903 <dhcp_get_option_long>
  80361f:	83 ec 0c             	sub    $0xc,%esp
  803622:	50                   	push   %eax
  803623:	e8 c8 40 00 00       	call   8076f0 <htonl>
  803628:	89 47 3c             	mov    %eax,0x3c(%edi)
  80362b:	83 c4 10             	add    $0x10,%esp
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  80362e:	ba 06 00 00 00       	mov    $0x6,%edx
  803633:	89 f8                	mov    %edi,%eax
  803635:	e8 bd f1 ff ff       	call   8027f7 <dhcp_get_option_ptr>
  80363a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (option_ptr != NULL) {
  80363d:	85 c0                	test   %eax,%eax
  80363f:	74 51                	je     803692 <dhcp_recv+0x2ea>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803641:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  803645:	c0 e8 02             	shr    $0x2,%al
  803648:	0f b6 c0             	movzbl %al,%eax
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
  80364b:	83 f8 03             	cmp    $0x3,%eax
  80364e:	ba 02 00 00 00       	mov    $0x2,%edx
  803653:	0f 43 c2             	cmovae %edx,%eax
  803656:	89 47 40             	mov    %eax,0x40(%edi)
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803659:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80365d:	89 5d 08             	mov    %ebx,0x8(%ebp)
  803660:	eb 24                	jmp    803686 <dhcp_recv+0x2de>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  803662:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  803666:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  803669:	8d 44 99 02          	lea    0x2(%ecx,%ebx,4),%eax
  80366d:	e8 91 f2 ff ff       	call   802903 <dhcp_get_option_long>
  803672:	83 ec 0c             	sub    $0xc,%esp
  803675:	50                   	push   %eax
  803676:	e8 75 40 00 00       	call   8076f0 <htonl>
  80367b:	89 44 9f 44          	mov    %eax,0x44(%edi,%ebx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  80367f:	80 45 e7 01          	addb   $0x1,-0x19(%ebp)
  803683:	83 c4 10             	add    $0x10,%esp
  803686:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80368a:	3b 47 40             	cmp    0x40(%edi),%eax
  80368d:	72 d3                	jb     803662 <dhcp_recv+0x2ba>
  80368f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  803692:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  803698:	89 d8                	mov    %ebx,%eax
  80369a:	e8 02 fb ff ff       	call   8031a1 <dhcp_check>
  80369f:	e9 dd 00 00 00       	jmp    803781 <dhcp_recv+0x3d9>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  8036a4:	83 e8 03             	sub    $0x3,%eax
  8036a7:	3c 02                	cmp    $0x2,%al
  8036a9:	0f 87 d2 00 00 00    	ja     803781 <dhcp_recv+0x3d9>
      dhcp->request_timeout = 0;
  8036af:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
      dhcp_bind(netif);
  8036b5:	89 d8                	mov    %ebx,%eax
  8036b7:	e8 19 fb ff ff       	call   8031d5 <dhcp_bind>
  8036bc:	e9 c0 00 00 00       	jmp    803781 <dhcp_recv+0x3d9>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  8036c1:	3c 06                	cmp    $0x6,%al
  8036c3:	75 67                	jne    80372c <dhcp_recv+0x384>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  8036c5:	0f b6 06             	movzbl (%esi),%eax
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  8036c8:	8d 50 fd             	lea    -0x3(%eax),%edx
  8036cb:	80 fa 02             	cmp    $0x2,%dl
  8036ce:	76 08                	jbe    8036d8 <dhcp_recv+0x330>
  8036d0:	3c 01                	cmp    $0x1,%al
  8036d2:	0f 85 a9 00 00 00    	jne    803781 <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  8036d8:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  8036de:	8b 7b 20             	mov    0x20(%ebx),%edi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  8036e1:	83 ec 0c             	sub    $0xc,%esp
  8036e4:	53                   	push   %ebx
  8036e5:	e8 44 10 00 00       	call   80472e <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  8036ea:	83 c4 08             	add    $0x8,%esp
  8036ed:	68 a4 1c 81 00       	push   $0x811ca4
  8036f2:	53                   	push   %ebx
  8036f3:	e8 7a 0e 00 00       	call   804572 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  8036f8:	83 c4 08             	add    $0x8,%esp
  8036fb:	68 a4 1c 81 00       	push   $0x811ca4
  803700:	53                   	push   %ebx
  803701:	e8 b4 0f 00 00       	call   8046ba <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  803706:	83 c4 08             	add    $0x8,%esp
  803709:	68 a4 1c 81 00       	push   $0x811ca4
  80370e:	53                   	push   %ebx
  80370f:	e8 c1 0f 00 00       	call   8046d5 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803714:	ba 0c 00 00 00       	mov    $0xc,%edx
  803719:	89 f8                	mov    %edi,%eax
  80371b:	e8 c8 f0 ff ff       	call   8027e8 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  803720:	89 d8                	mov    %ebx,%eax
  803722:	e8 c7 f7 ff ff       	call   802eee <dhcp_discover>
  803727:	83 c4 10             	add    $0x10,%esp
  80372a:	eb 55                	jmp    803781 <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80372c:	3c 02                	cmp    $0x2,%al
  80372e:	75 51                	jne    803781 <dhcp_recv+0x3d9>
  803730:	80 3e 06             	cmpb   $0x6,(%esi)
  803733:	75 4c                	jne    803781 <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  803735:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  80373b:	8b 7b 20             	mov    0x20(%ebx),%edi
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  80373e:	ba 36 00 00 00       	mov    $0x36,%edx
  803743:	89 f8                	mov    %edi,%eax
  803745:	e8 ad f0 ff ff       	call   8027f7 <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  80374a:	85 c0                	test   %eax,%eax
  80374c:	74 33                	je     803781 <dhcp_recv+0x3d9>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80374e:	83 c0 02             	add    $0x2,%eax
  803751:	e8 ad f1 ff ff       	call   802903 <dhcp_get_option_long>
  803756:	83 ec 0c             	sub    $0xc,%esp
  803759:	50                   	push   %eax
  80375a:	e8 91 3f 00 00       	call   8076f0 <htonl>
  80375f:	89 47 2c             	mov    %eax,0x2c(%edi)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  803762:	8b 47 10             	mov    0x10(%edi),%eax
  803765:	83 c4 10             	add    $0x10,%esp
  803768:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80376b:	74 05                	je     803772 <dhcp_recv+0x3ca>
  80376d:	8b 40 10             	mov    0x10(%eax),%eax
  803770:	eb 05                	jmp    803777 <dhcp_recv+0x3cf>
  803772:	b8 00 00 00 00       	mov    $0x0,%eax
  803777:	89 47 30             	mov    %eax,0x30(%edi)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  80377a:	89 d8                	mov    %ebx,%eax
  80377c:	e8 a8 f8 ff ff       	call   803029 <dhcp_select>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  803781:	83 ec 0c             	sub    $0xc,%esp
  803784:	ff 75 10             	pushl  0x10(%ebp)
  803787:	e8 99 10 00 00       	call   804825 <pbuf_free>
  dhcp->p = NULL;
  80378c:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
}
  803793:	eb 16                	jmp    8037ab <dhcp_recv+0x403>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  803795:	ba 35 00 00 00       	mov    $0x35,%edx
  80379a:	89 f0                	mov    %esi,%eax
  80379c:	e8 56 f0 ff ff       	call   8027f7 <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  8037a1:	85 c0                	test   %eax,%eax
  8037a3:	0f 85 69 fd ff ff    	jne    803512 <dhcp_recv+0x16a>
  8037a9:	eb d6                	jmp    803781 <dhcp_recv+0x3d9>
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  dhcp->p = NULL;
}
  8037ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8037ae:	5b                   	pop    %ebx
  8037af:	5e                   	pop    %esi
  8037b0:	5f                   	pop    %edi
  8037b1:	5d                   	pop    %ebp
  8037b2:	c3                   	ret    

008037b3 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  8037b3:	55                   	push   %ebp
  8037b4:	89 e5                	mov    %esp,%ebp
  8037b6:	57                   	push   %edi
  8037b7:	56                   	push   %esi
  8037b8:	53                   	push   %ebx
  8037b9:	83 ec 18             	sub    $0x18,%esp
  8037bc:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  8037bf:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  8037c2:	6a 58                	push   $0x58
  8037c4:	e8 6c 0a 00 00       	call   804235 <mem_malloc>
  if (dhcp == NULL) {
  8037c9:	83 c4 10             	add    $0x10,%esp
  8037cc:	85 c0                	test   %eax,%eax
  8037ce:	0f 84 1d 01 00 00    	je     8038f1 <dhcp_inform+0x13e>
  8037d4:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  8037d6:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  8037d9:	83 ec 04             	sub    $0x4,%esp
  8037dc:	6a 58                	push   $0x58
  8037de:	6a 00                	push   $0x0
  8037e0:	50                   	push   %eax
  8037e1:	e8 0b b4 00 00       	call   80ebf1 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  8037e6:	e8 83 57 00 00       	call   808f6e <udp_new>
  8037eb:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  8037ee:	83 c4 10             	add    $0x10,%esp
  8037f1:	85 c0                	test   %eax,%eax
  8037f3:	75 11                	jne    803806 <dhcp_inform+0x53>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  8037f5:	83 ec 0c             	sub    $0xc,%esp
  8037f8:	53                   	push   %ebx
  8037f9:	e8 85 07 00 00       	call   803f83 <mem_free>
    return;
  8037fe:	83 c4 10             	add    $0x10,%esp
  803801:	e9 eb 00 00 00       	jmp    8038f1 <dhcp_inform+0x13e>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803806:	89 f0                	mov    %esi,%eax
  803808:	e8 77 f3 ff ff       	call   802b84 <dhcp_create_request>
  if (result == ERR_OK) {
  80380d:	84 c0                	test   %al,%al
  80380f:	0f 85 d3 00 00 00    	jne    8038e8 <dhcp_inform+0x135>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803815:	b9 01 00 00 00       	mov    $0x1,%ecx
  80381a:	ba 35 00 00 00       	mov    $0x35,%edx
  80381f:	89 d8                	mov    %ebx,%eax
  803821:	e8 43 f1 ff ff       	call   802969 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803826:	ba 08 00 00 00       	mov    $0x8,%edx
  80382b:	89 d8                	mov    %ebx,%eax
  80382d:	e8 f6 f0 ff ff       	call   802928 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803832:	b9 02 00 00 00       	mov    $0x2,%ecx
  803837:	ba 39 00 00 00       	mov    $0x39,%edx
  80383c:	89 d8                	mov    %ebx,%eax
  80383e:	e8 26 f1 ff ff       	call   802969 <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  803843:	ba 40 02 00 00       	mov    $0x240,%edx
  803848:	89 d8                	mov    %ebx,%eax
  80384a:	e8 81 f1 ff ff       	call   8029d0 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  80384f:	89 d8                	mov    %ebx,%eax
  803851:	e8 de f1 ff ff       	call   802a34 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803856:	83 ec 08             	sub    $0x8,%esp
  803859:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80385d:	66 05 f0 00          	add    $0xf0,%ax
  803861:	0f b7 c0             	movzwl %ax,%eax
  803864:	50                   	push   %eax
  803865:	ff 73 1c             	pushl  0x1c(%ebx)
  803868:	e8 01 13 00 00       	call   804b6e <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80386d:	83 c4 0c             	add    $0xc,%esp
  803870:	6a 44                	push   $0x44
  803872:	68 a4 1c 81 00       	push   $0x811ca4
  803877:	ff 73 08             	pushl  0x8(%ebx)
  80387a:	e8 69 53 00 00       	call   808be8 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  80387f:	83 c4 0c             	add    $0xc,%esp
  803882:	6a 43                	push   $0x43
  803884:	68 a0 1c 81 00       	push   $0x811ca0
  803889:	ff 73 08             	pushl  0x8(%ebx)
  80388c:	e8 f9 55 00 00       	call   808e8a <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803891:	89 34 24             	mov    %esi,(%esp)
  803894:	6a 43                	push   $0x43
  803896:	68 a0 1c 81 00       	push   $0x811ca0
  80389b:	ff 73 1c             	pushl  0x1c(%ebx)
  80389e:	ff 73 08             	pushl  0x8(%ebx)
  8038a1:	e8 fe 53 00 00       	call   808ca4 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8038a6:	83 c4 1c             	add    $0x1c,%esp
  8038a9:	6a 43                	push   $0x43
  8038ab:	68 a4 1c 81 00       	push   $0x811ca4
  8038b0:	ff 73 08             	pushl  0x8(%ebx)
  8038b3:	e8 d2 55 00 00       	call   808e8a <udp_connect>
    dhcp_delete_request(netif);
  8038b8:	89 f0                	mov    %esi,%eax
  8038ba:	e8 a6 f4 ff ff       	call   802d65 <dhcp_delete_request>
  8038bf:	83 c4 10             	add    $0x10,%esp
  8038c2:	eb 24                	jmp    8038e8 <dhcp_inform+0x135>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
      udp_remove(dhcp->pcb);
  8038c4:	83 ec 0c             	sub    $0xc,%esp
  8038c7:	50                   	push   %eax
  8038c8:	e8 5d 56 00 00       	call   808f2a <udp_remove>
  8038cd:	83 c4 10             	add    $0x10,%esp
    }
    dhcp->pcb = NULL;
  8038d0:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  8038d7:	83 ec 0c             	sub    $0xc,%esp
  8038da:	53                   	push   %ebx
  8038db:	e8 a3 06 00 00       	call   803f83 <mem_free>
    netif->dhcp = old_dhcp;
  8038e0:	89 7e 20             	mov    %edi,0x20(%esi)
  8038e3:	83 c4 10             	add    $0x10,%esp
  8038e6:	eb 09                	jmp    8038f1 <dhcp_inform+0x13e>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  8038e8:	8b 43 08             	mov    0x8(%ebx),%eax
  8038eb:	85 c0                	test   %eax,%eax
  8038ed:	75 d5                	jne    8038c4 <dhcp_inform+0x111>
  8038ef:	eb df                	jmp    8038d0 <dhcp_inform+0x11d>
    }
    dhcp->pcb = NULL;
    mem_free((void *)dhcp);
    netif->dhcp = old_dhcp;
  }
}
  8038f1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8038f4:	5b                   	pop    %ebx
  8038f5:	5e                   	pop    %esi
  8038f6:	5f                   	pop    %edi
  8038f7:	5d                   	pop    %ebp
  8038f8:	c3                   	ret    

008038f9 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  8038f9:	55                   	push   %ebp
  8038fa:	89 e5                	mov    %esp,%ebp
  8038fc:	56                   	push   %esi
  8038fd:	53                   	push   %ebx
  8038fe:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803901:	85 f6                	test   %esi,%esi
  803903:	75 17                	jne    80391c <dhcp_arp_reply+0x23>
  803905:	83 ec 04             	sub    $0x4,%esp
  803908:	68 02 14 81 00       	push   $0x811402
  80390d:	68 b5 02 00 00       	push   $0x2b5
  803912:	68 e2 13 81 00       	push   $0x8113e2
  803917:	e8 32 ab 00 00       	call   80e44e <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  80391c:	8b 5e 20             	mov    0x20(%esi),%ebx
  80391f:	85 db                	test   %ebx,%ebx
  803921:	0f 84 ea 00 00 00    	je     803a11 <dhcp_arp_reply+0x118>
  803927:	80 3b 08             	cmpb   $0x8,(%ebx)
  80392a:	0f 85 e1 00 00 00    	jne    803a11 <dhcp_arp_reply+0x118>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  803930:	8b 45 0c             	mov    0xc(%ebp),%eax
  803933:	8b 4b 30             	mov    0x30(%ebx),%ecx
  803936:	39 08                	cmp    %ecx,(%eax)
  803938:	0f 85 d3 00 00 00    	jne    803a11 <dhcp_arp_reply+0x118>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  80393e:	ba 0c 00 00 00       	mov    $0xc,%edx
  803943:	89 d8                	mov    %ebx,%eax
  803945:	e8 9e ee ff ff       	call   8027e8 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80394a:	89 f0                	mov    %esi,%eax
  80394c:	e8 33 f2 ff ff       	call   802b84 <dhcp_create_request>
  if (result == ERR_OK) {
  803951:	84 c0                	test   %al,%al
  803953:	0f 85 ae 00 00 00    	jne    803a07 <dhcp_arp_reply+0x10e>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803959:	b9 01 00 00 00       	mov    $0x1,%ecx
  80395e:	ba 35 00 00 00       	mov    $0x35,%edx
  803963:	89 d8                	mov    %ebx,%eax
  803965:	e8 ff ef ff ff       	call   802969 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  80396a:	ba 04 00 00 00       	mov    $0x4,%edx
  80396f:	89 d8                	mov    %ebx,%eax
  803971:	e8 b2 ef ff ff       	call   802928 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803976:	b9 02 00 00 00       	mov    $0x2,%ecx
  80397b:	ba 39 00 00 00       	mov    $0x39,%edx
  803980:	89 d8                	mov    %ebx,%eax
  803982:	e8 e2 ef ff ff       	call   802969 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803987:	ba 40 02 00 00       	mov    $0x240,%edx
  80398c:	89 d8                	mov    %ebx,%eax
  80398e:	e8 3d f0 ff ff       	call   8029d0 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803993:	b9 04 00 00 00       	mov    $0x4,%ecx
  803998:	ba 32 00 00 00       	mov    $0x32,%edx
  80399d:	89 d8                	mov    %ebx,%eax
  80399f:	e8 c5 ef ff ff       	call   802969 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8039a4:	83 ec 0c             	sub    $0xc,%esp
  8039a7:	ff 73 30             	pushl  0x30(%ebx)
  8039aa:	e8 62 3f 00 00       	call   807911 <ntohl>
  8039af:	89 c2                	mov    %eax,%edx
  8039b1:	89 d8                	mov    %ebx,%eax
  8039b3:	e8 31 f1 ff ff       	call   802ae9 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  8039b8:	89 d8                	mov    %ebx,%eax
  8039ba:	e8 75 f0 ff ff       	call   802a34 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8039bf:	83 c4 08             	add    $0x8,%esp
  8039c2:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8039c6:	66 05 f0 00          	add    $0xf0,%ax
  8039ca:	0f b7 c0             	movzwl %ax,%eax
  8039cd:	50                   	push   %eax
  8039ce:	ff 73 1c             	pushl  0x1c(%ebx)
  8039d1:	e8 98 11 00 00       	call   804b6e <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8039d6:	83 c4 0c             	add    $0xc,%esp
  8039d9:	6a 43                	push   $0x43
  8039db:	68 a4 1c 81 00       	push   $0x811ca4
  8039e0:	ff 73 08             	pushl  0x8(%ebx)
  8039e3:	e8 a2 54 00 00       	call   808e8a <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8039e8:	89 34 24             	mov    %esi,(%esp)
  8039eb:	6a 43                	push   $0x43
  8039ed:	68 a0 1c 81 00       	push   $0x811ca0
  8039f2:	ff 73 1c             	pushl  0x1c(%ebx)
  8039f5:	ff 73 08             	pushl  0x8(%ebx)
  8039f8:	e8 a7 52 00 00       	call   808ca4 <udp_sendto_if>
    dhcp_delete_request(netif);
  8039fd:	83 c4 20             	add    $0x20,%esp
  803a00:	89 f0                	mov    %esi,%eax
  803a02:	e8 5e f3 ff ff       	call   802d65 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803a07:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803a0b:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  803a11:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803a14:	5b                   	pop    %ebx
  803a15:	5e                   	pop    %esi
  803a16:	5d                   	pop    %ebp
  803a17:	c3                   	ret    

00803a18 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  803a18:	55                   	push   %ebp
  803a19:	89 e5                	mov    %esp,%ebp
  803a1b:	57                   	push   %edi
  803a1c:	56                   	push   %esi
  803a1d:	53                   	push   %ebx
  803a1e:	83 ec 1c             	sub    $0x1c,%esp
  803a21:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  803a24:	8b 5f 20             	mov    0x20(%edi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803a27:	ba 05 00 00 00       	mov    $0x5,%edx
  803a2c:	89 d8                	mov    %ebx,%eax
  803a2e:	e8 b5 ed ff ff       	call   8027e8 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803a33:	89 f8                	mov    %edi,%eax
  803a35:	e8 4a f1 ff ff       	call   802b84 <dhcp_create_request>
  803a3a:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803a3c:	84 c0                	test   %al,%al
  803a3e:	0f 85 89 00 00 00    	jne    803acd <dhcp_renew+0xb5>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803a44:	b9 01 00 00 00       	mov    $0x1,%ecx
  803a49:	ba 35 00 00 00       	mov    $0x35,%edx
  803a4e:	89 d8                	mov    %ebx,%eax
  803a50:	e8 14 ef ff ff       	call   802969 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803a55:	ba 03 00 00 00       	mov    $0x3,%edx
  803a5a:	89 d8                	mov    %ebx,%eax
  803a5c:	e8 c7 ee ff ff       	call   802928 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803a61:	b9 02 00 00 00       	mov    $0x2,%ecx
  803a66:	ba 39 00 00 00       	mov    $0x39,%edx
  803a6b:	89 d8                	mov    %ebx,%eax
  803a6d:	e8 f7 ee ff ff       	call   802969 <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  803a72:	ba 40 02 00 00       	mov    $0x240,%edx
  803a77:	89 d8                	mov    %ebx,%eax
  803a79:	e8 52 ef ff ff       	call   8029d0 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  803a7e:	89 d8                	mov    %ebx,%eax
  803a80:	e8 af ef ff ff       	call   802a34 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803a85:	83 ec 08             	sub    $0x8,%esp
  803a88:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803a8c:	66 05 f0 00          	add    $0xf0,%ax
  803a90:	0f b7 c0             	movzwl %ax,%eax
  803a93:	50                   	push   %eax
  803a94:	ff 73 1c             	pushl  0x1c(%ebx)
  803a97:	e8 d2 10 00 00       	call   804b6e <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803a9c:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803a9f:	83 c4 0c             	add    $0xc,%esp
  803aa2:	6a 43                	push   $0x43
  803aa4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803aa7:	50                   	push   %eax
  803aa8:	ff 73 08             	pushl  0x8(%ebx)
  803aab:	e8 da 53 00 00       	call   808e8a <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803ab0:	89 3c 24             	mov    %edi,(%esp)
  803ab3:	6a 43                	push   $0x43
  803ab5:	ff 75 e4             	pushl  -0x1c(%ebp)
  803ab8:	ff 73 1c             	pushl  0x1c(%ebx)
  803abb:	ff 73 08             	pushl  0x8(%ebx)
  803abe:	e8 e1 51 00 00       	call   808ca4 <udp_sendto_if>
    dhcp_delete_request(netif);
  803ac3:	83 c4 20             	add    $0x20,%esp
  803ac6:	89 f8                	mov    %edi,%eax
  803ac8:	e8 98 f2 ff ff       	call   802d65 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803acd:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803ad1:	83 c0 01             	add    $0x1,%eax
  803ad4:	88 43 01             	mov    %al,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803ad7:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  803adc:	3c 09                	cmp    $0x9,%al
  803ade:	77 08                	ja     803ae8 <dhcp_renew+0xd0>
  803ae0:	0f b6 c0             	movzbl %al,%eax
  803ae3:	66 69 d0 d0 07       	imul   $0x7d0,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803ae8:	0f b7 c2             	movzwl %dx,%eax
  803aeb:	05 f3 01 00 00       	add    $0x1f3,%eax
  803af0:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  803af5:	f7 ea                	imul   %edx
  803af7:	c1 fa 05             	sar    $0x5,%edx
  803afa:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803afe:	89 f0                	mov    %esi,%eax
  803b00:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803b03:	5b                   	pop    %ebx
  803b04:	5e                   	pop    %esi
  803b05:	5f                   	pop    %edi
  803b06:	5d                   	pop    %ebp
  803b07:	c3                   	ret    

00803b08 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  803b08:	55                   	push   %ebp
  803b09:	89 e5                	mov    %esp,%ebp
  803b0b:	53                   	push   %ebx
  803b0c:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803b0f:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  803b15:	eb 6b                	jmp    803b82 <dhcp_coarse_tmr+0x7a>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  803b17:	8b 43 20             	mov    0x20(%ebx),%eax
  803b1a:	85 c0                	test   %eax,%eax
  803b1c:	74 62                	je     803b80 <dhcp_coarse_tmr+0x78>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  803b1e:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803b22:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803b25:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803b29:	66 83 fa 01          	cmp    $0x1,%dx
  803b2d:	75 1d                	jne    803b4c <dhcp_coarse_tmr+0x44>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803b2f:	8b 43 20             	mov    0x20(%ebx),%eax
  803b32:	0f b6 00             	movzbl (%eax),%eax
  803b35:	89 c2                	mov    %eax,%edx
  803b37:	83 e2 fb             	and    $0xfffffffb,%edx
  803b3a:	80 fa 01             	cmp    $0x1,%dl
  803b3d:	74 04                	je     803b43 <dhcp_coarse_tmr+0x3b>
  803b3f:	3c 0a                	cmp    $0xa,%al
  803b41:	75 3d                	jne    803b80 <dhcp_coarse_tmr+0x78>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  803b43:	89 d8                	mov    %ebx,%eax
  803b45:	e8 b5 f2 ff ff       	call   802dff <dhcp_rebind>
  803b4a:	eb 34                	jmp    803b80 <dhcp_coarse_tmr+0x78>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803b4c:	8b 53 20             	mov    0x20(%ebx),%edx
  803b4f:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803b53:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803b56:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803b5a:	66 83 f8 01          	cmp    $0x1,%ax
  803b5e:	75 20                	jne    803b80 <dhcp_coarse_tmr+0x78>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803b60:	8b 43 20             	mov    0x20(%ebx),%eax
  803b63:	0f b6 00             	movzbl (%eax),%eax
  803b66:	89 c2                	mov    %eax,%edx
  803b68:	83 e2 fb             	and    $0xfffffffb,%edx
  803b6b:	80 fa 01             	cmp    $0x1,%dl
  803b6e:	74 04                	je     803b74 <dhcp_coarse_tmr+0x6c>
  803b70:	3c 0a                	cmp    $0xa,%al
  803b72:	75 0c                	jne    803b80 <dhcp_coarse_tmr+0x78>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  803b74:	83 ec 0c             	sub    $0xc,%esp
  803b77:	53                   	push   %ebx
  803b78:	e8 9b fe ff ff       	call   803a18 <dhcp_renew>
  803b7d:	83 c4 10             	add    $0x10,%esp
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  803b80:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  803b82:	85 db                	test   %ebx,%ebx
  803b84:	75 91                	jne    803b17 <dhcp_coarse_tmr+0xf>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  803b86:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803b89:	c9                   	leave  
  803b8a:	c3                   	ret    

00803b8b <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  803b8b:	55                   	push   %ebp
  803b8c:	89 e5                	mov    %esp,%ebp
  803b8e:	57                   	push   %edi
  803b8f:	56                   	push   %esi
  803b90:	53                   	push   %ebx
  803b91:	83 ec 1c             	sub    $0x1c,%esp
  803b94:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803b97:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  803b9a:	ba 0d 00 00 00       	mov    $0xd,%edx
  803b9f:	89 d8                	mov    %ebx,%eax
  803ba1:	e8 42 ec ff ff       	call   8027e8 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  803ba6:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803bad:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803bb4:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803bbb:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803bc2:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803bc9:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803bd0:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803bd7:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803bde:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803be5:	89 f0                	mov    %esi,%eax
  803be7:	e8 98 ef ff ff       	call   802b84 <dhcp_create_request>
  803bec:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803bee:	84 c0                	test   %al,%al
  803bf0:	75 6c                	jne    803c5e <dhcp_release+0xd3>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803bf2:	b9 01 00 00 00       	mov    $0x1,%ecx
  803bf7:	ba 35 00 00 00       	mov    $0x35,%edx
  803bfc:	89 d8                	mov    %ebx,%eax
  803bfe:	e8 66 ed ff ff       	call   802969 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803c03:	ba 07 00 00 00       	mov    $0x7,%edx
  803c08:	89 d8                	mov    %ebx,%eax
  803c0a:	e8 19 ed ff ff       	call   802928 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  803c0f:	89 d8                	mov    %ebx,%eax
  803c11:	e8 1e ee ff ff       	call   802a34 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803c16:	83 ec 08             	sub    $0x8,%esp
  803c19:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803c1d:	66 05 f0 00          	add    $0xf0,%ax
  803c21:	0f b7 c0             	movzwl %ax,%eax
  803c24:	50                   	push   %eax
  803c25:	ff 73 1c             	pushl  0x1c(%ebx)
  803c28:	e8 41 0f 00 00       	call   804b6e <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803c2d:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803c30:	83 c4 0c             	add    $0xc,%esp
  803c33:	6a 43                	push   $0x43
  803c35:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803c38:	50                   	push   %eax
  803c39:	ff 73 08             	pushl  0x8(%ebx)
  803c3c:	e8 49 52 00 00       	call   808e8a <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803c41:	89 34 24             	mov    %esi,(%esp)
  803c44:	6a 43                	push   $0x43
  803c46:	ff 75 e4             	pushl  -0x1c(%ebp)
  803c49:	ff 73 1c             	pushl  0x1c(%ebx)
  803c4c:	ff 73 08             	pushl  0x8(%ebx)
  803c4f:	e8 50 50 00 00       	call   808ca4 <udp_sendto_if>
    dhcp_delete_request(netif);
  803c54:	83 c4 20             	add    $0x20,%esp
  803c57:	89 f0                	mov    %esi,%eax
  803c59:	e8 07 f1 ff ff       	call   802d65 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803c5e:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803c62:	83 c0 01             	add    $0x1,%eax
  803c65:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803c68:	ba 10 27 00 00       	mov    $0x2710,%edx
  803c6d:	3c 09                	cmp    $0x9,%al
  803c6f:	77 08                	ja     803c79 <dhcp_release+0xee>
  803c71:	0f b6 c0             	movzbl %al,%eax
  803c74:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803c79:	0f b7 c2             	movzwl %dx,%eax
  803c7c:	05 f3 01 00 00       	add    $0x1f3,%eax
  803c81:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  803c86:	f7 ea                	imul   %edx
  803c88:	c1 fa 05             	sar    $0x5,%edx
  803c8b:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  803c8f:	83 ec 0c             	sub    $0xc,%esp
  803c92:	56                   	push   %esi
  803c93:	e8 96 0a 00 00       	call   80472e <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803c98:	83 c4 08             	add    $0x8,%esp
  803c9b:	68 a4 1c 81 00       	push   $0x811ca4
  803ca0:	56                   	push   %esi
  803ca1:	e8 cc 08 00 00       	call   804572 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803ca6:	83 c4 08             	add    $0x8,%esp
  803ca9:	68 a4 1c 81 00       	push   $0x811ca4
  803cae:	56                   	push   %esi
  803caf:	e8 06 0a 00 00       	call   8046ba <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803cb4:	83 c4 08             	add    $0x8,%esp
  803cb7:	68 a4 1c 81 00       	push   $0x811ca4
  803cbc:	56                   	push   %esi
  803cbd:	e8 13 0a 00 00       	call   8046d5 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  803cc2:	89 f8                	mov    %edi,%eax
  803cc4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803cc7:	5b                   	pop    %ebx
  803cc8:	5e                   	pop    %esi
  803cc9:	5f                   	pop    %edi
  803cca:	5d                   	pop    %ebp
  803ccb:	c3                   	ret    

00803ccc <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  803ccc:	55                   	push   %ebp
  803ccd:	89 e5                	mov    %esp,%ebp
  803ccf:	53                   	push   %ebx
  803cd0:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803cd3:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  803cd9:	e9 c6 00 00 00       	jmp    803da4 <dhcp_fine_tmr+0xd8>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  803cde:	8b 53 20             	mov    0x20(%ebx),%edx
  803ce1:	85 d2                	test   %edx,%edx
  803ce3:	0f 84 b9 00 00 00    	je     803da2 <dhcp_fine_tmr+0xd6>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  803ce9:	0f b7 42 26          	movzwl 0x26(%edx),%eax
  803ced:	66 83 f8 01          	cmp    $0x1,%ax
  803cf1:	76 0c                	jbe    803cff <dhcp_fine_tmr+0x33>
        netif->dhcp->request_timeout--;
  803cf3:	83 e8 01             	sub    $0x1,%eax
  803cf6:	66 89 42 26          	mov    %ax,0x26(%edx)
  803cfa:	e9 a3 00 00 00       	jmp    803da2 <dhcp_fine_tmr+0xd6>
      }
      else if (netif->dhcp->request_timeout == 1) {
  803cff:	66 83 f8 01          	cmp    $0x1,%ax
  803d03:	0f 85 99 00 00 00    	jne    803da2 <dhcp_fine_tmr+0xd6>
        netif->dhcp->request_timeout--;
  803d09:	66 c7 42 26 00 00    	movw   $0x0,0x26(%edx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803d0f:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803d12:	0f b6 02             	movzbl (%edx),%eax
  803d15:	3c 0c                	cmp    $0xc,%al
  803d17:	74 04                	je     803d1d <dhcp_fine_tmr+0x51>
  803d19:	3c 06                	cmp    $0x6,%al
  803d1b:	75 09                	jne    803d26 <dhcp_fine_tmr+0x5a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  803d1d:	89 d8                	mov    %ebx,%eax
  803d1f:	e8 ca f1 ff ff       	call   802eee <dhcp_discover>
  803d24:	eb 7c                	jmp    803da2 <dhcp_fine_tmr+0xd6>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  803d26:	3c 01                	cmp    $0x1,%al
  803d28:	75 24                	jne    803d4e <dhcp_fine_tmr+0x82>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  803d2a:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803d2e:	77 09                	ja     803d39 <dhcp_fine_tmr+0x6d>
      dhcp_select(netif);
  803d30:	89 d8                	mov    %ebx,%eax
  803d32:	e8 f2 f2 ff ff       	call   803029 <dhcp_select>
  803d37:	eb 69                	jmp    803da2 <dhcp_fine_tmr+0xd6>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  803d39:	83 ec 0c             	sub    $0xc,%esp
  803d3c:	53                   	push   %ebx
  803d3d:	e8 49 fe ff ff       	call   803b8b <dhcp_release>
      dhcp_discover(netif);
  803d42:	89 d8                	mov    %ebx,%eax
  803d44:	e8 a5 f1 ff ff       	call   802eee <dhcp_discover>
  803d49:	83 c4 10             	add    $0x10,%esp
  803d4c:	eb 54                	jmp    803da2 <dhcp_fine_tmr+0xd6>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  803d4e:	3c 08                	cmp    $0x8,%al
  803d50:	75 18                	jne    803d6a <dhcp_fine_tmr+0x9e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  803d52:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803d56:	77 09                	ja     803d61 <dhcp_fine_tmr+0x95>
      dhcp_check(netif);
  803d58:	89 d8                	mov    %ebx,%eax
  803d5a:	e8 42 f4 ff ff       	call   8031a1 <dhcp_check>
  803d5f:	eb 41                	jmp    803da2 <dhcp_fine_tmr+0xd6>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  803d61:	89 d8                	mov    %ebx,%eax
  803d63:	e8 6d f4 ff ff       	call   8031d5 <dhcp_bind>
  803d68:	eb 38                	jmp    803da2 <dhcp_fine_tmr+0xd6>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  803d6a:	3c 05                	cmp    $0x5,%al
  803d6c:	75 0e                	jne    803d7c <dhcp_fine_tmr+0xb0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  803d6e:	83 ec 0c             	sub    $0xc,%esp
  803d71:	53                   	push   %ebx
  803d72:	e8 a1 fc ff ff       	call   803a18 <dhcp_renew>
  803d77:	83 c4 10             	add    $0x10,%esp
  803d7a:	eb 26                	jmp    803da2 <dhcp_fine_tmr+0xd6>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  803d7c:	3c 04                	cmp    $0x4,%al
  803d7e:	75 22                	jne    803da2 <dhcp_fine_tmr+0xd6>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  803d80:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803d84:	77 09                	ja     803d8f <dhcp_fine_tmr+0xc3>
      dhcp_rebind(netif);
  803d86:	89 d8                	mov    %ebx,%eax
  803d88:	e8 72 f0 ff ff       	call   802dff <dhcp_rebind>
  803d8d:	eb 13                	jmp    803da2 <dhcp_fine_tmr+0xd6>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  803d8f:	83 ec 0c             	sub    $0xc,%esp
  803d92:	53                   	push   %ebx
  803d93:	e8 f3 fd ff ff       	call   803b8b <dhcp_release>
      dhcp_discover(netif);
  803d98:	89 d8                	mov    %ebx,%eax
  803d9a:	e8 4f f1 ff ff       	call   802eee <dhcp_discover>
  803d9f:	83 c4 10             	add    $0x10,%esp
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  803da2:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  803da4:	85 db                	test   %ebx,%ebx
  803da6:	0f 85 32 ff ff ff    	jne    803cde <dhcp_fine_tmr+0x12>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  803dac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803daf:	c9                   	leave  
  803db0:	c3                   	ret    

00803db1 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  803db1:	55                   	push   %ebp
  803db2:	89 e5                	mov    %esp,%ebp
  803db4:	56                   	push   %esi
  803db5:	53                   	push   %ebx
  803db6:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803db9:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  803dbc:	85 f6                	test   %esi,%esi
  803dbe:	75 17                	jne    803dd7 <dhcp_stop+0x26>
  803dc0:	83 ec 04             	sub    $0x4,%esp
  803dc3:	68 54 14 81 00       	push   $0x811454
  803dc8:	68 2c 04 00 00       	push   $0x42c
  803dcd:	68 e2 13 81 00       	push   $0x8113e2
  803dd2:	e8 77 a6 00 00       	call   80e44e <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  803dd7:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  803ddb:	85 db                	test   %ebx,%ebx
  803ddd:	74 4e                	je     803e2d <dhcp_stop+0x7c>
    if (dhcp->pcb != NULL) {
  803ddf:	8b 43 08             	mov    0x8(%ebx),%eax
  803de2:	85 c0                	test   %eax,%eax
  803de4:	74 13                	je     803df9 <dhcp_stop+0x48>
      udp_remove(dhcp->pcb);
  803de6:	83 ec 0c             	sub    $0xc,%esp
  803de9:	50                   	push   %eax
  803dea:	e8 3b 51 00 00       	call   808f2a <udp_remove>
      dhcp->pcb = NULL;
  803def:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  803df6:	83 c4 10             	add    $0x10,%esp
    }
    if (dhcp->p != NULL) {
  803df9:	8b 43 0c             	mov    0xc(%ebx),%eax
  803dfc:	85 c0                	test   %eax,%eax
  803dfe:	74 13                	je     803e13 <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  803e00:	83 ec 0c             	sub    $0xc,%esp
  803e03:	50                   	push   %eax
  803e04:	e8 1c 0a 00 00       	call   804825 <pbuf_free>
      dhcp->p = NULL;
  803e09:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  803e10:	83 c4 10             	add    $0x10,%esp
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  803e13:	89 d8                	mov    %ebx,%eax
  803e15:	e8 46 f5 ff ff       	call   803360 <dhcp_free_reply>
    mem_free((void *)dhcp);
  803e1a:	83 ec 0c             	sub    $0xc,%esp
  803e1d:	53                   	push   %ebx
  803e1e:	e8 60 01 00 00       	call   803f83 <mem_free>
    netif->dhcp = NULL;
  803e23:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803e2a:	83 c4 10             	add    $0x10,%esp
  }
}
  803e2d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803e30:	5b                   	pop    %ebx
  803e31:	5e                   	pop    %esi
  803e32:	5d                   	pop    %ebp
  803e33:	c3                   	ret    

00803e34 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  803e34:	55                   	push   %ebp
  803e35:	89 e5                	mov    %esp,%ebp
  803e37:	56                   	push   %esi
  803e38:	53                   	push   %ebx
  803e39:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803e3c:	85 db                	test   %ebx,%ebx
  803e3e:	75 17                	jne    803e57 <dhcp_start+0x23>
  803e40:	83 ec 04             	sub    $0x4,%esp
  803e43:	68 02 14 81 00       	push   $0x811402
  803e48:	68 38 02 00 00       	push   $0x238
  803e4d:	68 e2 13 81 00       	push   $0x8113e2
  803e52:	e8 f7 a5 00 00       	call   80e44e <_panic>
  dhcp = netif->dhcp;
  803e57:	8b 73 20             	mov    0x20(%ebx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  803e5a:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  803e5e:	85 f6                	test   %esi,%esi
  803e60:	75 1a                	jne    803e7c <dhcp_start+0x48>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  803e62:	83 ec 0c             	sub    $0xc,%esp
  803e65:	6a 58                	push   $0x58
  803e67:	e8 c9 03 00 00       	call   804235 <mem_malloc>
  803e6c:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  803e6e:	83 c4 10             	add    $0x10,%esp
  803e71:	85 c0                	test   %eax,%eax
  803e73:	0f 84 98 00 00 00    	je     803f11 <dhcp_start+0xdd>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  803e79:	89 43 20             	mov    %eax,0x20(%ebx)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  803e7c:	83 ec 04             	sub    $0x4,%esp
  803e7f:	6a 58                	push   $0x58
  803e81:	6a 00                	push   $0x0
  803e83:	56                   	push   %esi
  803e84:	e8 68 ad 00 00       	call   80ebf1 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  803e89:	e8 e0 50 00 00       	call   808f6e <udp_new>
  803e8e:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803e91:	83 c4 10             	add    $0x10,%esp
  803e94:	85 c0                	test   %eax,%eax
  803e96:	75 1a                	jne    803eb2 <dhcp_start+0x7e>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  803e98:	83 ec 0c             	sub    $0xc,%esp
  803e9b:	56                   	push   %esi
  803e9c:	e8 e2 00 00 00       	call   803f83 <mem_free>
    netif->dhcp = dhcp = NULL;
  803ea1:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  803ea8:	83 c4 10             	add    $0x10,%esp
  803eab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803eb0:	eb 64                	jmp    803f16 <dhcp_start+0xe2>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803eb2:	83 ec 04             	sub    $0x4,%esp
  803eb5:	6a 44                	push   $0x44
  803eb7:	68 a4 1c 81 00       	push   $0x811ca4
  803ebc:	50                   	push   %eax
  803ebd:	e8 26 4d 00 00       	call   808be8 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803ec2:	83 c4 0c             	add    $0xc,%esp
  803ec5:	6a 43                	push   $0x43
  803ec7:	68 a4 1c 81 00       	push   $0x811ca4
  803ecc:	ff 76 08             	pushl  0x8(%esi)
  803ecf:	e8 b6 4f 00 00       	call   808e8a <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803ed4:	83 c4 0c             	add    $0xc,%esp
  803ed7:	53                   	push   %ebx
  803ed8:	68 a8 33 80 00       	push   $0x8033a8
  803edd:	ff 76 08             	pushl  0x8(%esi)
  803ee0:	e8 31 50 00 00       	call   808f16 <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  803ee5:	89 d8                	mov    %ebx,%eax
  803ee7:	e8 02 f0 ff ff       	call   802eee <dhcp_discover>
  if (result != ERR_OK) {
  803eec:	83 c4 10             	add    $0x10,%esp
  803eef:	84 c0                	test   %al,%al
  803ef1:	74 13                	je     803f06 <dhcp_start+0xd2>
    /* free resources allocated above */
    dhcp_stop(netif);
  803ef3:	83 ec 0c             	sub    $0xc,%esp
  803ef6:	53                   	push   %ebx
  803ef7:	e8 b5 fe ff ff       	call   803db1 <dhcp_stop>
    return ERR_MEM;
  803efc:	83 c4 10             	add    $0x10,%esp
  803eff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803f04:	eb 10                	jmp    803f16 <dhcp_start+0xe2>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  803f06:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
  return result;
  803f0a:	b8 00 00 00 00       	mov    $0x0,%eax
  803f0f:	eb 05                	jmp    803f16 <dhcp_start+0xe2>
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
    if (dhcp == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  803f11:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  return result;
}
  803f16:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803f19:	5b                   	pop    %ebx
  803f1a:	5e                   	pop    %esi
  803f1b:	5d                   	pop    %ebp
  803f1c:	c3                   	ret    

00803f1d <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  803f1d:	55                   	push   %ebp
  803f1e:	89 e5                	mov    %esp,%ebp
  803f20:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  803f23:	b8 23 53 81 00       	mov    $0x815323,%eax
  803f28:	83 e0 fc             	and    $0xfffffffc,%eax
  803f2b:	a3 0c 53 81 00       	mov    %eax,0x81530c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  803f30:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  803f36:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  803f3d:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  803f41:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  803f47:	89 15 08 53 81 00    	mov    %edx,0x815308
  ram_end->used = 1;
  803f4d:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  803f54:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  803f5b:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  803f5e:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  803f65:	00 22 00 

  mem_sem = sys_sem_new(1);
  803f68:	6a 01                	push   $0x1
  803f6a:	e8 bd 5d 00 00       	call   809d2c <sys_sem_new>
  803f6f:	a3 00 53 81 00       	mov    %eax,0x815300

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  803f74:	a1 0c 53 81 00       	mov    0x81530c,%eax
  803f79:	a3 04 53 81 00       	mov    %eax,0x815304

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  803f7e:	83 c4 10             	add    $0x10,%esp
  803f81:	c9                   	leave  
  803f82:	c3                   	ret    

00803f83 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  803f83:	55                   	push   %ebp
  803f84:	89 e5                	mov    %esp,%ebp
  803f86:	56                   	push   %esi
  803f87:	53                   	push   %ebx
  803f88:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  803f8b:	85 db                	test   %ebx,%ebx
  803f8d:	0f 84 52 01 00 00    	je     8040e5 <mem_free+0x162>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  803f93:	f6 c3 03             	test   $0x3,%bl
  803f96:	74 17                	je     803faf <mem_free+0x2c>
  803f98:	83 ec 04             	sub    $0x4,%esp
  803f9b:	68 70 14 81 00       	push   $0x811470
  803fa0:	68 30 01 00 00       	push   $0x130
  803fa5:	68 67 15 81 00       	push   $0x811567
  803faa:	e8 9f a4 00 00       	call   80e44e <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  803faf:	3b 1d 0c 53 81 00    	cmp    0x81530c,%ebx
  803fb5:	72 08                	jb     803fbf <mem_free+0x3c>
  803fb7:	3b 1d 08 53 81 00    	cmp    0x815308,%ebx
  803fbd:	72 17                	jb     803fd6 <mem_free+0x53>
  803fbf:	83 ec 04             	sub    $0x4,%esp
  803fc2:	68 7b 15 81 00       	push   $0x81157b
  803fc7:	68 33 01 00 00       	push   $0x133
  803fcc:	68 67 15 81 00       	push   $0x811567
  803fd1:	e8 78 a4 00 00       	call   80e44e <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  803fd6:	83 ec 08             	sub    $0x8,%esp
  803fd9:	6a 00                	push   $0x0
  803fdb:	ff 35 00 53 81 00    	pushl  0x815300
  803fe1:	e8 60 60 00 00       	call   80a046 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  803fe6:	83 c4 10             	add    $0x10,%esp
  803fe9:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  803fed:	75 17                	jne    804006 <mem_free+0x83>
  803fef:	83 ec 04             	sub    $0x4,%esp
  803ff2:	68 92 15 81 00       	push   $0x811592
  803ff7:	68 43 01 00 00       	push   $0x143
  803ffc:	68 67 15 81 00       	push   $0x811567
  804001:	e8 48 a4 00 00       	call   80e44e <_panic>
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  804006:	8d 53 f4             	lea    -0xc(%ebx),%edx
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
  804009:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  80400d:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  804013:	73 06                	jae    80401b <mem_free+0x98>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  804015:	89 15 04 53 81 00    	mov    %edx,0x815304
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80401b:	8b 0d 0c 53 81 00    	mov    0x81530c,%ecx
  804021:	39 ca                	cmp    %ecx,%edx
  804023:	73 17                	jae    80403c <mem_free+0xb9>
  804025:	83 ec 04             	sub    $0x4,%esp
  804028:	68 a6 15 81 00       	push   $0x8115a6
  80402d:	68 e3 00 00 00       	push   $0xe3
  804032:	68 67 15 81 00       	push   $0x811567
  804037:	e8 12 a4 00 00       	call   80e44e <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80403c:	8b 35 08 53 81 00    	mov    0x815308,%esi
  804042:	39 f2                	cmp    %esi,%edx
  804044:	72 17                	jb     80405d <mem_free+0xda>
  804046:	83 ec 04             	sub    $0x4,%esp
  804049:	68 bd 15 81 00       	push   $0x8115bd
  80404e:	68 e4 00 00 00       	push   $0xe4
  804053:	68 67 15 81 00       	push   $0x811567
  804058:	e8 f1 a3 00 00       	call   80e44e <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80405d:	8b 43 f4             	mov    -0xc(%ebx),%eax
  804060:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804065:	76 17                	jbe    80407e <mem_free+0xfb>
  804067:	83 ec 04             	sub    $0x4,%esp
  80406a:	68 94 14 81 00       	push   $0x811494
  80406f:	68 e8 00 00 00       	push   $0xe8
  804074:	68 67 15 81 00       	push   $0x811567
  804079:	e8 d0 a3 00 00       	call   80e44e <_panic>

  nmem = (struct mem *)&ram[mem->next];
  80407e:	01 c8                	add    %ecx,%eax
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  804080:	39 c2                	cmp    %eax,%edx
  804082:	74 27                	je     8040ab <mem_free+0x128>
  804084:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  804088:	75 21                	jne    8040ab <mem_free+0x128>
  80408a:	39 c6                	cmp    %eax,%esi
  80408c:	74 1d                	je     8040ab <mem_free+0x128>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  80408e:	3b 05 04 53 81 00    	cmp    0x815304,%eax
  804094:	75 06                	jne    80409c <mem_free+0x119>
      lfree = mem;
  804096:	89 15 04 53 81 00    	mov    %edx,0x815304
    }
    mem->next = nmem->next;
  80409c:	8b 30                	mov    (%eax),%esi
  80409e:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  8040a1:	8b 00                	mov    (%eax),%eax
  8040a3:	89 d6                	mov    %edx,%esi
  8040a5:	29 ce                	sub    %ecx,%esi
  8040a7:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  8040ab:	8b 73 f8             	mov    -0x8(%ebx),%esi
  8040ae:	8d 04 31             	lea    (%ecx,%esi,1),%eax
  if (pmem != mem && pmem->used == 0) {
  8040b1:	39 c2                	cmp    %eax,%edx
  8040b3:	74 1f                	je     8040d4 <mem_free+0x151>
  8040b5:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  8040b9:	75 19                	jne    8040d4 <mem_free+0x151>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  8040bb:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  8040c1:	75 05                	jne    8040c8 <mem_free+0x145>
      lfree = pmem;
  8040c3:	a3 04 53 81 00       	mov    %eax,0x815304
    }
    pmem->next = mem->next;
  8040c8:	8b 53 f4             	mov    -0xc(%ebx),%edx
  8040cb:	89 10                	mov    %edx,(%eax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8040cd:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8040d0:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8040d4:	83 ec 0c             	sub    $0xc,%esp
  8040d7:	ff 35 00 53 81 00    	pushl  0x815300
  8040dd:	e8 f6 5e 00 00       	call   809fd8 <sys_sem_signal>
  8040e2:	83 c4 10             	add    $0x10,%esp
}
  8040e5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8040e8:	5b                   	pop    %ebx
  8040e9:	5e                   	pop    %esi
  8040ea:	5d                   	pop    %ebp
  8040eb:	c3                   	ret    

008040ec <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  8040ec:	55                   	push   %ebp
  8040ed:	89 e5                	mov    %esp,%ebp
  8040ef:	57                   	push   %edi
  8040f0:	56                   	push   %esi
  8040f1:	53                   	push   %ebx
  8040f2:	83 ec 1c             	sub    $0x1c,%esp
  8040f5:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  8040f8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8040fb:	8d 58 03             	lea    0x3(%eax),%ebx
  8040fe:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  804101:	83 fb 0b             	cmp    $0xb,%ebx
  804104:	76 0d                	jbe    804113 <mem_realloc+0x27>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  804106:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  80410c:	76 0a                	jbe    804118 <mem_realloc+0x2c>
  80410e:	e9 15 01 00 00       	jmp    804228 <mem_realloc+0x13c>
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  804113:	bb 0c 00 00 00       	mov    $0xc,%ebx

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804118:	a1 0c 53 81 00       	mov    0x81530c,%eax
  80411d:	39 f0                	cmp    %esi,%eax
  80411f:	77 08                	ja     804129 <mem_realloc+0x3d>
  804121:	3b 35 08 53 81 00    	cmp    0x815308,%esi
  804127:	72 17                	jb     804140 <mem_realloc+0x54>
  804129:	83 ec 04             	sub    $0x4,%esp
  80412c:	68 d7 15 81 00       	push   $0x8115d7
  804131:	68 79 01 00 00       	push   $0x179
  804136:	68 67 15 81 00       	push   $0x811567
  80413b:	e8 0e a3 00 00       	call   80e44e <_panic>
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  804140:	8d 56 f4             	lea    -0xc(%esi),%edx
  804143:	29 c2                	sub    %eax,%edx
  804145:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  804148:	8b 46 f4             	mov    -0xc(%esi),%eax
  80414b:	8d 78 f4             	lea    -0xc(%eax),%edi
  80414e:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804150:	39 df                	cmp    %ebx,%edi
  804152:	73 17                	jae    80416b <mem_realloc+0x7f>
  804154:	83 ec 04             	sub    $0x4,%esp
  804157:	68 c0 14 81 00       	push   $0x8114c0
  80415c:	68 8a 01 00 00       	push   $0x18a
  804161:	68 67 15 81 00       	push   $0x811567
  804166:	e8 e3 a2 00 00       	call   80e44e <_panic>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
    /* No change in size, simply return */
    return rmem;
  80416b:	89 f0                	mov    %esi,%eax
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  80416d:	39 df                	cmp    %ebx,%edi
  80416f:	0f 84 b8 00 00 00    	je     80422d <mem_realloc+0x141>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  804175:	83 ec 08             	sub    $0x8,%esp
  804178:	6a 00                	push   $0x0
  80417a:	ff 35 00 53 81 00    	pushl  0x815300
  804180:	e8 c1 5e 00 00       	call   80a046 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  804185:	a1 0c 53 81 00       	mov    0x81530c,%eax
  80418a:	89 c2                	mov    %eax,%edx
  80418c:	03 56 f4             	add    -0xc(%esi),%edx
  if(mem2->used == 0) {
  80418f:	83 c4 10             	add    $0x10,%esp
  804192:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804196:	75 3c                	jne    8041d4 <mem_realloc+0xe8>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  804198:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80419a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80419d:	8d 5c 3b 0c          	lea    0xc(%ebx,%edi,1),%ebx
    if (lfree == mem2) {
  8041a1:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  8041a7:	75 09                	jne    8041b2 <mem_realloc+0xc6>
      lfree = (struct mem *)&ram[ptr2];
  8041a9:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  8041ac:	89 15 04 53 81 00    	mov    %edx,0x815304
    }
    mem2 = (struct mem *)&ram[ptr2];
  8041b2:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  8041b5:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  8041b9:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  8041bb:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8041be:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  8041c1:	89 5e f4             	mov    %ebx,-0xc(%esi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8041c4:	8b 12                	mov    (%edx),%edx
  8041c6:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8041cc:	74 45                	je     804213 <mem_realloc+0x127>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8041ce:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
  8041d2:	eb 3f                	jmp    804213 <mem_realloc+0x127>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  8041d4:	8d 53 18             	lea    0x18(%ebx),%edx
  8041d7:	39 d7                	cmp    %edx,%edi
  8041d9:	72 38                	jb     804213 <mem_realloc+0x127>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8041db:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8041de:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8041e2:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8041e5:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  8041eb:	73 06                	jae    8041f3 <mem_realloc+0x107>
      lfree = mem2;
  8041ed:	89 15 04 53 81 00    	mov    %edx,0x815304
    }
    mem2->used = 0;
  8041f3:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  8041f7:	8b 5e f4             	mov    -0xc(%esi),%ebx
  8041fa:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  8041fc:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8041ff:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  804202:	89 4e f4             	mov    %ecx,-0xc(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804205:	8b 12                	mov    (%edx),%edx
  804207:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80420d:	74 04                	je     804213 <mem_realloc+0x127>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80420f:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  804213:	83 ec 0c             	sub    $0xc,%esp
  804216:	ff 35 00 53 81 00    	pushl  0x815300
  80421c:	e8 b7 5d 00 00       	call   809fd8 <sys_sem_signal>
  return rmem;
  804221:	83 c4 10             	add    $0x10,%esp
  804224:	89 f0                	mov    %esi,%eax
  804226:	eb 05                	jmp    80422d <mem_realloc+0x141>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  804228:	b8 00 00 00 00       	mov    $0x0,%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
  80422d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804230:	5b                   	pop    %ebx
  804231:	5e                   	pop    %esi
  804232:	5f                   	pop    %edi
  804233:	5d                   	pop    %ebp
  804234:	c3                   	ret    

00804235 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  804235:	55                   	push   %ebp
  804236:	89 e5                	mov    %esp,%ebp
  804238:	57                   	push   %edi
  804239:	56                   	push   %esi
  80423a:	53                   	push   %ebx
  80423b:	83 ec 1c             	sub    $0x1c,%esp
  80423e:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  804241:	85 f6                	test   %esi,%esi
  804243:	0f 84 72 01 00 00    	je     8043bb <mem_malloc+0x186>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  804249:	83 c6 03             	add    $0x3,%esi
  80424c:	83 e6 fc             	and    $0xfffffffc,%esi

  if(size < MIN_SIZE_ALIGNED) {
  80424f:	83 fe 0b             	cmp    $0xb,%esi
  804252:	76 0d                	jbe    804261 <mem_malloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  804254:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  80425a:	76 0a                	jbe    804266 <mem_malloc+0x31>
  80425c:	e9 61 01 00 00       	jmp    8043c2 <mem_malloc+0x18d>
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  804261:	be 0c 00 00 00       	mov    $0xc,%esi
  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  804266:	83 ec 08             	sub    $0x8,%esp
  804269:	6a 00                	push   $0x0
  80426b:	ff 35 00 53 81 00    	pushl  0x815300
  804271:	e8 d0 5d 00 00       	call   80a046 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804276:	8b 15 0c 53 81 00    	mov    0x81530c,%edx
  80427c:	a1 04 53 81 00       	mov    0x815304,%eax
  804281:	29 d0                	sub    %edx,%eax
  804283:	83 c4 10             	add    $0x10,%esp
  804286:	bf 00 00 22 00       	mov    $0x220000,%edi
  80428b:	29 f7                	sub    %esi,%edi
  80428d:	e9 09 01 00 00       	jmp    80439b <mem_malloc+0x166>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  804292:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  804295:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  804299:	0f 85 fa 00 00 00    	jne    804399 <mem_malloc+0x164>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80429f:	8b 0b                	mov    (%ebx),%ecx
  8042a1:	83 e9 0c             	sub    $0xc,%ecx
  8042a4:	29 c1                	sub    %eax,%ecx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  8042a6:	39 f1                	cmp    %esi,%ecx
  8042a8:	0f 82 eb 00 00 00    	jb     804399 <mem_malloc+0x164>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  8042ae:	8d 7e 18             	lea    0x18(%esi),%edi
  8042b1:	39 f9                	cmp    %edi,%ecx
  8042b3:	72 2d                	jb     8042e2 <mem_malloc+0xad>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  8042b5:	8d 7c 30 0c          	lea    0xc(%eax,%esi,1),%edi
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  8042b9:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  8042bc:	8d 0c 3a             	lea    (%edx,%edi,1),%ecx
          mem2->used = 0;
  8042bf:	c6 41 08 00          	movb   $0x0,0x8(%ecx)
          mem2->next = mem->next;
  8042c3:	8b 3b                	mov    (%ebx),%edi
  8042c5:	89 39                	mov    %edi,(%ecx)
          mem2->prev = ptr;
  8042c7:	89 41 04             	mov    %eax,0x4(%ecx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  8042ca:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8042cd:	89 3b                	mov    %edi,(%ebx)
          mem->used = 1;
  8042cf:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  8042d3:	8b 01                	mov    (%ecx),%eax
  8042d5:	3d 00 00 22 00       	cmp    $0x220000,%eax
  8042da:	74 0a                	je     8042e6 <mem_malloc+0xb1>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8042dc:	89 7c 02 04          	mov    %edi,0x4(%edx,%eax,1)
  8042e0:	eb 04                	jmp    8042e6 <mem_malloc+0xb1>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  8042e2:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  8042e6:	a1 04 53 81 00       	mov    0x815304,%eax
  8042eb:	39 c3                	cmp    %eax,%ebx
  8042ed:	75 3c                	jne    80432b <mem_malloc+0xf6>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8042ef:	8b 0d 08 53 81 00    	mov    0x815308,%ecx
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  8042f5:	8b 3d 0c 53 81 00    	mov    0x81530c,%edi
  8042fb:	ba 00 00 00 00       	mov    $0x0,%edx
  804300:	eb 0b                	jmp    80430d <mem_malloc+0xd8>
  804302:	89 fa                	mov    %edi,%edx
  804304:	03 10                	add    (%eax),%edx
  804306:	89 d0                	mov    %edx,%eax
  804308:	ba 01 00 00 00       	mov    $0x1,%edx
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80430d:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  804311:	75 0b                	jne    80431e <mem_malloc+0xe9>
  804313:	84 d2                	test   %dl,%dl
  804315:	74 14                	je     80432b <mem_malloc+0xf6>
  804317:	a3 04 53 81 00       	mov    %eax,0x815304
  80431c:	eb 0d                	jmp    80432b <mem_malloc+0xf6>
  80431e:	39 c1                	cmp    %eax,%ecx
  804320:	75 e0                	jne    804302 <mem_malloc+0xcd>
  804322:	84 d2                	test   %dl,%dl
  804324:	74 05                	je     80432b <mem_malloc+0xf6>
  804326:	a3 04 53 81 00       	mov    %eax,0x815304
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80432b:	83 ec 0c             	sub    $0xc,%esp
  80432e:	ff 35 00 53 81 00    	pushl  0x815300
  804334:	e8 9f 5c 00 00       	call   809fd8 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  804339:	8d 44 33 0c          	lea    0xc(%ebx,%esi,1),%eax
  80433d:	83 c4 10             	add    $0x10,%esp
  804340:	39 05 08 53 81 00    	cmp    %eax,0x815308
  804346:	73 17                	jae    80435f <mem_malloc+0x12a>
  804348:	83 ec 04             	sub    $0x4,%esp
  80434b:	68 e4 14 81 00       	push   $0x8114e4
  804350:	68 4b 02 00 00       	push   $0x24b
  804355:	68 67 15 81 00       	push   $0x811567
  80435a:	e8 ef a0 00 00       	call   80e44e <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80435f:	8d 43 0c             	lea    0xc(%ebx),%eax
  804362:	a8 03                	test   $0x3,%al
  804364:	74 17                	je     80437d <mem_malloc+0x148>
  804366:	83 ec 04             	sub    $0x4,%esp
  804369:	68 14 15 81 00       	push   $0x811514
  80436e:	68 4d 02 00 00       	push   $0x24d
  804373:	68 67 15 81 00       	push   $0x811567
  804378:	e8 d1 a0 00 00       	call   80e44e <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  80437d:	f6 c3 03             	test   $0x3,%bl
  804380:	74 45                	je     8043c7 <mem_malloc+0x192>
  804382:	83 ec 04             	sub    $0x4,%esp
  804385:	68 44 15 81 00       	push   $0x811544
  80438a:	68 4f 02 00 00       	push   $0x24f
  80438f:	68 67 15 81 00       	push   $0x811567
  804394:	e8 b5 a0 00 00       	call   80e44e <_panic>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  804399:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80439b:	39 f8                	cmp    %edi,%eax
  80439d:	0f 82 ef fe ff ff    	jb     804292 <mem_malloc+0x5d>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  8043a3:	83 ec 0c             	sub    $0xc,%esp
  8043a6:	ff 35 00 53 81 00    	pushl  0x815300
  8043ac:	e8 27 5c 00 00       	call   809fd8 <sys_sem_signal>
  return NULL;
  8043b1:	83 c4 10             	add    $0x10,%esp
  8043b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8043b9:	eb 0c                	jmp    8043c7 <mem_malloc+0x192>
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
  8043bb:	b8 00 00 00 00       	mov    $0x0,%eax
  8043c0:	eb 05                	jmp    8043c7 <mem_malloc+0x192>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  8043c2:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
}
  8043c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8043ca:	5b                   	pop    %ebx
  8043cb:	5e                   	pop    %esi
  8043cc:	5f                   	pop    %edi
  8043cd:	5d                   	pop    %ebp
  8043ce:	c3                   	ret    

008043cf <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8043cf:	55                   	push   %ebp
  8043d0:	89 e5                	mov    %esp,%ebp
  8043d2:	56                   	push   %esi
  8043d3:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8043d4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8043d7:	0f af 5d 08          	imul   0x8(%ebp),%ebx
  8043db:	83 ec 0c             	sub    $0xc,%esp
  8043de:	53                   	push   %ebx
  8043df:	e8 51 fe ff ff       	call   804235 <mem_malloc>
  8043e4:	89 c6                	mov    %eax,%esi
  if (p) {
  8043e6:	83 c4 10             	add    $0x10,%esp
  8043e9:	85 c0                	test   %eax,%eax
  8043eb:	74 0f                	je     8043fc <mem_calloc+0x2d>
    /* zero the memory */
    memset(p, 0, count * size);
  8043ed:	83 ec 04             	sub    $0x4,%esp
  8043f0:	53                   	push   %ebx
  8043f1:	6a 00                	push   $0x0
  8043f3:	50                   	push   %eax
  8043f4:	e8 f8 a7 00 00       	call   80ebf1 <memset>
  8043f9:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  8043fc:	89 f0                	mov    %esi,%eax
  8043fe:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804401:	5b                   	pop    %ebx
  804402:	5e                   	pop    %esi
  804403:	5d                   	pop    %ebp
  804404:	c3                   	ret    

00804405 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  804405:	55                   	push   %ebp
  804406:	89 e5                	mov    %esp,%ebp
  804408:	57                   	push   %edi
  804409:	56                   	push   %esi
  80440a:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80440b:	b8 43 53 a3 00       	mov    $0xa35343,%eax
  804410:	83 e0 fc             	and    $0xfffffffc,%eax
  804413:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  804418:	c7 84 12 c0 43 b3 00 	movl   $0x0,0xb343c0(%edx,%edx,1)
  80441f:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804423:	0f b7 b2 68 16 81 00 	movzwl 0x811668(%edx),%esi
  80442a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80442f:	eb 19                	jmp    80444a <memp_init+0x45>
      memp->next = memp_tab[i];
  804431:	bb c0 43 b3 00       	mov    $0xb343c0,%ebx
  804436:	8b 3c 53             	mov    (%ebx,%edx,2),%edi
  804439:	89 38                	mov    %edi,(%eax)
      memp_tab[i] = memp;
  80443b:	89 04 53             	mov    %eax,(%ebx,%edx,2)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80443e:	0f b7 9a 84 16 81 00 	movzwl 0x811684(%edx),%ebx
  804445:	01 d8                	add    %ebx,%eax
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804447:	83 c1 01             	add    $0x1,%ecx
  80444a:	66 39 f1             	cmp    %si,%cx
  80444d:	75 e2                	jne    804431 <memp_init+0x2c>
  80444f:	83 c2 02             	add    $0x2,%edx
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  804452:	83 fa 1c             	cmp    $0x1c,%edx
  804455:	75 c1                	jne    804418 <memp_init+0x13>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  804457:	5b                   	pop    %ebx
  804458:	5e                   	pop    %esi
  804459:	5f                   	pop    %edi
  80445a:	5d                   	pop    %ebp
  80445b:	c3                   	ret    

0080445c <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80445c:	55                   	push   %ebp
  80445d:	89 e5                	mov    %esp,%ebp
  80445f:	83 ec 08             	sub    $0x8,%esp
  804462:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804465:	83 fa 0d             	cmp    $0xd,%edx
  804468:	76 17                	jbe    804481 <memp_malloc+0x25>
  80446a:	83 ec 04             	sub    $0x4,%esp
  80446d:	68 f1 15 81 00       	push   $0x8115f1
  804472:	68 2d 01 00 00       	push   $0x12d
  804477:	68 0e 16 81 00       	push   $0x81160e
  80447c:	e8 cd 9f 00 00       	call   80e44e <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  804481:	8b 04 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%eax
  
  if (memp != NULL) {    
  804488:	85 c0                	test   %eax,%eax
  80448a:	74 24                	je     8044b0 <memp_malloc+0x54>
    memp_tab[type] = memp->next;    
  80448c:	8b 08                	mov    (%eax),%ecx
  80448e:	89 0c 95 c0 43 b3 00 	mov    %ecx,0xb343c0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804495:	a8 03                	test   $0x3,%al
  804497:	74 17                	je     8044b0 <memp_malloc+0x54>
  804499:	83 ec 04             	sub    $0x4,%esp
  80449c:	68 24 16 81 00       	push   $0x811624
  8044a1:	68 3f 01 00 00       	push   $0x13f
  8044a6:	68 0e 16 81 00       	push   $0x81160e
  8044ab:	e8 9e 9f 00 00       	call   80e44e <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  8044b0:	c9                   	leave  
  8044b1:	c3                   	ret    

008044b2 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8044b2:	55                   	push   %ebp
  8044b3:	89 e5                	mov    %esp,%ebp
  8044b5:	83 ec 08             	sub    $0x8,%esp
  8044b8:	8b 55 08             	mov    0x8(%ebp),%edx
  8044bb:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8044be:	85 c0                	test   %eax,%eax
  8044c0:	74 2b                	je     8044ed <memp_free+0x3b>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8044c2:	a8 03                	test   $0x3,%al
  8044c4:	74 17                	je     8044dd <memp_free+0x2b>
  8044c6:	83 ec 04             	sub    $0x4,%esp
  8044c9:	68 48 16 81 00       	push   $0x811648
  8044ce:	68 5b 01 00 00       	push   $0x15b
  8044d3:	68 0e 16 81 00       	push   $0x81160e
  8044d8:	e8 71 9f 00 00       	call   80e44e <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  8044dd:	8b 0c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ecx
  8044e4:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  8044e6:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  8044ed:	c9                   	leave  
  8044ee:	c3                   	ret    

008044ef <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  8044ef:	55                   	push   %ebp
  8044f0:	89 e5                	mov    %esp,%ebp
  8044f2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  8044f5:	85 c9                	test   %ecx,%ecx
  8044f7:	74 38                	je     804531 <netif_remove+0x42>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  8044f9:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  8044fe:	39 c1                	cmp    %eax,%ecx
  804500:	75 17                	jne    804519 <netif_remove+0x2a>
    netif_list = netif->next;
  804502:	8b 01                	mov    (%ecx),%eax
  804504:	a3 34 b2 b3 00       	mov    %eax,0xb3b234
  804509:	eb 14                	jmp    80451f <netif_remove+0x30>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  80450b:	8b 10                	mov    (%eax),%edx
  80450d:	39 d1                	cmp    %edx,%ecx
  80450f:	75 06                	jne    804517 <netif_remove+0x28>
        tmpNetif->next = netif->next;
  804511:	8b 11                	mov    (%ecx),%edx
  804513:	89 10                	mov    %edx,(%eax)
  804515:	eb 08                	jmp    80451f <netif_remove+0x30>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804517:	89 d0                	mov    %edx,%eax
  804519:	85 c0                	test   %eax,%eax
  80451b:	75 ee                	jne    80450b <netif_remove+0x1c>
  80451d:	eb 12                	jmp    804531 <netif_remove+0x42>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  80451f:	3b 0d 38 b2 b3 00    	cmp    0xb3b238,%ecx
  804525:	75 0a                	jne    804531 <netif_remove+0x42>
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804527:	c7 05 38 b2 b3 00 00 	movl   $0x0,0xb3b238
  80452e:	00 00 00 
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804531:	5d                   	pop    %ebp
  804532:	c3                   	ret    

00804533 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  804533:	55                   	push   %ebp
  804534:	89 e5                	mov    %esp,%ebp
  804536:	53                   	push   %ebx
  804537:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  80453a:	85 c9                	test   %ecx,%ecx
  80453c:	74 2c                	je     80456a <netif_find+0x37>
    return NULL;
  }

  num = name[2] - '0';
  80453e:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  804542:	8d 50 d0             	lea    -0x30(%eax),%edx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804545:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  80454a:	eb 18                	jmp    804564 <netif_find+0x31>
    if (num == netif->num &&
  80454c:	3a 50 31             	cmp    0x31(%eax),%dl
  80454f:	75 11                	jne    804562 <netif_find+0x2f>
  804551:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  804555:	38 19                	cmp    %bl,(%ecx)
  804557:	75 09                	jne    804562 <netif_find+0x2f>
       name[0] == netif->name[0] &&
  804559:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  80455d:	38 59 01             	cmp    %bl,0x1(%ecx)
  804560:	74 0d                	je     80456f <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804562:	8b 00                	mov    (%eax),%eax
  804564:	85 c0                	test   %eax,%eax
  804566:	75 e4                	jne    80454c <netif_find+0x19>
  804568:	eb 05                	jmp    80456f <netif_find+0x3c>
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    return NULL;
  80456a:	b8 00 00 00 00       	mov    $0x0,%eax
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  80456f:	5b                   	pop    %ebx
  804570:	5d                   	pop    %ebp
  804571:	c3                   	ret    

00804572 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  804572:	55                   	push   %ebp
  804573:	89 e5                	mov    %esp,%ebp
  804575:	57                   	push   %edi
  804576:	56                   	push   %esi
  804577:	53                   	push   %ebx
  804578:	83 ec 0c             	sub    $0xc,%esp
  80457b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80457e:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804581:	8b 43 04             	mov    0x4(%ebx),%eax
  804584:	39 06                	cmp    %eax,(%esi)
  804586:	74 54                	je     8045dc <netif_set_ipaddr+0x6a>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  804588:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    while (pcb != NULL) {
  80458d:	eb 1d                	jmp    8045ac <netif_set_ipaddr+0x3a>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80458f:	8b 4b 04             	mov    0x4(%ebx),%ecx
  804592:	39 08                	cmp    %ecx,(%eax)
  804594:	75 13                	jne    8045a9 <netif_set_ipaddr+0x37>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  804596:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  804599:	83 ec 0c             	sub    $0xc,%esp
  80459c:	50                   	push   %eax
  80459d:	e8 42 16 00 00       	call   805be4 <tcp_abort>
  8045a2:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  8045a5:	89 f8                	mov    %edi,%eax
  8045a7:	eb 03                	jmp    8045ac <netif_set_ipaddr+0x3a>
      } else {
        pcb = pcb->next;
  8045a9:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  8045ac:	85 c0                	test   %eax,%eax
  8045ae:	75 df                	jne    80458f <netif_set_ipaddr+0x1d>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8045b0:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  8045b5:	eb 21                	jmp    8045d8 <netif_set_ipaddr+0x66>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  8045b7:	85 c0                	test   %eax,%eax
  8045b9:	74 1a                	je     8045d5 <netif_set_ipaddr+0x63>
  8045bb:	8b 10                	mov    (%eax),%edx
  8045bd:	85 d2                	test   %edx,%edx
  8045bf:	74 14                	je     8045d5 <netif_set_ipaddr+0x63>
  8045c1:	3b 53 04             	cmp    0x4(%ebx),%edx
  8045c4:	75 0f                	jne    8045d5 <netif_set_ipaddr+0x63>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8045c6:	85 f6                	test   %esi,%esi
  8045c8:	74 04                	je     8045ce <netif_set_ipaddr+0x5c>
  8045ca:	8b 16                	mov    (%esi),%edx
  8045cc:	eb 05                	jmp    8045d3 <netif_set_ipaddr+0x61>
  8045ce:	ba 00 00 00 00       	mov    $0x0,%edx
  8045d3:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8045d5:	8b 40 0c             	mov    0xc(%eax),%eax
  8045d8:	85 c0                	test   %eax,%eax
  8045da:	75 db                	jne    8045b7 <netif_set_ipaddr+0x45>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  8045dc:	85 f6                	test   %esi,%esi
  8045de:	74 04                	je     8045e4 <netif_set_ipaddr+0x72>
  8045e0:	8b 06                	mov    (%esi),%eax
  8045e2:	eb 05                	jmp    8045e9 <netif_set_ipaddr+0x77>
  8045e4:	b8 00 00 00 00       	mov    $0x0,%eax
  8045e9:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  8045ec:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8045ef:	5b                   	pop    %ebx
  8045f0:	5e                   	pop    %esi
  8045f1:	5f                   	pop    %edi
  8045f2:	5d                   	pop    %ebp
  8045f3:	c3                   	ret    

008045f4 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  8045f4:	55                   	push   %ebp
  8045f5:	89 e5                	mov    %esp,%ebp
  8045f7:	57                   	push   %edi
  8045f8:	56                   	push   %esi
  8045f9:	53                   	push   %ebx
  8045fa:	83 ec 14             	sub    $0x14,%esp
  8045fd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804600:	8b 7d 10             	mov    0x10(%ebp),%edi
  804603:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  804606:	ff 75 0c             	pushl  0xc(%ebp)
  804609:	53                   	push   %ebx
  80460a:	e8 63 ff ff ff       	call   804572 <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  80460f:	83 c4 10             	add    $0x10,%esp
  804612:	85 ff                	test   %edi,%edi
  804614:	74 04                	je     80461a <netif_set_addr+0x26>
  804616:	8b 07                	mov    (%edi),%eax
  804618:	eb 05                	jmp    80461f <netif_set_addr+0x2b>
  80461a:	b8 00 00 00 00       	mov    $0x0,%eax
  80461f:	89 43 08             	mov    %eax,0x8(%ebx)
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  ip_addr_set(&(netif->gw), gw);
  804622:	85 f6                	test   %esi,%esi
  804624:	74 04                	je     80462a <netif_set_addr+0x36>
  804626:	8b 06                	mov    (%esi),%eax
  804628:	eb 05                	jmp    80462f <netif_set_addr+0x3b>
  80462a:	b8 00 00 00 00       	mov    $0x0,%eax
  80462f:	89 43 0c             	mov    %eax,0xc(%ebx)
    struct ip_addr *gw)
{
  netif_set_ipaddr(netif, ipaddr);
  netif_set_netmask(netif, netmask);
  netif_set_gw(netif, gw);
}
  804632:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804635:	5b                   	pop    %ebx
  804636:	5e                   	pop    %esi
  804637:	5f                   	pop    %edi
  804638:	5d                   	pop    %ebp
  804639:	c3                   	ret    

0080463a <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  80463a:	55                   	push   %ebp
  80463b:	89 e5                	mov    %esp,%ebp
  80463d:	53                   	push   %ebx
  80463e:	83 ec 04             	sub    $0x4,%esp
  804641:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  804644:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  80464b:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804652:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  804659:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  80465d:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  804664:	8b 45 18             	mov    0x18(%ebp),%eax
  804667:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  80466a:	0f b6 05 f8 43 b3 00 	movzbl 0xb343f8,%eax
  804671:	8d 50 01             	lea    0x1(%eax),%edx
  804674:	88 15 f8 43 b3 00    	mov    %dl,0xb343f8
  80467a:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  80467d:	8b 45 20             	mov    0x20(%ebp),%eax
  804680:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  804683:	ff 75 14             	pushl  0x14(%ebp)
  804686:	ff 75 10             	pushl  0x10(%ebp)
  804689:	ff 75 0c             	pushl  0xc(%ebp)
  80468c:	53                   	push   %ebx
  80468d:	e8 62 ff ff ff       	call   8045f4 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  804692:	89 1c 24             	mov    %ebx,(%esp)
  804695:	ff 55 1c             	call   *0x1c(%ebp)
  804698:	83 c4 10             	add    $0x10,%esp
  80469b:	84 c0                	test   %al,%al
  80469d:	75 11                	jne    8046b0 <netif_add+0x76>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  80469f:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  8046a4:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  8046a6:	89 1d 34 b2 b3 00    	mov    %ebx,0xb3b234
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  8046ac:	89 d8                	mov    %ebx,%eax
  8046ae:	eb 05                	jmp    8046b5 <netif_add+0x7b>

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    return NULL;
  8046b0:	b8 00 00 00 00       	mov    $0x0,%eax
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  8046b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8046b8:	c9                   	leave  
  8046b9:	c3                   	ret    

008046ba <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  8046ba:	55                   	push   %ebp
  8046bb:	89 e5                	mov    %esp,%ebp
  8046bd:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&(netif->gw), gw);
  8046c0:	85 c0                	test   %eax,%eax
  8046c2:	74 04                	je     8046c8 <netif_set_gw+0xe>
  8046c4:	8b 10                	mov    (%eax),%edx
  8046c6:	eb 05                	jmp    8046cd <netif_set_gw+0x13>
  8046c8:	ba 00 00 00 00       	mov    $0x0,%edx
  8046cd:	8b 45 08             	mov    0x8(%ebp),%eax
  8046d0:	89 50 0c             	mov    %edx,0xc(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  8046d3:	5d                   	pop    %ebp
  8046d4:	c3                   	ret    

008046d5 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  8046d5:	55                   	push   %ebp
  8046d6:	89 e5                	mov    %esp,%ebp
  8046d8:	8b 45 0c             	mov    0xc(%ebp),%eax
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  8046db:	85 c0                	test   %eax,%eax
  8046dd:	74 04                	je     8046e3 <netif_set_netmask+0xe>
  8046df:	8b 10                	mov    (%eax),%edx
  8046e1:	eb 05                	jmp    8046e8 <netif_set_netmask+0x13>
  8046e3:	ba 00 00 00 00       	mov    $0x0,%edx
  8046e8:	8b 45 08             	mov    0x8(%ebp),%eax
  8046eb:	89 50 08             	mov    %edx,0x8(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  8046ee:	5d                   	pop    %ebp
  8046ef:	c3                   	ret    

008046f0 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  8046f0:	55                   	push   %ebp
  8046f1:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  8046f3:	8b 45 08             	mov    0x8(%ebp),%eax
  8046f6:	a3 38 b2 b3 00       	mov    %eax,0xb3b238
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  8046fb:	5d                   	pop    %ebp
  8046fc:	c3                   	ret    

008046fd <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  8046fd:	55                   	push   %ebp
  8046fe:	89 e5                	mov    %esp,%ebp
  804700:	83 ec 08             	sub    $0x8,%esp
  804703:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  804706:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  80470a:	a8 01                	test   $0x1,%al
  80470c:	75 1e                	jne    80472c <netif_set_up+0x2f>
    netif->flags |= NETIF_FLAG_UP;
  80470e:	89 c1                	mov    %eax,%ecx
  804710:	83 c9 01             	or     $0x1,%ecx
  804713:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  804716:	a8 20                	test   $0x20,%al
  804718:	74 12                	je     80472c <netif_set_up+0x2f>
      etharp_query(netif, &(netif->ip_addr), NULL);
  80471a:	83 ec 04             	sub    $0x4,%esp
  80471d:	6a 00                	push   $0x0
  80471f:	8d 42 04             	lea    0x4(%edx),%eax
  804722:	50                   	push   %eax
  804723:	52                   	push   %edx
  804724:	e8 2c 51 00 00       	call   809855 <etharp_query>
  804729:	83 c4 10             	add    $0x10,%esp
    }
#endif /* LWIP_ARP */
    
  }
}
  80472c:	c9                   	leave  
  80472d:	c3                   	ret    

0080472e <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  80472e:	55                   	push   %ebp
  80472f:	89 e5                	mov    %esp,%ebp
  804731:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  804734:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  804738:	a8 01                	test   $0x1,%al
  80473a:	74 06                	je     804742 <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  80473c:	83 e0 fe             	and    $0xfffffffe,%eax
  80473f:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804742:	5d                   	pop    %ebp
  804743:	c3                   	ret    

00804744 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804744:	55                   	push   %ebp
  804745:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  804747:	8b 45 08             	mov    0x8(%ebp),%eax
  80474a:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  80474e:	83 e0 01             	and    $0x1,%eax
}
  804751:	5d                   	pop    %ebp
  804752:	c3                   	ret    

00804753 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804753:	55                   	push   %ebp
  804754:	89 e5                	mov    %esp,%ebp
  804756:	56                   	push   %esi
  804757:	53                   	push   %ebx
  804758:	8b 55 08             	mov    0x8(%ebp),%edx
  80475b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  80475e:	85 d2                	test   %edx,%edx
  804760:	75 17                	jne    804779 <pbuf_header+0x26>
  804762:	83 ec 04             	sub    $0x4,%esp
  804765:	68 64 17 81 00       	push   $0x811764
  80476a:	68 64 01 00 00       	push   $0x164
  80476f:	68 a0 16 81 00       	push   $0x8116a0
  804774:	e8 d5 9c 00 00       	call   80e44e <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  804779:	66 85 c9             	test   %cx,%cx
  80477c:	0f 84 97 00 00 00    	je     804819 <pbuf_header+0xc6>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  804782:	89 ce                	mov    %ecx,%esi

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  804784:	66 85 c9             	test   %cx,%cx
  804787:	79 1f                	jns    8047a8 <pbuf_header+0x55>
    increment_magnitude = -header_size_increment;
  804789:	f7 de                	neg    %esi
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  80478b:	66 3b 72 0a          	cmp    0xa(%edx),%si
  80478f:	76 17                	jbe    8047a8 <pbuf_header+0x55>
  804791:	83 ec 04             	sub    $0x4,%esp
  804794:	68 b5 16 81 00       	push   $0x8116b5
  804799:	68 6b 01 00 00       	push   $0x16b
  80479e:	68 a0 16 81 00       	push   $0x8116a0
  8047a3:	e8 a6 9c 00 00       	call   80e44e <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  8047a8:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  8047ac:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  8047af:	66 85 c0             	test   %ax,%ax
  8047b2:	74 06                	je     8047ba <pbuf_header+0x67>
  8047b4:	66 83 f8 03          	cmp    $0x3,%ax
  8047b8:	75 13                	jne    8047cd <pbuf_header+0x7a>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  8047ba:	0f bf c1             	movswl %cx,%eax
  8047bd:	29 c3                	sub    %eax,%ebx
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8047bf:	8d 72 10             	lea    0x10(%edx),%esi
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
  8047c2:	b8 01 00 00 00       	mov    $0x1,%eax
  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8047c7:	39 f3                	cmp    %esi,%ebx
  8047c9:	73 3c                	jae    804807 <pbuf_header+0xb4>
  8047cb:	eb 51                	jmp    80481e <pbuf_header+0xcb>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  8047cd:	83 e8 01             	sub    $0x1,%eax
  8047d0:	66 83 f8 01          	cmp    $0x1,%ax
  8047d4:	77 1a                	ja     8047f0 <pbuf_header+0x9d>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  8047d6:	b8 01 00 00 00       	mov    $0x1,%eax
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  8047db:	66 85 c9             	test   %cx,%cx
  8047de:	79 3e                	jns    80481e <pbuf_header+0xcb>
  8047e0:	66 3b 72 0a          	cmp    0xa(%edx),%si
  8047e4:	77 38                	ja     80481e <pbuf_header+0xcb>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  8047e6:	0f bf c1             	movswl %cx,%eax
  8047e9:	29 c3                	sub    %eax,%ebx
  8047eb:	89 5a 04             	mov    %ebx,0x4(%edx)
  8047ee:	eb 1a                	jmp    80480a <pbuf_header+0xb7>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  8047f0:	83 ec 04             	sub    $0x4,%esp
  8047f3:	68 d3 16 81 00       	push   $0x8116d3
  8047f8:	68 9a 01 00 00       	push   $0x19a
  8047fd:	68 a0 16 81 00       	push   $0x8116a0
  804802:	e8 47 9c 00 00       	call   80e44e <_panic>
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  804807:	89 5a 04             	mov    %ebx,0x4(%edx)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  80480a:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  80480e:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  804812:	b8 00 00 00 00       	mov    $0x0,%eax
  804817:	eb 05                	jmp    80481e <pbuf_header+0xcb>
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
  804819:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
  80481e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804821:	5b                   	pop    %ebx
  804822:	5e                   	pop    %esi
  804823:	5d                   	pop    %ebp
  804824:	c3                   	ret    

00804825 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  804825:	55                   	push   %ebp
  804826:	89 e5                	mov    %esp,%ebp
  804828:	56                   	push   %esi
  804829:	53                   	push   %ebx
  80482a:	8b 55 08             	mov    0x8(%ebp),%edx
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  80482d:	85 d2                	test   %edx,%edx
  80482f:	75 17                	jne    804848 <pbuf_free+0x23>
    LWIP_ASSERT("p != NULL", p != NULL);
  804831:	83 ec 04             	sub    $0x4,%esp
  804834:	68 64 17 81 00       	push   $0x811764
  804839:	68 d0 01 00 00       	push   $0x1d0
  80483e:	68 a0 16 81 00       	push   $0x8116a0
  804843:	e8 06 9c 00 00       	call   80e44e <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804848:	80 7a 0c 03          	cmpb   $0x3,0xc(%edx)
  80484c:	76 17                	jbe    804865 <pbuf_free+0x40>
  80484e:	83 ec 04             	sub    $0x4,%esp
  804851:	68 e1 16 81 00       	push   $0x8116e1
  804856:	68 db 01 00 00       	push   $0x1db
  80485b:	68 a0 16 81 00       	push   $0x8116a0
  804860:	e8 e9 9b 00 00       	call   80e44e <_panic>
  804865:	bb 00 00 00 00       	mov    $0x0,%ebx
  80486a:	eb 02                	jmp    80486e <pbuf_free+0x49>
      } else {
        mem_free(p);
      }
      count++;
      /* proceed to next pbuf */
      p = q;
  80486c:	89 f2                	mov    %esi,%edx
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80486e:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
  804872:	66 85 c0             	test   %ax,%ax
  804875:	75 17                	jne    80488e <pbuf_free+0x69>
  804877:	83 ec 04             	sub    $0x4,%esp
  80487a:	68 f6 16 81 00       	push   $0x8116f6
  80487f:	68 e8 01 00 00       	push   $0x1e8
  804884:	68 a0 16 81 00       	push   $0x8116a0
  804889:	e8 c0 9b 00 00       	call   80e44e <_panic>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  80488e:	83 e8 01             	sub    $0x1,%eax
  804891:	66 89 42 0e          	mov    %ax,0xe(%edx)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  804895:	66 85 c0             	test   %ax,%ax
  804898:	75 48                	jne    8048e2 <pbuf_free+0xbd>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  80489a:	8b 32                	mov    (%edx),%esi
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  80489c:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  8048a0:	66 83 f8 03          	cmp    $0x3,%ax
  8048a4:	75 10                	jne    8048b6 <pbuf_free+0x91>
        memp_free(MEMP_PBUF_POOL, p);
  8048a6:	83 ec 08             	sub    $0x8,%esp
  8048a9:	52                   	push   %edx
  8048aa:	6a 0d                	push   $0xd
  8048ac:	e8 01 fc ff ff       	call   8044b2 <memp_free>
  8048b1:	83 c4 10             	add    $0x10,%esp
  8048b4:	eb 25                	jmp    8048db <pbuf_free+0xb6>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  8048b6:	83 e8 01             	sub    $0x1,%eax
  8048b9:	66 83 f8 01          	cmp    $0x1,%ax
  8048bd:	77 10                	ja     8048cf <pbuf_free+0xaa>
        memp_free(MEMP_PBUF, p);
  8048bf:	83 ec 08             	sub    $0x8,%esp
  8048c2:	52                   	push   %edx
  8048c3:	6a 0c                	push   $0xc
  8048c5:	e8 e8 fb ff ff       	call   8044b2 <memp_free>
  8048ca:	83 c4 10             	add    $0x10,%esp
  8048cd:	eb 0c                	jmp    8048db <pbuf_free+0xb6>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  8048cf:	83 ec 0c             	sub    $0xc,%esp
  8048d2:	52                   	push   %edx
  8048d3:	e8 ab f6 ff ff       	call   803f83 <mem_free>
  8048d8:	83 c4 10             	add    $0x10,%esp
      }
      count++;
  8048db:	83 c3 01             	add    $0x1,%ebx
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  8048de:	85 f6                	test   %esi,%esi
  8048e0:	75 8a                	jne    80486c <pbuf_free+0x47>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  8048e2:	89 d8                	mov    %ebx,%eax
  8048e4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8048e7:	5b                   	pop    %ebx
  8048e8:	5e                   	pop    %esi
  8048e9:	5d                   	pop    %ebp
  8048ea:	c3                   	ret    

008048eb <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  8048eb:	55                   	push   %ebp
  8048ec:	89 e5                	mov    %esp,%ebp
  8048ee:	57                   	push   %edi
  8048ef:	56                   	push   %esi
  8048f0:	53                   	push   %ebx
  8048f1:	83 ec 1c             	sub    $0x1c,%esp
  8048f4:	8b 45 08             	mov    0x8(%ebp),%eax
  8048f7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  8048fa:	83 f8 01             	cmp    $0x1,%eax
  8048fd:	74 18                	je     804917 <pbuf_alloc+0x2c>
  8048ff:	83 f8 01             	cmp    $0x1,%eax
  804902:	72 0c                	jb     804910 <pbuf_alloc+0x25>
  804904:	83 f8 02             	cmp    $0x2,%eax
  804907:	74 18                	je     804921 <pbuf_alloc+0x36>
  804909:	83 f8 03             	cmp    $0x3,%eax
  80490c:	74 34                	je     804942 <pbuf_alloc+0x57>
  80490e:	eb 1b                	jmp    80492b <pbuf_alloc+0x40>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  804910:	bf 14 00 00 00       	mov    $0x14,%edi
  804915:	eb 05                	jmp    80491c <pbuf_alloc+0x31>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804917:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  80491c:	83 c7 14             	add    $0x14,%edi
  80491f:	eb 05                	jmp    804926 <pbuf_alloc+0x3b>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804921:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  804926:	83 c7 0e             	add    $0xe,%edi
    break;
  804929:	eb 1c                	jmp    804947 <pbuf_alloc+0x5c>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  80492b:	83 ec 04             	sub    $0x4,%esp
  80492e:	68 0c 17 81 00       	push   $0x81170c
  804933:	68 8a 00 00 00       	push   $0x8a
  804938:	68 a0 16 81 00       	push   $0x8116a0
  80493d:	e8 0c 9b 00 00       	call   80e44e <_panic>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804942:	bf 00 00 00 00       	mov    $0x0,%edi
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  804947:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  80494b:	77 0f                	ja     80495c <pbuf_alloc+0x71>
  80494d:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  804951:	0f 82 60 01 00 00    	jb     804ab7 <pbuf_alloc+0x1cc>
  804957:	e9 a1 01 00 00       	jmp    804afd <pbuf_alloc+0x212>
  80495c:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
  804960:	0f 85 c8 01 00 00    	jne    804b2e <pbuf_alloc+0x243>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  804966:	83 ec 0c             	sub    $0xc,%esp
  804969:	6a 0d                	push   $0xd
  80496b:	e8 ec fa ff ff       	call   80445c <memp_malloc>
  804970:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  804972:	83 c4 10             	add    $0x10,%esp
  804975:	85 c0                	test   %eax,%eax
  804977:	0f 84 d6 01 00 00    	je     804b53 <pbuf_alloc+0x268>
      return NULL;
    }
    p->type = type;
  80497d:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  804981:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  804987:	0f b7 ff             	movzwl %di,%edi
  80498a:	8d 54 38 13          	lea    0x13(%eax,%edi,1),%edx
  80498e:	83 e2 fc             	and    $0xfffffffc,%edx
  804991:	89 50 04             	mov    %edx,0x4(%eax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  804994:	66 89 58 08          	mov    %bx,0x8(%eax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  804998:	0f b7 db             	movzwl %bx,%ebx
  80499b:	83 c7 03             	add    $0x3,%edi
  80499e:	83 e7 fc             	and    $0xfffffffc,%edi
  8049a1:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  8049a6:	29 f8                	sub    %edi,%eax
  8049a8:	39 d8                	cmp    %ebx,%eax
  8049aa:	0f 4f c3             	cmovg  %ebx,%eax
  8049ad:	66 89 46 0a          	mov    %ax,0xa(%esi)
  8049b1:	0f b7 c0             	movzwl %ax,%eax
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  8049b4:	8d 8e e0 07 00 00    	lea    0x7e0(%esi),%ecx
  8049ba:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8049bd:	01 c2                	add    %eax,%edx
  8049bf:	39 d1                	cmp    %edx,%ecx
  8049c1:	73 17                	jae    8049da <pbuf_alloc+0xef>
  8049c3:	83 ec 04             	sub    $0x4,%esp
  8049c6:	68 24 18 81 00       	push   $0x811824
  8049cb:	68 a3 00 00 00       	push   $0xa3
  8049d0:	68 a0 16 81 00       	push   $0x8116a0
  8049d5:	e8 74 9a 00 00       	call   80e44e <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  8049da:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  8049e0:	29 c3                	sub    %eax,%ebx
    p->ref = 1;

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  8049e2:	89 f7                	mov    %esi,%edi
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  8049e4:	e9 c1 00 00 00       	jmp    804aaa <pbuf_alloc+0x1bf>
      q = memp_malloc(MEMP_PBUF_POOL);
  8049e9:	83 ec 0c             	sub    $0xc,%esp
  8049ec:	6a 0d                	push   $0xd
  8049ee:	e8 69 fa ff ff       	call   80445c <memp_malloc>
      if (q == NULL) {
  8049f3:	83 c4 10             	add    $0x10,%esp
  8049f6:	85 c0                	test   %eax,%eax
  8049f8:	75 16                	jne    804a10 <pbuf_alloc+0x125>
        /* free chain so far allocated */
        pbuf_free(p);
  8049fa:	83 ec 0c             	sub    $0xc,%esp
  8049fd:	56                   	push   %esi
  8049fe:	e8 22 fe ff ff       	call   804825 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
  804a03:	83 c4 10             	add    $0x10,%esp
  804a06:	b8 00 00 00 00       	mov    $0x0,%eax
  804a0b:	e9 56 01 00 00       	jmp    804b66 <pbuf_alloc+0x27b>
      }
      q->type = type;
  804a10:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804a14:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  804a18:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  804a1e:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804a20:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  804a26:	7e 17                	jle    804a3f <pbuf_alloc+0x154>
  804a28:	83 ec 04             	sub    $0x4,%esp
  804a2b:	68 27 17 81 00       	push   $0x811727
  804a30:	68 bc 00 00 00       	push   $0xbc
  804a35:	68 a0 16 81 00       	push   $0x8116a0
  804a3a:	e8 0f 9a 00 00       	call   80e44e <_panic>
      q->tot_len = (u16_t)rem_len;
  804a3f:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804a43:	0f b7 d3             	movzwl %bx,%edx
  804a46:	81 fa d0 07 00 00    	cmp    $0x7d0,%edx
  804a4c:	bf d0 07 00 00       	mov    $0x7d0,%edi
  804a51:	0f 4f d7             	cmovg  %edi,%edx
  804a54:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  804a58:	8d 48 10             	lea    0x10(%eax),%ecx
  804a5b:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804a5e:	f6 c1 03             	test   $0x3,%cl
  804a61:	74 17                	je     804a7a <pbuf_alloc+0x18f>
  804a63:	83 ec 04             	sub    $0x4,%esp
  804a66:	68 58 18 81 00       	push   $0x811858
  804a6b:	68 c2 00 00 00       	push   $0xc2
  804a70:	68 a0 16 81 00       	push   $0x8116a0
  804a75:	e8 d4 99 00 00       	call   80e44e <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804a7a:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  804a7e:	03 4e 04             	add    0x4(%esi),%ecx
  804a81:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  804a84:	73 17                	jae    804a9d <pbuf_alloc+0x1b2>
  804a86:	83 ec 04             	sub    $0x4,%esp
  804a89:	68 24 18 81 00       	push   $0x811824
  804a8e:	68 c5 00 00 00       	push   $0xc5
  804a93:	68 a0 16 81 00       	push   $0x8116a0
  804a98:	e8 b1 99 00 00       	call   80e44e <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  804a9d:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  804aa3:	0f b7 d2             	movzwl %dx,%edx
  804aa6:	29 d3                	sub    %edx,%ebx
      /* remember this pbuf for linkage in next iteration */
      r = q;
  804aa8:	89 c7                	mov    %eax,%edi
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  804aaa:	85 db                	test   %ebx,%ebx
  804aac:	0f 8f 37 ff ff ff    	jg     8049e9 <pbuf_alloc+0xfe>
  804ab2:	e9 8e 00 00 00       	jmp    804b45 <pbuf_alloc+0x25a>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  804ab7:	0f b7 ff             	movzwl %di,%edi
  804aba:	83 ec 0c             	sub    $0xc,%esp
  804abd:	8d 47 13             	lea    0x13(%edi),%eax
  804ac0:	83 e0 fc             	and    $0xfffffffc,%eax
  804ac3:	89 c2                	mov    %eax,%edx
  804ac5:	0f b7 c3             	movzwl %bx,%eax
  804ac8:	83 c0 03             	add    $0x3,%eax
  804acb:	83 e0 fc             	and    $0xfffffffc,%eax
  804ace:	01 d0                	add    %edx,%eax
  804ad0:	50                   	push   %eax
  804ad1:	e8 5f f7 ff ff       	call   804235 <mem_malloc>
  804ad6:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  804ad8:	83 c4 10             	add    $0x10,%esp
  804adb:	85 c0                	test   %eax,%eax
  804add:	74 7b                	je     804b5a <pbuf_alloc+0x26f>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  804adf:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  804ae3:	83 e0 fc             	and    $0xfffffffc,%eax
  804ae6:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  804ae9:	66 89 5e 08          	mov    %bx,0x8(%esi)
  804aed:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  804af1:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  804af7:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  804afb:	eb 48                	jmp    804b45 <pbuf_alloc+0x25a>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  804afd:	83 ec 0c             	sub    $0xc,%esp
  804b00:	6a 0c                	push   $0xc
  804b02:	e8 55 f9 ff ff       	call   80445c <memp_malloc>
  804b07:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  804b09:	83 c4 10             	add    $0x10,%esp
  804b0c:	85 c0                	test   %eax,%eax
  804b0e:	74 51                	je     804b61 <pbuf_alloc+0x276>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  804b10:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804b17:	66 89 58 08          	mov    %bx,0x8(%eax)
  804b1b:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  804b1f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804b25:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  804b29:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  804b2c:	eb 17                	jmp    804b45 <pbuf_alloc+0x25a>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804b2e:	83 ec 04             	sub    $0x4,%esp
  804b31:	68 3b 17 81 00       	push   $0x81173b
  804b36:	68 f1 00 00 00       	push   $0xf1
  804b3b:	68 a0 16 81 00       	push   $0x8116a0
  804b40:	e8 09 99 00 00       	call   80e44e <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  804b45:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  804b4b:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  804b4f:	89 f0                	mov    %esi,%eax
  804b51:	eb 13                	jmp    804b66 <pbuf_alloc+0x27b>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      return NULL;
  804b53:	b8 00 00 00 00       	mov    $0x0,%eax
  804b58:	eb 0c                	jmp    804b66 <pbuf_alloc+0x27b>
    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    if (p == NULL) {
      return NULL;
  804b5a:	b8 00 00 00 00       	mov    $0x0,%eax
  804b5f:	eb 05                	jmp    804b66 <pbuf_alloc+0x27b>
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
    if (p == NULL) {
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  804b61:	b8 00 00 00 00       	mov    $0x0,%eax
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  804b66:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804b69:	5b                   	pop    %ebx
  804b6a:	5e                   	pop    %esi
  804b6b:	5f                   	pop    %edi
  804b6c:	5d                   	pop    %ebp
  804b6d:	c3                   	ret    

00804b6e <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  804b6e:	55                   	push   %ebp
  804b6f:	89 e5                	mov    %esp,%ebp
  804b71:	57                   	push   %edi
  804b72:	56                   	push   %esi
  804b73:	53                   	push   %ebx
  804b74:	83 ec 0c             	sub    $0xc,%esp
  804b77:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804b7a:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804b7d:	85 db                	test   %ebx,%ebx
  804b7f:	75 17                	jne    804b98 <pbuf_realloc+0x2a>
  804b81:	83 ec 04             	sub    $0x4,%esp
  804b84:	68 56 17 81 00       	push   $0x811756
  804b89:	68 13 01 00 00       	push   $0x113
  804b8e:	68 a0 16 81 00       	push   $0x8116a0
  804b93:	e8 b6 98 00 00       	call   80e44e <_panic>
  804b98:	89 f7                	mov    %esi,%edi
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804b9a:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804b9e:	76 17                	jbe    804bb7 <pbuf_realloc+0x49>
  804ba0:	83 ec 04             	sub    $0x4,%esp
  804ba3:	68 6e 17 81 00       	push   $0x81176e
  804ba8:	68 17 01 00 00       	push   $0x117
  804bad:	68 a0 16 81 00       	push   $0x8116a0
  804bb2:	e8 97 98 00 00       	call   80e44e <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  804bb7:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  804bbb:	66 39 f2             	cmp    %si,%dx
  804bbe:	0f 86 b8 00 00 00    	jbe    804c7c <pbuf_realloc+0x10e>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  804bc4:	0f b7 ce             	movzwl %si,%ecx
  804bc7:	0f b7 c2             	movzwl %dx,%eax
  804bca:	29 c1                	sub    %eax,%ecx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  804bcc:	eb 46                	jmp    804c14 <pbuf_realloc+0xa6>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  804bce:	29 c6                	sub    %eax,%esi
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804bd0:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  804bd6:	7e 17                	jle    804bef <pbuf_realloc+0x81>
  804bd8:	83 ec 04             	sub    $0x4,%esp
  804bdb:	68 89 17 81 00       	push   $0x811789
  804be0:	68 2b 01 00 00       	push   $0x12b
  804be5:	68 a0 16 81 00       	push   $0x8116a0
  804bea:	e8 5f 98 00 00       	call   80e44e <_panic>
    q->tot_len += (u16_t)grow;
  804bef:	89 f8                	mov    %edi,%eax
  804bf1:	29 d0                	sub    %edx,%eax
  804bf3:	66 01 43 08          	add    %ax,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  804bf7:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804bf9:	85 db                	test   %ebx,%ebx
  804bfb:	75 17                	jne    804c14 <pbuf_realloc+0xa6>
  804bfd:	83 ec 04             	sub    $0x4,%esp
  804c00:	68 9a 17 81 00       	push   $0x81179a
  804c05:	68 2f 01 00 00       	push   $0x12f
  804c0a:	68 a0 16 81 00       	push   $0x8116a0
  804c0f:	e8 3a 98 00 00       	call   80e44e <_panic>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  804c14:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804c18:	66 39 c6             	cmp    %ax,%si
  804c1b:	77 b1                	ja     804bce <pbuf_realloc+0x60>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804c1d:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804c21:	75 39                	jne    804c5c <pbuf_realloc+0xee>
  804c23:	66 39 c6             	cmp    %ax,%si
  804c26:	74 34                	je     804c5c <pbuf_realloc+0xee>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804c28:	8b 53 04             	mov    0x4(%ebx),%edx
  804c2b:	29 da                	sub    %ebx,%edx
  804c2d:	0f b7 c6             	movzwl %si,%eax
  804c30:	01 d0                	add    %edx,%eax
  804c32:	83 ec 08             	sub    $0x8,%esp
  804c35:	50                   	push   %eax
  804c36:	53                   	push   %ebx
  804c37:	e8 b0 f4 ff ff       	call   8040ec <mem_realloc>
  804c3c:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804c3e:	83 c4 10             	add    $0x10,%esp
  804c41:	85 c0                	test   %eax,%eax
  804c43:	75 17                	jne    804c5c <pbuf_realloc+0xee>
  804c45:	83 ec 04             	sub    $0x4,%esp
  804c48:	68 b2 17 81 00       	push   $0x8117b2
  804c4d:	68 39 01 00 00       	push   $0x139
  804c52:	68 a0 16 81 00       	push   $0x8116a0
  804c57:	e8 f2 97 00 00       	call   80e44e <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  804c5c:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804c60:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  804c64:	8b 03                	mov    (%ebx),%eax
  804c66:	85 c0                	test   %eax,%eax
  804c68:	74 0c                	je     804c76 <pbuf_realloc+0x108>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  804c6a:	83 ec 0c             	sub    $0xc,%esp
  804c6d:	50                   	push   %eax
  804c6e:	e8 b2 fb ff ff       	call   804825 <pbuf_free>
  804c73:	83 c4 10             	add    $0x10,%esp
  }
  /* q is last packet in chain */
  q->next = NULL;
  804c76:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  804c7c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804c7f:	5b                   	pop    %ebx
  804c80:	5e                   	pop    %esi
  804c81:	5f                   	pop    %edi
  804c82:	5d                   	pop    %ebp
  804c83:	c3                   	ret    

00804c84 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804c84:	55                   	push   %ebp
  804c85:	89 e5                	mov    %esp,%ebp
  804c87:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  804c8a:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  804c8f:	eb 05                	jmp    804c96 <pbuf_clen+0x12>
    ++len;
  804c91:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  804c94:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  804c96:	85 d2                	test   %edx,%edx
  804c98:	75 f7                	jne    804c91 <pbuf_clen+0xd>
    ++len;
    p = p->next;
  }
  return len;
}
  804c9a:	5d                   	pop    %ebp
  804c9b:	c3                   	ret    

00804c9c <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804c9c:	55                   	push   %ebp
  804c9d:	89 e5                	mov    %esp,%ebp
  804c9f:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804ca2:	85 c0                	test   %eax,%eax
  804ca4:	74 05                	je     804cab <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804ca6:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804cab:	5d                   	pop    %ebp
  804cac:	c3                   	ret    

00804cad <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804cad:	55                   	push   %ebp
  804cae:	89 e5                	mov    %esp,%ebp
  804cb0:	53                   	push   %ebx
  804cb1:	83 ec 04             	sub    $0x4,%esp
  804cb4:	8b 45 08             	mov    0x8(%ebp),%eax
  804cb7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804cba:	85 c0                	test   %eax,%eax
  804cbc:	74 04                	je     804cc2 <pbuf_cat+0x15>
  804cbe:	85 db                	test   %ebx,%ebx
  804cc0:	75 21                	jne    804ce3 <pbuf_cat+0x36>
  804cc2:	83 ec 04             	sub    $0x4,%esp
  804cc5:	68 88 18 81 00       	push   $0x811888
  804cca:	68 42 02 00 00       	push   $0x242
  804ccf:	68 a0 16 81 00       	push   $0x8116a0
  804cd4:	e8 75 97 00 00       	call   80e44e <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804cd9:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804cdd:	66 01 48 08          	add    %cx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  804ce1:	89 d0                	mov    %edx,%eax
  804ce3:	8b 10                	mov    (%eax),%edx
  804ce5:	85 d2                	test   %edx,%edx
  804ce7:	75 f0                	jne    804cd9 <pbuf_cat+0x2c>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804ce9:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804ced:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804cf1:	74 17                	je     804d0a <pbuf_cat+0x5d>
  804cf3:	83 ec 04             	sub    $0x4,%esp
  804cf6:	68 c0 18 81 00       	push   $0x8118c0
  804cfb:	68 4a 02 00 00       	push   $0x24a
  804d00:	68 a0 16 81 00       	push   $0x8116a0
  804d05:	e8 44 97 00 00       	call   80e44e <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804d0a:	66 03 53 08          	add    0x8(%ebx),%dx
  804d0e:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804d12:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804d14:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804d17:	c9                   	leave  
  804d18:	c3                   	ret    

00804d19 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804d19:	55                   	push   %ebp
  804d1a:	89 e5                	mov    %esp,%ebp
  804d1c:	53                   	push   %ebx
  804d1d:	83 ec 0c             	sub    $0xc,%esp
  804d20:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804d23:	53                   	push   %ebx
  804d24:	ff 75 08             	pushl  0x8(%ebp)
  804d27:	e8 81 ff ff ff       	call   804cad <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804d2c:	89 1c 24             	mov    %ebx,(%esp)
  804d2f:	e8 68 ff ff ff       	call   804c9c <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804d34:	83 c4 10             	add    $0x10,%esp
  804d37:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804d3a:	c9                   	leave  
  804d3b:	c3                   	ret    

00804d3c <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804d3c:	55                   	push   %ebp
  804d3d:	89 e5                	mov    %esp,%ebp
  804d3f:	57                   	push   %edi
  804d40:	56                   	push   %esi
  804d41:	53                   	push   %ebx
  804d42:	83 ec 1c             	sub    $0x1c,%esp
  804d45:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804d48:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804d4a:	85 f6                	test   %esi,%esi
  804d4c:	0f 84 80 00 00 00    	je     804dd2 <pbuf_dechain+0x96>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804d52:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804d56:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804d5a:	0f b7 7e 08          	movzwl 0x8(%esi),%edi
  804d5e:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804d61:	0f b7 d0             	movzwl %ax,%edx
  804d64:	0f b7 f9             	movzwl %cx,%edi
  804d67:	29 fa                	sub    %edi,%edx
  804d69:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  804d6c:	74 17                	je     804d85 <pbuf_dechain+0x49>
  804d6e:	83 ec 04             	sub    $0x4,%esp
  804d71:	68 f0 18 81 00       	push   $0x8118f0
  804d76:	68 80 02 00 00       	push   $0x280
  804d7b:	68 a0 16 81 00       	push   $0x8116a0
  804d80:	e8 c9 96 00 00       	call   80e44e <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804d85:	29 c8                	sub    %ecx,%eax
  804d87:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804d8b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804d91:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d95:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804d99:	83 ec 0c             	sub    $0xc,%esp
  804d9c:	56                   	push   %esi
  804d9d:	e8 83 fa ff ff       	call   804825 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804da2:	83 c4 10             	add    $0x10,%esp
  804da5:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804da9:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  804dad:	74 17                	je     804dc6 <pbuf_dechain+0x8a>
  804daf:	83 ec 04             	sub    $0x4,%esp
  804db2:	68 cd 17 81 00       	push   $0x8117cd
  804db7:	68 91 02 00 00       	push   $0x291
  804dbc:	68 a0 16 81 00       	push   $0x8116a0
  804dc1:	e8 88 96 00 00       	call   80e44e <_panic>
  return ((tail_gone > 0) ? NULL : q);
  804dc6:	84 c0                	test   %al,%al
  804dc8:	b8 00 00 00 00       	mov    $0x0,%eax
  804dcd:	0f 44 c6             	cmove  %esi,%eax
  804dd0:	eb 0f                	jmp    804de1 <pbuf_dechain+0xa5>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804dd2:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804dd6:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804dda:	75 d3                	jne    804daf <pbuf_dechain+0x73>
  return ((tail_gone > 0) ? NULL : q);
  804ddc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804de1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804de4:	5b                   	pop    %ebx
  804de5:	5e                   	pop    %esi
  804de6:	5f                   	pop    %edi
  804de7:	5d                   	pop    %ebp
  804de8:	c3                   	ret    

00804de9 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804de9:	55                   	push   %ebp
  804dea:	89 e5                	mov    %esp,%ebp
  804dec:	57                   	push   %edi
  804ded:	56                   	push   %esi
  804dee:	53                   	push   %ebx
  804def:	83 ec 1c             	sub    $0x1c,%esp
  804df2:	8b 75 08             	mov    0x8(%ebp),%esi
  804df5:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804df8:	85 f6                	test   %esi,%esi
  804dfa:	74 0e                	je     804e0a <pbuf_copy+0x21>
  804dfc:	85 db                	test   %ebx,%ebx
  804dfe:	74 0a                	je     804e0a <pbuf_copy+0x21>
  804e00:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804e04:	66 39 46 08          	cmp    %ax,0x8(%esi)
  804e08:	73 17                	jae    804e21 <pbuf_copy+0x38>
  804e0a:	83 ec 04             	sub    $0x4,%esp
  804e0d:	68 14 19 81 00       	push   $0x811914
  804e12:	68 b1 02 00 00       	push   $0x2b1
  804e17:	68 a0 16 81 00       	push   $0x8116a0
  804e1c:	e8 2d 96 00 00       	call   80e44e <_panic>
  804e21:	bf 00 00 00 00       	mov    $0x0,%edi
  804e26:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804e2c:	66 89 7d e6          	mov    %di,-0x1a(%ebp)
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  804e30:	85 f6                	test   %esi,%esi
  804e32:	75 17                	jne    804e4b <pbuf_copy+0x62>
  804e34:	83 ec 04             	sub    $0x4,%esp
  804e37:	68 e2 17 81 00       	push   $0x8117e2
  804e3c:	68 b6 02 00 00       	push   $0x2b6
  804e41:	68 a0 16 81 00       	push   $0x8116a0
  804e46:	e8 03 96 00 00       	call   80e44e <_panic>
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  804e4b:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  804e4f:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804e53:	29 c1                	sub    %eax,%ecx
  804e55:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  804e59:	0f b7 7d e6          	movzwl -0x1a(%ebp),%edi
  804e5d:	0f b7 c7             	movzwl %di,%eax
  804e60:	29 c2                	sub    %eax,%edx
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  804e62:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804e66:	29 f8                	sub    %edi,%eax
  804e68:	0f b7 7e 0a          	movzwl 0xa(%esi),%edi
  804e6c:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  804e70:	39 d1                	cmp    %edx,%ecx
  804e72:	89 c1                	mov    %eax,%ecx
  804e74:	0f 4c cf             	cmovl  %edi,%ecx
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  804e77:	83 ec 04             	sub    $0x4,%esp
  804e7a:	66 89 4d e2          	mov    %cx,-0x1e(%ebp)
  804e7e:	0f b7 c1             	movzwl %cx,%eax
  804e81:	50                   	push   %eax
  804e82:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804e86:	03 43 04             	add    0x4(%ebx),%eax
  804e89:	50                   	push   %eax
  804e8a:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  804e8e:	0f b7 c7             	movzwl %di,%eax
  804e91:	03 46 04             	add    0x4(%esi),%eax
  804e94:	50                   	push   %eax
  804e95:	e8 0c 9e 00 00       	call   80eca6 <memcpy>
    offset_to += len;
  804e9a:	89 f8                	mov    %edi,%eax
  804e9c:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  804ea0:	01 c8                	add    %ecx,%eax
  804ea2:	89 c2                	mov    %eax,%edx
  804ea4:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    offset_from += len;
  804ea8:	66 01 4d e6          	add    %cx,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804eac:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  804eb0:	83 c4 10             	add    $0x10,%esp
  804eb3:	66 39 c2             	cmp    %ax,%dx
  804eb6:	76 17                	jbe    804ecf <pbuf_copy+0xe6>
  804eb8:	83 ec 04             	sub    $0x4,%esp
  804ebb:	68 ef 17 81 00       	push   $0x8117ef
  804ec0:	68 c2 02 00 00       	push   $0x2c2
  804ec5:	68 a0 16 81 00       	push   $0x8116a0
  804eca:	e8 7f 95 00 00       	call   80e44e <_panic>
    if (offset_to == p_to->len) {
  804ecf:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
  804ed3:	75 08                	jne    804edd <pbuf_copy+0xf4>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  804ed5:	8b 36                	mov    (%esi),%esi
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
  804ed7:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804edd:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804ee1:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  804ee5:	76 17                	jbe    804efe <pbuf_copy+0x115>
  804ee7:	83 ec 04             	sub    $0x4,%esp
  804eea:	68 06 18 81 00       	push   $0x811806
  804eef:	68 c8 02 00 00       	push   $0x2c8
  804ef4:	68 a0 16 81 00       	push   $0x8116a0
  804ef9:	e8 50 95 00 00       	call   80e44e <_panic>
    if (offset_from >= p_from->len) {
  804efe:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  804f02:	72 08                	jb     804f0c <pbuf_copy+0x123>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  804f04:	8b 1b                	mov    (%ebx),%ebx
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  804f06:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804f0c:	85 db                	test   %ebx,%ebx
  804f0e:	74 26                	je     804f36 <pbuf_copy+0x14d>
  804f10:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804f14:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  804f18:	75 1c                	jne    804f36 <pbuf_copy+0x14d>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804f1a:	83 3b 00             	cmpl   $0x0,(%ebx)
  804f1d:	74 17                	je     804f36 <pbuf_copy+0x14d>
  804f1f:	83 ec 04             	sub    $0x4,%esp
  804f22:	68 44 19 81 00       	push   $0x811944
  804f27:	68 d2 02 00 00       	push   $0x2d2
  804f2c:	68 a0 16 81 00       	push   $0x8116a0
  804f31:	e8 18 95 00 00       	call   80e44e <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804f36:	85 f6                	test   %esi,%esi
  804f38:	74 26                	je     804f60 <pbuf_copy+0x177>
  804f3a:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  804f3e:	66 39 46 0a          	cmp    %ax,0xa(%esi)
  804f42:	75 1c                	jne    804f60 <pbuf_copy+0x177>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804f44:	83 3e 00             	cmpl   $0x0,(%esi)
  804f47:	74 17                	je     804f60 <pbuf_copy+0x177>
  804f49:	83 ec 04             	sub    $0x4,%esp
  804f4c:	68 44 19 81 00       	push   $0x811944
  804f51:	68 d7 02 00 00       	push   $0x2d7
  804f56:	68 a0 16 81 00       	push   $0x8116a0
  804f5b:	e8 ee 94 00 00       	call   80e44e <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  804f60:	85 db                	test   %ebx,%ebx
  804f62:	0f 85 c8 fe ff ff    	jne    804e30 <pbuf_copy+0x47>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  804f68:	b8 00 00 00 00       	mov    $0x0,%eax
  804f6d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804f70:	5b                   	pop    %ebx
  804f71:	5e                   	pop    %esi
  804f72:	5f                   	pop    %edi
  804f73:	5d                   	pop    %ebp
  804f74:	c3                   	ret    

00804f75 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  804f75:	55                   	push   %ebp
  804f76:	89 e5                	mov    %esp,%ebp
  804f78:	57                   	push   %edi
  804f79:	56                   	push   %esi
  804f7a:	53                   	push   %ebx
  804f7b:	83 ec 1c             	sub    $0x1c,%esp
  804f7e:	8b 75 08             	mov    0x8(%ebp),%esi
  804f81:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  804f85:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  804f89:	85 f6                	test   %esi,%esi
  804f8b:	75 17                	jne    804fa4 <pbuf_copy_partial+0x2f>
  804f8d:	83 ec 04             	sub    $0x4,%esp
  804f90:	68 70 19 81 00       	push   $0x811970
  804f95:	68 ef 02 00 00       	push   $0x2ef
  804f9a:	68 a0 16 81 00       	push   $0x8116a0
  804f9f:	e8 aa 94 00 00       	call   80e44e <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  804fa4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  804fa8:	75 66                	jne    805010 <pbuf_copy_partial+0x9b>
  804faa:	83 ec 04             	sub    $0x4,%esp
  804fad:	68 94 19 81 00       	push   $0x811994
  804fb2:	68 f0 02 00 00       	push   $0x2f0
  804fb7:	68 a0 16 81 00       	push   $0x8116a0
  804fbc:	e8 8d 94 00 00       	call   80e44e <_panic>
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  804fc1:	66 85 c0             	test   %ax,%ax
  804fc4:	74 0d                	je     804fd3 <pbuf_copy_partial+0x5e>
  804fc6:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  804fca:	66 39 d0             	cmp    %dx,%ax
  804fcd:	72 04                	jb     804fd3 <pbuf_copy_partial+0x5e>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  804fcf:	29 d0                	sub    %edx,%eax
  804fd1:	eb 39                	jmp    80500c <pbuf_copy_partial+0x97>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  804fd3:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  804fd7:	29 c3                	sub    %eax,%ebx
  804fd9:	66 39 df             	cmp    %bx,%di
  804fdc:	0f 46 df             	cmovbe %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  804fdf:	83 ec 04             	sub    $0x4,%esp
  804fe2:	0f b7 d3             	movzwl %bx,%edx
  804fe5:	52                   	push   %edx
  804fe6:	0f b7 c0             	movzwl %ax,%eax
  804fe9:	03 46 04             	add    0x4(%esi),%eax
  804fec:	50                   	push   %eax
  804fed:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804ff1:	03 45 0c             	add    0xc(%ebp),%eax
  804ff4:	50                   	push   %eax
  804ff5:	e8 ac 9c 00 00       	call   80eca6 <memcpy>
      copied_total += buf_copy_len;
  804ffa:	66 01 5d e4          	add    %bx,-0x1c(%ebp)
      left += buf_copy_len;
  804ffe:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      len -= buf_copy_len;
  805002:	29 df                	sub    %ebx,%edi
  805004:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  805007:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80500c:	8b 36                	mov    (%esi),%esi
  80500e:	eb 0c                	jmp    80501c <pbuf_copy_partial+0xa7>
  805010:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  805016:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  80501c:	66 85 ff             	test   %di,%di
  80501f:	74 04                	je     805025 <pbuf_copy_partial+0xb0>
  805021:	85 f6                	test   %esi,%esi
  805023:	75 9c                	jne    804fc1 <pbuf_copy_partial+0x4c>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  805025:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  805029:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80502c:	5b                   	pop    %ebx
  80502d:	5e                   	pop    %esi
  80502e:	5f                   	pop    %edi
  80502f:	5d                   	pop    %ebp
  805030:	c3                   	ret    

00805031 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  805031:	55                   	push   %ebp
  805032:	89 e5                	mov    %esp,%ebp
  805034:	83 ec 14             	sub    $0x14,%esp
  805037:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80503a:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  80503f:	8b 40 04             	mov    0x4(%eax),%eax
  805042:	ff 30                	pushl  (%eax)
  805044:	e8 8f 4f 00 00       	call   809fd8 <sys_sem_signal>
}
  805049:	83 c4 10             	add    $0x10,%esp
  80504c:	c9                   	leave  
  80504d:	c3                   	ret    

0080504e <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80504e:	55                   	push   %ebp
  80504f:	89 e5                	mov    %esp,%ebp
  805051:	57                   	push   %edi
  805052:	56                   	push   %esi
  805053:	53                   	push   %ebx
  805054:	83 ec 0c             	sub    $0xc,%esp
  805057:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  80505a:	e8 7b 53 00 00       	call   80a3da <sys_arch_timeouts>
  80505f:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  805061:	85 c0                	test   %eax,%eax
  805063:	74 06                	je     80506b <sys_mbox_fetch+0x1d>
  805065:	8b 00                	mov    (%eax),%eax
  805067:	85 c0                	test   %eax,%eax
  805069:	75 13                	jne    80507e <sys_mbox_fetch+0x30>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80506b:	83 ec 04             	sub    $0x4,%esp
  80506e:	6a 00                	push   $0x0
  805070:	57                   	push   %edi
  805071:	ff 75 08             	pushl  0x8(%ebp)
  805074:	e8 ce 51 00 00       	call   80a247 <sys_arch_mbox_fetch>
  805079:	83 c4 10             	add    $0x10,%esp
  80507c:	eb 5c                	jmp    8050da <sys_mbox_fetch+0x8c>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  80507e:	8b 40 04             	mov    0x4(%eax),%eax
  805081:	85 c0                	test   %eax,%eax
  805083:	74 15                	je     80509a <sys_mbox_fetch+0x4c>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  805085:	83 ec 04             	sub    $0x4,%esp
  805088:	50                   	push   %eax
  805089:	57                   	push   %edi
  80508a:	ff 75 08             	pushl  0x8(%ebp)
  80508d:	e8 b5 51 00 00       	call   80a247 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  805092:	83 c4 10             	add    $0x10,%esp
  805095:	83 f8 ff             	cmp    $0xffffffff,%eax
  805098:	75 29                	jne    8050c3 <sys_mbox_fetch+0x75>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80509a:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  80509c:	8b 10                	mov    (%eax),%edx
  80509e:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  8050a0:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8050a3:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8050a6:	83 ec 08             	sub    $0x8,%esp
  8050a9:	50                   	push   %eax
  8050aa:	6a 0b                	push   $0xb
  8050ac:	e8 01 f4 ff ff       	call   8044b2 <memp_free>
      if (h != NULL) {
  8050b1:	83 c4 10             	add    $0x10,%esp
  8050b4:	85 db                	test   %ebx,%ebx
  8050b6:	74 a2                	je     80505a <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  8050b8:	83 ec 0c             	sub    $0xc,%esp
  8050bb:	56                   	push   %esi
  8050bc:	ff d3                	call   *%ebx
  8050be:	83 c4 10             	add    $0x10,%esp
  8050c1:	eb 97                	jmp    80505a <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8050c3:	8b 0b                	mov    (%ebx),%ecx
  8050c5:	8b 51 04             	mov    0x4(%ecx),%edx
  8050c8:	39 d0                	cmp    %edx,%eax
  8050ca:	73 07                	jae    8050d3 <sys_mbox_fetch+0x85>
        timeouts->next->time -= time_needed;
  8050cc:	29 c2                	sub    %eax,%edx
  8050ce:	89 51 04             	mov    %edx,0x4(%ecx)
  8050d1:	eb 07                	jmp    8050da <sys_mbox_fetch+0x8c>
      } else {
        timeouts->next->time = 0;
  8050d3:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
      }
    }
  }
}
  8050da:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8050dd:	5b                   	pop    %ebx
  8050de:	5e                   	pop    %esi
  8050df:	5f                   	pop    %edi
  8050e0:	5d                   	pop    %ebp
  8050e1:	c3                   	ret    

008050e2 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  8050e2:	55                   	push   %ebp
  8050e3:	89 e5                	mov    %esp,%ebp
  8050e5:	57                   	push   %edi
  8050e6:	56                   	push   %esi
  8050e7:	53                   	push   %ebx
  8050e8:	83 ec 0c             	sub    $0xc,%esp
  8050eb:	8b 75 08             	mov    0x8(%ebp),%esi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  8050ee:	e8 e7 52 00 00       	call   80a3da <sys_arch_timeouts>
  8050f3:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  8050f5:	85 c0                	test   %eax,%eax
  8050f7:	74 06                	je     8050ff <sys_sem_wait+0x1d>
  8050f9:	8b 00                	mov    (%eax),%eax
  8050fb:	85 c0                	test   %eax,%eax
  8050fd:	75 10                	jne    80510f <sys_sem_wait+0x2d>
    sys_arch_sem_wait(sem, 0);
  8050ff:	83 ec 08             	sub    $0x8,%esp
  805102:	6a 00                	push   $0x0
  805104:	56                   	push   %esi
  805105:	e8 3c 4f 00 00       	call   80a046 <sys_arch_sem_wait>
  80510a:	83 c4 10             	add    $0x10,%esp
  80510d:	eb 59                	jmp    805168 <sys_sem_wait+0x86>
  } else {
    if (timeouts->next->time > 0) {
  80510f:	8b 40 04             	mov    0x4(%eax),%eax
  805112:	85 c0                	test   %eax,%eax
  805114:	74 12                	je     805128 <sys_sem_wait+0x46>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  805116:	83 ec 08             	sub    $0x8,%esp
  805119:	50                   	push   %eax
  80511a:	56                   	push   %esi
  80511b:	e8 26 4f 00 00       	call   80a046 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  805120:	83 c4 10             	add    $0x10,%esp
  805123:	83 f8 ff             	cmp    $0xffffffff,%eax
  805126:	75 29                	jne    805151 <sys_sem_wait+0x6f>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  805128:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  80512a:	8b 10                	mov    (%eax),%edx
  80512c:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  80512e:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805131:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805134:	83 ec 08             	sub    $0x8,%esp
  805137:	50                   	push   %eax
  805138:	6a 0b                	push   $0xb
  80513a:	e8 73 f3 ff ff       	call   8044b2 <memp_free>
      if (h != NULL) {
  80513f:	83 c4 10             	add    $0x10,%esp
  805142:	85 db                	test   %ebx,%ebx
  805144:	74 a8                	je     8050ee <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  805146:	83 ec 0c             	sub    $0xc,%esp
  805149:	57                   	push   %edi
  80514a:	ff d3                	call   *%ebx
  80514c:	83 c4 10             	add    $0x10,%esp
  80514f:	eb 9d                	jmp    8050ee <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  805151:	8b 0b                	mov    (%ebx),%ecx
  805153:	8b 51 04             	mov    0x4(%ecx),%edx
  805156:	39 d0                	cmp    %edx,%eax
  805158:	73 07                	jae    805161 <sys_sem_wait+0x7f>
        timeouts->next->time -= time_needed;
  80515a:	29 c2                	sub    %eax,%edx
  80515c:	89 51 04             	mov    %edx,0x4(%ecx)
  80515f:	eb 07                	jmp    805168 <sys_sem_wait+0x86>
      } else {
        timeouts->next->time = 0;
  805161:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
      }
    }
  }
}
  805168:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80516b:	5b                   	pop    %ebx
  80516c:	5e                   	pop    %esi
  80516d:	5f                   	pop    %edi
  80516e:	5d                   	pop    %ebp
  80516f:	c3                   	ret    

00805170 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  805170:	55                   	push   %ebp
  805171:	89 e5                	mov    %esp,%ebp
  805173:	56                   	push   %esi
  805174:	53                   	push   %ebx
  805175:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  805178:	83 ec 0c             	sub    $0xc,%esp
  80517b:	6a 0b                	push   $0xb
  80517d:	e8 da f2 ff ff       	call   80445c <memp_malloc>
  if (timeout == NULL) {
  805182:	83 c4 10             	add    $0x10,%esp
  805185:	85 c0                	test   %eax,%eax
  805187:	75 17                	jne    8051a0 <sys_timeout+0x30>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  805189:	83 ec 04             	sub    $0x4,%esp
  80518c:	68 b9 19 81 00       	push   $0x8119b9
  805191:	68 c3 00 00 00       	push   $0xc3
  805196:	68 d6 19 81 00       	push   $0x8119d6
  80519b:	e8 ae 92 00 00       	call   80e44e <_panic>
  8051a0:	89 c3                	mov    %eax,%ebx
    return;
  }
  timeout->next = NULL;
  8051a2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  8051a8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8051ab:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  8051ae:	8b 45 10             	mov    0x10(%ebp),%eax
  8051b1:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  8051b4:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  8051b7:	e8 1e 52 00 00       	call   80a3da <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  8051bc:	85 c0                	test   %eax,%eax
  8051be:	75 17                	jne    8051d7 <sys_timeout+0x67>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  8051c0:	83 ec 04             	sub    $0x4,%esp
  8051c3:	68 ea 19 81 00       	push   $0x8119ea
  8051c8:	68 d1 00 00 00       	push   $0xd1
  8051cd:	68 d6 19 81 00       	push   $0x8119d6
  8051d2:	e8 77 92 00 00       	call   80e44e <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  8051d7:	8b 08                	mov    (%eax),%ecx
  8051d9:	85 c9                	test   %ecx,%ecx
  8051db:	75 04                	jne    8051e1 <sys_timeout+0x71>
    timeouts->next = timeout;
  8051dd:	89 18                	mov    %ebx,(%eax)
    return;
  8051df:	eb 37                	jmp    805218 <sys_timeout+0xa8>
  }

  if (timeouts->next->time > msecs) {
  8051e1:	8b 51 04             	mov    0x4(%ecx),%edx
  8051e4:	39 d6                	cmp    %edx,%esi
  8051e6:	73 0f                	jae    8051f7 <sys_timeout+0x87>
    timeouts->next->time -= msecs;
  8051e8:	29 f2                	sub    %esi,%edx
  8051ea:	89 51 04             	mov    %edx,0x4(%ecx)
    timeout->next = timeouts->next;
  8051ed:	8b 10                	mov    (%eax),%edx
  8051ef:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  8051f1:	89 18                	mov    %ebx,(%eax)
  8051f3:	eb 23                	jmp    805218 <sys_timeout+0xa8>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
      if (t->next == NULL || t->next->time > timeout->time) {
  8051f5:	89 d1                	mov    %edx,%ecx
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  8051f7:	8b 43 04             	mov    0x4(%ebx),%eax
  8051fa:	2b 41 04             	sub    0x4(%ecx),%eax
  8051fd:	89 43 04             	mov    %eax,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  805200:	8b 11                	mov    (%ecx),%edx
  805202:	85 d2                	test   %edx,%edx
  805204:	74 0c                	je     805212 <sys_timeout+0xa2>
  805206:	8b 72 04             	mov    0x4(%edx),%esi
  805209:	39 f0                	cmp    %esi,%eax
  80520b:	73 e8                	jae    8051f5 <sys_timeout+0x85>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  80520d:	29 c6                	sub    %eax,%esi
  80520f:	89 72 04             	mov    %esi,0x4(%edx)
        }
        timeout->next = t->next;
  805212:	8b 01                	mov    (%ecx),%eax
  805214:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  805216:	89 19                	mov    %ebx,(%ecx)
        break;
      }
    }
  }
}
  805218:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80521b:	5b                   	pop    %ebx
  80521c:	5e                   	pop    %esi
  80521d:	5d                   	pop    %ebp
  80521e:	c3                   	ret    

0080521f <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80521f:	55                   	push   %ebp
  805220:	89 e5                	mov    %esp,%ebp
  805222:	57                   	push   %edi
  805223:	56                   	push   %esi
  805224:	53                   	push   %ebx
  805225:	83 ec 0c             	sub    $0xc,%esp
  805228:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80522b:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80522e:	e8 a7 51 00 00       	call   80a3da <sys_arch_timeouts>

  if (timeouts == NULL) {
  805233:	85 c0                	test   %eax,%eax
  805235:	75 17                	jne    80524e <sys_untimeout+0x2f>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  805237:	83 ec 04             	sub    $0x4,%esp
  80523a:	68 08 1a 81 00       	push   $0x811a08
  80523f:	68 00 01 00 00       	push   $0x100
  805244:	68 d6 19 81 00       	push   $0x8119d6
  805249:	e8 00 92 00 00       	call   80e44e <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  80524e:	8b 10                	mov    (%eax),%edx
  805250:	85 d2                	test   %edx,%edx
  805252:	74 45                	je     805299 <sys_untimeout+0x7a>
  805254:	bf 00 00 00 00       	mov    $0x0,%edi
  805259:	eb 02                	jmp    80525d <sys_untimeout+0x3e>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80525b:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  80525d:	39 5a 08             	cmp    %ebx,0x8(%edx)
  805260:	75 2f                	jne    805291 <sys_untimeout+0x72>
  805262:	39 72 0c             	cmp    %esi,0xc(%edx)
  805265:	75 2a                	jne    805291 <sys_untimeout+0x72>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  805267:	85 ff                	test   %edi,%edi
  805269:	75 06                	jne    805271 <sys_untimeout+0x52>
        timeouts->next = t->next;
  80526b:	8b 0a                	mov    (%edx),%ecx
  80526d:	89 08                	mov    %ecx,(%eax)
  80526f:	eb 04                	jmp    805275 <sys_untimeout+0x56>
      else
        prev_t->next = t->next;
  805271:	8b 02                	mov    (%edx),%eax
  805273:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  805275:	8b 02                	mov    (%edx),%eax
  805277:	85 c0                	test   %eax,%eax
  805279:	74 06                	je     805281 <sys_untimeout+0x62>
        t->next->time += t->time;
  80527b:	8b 4a 04             	mov    0x4(%edx),%ecx
  80527e:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  805281:	83 ec 08             	sub    $0x8,%esp
  805284:	52                   	push   %edx
  805285:	6a 0b                	push   $0xb
  805287:	e8 26 f2 ff ff       	call   8044b2 <memp_free>
      return;
  80528c:	83 c4 10             	add    $0x10,%esp
  80528f:	eb 08                	jmp    805299 <sys_untimeout+0x7a>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805291:	8b 0a                	mov    (%edx),%ecx
  805293:	89 d7                	mov    %edx,%edi
  805295:	85 c9                	test   %ecx,%ecx
  805297:	75 c2                	jne    80525b <sys_untimeout+0x3c>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  805299:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80529c:	5b                   	pop    %ebx
  80529d:	5e                   	pop    %esi
  80529e:	5f                   	pop    %edi
  80529f:	5d                   	pop    %ebp
  8052a0:	c3                   	ret    

008052a1 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8052a1:	55                   	push   %ebp
  8052a2:	89 e5                	mov    %esp,%ebp
  8052a4:	83 ec 18             	sub    $0x18,%esp
  8052a7:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  8052aa:	8d 4d 08             	lea    0x8(%ebp),%ecx
  8052ad:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  8052b0:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  8052b6:	85 c0                	test   %eax,%eax
  8052b8:	74 15                	je     8052cf <sys_sem_wait_timeout+0x2e>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  8052ba:	83 ec 04             	sub    $0x4,%esp
  8052bd:	8d 55 f0             	lea    -0x10(%ebp),%edx
  8052c0:	52                   	push   %edx
  8052c1:	68 31 50 80 00       	push   $0x805031
  8052c6:	50                   	push   %eax
  8052c7:	e8 a4 fe ff ff       	call   805170 <sys_timeout>
  8052cc:	83 c4 10             	add    $0x10,%esp
  }
  sys_sem_wait(sem);
  8052cf:	83 ec 0c             	sub    $0xc,%esp
  8052d2:	ff 75 08             	pushl  0x8(%ebp)
  8052d5:	e8 08 fe ff ff       	call   8050e2 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  8052da:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  8052dd:	b8 00 00 00 00       	mov    $0x0,%eax
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  8052e2:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  8052e7:	75 19                	jne    805302 <sys_sem_wait_timeout+0x61>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  8052e9:	83 ec 08             	sub    $0x8,%esp
  8052ec:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8052ef:	50                   	push   %eax
  8052f0:	68 31 50 80 00       	push   $0x805031
  8052f5:	e8 25 ff ff ff       	call   80521f <sys_untimeout>
    return 1;
  8052fa:	83 c4 10             	add    $0x10,%esp
  8052fd:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  805302:	c9                   	leave  
  805303:	c3                   	ret    

00805304 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  805304:	55                   	push   %ebp
  805305:	89 e5                	mov    %esp,%ebp
  805307:	53                   	push   %ebx
  805308:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  80530b:	6a 00                	push   $0x0
  80530d:	e8 1a 4a 00 00       	call   809d2c <sys_sem_new>
  805312:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  805314:	83 c4 08             	add    $0x8,%esp
  805317:	ff 75 08             	pushl  0x8(%ebp)
  80531a:	50                   	push   %eax
  80531b:	e8 81 ff ff ff       	call   8052a1 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  805320:	89 1c 24             	mov    %ebx,(%esp)
  805323:	e8 85 4a 00 00       	call   809dad <sys_sem_free>
}
  805328:	83 c4 10             	add    $0x10,%esp
  80532b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80532e:	c9                   	leave  
  80532f:	c3                   	ret    

00805330 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  805330:	55                   	push   %ebp
  805331:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  805333:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  805338:	5d                   	pop    %ebp
  805339:	c3                   	ret    

0080533a <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80533a:	55                   	push   %ebp
  80533b:	89 e5                	mov    %esp,%ebp
  80533d:	57                   	push   %edi
  80533e:	56                   	push   %esi
  80533f:	53                   	push   %ebx
  805340:	83 ec 04             	sub    $0x4,%esp
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805343:	8b 35 3c b2 b3 00    	mov    0xb3b23c,%esi
  805349:	0f b7 0d 0c 40 81 00 	movzwl 0x81400c,%ecx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805350:	8b 3d 50 b2 b3 00    	mov    0xb3b250,%edi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805356:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80535b:	89 45 f0             	mov    %eax,-0x10(%ebp)
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  80535e:	bb 00 10 00 00       	mov    $0x1000,%ebx
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  805363:	89 c8                	mov    %ecx,%eax
  805365:	66 83 c0 01          	add    $0x1,%ax
    port = TCP_LOCAL_PORT_RANGE_START;
  805369:	0f 48 c3             	cmovs  %ebx,%eax
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80536c:	89 f2                	mov    %esi,%edx
  80536e:	eb 0c                	jmp    80537c <tcp_new_port+0x42>
    if (pcb->local_port == port) {
  805370:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  805374:	66 39 c8             	cmp    %cx,%ax
  805377:	74 ea                	je     805363 <tcp_new_port+0x29>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805379:	8b 52 0c             	mov    0xc(%edx),%edx
  80537c:	85 d2                	test   %edx,%edx
  80537e:	75 f0                	jne    805370 <tcp_new_port+0x36>
  805380:	89 fa                	mov    %edi,%edx
  805382:	eb 0c                	jmp    805390 <tcp_new_port+0x56>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  805384:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  805388:	66 39 c8             	cmp    %cx,%ax
  80538b:	74 d6                	je     805363 <tcp_new_port+0x29>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80538d:	8b 52 0c             	mov    0xc(%edx),%edx
  805390:	85 d2                	test   %edx,%edx
  805392:	75 f0                	jne    805384 <tcp_new_port+0x4a>
  805394:	8b 55 f0             	mov    -0x10(%ebp),%edx
  805397:	eb 0c                	jmp    8053a5 <tcp_new_port+0x6b>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  805399:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80539d:	66 39 c8             	cmp    %cx,%ax
  8053a0:	74 c1                	je     805363 <tcp_new_port+0x29>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8053a2:	8b 52 0c             	mov    0xc(%edx),%edx
  8053a5:	85 d2                	test   %edx,%edx
  8053a7:	75 f0                	jne    805399 <tcp_new_port+0x5f>
  8053a9:	66 a3 0c 40 81 00    	mov    %ax,0x81400c
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  8053af:	83 c4 04             	add    $0x4,%esp
  8053b2:	5b                   	pop    %ebx
  8053b3:	5e                   	pop    %esi
  8053b4:	5f                   	pop    %edi
  8053b5:	5d                   	pop    %ebp
  8053b6:	c3                   	ret    

008053b7 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8053b7:	55                   	push   %ebp
  8053b8:	89 e5                	mov    %esp,%ebp
  8053ba:	57                   	push   %edi
  8053bb:	56                   	push   %esi
  8053bc:	53                   	push   %ebx
  8053bd:	83 ec 0c             	sub    $0xc,%esp
  8053c0:	8b 75 08             	mov    0x8(%ebp),%esi
  8053c3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8053c6:	8b 55 10             	mov    0x10(%ebp),%edx
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8053c9:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  8053cd:	74 17                	je     8053e6 <tcp_bind+0x2f>
  8053cf:	83 ec 04             	sub    $0x4,%esp
  8053d2:	68 28 1a 81 00       	push   $0x811a28
  8053d7:	68 05 01 00 00       	push   $0x105
  8053dc:	68 0a 1c 81 00       	push   $0x811c0a
  8053e1:	e8 68 90 00 00       	call   80e44e <_panic>
  8053e6:	89 d0                	mov    %edx,%eax

  if (port == 0) {
  8053e8:	66 85 d2             	test   %dx,%dx
  8053eb:	75 05                	jne    8053f2 <tcp_bind+0x3b>
    port = tcp_new_port();
  8053ed:	e8 48 ff ff ff       	call   80533a <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8053f2:	8b 15 44 b2 b3 00    	mov    0xb3b244,%edx
  8053f8:	eb 35                	jmp    80542f <tcp_bind+0x78>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  8053fa:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  8053fe:	75 2c                	jne    80542c <tcp_bind+0x75>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805400:	85 d2                	test   %edx,%edx
  805402:	0f 84 f3 00 00 00    	je     8054fb <tcp_bind+0x144>
  805408:	8b 0a                	mov    (%edx),%ecx
  80540a:	85 db                	test   %ebx,%ebx
  80540c:	0f 84 f0 00 00 00    	je     805502 <tcp_bind+0x14b>
  805412:	85 c9                	test   %ecx,%ecx
  805414:	0f 84 e8 00 00 00    	je     805502 <tcp_bind+0x14b>
          ip_addr_isany(ipaddr) ||
  80541a:	8b 3b                	mov    (%ebx),%edi
  80541c:	39 f9                	cmp    %edi,%ecx
  80541e:	0f 84 e5 00 00 00    	je     805509 <tcp_bind+0x152>
  805424:	85 ff                	test   %edi,%edi
  805426:	0f 84 dd 00 00 00    	je     805509 <tcp_bind+0x152>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80542c:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80542f:	85 d2                	test   %edx,%edx
  805431:	75 c7                	jne    8053fa <tcp_bind+0x43>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805433:	8b 15 3c b2 b3 00    	mov    0xb3b23c,%edx
  805439:	eb 35                	jmp    805470 <tcp_bind+0xb9>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80543b:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  80543f:	75 2c                	jne    80546d <tcp_bind+0xb6>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805441:	85 d2                	test   %edx,%edx
  805443:	0f 84 c7 00 00 00    	je     805510 <tcp_bind+0x159>
  805449:	8b 0a                	mov    (%edx),%ecx
  80544b:	85 db                	test   %ebx,%ebx
  80544d:	0f 84 c4 00 00 00    	je     805517 <tcp_bind+0x160>
  805453:	85 c9                	test   %ecx,%ecx
  805455:	0f 84 bc 00 00 00    	je     805517 <tcp_bind+0x160>
          ip_addr_isany(ipaddr) ||
  80545b:	8b 3b                	mov    (%ebx),%edi
  80545d:	39 f9                	cmp    %edi,%ecx
  80545f:	0f 84 b9 00 00 00    	je     80551e <tcp_bind+0x167>
  805465:	85 ff                	test   %edi,%edi
  805467:	0f 84 b1 00 00 00    	je     80551e <tcp_bind+0x167>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80546d:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805470:	85 d2                	test   %edx,%edx
  805472:	75 c7                	jne    80543b <tcp_bind+0x84>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805474:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  80547a:	eb 35                	jmp    8054b1 <tcp_bind+0xfa>
    if (cpcb->local_port == port) {
  80547c:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  805480:	75 2c                	jne    8054ae <tcp_bind+0xf7>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805482:	85 d2                	test   %edx,%edx
  805484:	0f 84 9b 00 00 00    	je     805525 <tcp_bind+0x16e>
  80548a:	8b 0a                	mov    (%edx),%ecx
  80548c:	85 db                	test   %ebx,%ebx
  80548e:	0f 84 98 00 00 00    	je     80552c <tcp_bind+0x175>
  805494:	85 c9                	test   %ecx,%ecx
  805496:	0f 84 90 00 00 00    	je     80552c <tcp_bind+0x175>
          ip_addr_isany(ipaddr) ||
  80549c:	8b 3b                	mov    (%ebx),%edi
  80549e:	39 f9                	cmp    %edi,%ecx
  8054a0:	0f 84 8d 00 00 00    	je     805533 <tcp_bind+0x17c>
  8054a6:	85 ff                	test   %edi,%edi
  8054a8:	0f 84 85 00 00 00    	je     805533 <tcp_bind+0x17c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8054ae:	8b 52 0c             	mov    0xc(%edx),%edx
  8054b1:	85 d2                	test   %edx,%edx
  8054b3:	75 c7                	jne    80547c <tcp_bind+0xc5>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8054b5:	8b 15 50 b2 b3 00    	mov    0xb3b250,%edx
  8054bb:	eb 0f                	jmp    8054cc <tcp_bind+0x115>
    if (cpcb->local_port == port) {
  8054bd:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  8054c1:	75 06                	jne    8054c9 <tcp_bind+0x112>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  8054c3:	8b 3b                	mov    (%ebx),%edi
  8054c5:	39 3a                	cmp    %edi,(%edx)
  8054c7:	74 71                	je     80553a <tcp_bind+0x183>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8054c9:	8b 52 0c             	mov    0xc(%edx),%edx
  8054cc:	85 d2                	test   %edx,%edx
  8054ce:	75 ed                	jne    8054bd <tcp_bind+0x106>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  8054d0:	85 db                	test   %ebx,%ebx
  8054d2:	74 09                	je     8054dd <tcp_bind+0x126>
  8054d4:	83 3b 00             	cmpl   $0x0,(%ebx)
  8054d7:	74 04                	je     8054dd <tcp_bind+0x126>
    pcb->local_ip = *ipaddr;
  8054d9:	8b 13                	mov    (%ebx),%edx
  8054db:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  8054dd:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  8054e1:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  8054e6:	89 46 0c             	mov    %eax,0xc(%esi)
  8054e9:	89 35 4c b2 b3 00    	mov    %esi,0xb3b24c
  8054ef:	e8 70 cd ff ff       	call   802264 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  8054f4:	b8 00 00 00 00       	mov    $0x0,%eax
  8054f9:	eb 44                	jmp    80553f <tcp_bind+0x188>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  8054fb:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805500:	eb 3d                	jmp    80553f <tcp_bind+0x188>
  805502:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805507:	eb 36                	jmp    80553f <tcp_bind+0x188>
  805509:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80550e:	eb 2f                	jmp    80553f <tcp_bind+0x188>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805510:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805515:	eb 28                	jmp    80553f <tcp_bind+0x188>
  805517:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80551c:	eb 21                	jmp    80553f <tcp_bind+0x188>
  80551e:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805523:	eb 1a                	jmp    80553f <tcp_bind+0x188>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805525:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80552a:	eb 13                	jmp    80553f <tcp_bind+0x188>
  80552c:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805531:	eb 0c                	jmp    80553f <tcp_bind+0x188>
  805533:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805538:	eb 05                	jmp    80553f <tcp_bind+0x188>
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80553a:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
  80553f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805542:	5b                   	pop    %ebx
  805543:	5e                   	pop    %esi
  805544:	5f                   	pop    %edi
  805545:	5d                   	pop    %ebp
  805546:	c3                   	ret    

00805547 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  805547:	55                   	push   %ebp
  805548:	89 e5                	mov    %esp,%ebp
  80554a:	57                   	push   %edi
  80554b:	56                   	push   %esi
  80554c:	53                   	push   %ebx
  80554d:	83 ec 1c             	sub    $0x1c,%esp
  805550:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805553:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  805557:	74 17                	je     805570 <tcp_listen_with_backlog+0x29>
  805559:	83 ec 04             	sub    $0x4,%esp
  80555c:	68 54 1a 81 00       	push   $0x811a54
  805561:	68 60 01 00 00       	push   $0x160
  805566:	68 0a 1c 81 00       	push   $0x811c0a
  80556b:	e8 de 8e 00 00       	call   80e44e <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805570:	83 ec 0c             	sub    $0xc,%esp
  805573:	6a 03                	push   $0x3
  805575:	e8 e2 ee ff ff       	call   80445c <memp_malloc>
  80557a:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  80557c:	83 c4 10             	add    $0x10,%esp
  80557f:	85 c0                	test   %eax,%eax
  805581:	0f 84 d2 00 00 00    	je     805659 <tcp_listen_with_backlog+0x112>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  805587:	8b 43 18             	mov    0x18(%ebx),%eax
  80558a:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  80558d:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805591:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  805595:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  80559c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8055a0:	83 c8 02             	or     $0x2,%eax
  8055a3:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  8055a7:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  8055ab:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  8055ae:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  8055b2:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  8055b5:	85 db                	test   %ebx,%ebx
  8055b7:	74 04                	je     8055bd <tcp_listen_with_backlog+0x76>
  8055b9:	8b 03                	mov    (%ebx),%eax
  8055bb:	eb 05                	jmp    8055c2 <tcp_listen_with_backlog+0x7b>
  8055bd:	b8 00 00 00 00       	mov    $0x0,%eax
  8055c2:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8055c4:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  8055c9:	39 c3                	cmp    %eax,%ebx
  8055cb:	75 0a                	jne    8055d7 <tcp_listen_with_backlog+0x90>
  8055cd:	8b 43 0c             	mov    0xc(%ebx),%eax
  8055d0:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  8055d5:	eb 4f                	jmp    805626 <tcp_listen_with_backlog+0xdf>
  8055d7:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  8055dc:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  8055e0:	89 df                	mov    %ebx,%edi
  8055e2:	eb 2c                	jmp    805610 <tcp_listen_with_backlog+0xc9>
  8055e4:	8b 50 0c             	mov    0xc(%eax),%edx
  8055e7:	39 d7                	cmp    %edx,%edi
  8055e9:	0f 94 c3             	sete   %bl
  8055ec:	85 d2                	test   %edx,%edx
  8055ee:	0f 95 c1             	setne  %cl
  8055f1:	84 cb                	test   %cl,%bl
  8055f3:	74 15                	je     80560a <tcp_listen_with_backlog+0xc3>
  8055f5:	89 fb                	mov    %edi,%ebx
  8055f7:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8055fb:	74 05                	je     805602 <tcp_listen_with_backlog+0xbb>
  8055fd:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  805602:	8b 53 0c             	mov    0xc(%ebx),%edx
  805605:	89 50 0c             	mov    %edx,0xc(%eax)
  805608:	eb 1c                	jmp    805626 <tcp_listen_with_backlog+0xdf>
  80560a:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
  80560e:	89 d0                	mov    %edx,%eax
  805610:	85 c0                	test   %eax,%eax
  805612:	75 d0                	jne    8055e4 <tcp_listen_with_backlog+0x9d>
  805614:	89 fb                	mov    %edi,%ebx
  805616:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  80561a:	74 0a                	je     805626 <tcp_listen_with_backlog+0xdf>
  80561c:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805623:	00 00 00 
  805626:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  80562d:	83 ec 08             	sub    $0x8,%esp
  805630:	53                   	push   %ebx
  805631:	6a 02                	push   $0x2
  805633:	e8 7a ee ff ff       	call   8044b2 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  805638:	c7 46 20 30 53 80 00 	movl   $0x805330,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  80563f:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  805644:	89 46 0c             	mov    %eax,0xc(%esi)
  805647:	89 35 44 b2 b3 00    	mov    %esi,0xb3b244
  80564d:	e8 12 cc ff ff       	call   802264 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  805652:	83 c4 10             	add    $0x10,%esp
  805655:	89 f0                	mov    %esi,%eax
  805657:	eb 05                	jmp    80565e <tcp_listen_with_backlog+0x117>
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  805659:	b8 00 00 00 00       	mov    $0x0,%eax
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  return (struct tcp_pcb *)lpcb;
}
  80565e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805661:	5b                   	pop    %ebx
  805662:	5e                   	pop    %esi
  805663:	5f                   	pop    %edi
  805664:	5d                   	pop    %ebp
  805665:	c3                   	ret    

00805666 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  805666:	55                   	push   %ebp
  805667:	89 e5                	mov    %esp,%ebp
  805669:	56                   	push   %esi
  80566a:	53                   	push   %ebx
  80566b:	8b 45 08             	mov    0x8(%ebp),%eax
  80566e:	8b 55 0c             	mov    0xc(%ebp),%edx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805671:	0f b7 58 28          	movzwl 0x28(%eax),%ebx
  805675:	0f b7 f3             	movzwl %bx,%esi
  805678:	0f b7 ca             	movzwl %dx,%ecx
  80567b:	01 f1                	add    %esi,%ecx
  80567d:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  805683:	76 0e                	jbe    805693 <tcp_recved+0x2d>
    pcb->rcv_wnd = TCP_WND;
  805685:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  80568b:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  805691:	eb 10                	jmp    8056a3 <tcp_recved+0x3d>
  } else {
    pcb->rcv_wnd += len;
  805693:	01 da                	add    %ebx,%edx
  805695:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805699:	66 3b 50 34          	cmp    0x34(%eax),%dx
  80569d:	72 04                	jb     8056a3 <tcp_recved+0x3d>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  80569f:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  8056a3:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  8056a7:	f6 c2 03             	test   $0x3,%dl
  8056aa:	75 24                	jne    8056d0 <tcp_recved+0x6a>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  8056ac:	f6 c2 01             	test   $0x1,%dl
  8056af:	74 17                	je     8056c8 <tcp_recved+0x62>
  8056b1:	83 e2 fe             	and    $0xfffffffe,%edx
  8056b4:	83 ca 02             	or     $0x2,%edx
  8056b7:	88 50 20             	mov    %dl,0x20(%eax)
  8056ba:	83 ec 0c             	sub    $0xc,%esp
  8056bd:	50                   	push   %eax
  8056be:	e8 37 29 00 00       	call   807ffa <tcp_output>
  8056c3:	83 c4 10             	add    $0x10,%esp
  8056c6:	eb 27                	jmp    8056ef <tcp_recved+0x89>
  8056c8:	83 ca 01             	or     $0x1,%edx
  8056cb:	88 50 20             	mov    %dl,0x20(%eax)
  8056ce:	eb 1f                	jmp    8056ef <tcp_recved+0x89>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  8056d0:	f6 c2 01             	test   $0x1,%dl
  8056d3:	74 1a                	je     8056ef <tcp_recved+0x89>
  8056d5:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  8056db:	76 12                	jbe    8056ef <tcp_recved+0x89>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  8056dd:	83 ca 02             	or     $0x2,%edx
  8056e0:	88 50 20             	mov    %dl,0x20(%eax)
  8056e3:	83 ec 0c             	sub    $0xc,%esp
  8056e6:	50                   	push   %eax
  8056e7:	e8 0e 29 00 00       	call   807ffa <tcp_output>
  8056ec:	83 c4 10             	add    $0x10,%esp
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  8056ef:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8056f2:	5b                   	pop    %ebx
  8056f3:	5e                   	pop    %esi
  8056f4:	5d                   	pop    %ebp
  8056f5:	c3                   	ret    

008056f6 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  8056f6:	55                   	push   %ebp
  8056f7:	89 e5                	mov    %esp,%ebp
  8056f9:	53                   	push   %ebx
  8056fa:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8056fd:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  805703:	eb 5d                	jmp    805762 <tcp_fasttmr+0x6c>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  805705:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80570b:	85 c0                	test   %eax,%eax
  80570d:	74 32                	je     805741 <tcp_fasttmr+0x4b>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80570f:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  805715:	85 d2                	test   %edx,%edx
  805717:	74 12                	je     80572b <tcp_fasttmr+0x35>
  805719:	6a 00                	push   $0x0
  80571b:	50                   	push   %eax
  80571c:	53                   	push   %ebx
  80571d:	ff 73 18             	pushl  0x18(%ebx)
  805720:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  805722:	83 c4 10             	add    $0x10,%esp
  805725:	84 c0                	test   %al,%al
  805727:	75 18                	jne    805741 <tcp_fasttmr+0x4b>
  805729:	eb 0c                	jmp    805737 <tcp_fasttmr+0x41>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80572b:	83 ec 0c             	sub    $0xc,%esp
  80572e:	50                   	push   %eax
  80572f:	e8 f1 f0 ff ff       	call   804825 <pbuf_free>
  805734:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  805737:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80573e:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  805741:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  805745:	a8 01                	test   $0x1,%al
  805747:	74 16                	je     80575f <tcp_fasttmr+0x69>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  805749:	83 c8 02             	or     $0x2,%eax
  80574c:	88 43 20             	mov    %al,0x20(%ebx)
  80574f:	83 ec 0c             	sub    $0xc,%esp
  805752:	53                   	push   %ebx
  805753:	e8 a2 28 00 00       	call   807ffa <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805758:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  80575c:	83 c4 10             	add    $0x10,%esp
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80575f:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  805762:	85 db                	test   %ebx,%ebx
  805764:	75 9f                	jne    805705 <tcp_fasttmr+0xf>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  805766:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805769:	c9                   	leave  
  80576a:	c3                   	ret    

0080576b <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  80576b:	55                   	push   %ebp
  80576c:	89 e5                	mov    %esp,%ebp
  80576e:	56                   	push   %esi
  80576f:	53                   	push   %ebx
  805770:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  
  if (seg != NULL) {
  805773:	85 db                	test   %ebx,%ebx
  805775:	74 2a                	je     8057a1 <tcp_seg_free+0x36>
    if (seg->p != NULL) {
  805777:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  80577a:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
    if (seg->p != NULL) {
  80577f:	85 c0                	test   %eax,%eax
  805781:	74 0e                	je     805791 <tcp_seg_free+0x26>
      count = pbuf_free(seg->p);
  805783:	83 ec 0c             	sub    $0xc,%esp
  805786:	50                   	push   %eax
  805787:	e8 99 f0 ff ff       	call   804825 <pbuf_free>
  80578c:	89 c6                	mov    %eax,%esi
  80578e:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  805791:	83 ec 08             	sub    $0x8,%esp
  805794:	53                   	push   %ebx
  805795:	6a 04                	push   $0x4
  805797:	e8 16 ed ff ff       	call   8044b2 <memp_free>
  80579c:	83 c4 10             	add    $0x10,%esp
  80579f:	eb 05                	jmp    8057a6 <tcp_seg_free+0x3b>
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  8057a1:	be 00 00 00 00       	mov    $0x0,%esi
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  }
  return count;
}
  8057a6:	89 f0                	mov    %esi,%eax
  8057a8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8057ab:	5b                   	pop    %ebx
  8057ac:	5e                   	pop    %esi
  8057ad:	5d                   	pop    %ebp
  8057ae:	c3                   	ret    

008057af <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  8057af:	55                   	push   %ebp
  8057b0:	89 e5                	mov    %esp,%ebp
  8057b2:	56                   	push   %esi
  8057b3:	53                   	push   %ebx
  8057b4:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  8057b7:	bb 00 00 00 00       	mov    $0x0,%ebx
  struct tcp_seg *next;
  while (seg != NULL) {
  8057bc:	eb 12                	jmp    8057d0 <tcp_segs_free+0x21>
    next = seg->next;
  8057be:	8b 30                	mov    (%eax),%esi
    count += tcp_seg_free(seg);
  8057c0:	83 ec 0c             	sub    $0xc,%esp
  8057c3:	50                   	push   %eax
  8057c4:	e8 a2 ff ff ff       	call   80576b <tcp_seg_free>
  8057c9:	01 c3                	add    %eax,%ebx
  8057cb:	83 c4 10             	add    $0x10,%esp
    seg = next;
  8057ce:	89 f0                	mov    %esi,%eax
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  8057d0:	85 c0                	test   %eax,%eax
  8057d2:	75 ea                	jne    8057be <tcp_segs_free+0xf>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  8057d4:	89 d8                	mov    %ebx,%eax
  8057d6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8057d9:	5b                   	pop    %ebx
  8057da:	5e                   	pop    %esi
  8057db:	5d                   	pop    %ebp
  8057dc:	c3                   	ret    

008057dd <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8057dd:	55                   	push   %ebp
  8057de:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  8057e0:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057e3:	8b 45 08             	mov    0x8(%ebp),%eax
  8057e6:	88 50 14             	mov    %dl,0x14(%eax)
}
  8057e9:	5d                   	pop    %ebp
  8057ea:	c3                   	ret    

008057eb <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  8057eb:	55                   	push   %ebp
  8057ec:	89 e5                	mov    %esp,%ebp
  8057ee:	53                   	push   %ebx
  8057ef:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  8057f2:	6a 04                	push   $0x4
  8057f4:	e8 63 ec ff ff       	call   80445c <memp_malloc>
  8057f9:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  8057fb:	83 c4 10             	add    $0x10,%esp
  8057fe:	85 c0                	test   %eax,%eax
  805800:	74 1c                	je     80581e <tcp_seg_copy+0x33>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  805802:	83 ec 04             	sub    $0x4,%esp
  805805:	6a 14                	push   $0x14
  805807:	ff 75 08             	pushl  0x8(%ebp)
  80580a:	50                   	push   %eax
  80580b:	e8 96 94 00 00       	call   80eca6 <memcpy>
  pbuf_ref(cseg->p);
  805810:	83 c4 04             	add    $0x4,%esp
  805813:	ff 73 04             	pushl  0x4(%ebx)
  805816:	e8 81 f4 ff ff       	call   804c9c <pbuf_ref>
  return cseg;
  80581b:	83 c4 10             	add    $0x10,%esp
}
  80581e:	89 d8                	mov    %ebx,%eax
  805820:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805823:	c9                   	leave  
  805824:	c3                   	ret    

00805825 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  805825:	55                   	push   %ebp
  805826:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  805828:	8b 55 0c             	mov    0xc(%ebp),%edx
  80582b:	8b 45 08             	mov    0x8(%ebp),%eax
  80582e:	89 50 18             	mov    %edx,0x18(%eax)
}
  805831:	5d                   	pop    %ebp
  805832:	c3                   	ret    

00805833 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  805833:	55                   	push   %ebp
  805834:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  805836:	8b 55 0c             	mov    0xc(%ebp),%edx
  805839:	8b 45 08             	mov    0x8(%ebp),%eax
  80583c:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  805842:	5d                   	pop    %ebp
  805843:	c3                   	ret    

00805844 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805844:	55                   	push   %ebp
  805845:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  805847:	8b 55 0c             	mov    0xc(%ebp),%edx
  80584a:	8b 45 08             	mov    0x8(%ebp),%eax
  80584d:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  805853:	5d                   	pop    %ebp
  805854:	c3                   	ret    

00805855 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  805855:	55                   	push   %ebp
  805856:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  805858:	8b 55 0c             	mov    0xc(%ebp),%edx
  80585b:	8b 45 08             	mov    0x8(%ebp),%eax
  80585e:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805864:	5d                   	pop    %ebp
  805865:	c3                   	ret    

00805866 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805866:	55                   	push   %ebp
  805867:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805869:	8b 55 0c             	mov    0xc(%ebp),%edx
  80586c:	8b 45 08             	mov    0x8(%ebp),%eax
  80586f:	89 50 20             	mov    %edx,0x20(%eax)
}
  805872:	5d                   	pop    %ebp
  805873:	c3                   	ret    

00805874 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805874:	55                   	push   %ebp
  805875:	89 e5                	mov    %esp,%ebp
  805877:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  80587a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80587d:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  805883:	8b 55 10             	mov    0x10(%ebp),%edx
  805886:	88 50 31             	mov    %dl,0x31(%eax)
}
  805889:	5d                   	pop    %ebp
  80588a:	c3                   	ret    

0080588b <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  80588b:	55                   	push   %ebp
  80588c:	89 e5                	mov    %esp,%ebp
  80588e:	53                   	push   %ebx
  80588f:	83 ec 04             	sub    $0x4,%esp
  805892:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  805895:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  805898:	83 f8 0a             	cmp    $0xa,%eax
  80589b:	74 64                	je     805901 <tcp_pcb_purge+0x76>
  80589d:	83 f8 01             	cmp    $0x1,%eax
  8058a0:	76 5f                	jbe    805901 <tcp_pcb_purge+0x76>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  8058a2:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8058a8:	85 c0                	test   %eax,%eax
  8058aa:	74 16                	je     8058c2 <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  8058ac:	83 ec 0c             	sub    $0xc,%esp
  8058af:	50                   	push   %eax
  8058b0:	e8 70 ef ff ff       	call   804825 <pbuf_free>
      pcb->refused_data = NULL;
  8058b5:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8058bc:	00 00 00 
  8058bf:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  8058c2:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  8058c8:	83 ec 0c             	sub    $0xc,%esp
  8058cb:	ff 73 7c             	pushl  0x7c(%ebx)
  8058ce:	e8 dc fe ff ff       	call   8057af <tcp_segs_free>
    pcb->ooseq = NULL;
  8058d3:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  8058da:	83 c4 04             	add    $0x4,%esp
  8058dd:	ff 73 74             	pushl  0x74(%ebx)
  8058e0:	e8 ca fe ff ff       	call   8057af <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  8058e5:	83 c4 04             	add    $0x4,%esp
  8058e8:	ff 73 78             	pushl  0x78(%ebx)
  8058eb:	e8 bf fe ff ff       	call   8057af <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  8058f0:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  8058f7:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  8058fe:	83 c4 10             	add    $0x10,%esp
  }
}
  805901:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805904:	c9                   	leave  
  805905:	c3                   	ret    

00805906 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805906:	55                   	push   %ebp
  805907:	89 e5                	mov    %esp,%ebp
  805909:	57                   	push   %edi
  80590a:	56                   	push   %esi
  80590b:	53                   	push   %ebx
  80590c:	83 ec 1c             	sub    $0x1c,%esp
  80590f:	8b 45 08             	mov    0x8(%ebp),%eax
  805912:	8b 7d 0c             	mov    0xc(%ebp),%edi
  805915:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  TCP_RMV(pcblist, pcb);
  805918:	8b 10                	mov    (%eax),%edx
  80591a:	39 fa                	cmp    %edi,%edx
  80591c:	75 07                	jne    805925 <tcp_pcb_remove+0x1f>
  80591e:	8b 52 0c             	mov    0xc(%edx),%edx
  805921:	89 10                	mov    %edx,(%eax)
  805923:	eb 55                	jmp    80597a <tcp_pcb_remove+0x74>
  805925:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80592b:	bf 00 00 00 00       	mov    $0x0,%edi
  805930:	eb 34                	jmp    805966 <tcp_pcb_remove+0x60>
  805932:	8b 42 0c             	mov    0xc(%edx),%eax
  805935:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  805938:	0f 94 c1             	sete   %cl
  80593b:	89 ce                	mov    %ecx,%esi
  80593d:	85 c0                	test   %eax,%eax
  80593f:	0f 95 c1             	setne  %cl
  805942:	89 f3                	mov    %esi,%ebx
  805944:	84 cb                	test   %cl,%bl
  805946:	74 17                	je     80595f <tcp_pcb_remove+0x59>
  805948:	89 f8                	mov    %edi,%eax
  80594a:	84 c0                	test   %al,%al
  80594c:	74 06                	je     805954 <tcp_pcb_remove+0x4e>
  80594e:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805954:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805957:	8b 40 0c             	mov    0xc(%eax),%eax
  80595a:	89 42 0c             	mov    %eax,0xc(%edx)
  80595d:	eb 1b                	jmp    80597a <tcp_pcb_remove+0x74>
  80595f:	bf 01 00 00 00       	mov    $0x1,%edi
  805964:	89 c2                	mov    %eax,%edx
  805966:	85 d2                	test   %edx,%edx
  805968:	75 c8                	jne    805932 <tcp_pcb_remove+0x2c>
  80596a:	89 f8                	mov    %edi,%eax
  80596c:	84 c0                	test   %al,%al
  80596e:	74 0a                	je     80597a <tcp_pcb_remove+0x74>
  805970:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805977:	00 00 00 
  80597a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80597d:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)

  tcp_pcb_purge(pcb);
  805984:	83 ec 0c             	sub    $0xc,%esp
  805987:	57                   	push   %edi
  805988:	e8 fe fe ff ff       	call   80588b <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  80598d:	8b 47 10             	mov    0x10(%edi),%eax
  805990:	83 c4 10             	add    $0x10,%esp
  805993:	83 f8 0a             	cmp    $0xa,%eax
  805996:	74 22                	je     8059ba <tcp_pcb_remove+0xb4>
  805998:	83 f8 01             	cmp    $0x1,%eax
  80599b:	74 1d                	je     8059ba <tcp_pcb_remove+0xb4>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  80599d:	0f b6 47 20          	movzbl 0x20(%edi),%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  8059a1:	a8 01                	test   $0x1,%al
  8059a3:	74 15                	je     8059ba <tcp_pcb_remove+0xb4>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  8059a5:	83 c8 02             	or     $0x2,%eax
  8059a8:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8059ab:	88 46 20             	mov    %al,0x20(%esi)
    tcp_output(pcb);
  8059ae:	83 ec 0c             	sub    $0xc,%esp
  8059b1:	56                   	push   %esi
  8059b2:	e8 43 26 00 00       	call   807ffa <tcp_output>
  8059b7:	83 c4 10             	add    $0x10,%esp
  }

  if (pcb->state != LISTEN) {
  8059ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8059bd:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  8059c1:	74 5d                	je     805a20 <tcp_pcb_remove+0x11a>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  8059c3:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
  8059c7:	74 17                	je     8059e0 <tcp_pcb_remove+0xda>
  8059c9:	83 ec 04             	sub    $0x4,%esp
  8059cc:	68 1e 1c 81 00       	push   $0x811c1e
  8059d1:	68 b4 04 00 00       	push   $0x4b4
  8059d6:	68 0a 1c 81 00       	push   $0x811c0a
  8059db:	e8 6e 8a 00 00       	call   80e44e <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  8059e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8059e3:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  8059e7:	74 17                	je     805a00 <tcp_pcb_remove+0xfa>
  8059e9:	83 ec 04             	sub    $0x4,%esp
  8059ec:	68 36 1c 81 00       	push   $0x811c36
  8059f1:	68 b5 04 00 00       	push   $0x4b5
  8059f6:	68 0a 1c 81 00       	push   $0x811c0a
  8059fb:	e8 4e 8a 00 00       	call   80e44e <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805a00:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805a03:	83 78 7c 00          	cmpl   $0x0,0x7c(%eax)
  805a07:	74 17                	je     805a20 <tcp_pcb_remove+0x11a>
  805a09:	83 ec 04             	sub    $0x4,%esp
  805a0c:	68 4f 1c 81 00       	push   $0x811c4f
  805a11:	68 b7 04 00 00       	push   $0x4b7
  805a16:	68 0a 1c 81 00       	push   $0x811c0a
  805a1b:	e8 2e 8a 00 00       	call   80e44e <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  805a20:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805a23:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805a2a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805a2d:	5b                   	pop    %ebx
  805a2e:	5e                   	pop    %esi
  805a2f:	5f                   	pop    %edi
  805a30:	5d                   	pop    %ebp
  805a31:	c3                   	ret    

00805a32 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  805a32:	55                   	push   %ebp
  805a33:	89 e5                	mov    %esp,%ebp
  805a35:	57                   	push   %edi
  805a36:	56                   	push   %esi
  805a37:	53                   	push   %ebx
  805a38:	83 ec 1c             	sub    $0x1c,%esp
  805a3b:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  805a3e:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  805a42:	0f 87 37 01 00 00    	ja     805b7f <tcp_close+0x14d>
  805a48:	8b 43 10             	mov    0x10(%ebx),%eax
  805a4b:	ff 24 85 68 1c 81 00 	jmp    *0x811c68(,%eax,4)
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805a52:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  805a57:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  805a5a:	39 c3                	cmp    %eax,%ebx
  805a5c:	75 0a                	jne    805a68 <tcp_close+0x36>
  805a5e:	8b 43 0c             	mov    0xc(%ebx),%eax
  805a61:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805a66:	eb 5e                	jmp    805ac6 <tcp_close+0x94>
  805a68:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805a6b:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  805a70:	bf 00 00 00 00       	mov    $0x0,%edi
  805a75:	eb 39                	jmp    805ab0 <tcp_close+0x7e>
  805a77:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805a7a:	8b 40 0c             	mov    0xc(%eax),%eax
  805a7d:	39 c3                	cmp    %eax,%ebx
  805a7f:	0f 94 c1             	sete   %cl
  805a82:	89 ce                	mov    %ecx,%esi
  805a84:	85 c0                	test   %eax,%eax
  805a86:	0f 95 c1             	setne  %cl
  805a89:	89 f2                	mov    %esi,%edx
  805a8b:	84 ca                	test   %cl,%dl
  805a8d:	74 19                	je     805aa8 <tcp_close+0x76>
  805a8f:	89 f8                	mov    %edi,%eax
  805a91:	84 c0                	test   %al,%al
  805a93:	74 08                	je     805a9d <tcp_close+0x6b>
  805a95:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805a98:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  805a9d:	8b 43 0c             	mov    0xc(%ebx),%eax
  805aa0:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  805aa3:	89 47 0c             	mov    %eax,0xc(%edi)
  805aa6:	eb 1e                	jmp    805ac6 <tcp_close+0x94>
  805aa8:	bf 01 00 00 00       	mov    $0x1,%edi
  805aad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  805ab0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  805ab4:	75 c1                	jne    805a77 <tcp_close+0x45>
  805ab6:	89 f8                	mov    %edi,%eax
  805ab8:	84 c0                	test   %al,%al
  805aba:	74 0a                	je     805ac6 <tcp_close+0x94>
  805abc:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805ac3:	00 00 00 
  805ac6:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  805acd:	83 ec 08             	sub    $0x8,%esp
  805ad0:	53                   	push   %ebx
  805ad1:	6a 02                	push   $0x2
  805ad3:	e8 da e9 ff ff       	call   8044b2 <memp_free>
    pcb = NULL;
    break;
  805ad8:	83 c4 10             	add    $0x10,%esp
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  805adb:	b8 00 00 00 00       	mov    $0x0,%eax
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  805ae0:	e9 bb 00 00 00       	jmp    805ba0 <tcp_close+0x16e>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  805ae5:	83 ec 08             	sub    $0x8,%esp
  805ae8:	53                   	push   %ebx
  805ae9:	68 44 b2 b3 00       	push   $0xb3b244
  805aee:	e8 13 fe ff ff       	call   805906 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  805af3:	83 c4 08             	add    $0x8,%esp
  805af6:	53                   	push   %ebx
  805af7:	6a 03                	push   $0x3
  805af9:	e8 b4 e9 ff ff       	call   8044b2 <memp_free>
    pcb = NULL;
    break;
  805afe:	83 c4 10             	add    $0x10,%esp
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
  805b01:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  805b06:	e9 95 00 00 00       	jmp    805ba0 <tcp_close+0x16e>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805b0b:	83 ec 08             	sub    $0x8,%esp
  805b0e:	53                   	push   %ebx
  805b0f:	68 3c b2 b3 00       	push   $0xb3b23c
  805b14:	e8 ed fd ff ff       	call   805906 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805b19:	83 c4 08             	add    $0x8,%esp
  805b1c:	53                   	push   %ebx
  805b1d:	6a 02                	push   $0x2
  805b1f:	e8 8e e9 ff ff       	call   8044b2 <memp_free>
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  805b24:	83 c4 10             	add    $0x10,%esp
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
  805b27:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  805b2c:	eb 72                	jmp    805ba0 <tcp_close+0x16e>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805b2e:	83 ec 08             	sub    $0x8,%esp
  805b31:	6a 01                	push   $0x1
  805b33:	53                   	push   %ebx
  805b34:	e8 4f 24 00 00       	call   807f88 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805b39:	83 c4 10             	add    $0x10,%esp
  805b3c:	84 c0                	test   %al,%al
  805b3e:	75 60                	jne    805ba0 <tcp_close+0x16e>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  805b40:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805b47:	eb 3b                	jmp    805b84 <tcp_close+0x152>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805b49:	83 ec 08             	sub    $0x8,%esp
  805b4c:	6a 01                	push   $0x1
  805b4e:	53                   	push   %ebx
  805b4f:	e8 34 24 00 00       	call   807f88 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805b54:	83 c4 10             	add    $0x10,%esp
  805b57:	84 c0                	test   %al,%al
  805b59:	75 45                	jne    805ba0 <tcp_close+0x16e>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  805b5b:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805b62:	eb 20                	jmp    805b84 <tcp_close+0x152>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805b64:	83 ec 08             	sub    $0x8,%esp
  805b67:	6a 01                	push   $0x1
  805b69:	53                   	push   %ebx
  805b6a:	e8 19 24 00 00       	call   807f88 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805b6f:	83 c4 10             	add    $0x10,%esp
  805b72:	84 c0                	test   %al,%al
  805b74:	75 2a                	jne    805ba0 <tcp_close+0x16e>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  805b76:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  805b7d:	eb 05                	jmp    805b84 <tcp_close+0x152>
    }
    break;
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
    pcb = NULL;
  805b7f:	bb 00 00 00 00       	mov    $0x0,%ebx
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  805b84:	85 db                	test   %ebx,%ebx
  805b86:	74 13                	je     805b9b <tcp_close+0x169>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  805b88:	83 ec 0c             	sub    $0xc,%esp
  805b8b:	53                   	push   %ebx
  805b8c:	e8 69 24 00 00       	call   807ffa <tcp_output>
  805b91:	83 c4 10             	add    $0x10,%esp
  805b94:	b8 00 00 00 00       	mov    $0x0,%eax
  805b99:	eb 05                	jmp    805ba0 <tcp_close+0x16e>
  805b9b:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return err;
}
  805ba0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805ba3:	5b                   	pop    %ebx
  805ba4:	5e                   	pop    %esi
  805ba5:	5f                   	pop    %edi
  805ba6:	5d                   	pop    %ebp
  805ba7:	c3                   	ret    

00805ba8 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  805ba8:	55                   	push   %ebp
  805ba9:	89 e5                	mov    %esp,%ebp
  805bab:	83 ec 08             	sub    $0x8,%esp
  805bae:	8b 45 10             	mov    0x10(%ebp),%eax
  805bb1:	8b 55 14             	mov    0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  805bb4:	85 c0                	test   %eax,%eax
  805bb6:	74 13                	je     805bcb <tcp_recv_null+0x23>
    pbuf_free(p);
  805bb8:	83 ec 0c             	sub    $0xc,%esp
  805bbb:	50                   	push   %eax
  805bbc:	e8 64 ec ff ff       	call   804825 <pbuf_free>
  805bc1:	83 c4 10             	add    $0x10,%esp
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
  805bc4:	b8 00 00 00 00       	mov    $0x0,%eax
  805bc9:	eb 17                	jmp    805be2 <tcp_recv_null+0x3a>
  805bcb:	b8 00 00 00 00       	mov    $0x0,%eax
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  arg = arg;
  if (p != NULL) {
    pbuf_free(p);
  } else if (err == ERR_OK) {
  805bd0:	84 d2                	test   %dl,%dl
  805bd2:	75 0e                	jne    805be2 <tcp_recv_null+0x3a>
    return tcp_close(pcb);
  805bd4:	83 ec 0c             	sub    $0xc,%esp
  805bd7:	ff 75 0c             	pushl  0xc(%ebp)
  805bda:	e8 53 fe ff ff       	call   805a32 <tcp_close>
  805bdf:	83 c4 10             	add    $0x10,%esp
  }
  return ERR_OK;
}
  805be2:	c9                   	leave  
  805be3:	c3                   	ret    

00805be4 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  805be4:	55                   	push   %ebp
  805be5:	89 e5                	mov    %esp,%ebp
  805be7:	57                   	push   %edi
  805be8:	56                   	push   %esi
  805be9:	53                   	push   %ebx
  805bea:	83 ec 2c             	sub    $0x2c,%esp
  805bed:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  805bf0:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805bf4:	75 21                	jne    805c17 <tcp_abort+0x33>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805bf6:	83 ec 08             	sub    $0x8,%esp
  805bf9:	53                   	push   %ebx
  805bfa:	68 50 b2 b3 00       	push   $0xb3b250
  805bff:	e8 02 fd ff ff       	call   805906 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805c04:	83 c4 08             	add    $0x8,%esp
  805c07:	53                   	push   %ebx
  805c08:	6a 02                	push   $0x2
  805c0a:	e8 a3 e8 ff ff       	call   8044b2 <memp_free>
  805c0f:	83 c4 10             	add    $0x10,%esp
  805c12:	e9 d1 00 00 00       	jmp    805ce8 <tcp_abort+0x104>
  } else {
    seqno = pcb->snd_nxt;
  805c17:	8b 43 54             	mov    0x54(%ebx),%eax
  805c1a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805c1d:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805c20:	85 db                	test   %ebx,%ebx
  805c22:	74 04                	je     805c28 <tcp_abort+0x44>
  805c24:	8b 03                	mov    (%ebx),%eax
  805c26:	eb 05                	jmp    805c2d <tcp_abort+0x49>
  805c28:	b8 00 00 00 00       	mov    $0x0,%eax
  805c2d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805c30:	83 fb fc             	cmp    $0xfffffffc,%ebx
  805c33:	74 05                	je     805c3a <tcp_abort+0x56>
  805c35:	8b 43 04             	mov    0x4(%ebx),%eax
  805c38:	eb 05                	jmp    805c3f <tcp_abort+0x5b>
  805c3a:	b8 00 00 00 00       	mov    $0x0,%eax
  805c3f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805c42:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805c46:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805c4a:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805c4e:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  805c52:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  805c58:	8b 43 18             	mov    0x18(%ebx),%eax
  805c5b:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805c5e:	83 ec 08             	sub    $0x8,%esp
  805c61:	53                   	push   %ebx
  805c62:	68 3c b2 b3 00       	push   $0xb3b23c
  805c67:	e8 9a fc ff ff       	call   805906 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805c6c:	8b 43 78             	mov    0x78(%ebx),%eax
  805c6f:	83 c4 10             	add    $0x10,%esp
  805c72:	85 c0                	test   %eax,%eax
  805c74:	74 0c                	je     805c82 <tcp_abort+0x9e>
      tcp_segs_free(pcb->unacked);
  805c76:	83 ec 0c             	sub    $0xc,%esp
  805c79:	50                   	push   %eax
  805c7a:	e8 30 fb ff ff       	call   8057af <tcp_segs_free>
  805c7f:	83 c4 10             	add    $0x10,%esp
    }
    if (pcb->unsent != NULL) {
  805c82:	8b 43 74             	mov    0x74(%ebx),%eax
  805c85:	85 c0                	test   %eax,%eax
  805c87:	74 0c                	je     805c95 <tcp_abort+0xb1>
      tcp_segs_free(pcb->unsent);
  805c89:	83 ec 0c             	sub    $0xc,%esp
  805c8c:	50                   	push   %eax
  805c8d:	e8 1d fb ff ff       	call   8057af <tcp_segs_free>
  805c92:	83 c4 10             	add    $0x10,%esp
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  805c95:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805c98:	85 c0                	test   %eax,%eax
  805c9a:	74 0c                	je     805ca8 <tcp_abort+0xc4>
      tcp_segs_free(pcb->ooseq);
  805c9c:	83 ec 0c             	sub    $0xc,%esp
  805c9f:	50                   	push   %eax
  805ca0:	e8 0a fb ff ff       	call   8057af <tcp_segs_free>
  805ca5:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  805ca8:	83 ec 08             	sub    $0x8,%esp
  805cab:	53                   	push   %ebx
  805cac:	6a 02                	push   $0x2
  805cae:	e8 ff e7 ff ff       	call   8044b2 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805cb3:	83 c4 10             	add    $0x10,%esp
  805cb6:	85 f6                	test   %esi,%esi
  805cb8:	74 0d                	je     805cc7 <tcp_abort+0xe3>
  805cba:	83 ec 08             	sub    $0x8,%esp
  805cbd:	6a fb                	push   $0xfffffffb
  805cbf:	ff 75 cc             	pushl  -0x34(%ebp)
  805cc2:	ff d6                	call   *%esi
  805cc4:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805cc7:	83 ec 08             	sub    $0x8,%esp
  805cca:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805cce:	50                   	push   %eax
  805ccf:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805cd3:	50                   	push   %eax
  805cd4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805cd7:	50                   	push   %eax
  805cd8:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805cdb:	50                   	push   %eax
  805cdc:	57                   	push   %edi
  805cdd:	ff 75 d4             	pushl  -0x2c(%ebp)
  805ce0:	e8 8c 27 00 00       	call   808471 <tcp_rst>
  805ce5:	83 c4 20             	add    $0x20,%esp
  }
}
  805ce8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805ceb:	5b                   	pop    %ebx
  805cec:	5e                   	pop    %esi
  805ced:	5f                   	pop    %edi
  805cee:	5d                   	pop    %ebp
  805cef:	c3                   	ret    

00805cf0 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  805cf0:	55                   	push   %ebp
  805cf1:	89 e5                	mov    %esp,%ebp
  805cf3:	57                   	push   %edi
  805cf4:	56                   	push   %esi
  805cf5:	53                   	push   %ebx
  805cf6:	83 ec 1c             	sub    $0x1c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  805cf9:	83 05 40 b2 b3 00 01 	addl   $0x1,0xb3b240

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  805d00:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  805d06:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)

  ++tcp_ticks;

  /* Steps through all of the active PCBs. */
  prev = NULL;
  805d0a:	bf 00 00 00 00       	mov    $0x0,%edi
  805d0f:	e9 53 03 00 00       	jmp    806067 <tcp_slowtmr+0x377>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805d14:	8b 43 10             	mov    0x10(%ebx),%eax
  805d17:	85 c0                	test   %eax,%eax
  805d19:	75 17                	jne    805d32 <tcp_slowtmr+0x42>
  805d1b:	83 ec 04             	sub    $0x4,%esp
  805d1e:	68 78 1a 81 00       	push   $0x811a78
  805d23:	68 36 02 00 00       	push   $0x236
  805d28:	68 0a 1c 81 00       	push   $0x811c0a
  805d2d:	e8 1c 87 00 00       	call   80e44e <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805d32:	83 f8 01             	cmp    $0x1,%eax
  805d35:	75 17                	jne    805d4e <tcp_slowtmr+0x5e>
  805d37:	83 ec 04             	sub    $0x4,%esp
  805d3a:	68 a4 1a 81 00       	push   $0x811aa4
  805d3f:	68 37 02 00 00       	push   $0x237
  805d44:	68 0a 1c 81 00       	push   $0x811c0a
  805d49:	e8 00 87 00 00       	call   80e44e <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805d4e:	83 f8 0a             	cmp    $0xa,%eax
  805d51:	75 17                	jne    805d6a <tcp_slowtmr+0x7a>
  805d53:	83 ec 04             	sub    $0x4,%esp
  805d56:	68 d0 1a 81 00       	push   $0x811ad0
  805d5b:	68 38 02 00 00       	push   $0x238
  805d60:	68 0a 1c 81 00       	push   $0x811c0a
  805d65:	e8 e4 86 00 00       	call   80e44e <_panic>

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805d6a:	83 f8 02             	cmp    $0x2,%eax
  805d6d:	75 12                	jne    805d81 <tcp_slowtmr+0x91>
  805d6f:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805d73:	80 fa 06             	cmp    $0x6,%dl
  805d76:	0f 85 ac 03 00 00    	jne    806128 <tcp_slowtmr+0x438>
  805d7c:	e9 a0 01 00 00       	jmp    805f21 <tcp_slowtmr+0x231>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805d81:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  805d85:	be 01 00 00 00       	mov    $0x1,%esi

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805d8a:	80 fa 0c             	cmp    $0xc,%dl
  805d8d:	0f 84 ee 00 00 00    	je     805e81 <tcp_slowtmr+0x191>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  805d93:	0f b6 8b a4 00 00 00 	movzbl 0xa4(%ebx),%ecx
  805d9a:	84 c9                	test   %cl,%cl
  805d9c:	74 54                	je     805df2 <tcp_slowtmr+0x102>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  805d9e:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  805da4:	83 c0 01             	add    $0x1,%eax
  805da7:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805dad:	0f b6 d1             	movzbl %cl,%edx
  805db0:	0f b6 92 87 1c 81 00 	movzbl 0x811c87(%edx),%edx
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805db7:	be 00 00 00 00       	mov    $0x0,%esi
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805dbc:	39 d0                	cmp    %edx,%eax
  805dbe:	0f 82 bd 00 00 00    	jb     805e81 <tcp_slowtmr+0x191>
          pcb->persist_cnt = 0;
  805dc4:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  805dcb:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  805dce:	80 f9 06             	cmp    $0x6,%cl
  805dd1:	77 09                	ja     805ddc <tcp_slowtmr+0xec>
            pcb->persist_backoff++;
  805dd3:	83 c1 01             	add    $0x1,%ecx
  805dd6:	88 8b a4 00 00 00    	mov    %cl,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  805ddc:	83 ec 0c             	sub    $0xc,%esp
  805ddf:	53                   	push   %ebx
  805de0:	e8 79 29 00 00       	call   80875e <tcp_zero_window_probe>
  805de5:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805de8:	be 00 00 00 00       	mov    $0x0,%esi
  805ded:	e9 8f 00 00 00       	jmp    805e81 <tcp_slowtmr+0x191>
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  805df2:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805df6:	66 85 c9             	test   %cx,%cx
  805df9:	78 07                	js     805e02 <tcp_slowtmr+0x112>
          ++pcb->rtime;
  805dfb:	83 c1 01             	add    $0x1,%ecx
  805dfe:	66 89 4b 32          	mov    %cx,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805e02:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805e06:	74 74                	je     805e7c <tcp_slowtmr+0x18c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805e08:	be 00 00 00 00       	mov    $0x0,%esi
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
          ++pcb->rtime;

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805e0d:	0f b7 4b 44          	movzwl 0x44(%ebx),%ecx
  805e11:	66 39 4b 32          	cmp    %cx,0x32(%ebx)
  805e15:	7c 6a                	jl     805e81 <tcp_slowtmr+0x191>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  805e17:	83 f8 02             	cmp    $0x2,%eax
  805e1a:	74 1f                	je     805e3b <tcp_slowtmr+0x14b>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805e1c:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805e20:	66 c1 f8 03          	sar    $0x3,%ax
  805e24:	98                   	cwtl   
  805e25:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805e29:	01 c8                	add    %ecx,%eax
  805e2b:	0f b6 d2             	movzbl %dl,%edx
  805e2e:	0f b6 8a 90 1c 81 00 	movzbl 0x811c90(%edx),%ecx
  805e35:	d3 e0                	shl    %cl,%eax
  805e37:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  805e3b:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  805e41:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  805e45:	66 39 43 5c          	cmp    %ax,0x5c(%ebx)
  805e49:	66 0f 46 43 5c       	cmovbe 0x5c(%ebx),%ax
  805e4e:	66 d1 e8             	shr    %ax
  805e51:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  805e55:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  805e59:	66 39 d0             	cmp    %dx,%ax
  805e5c:	73 07                	jae    805e65 <tcp_slowtmr+0x175>
            pcb->ssthresh = pcb->mss * 2;
  805e5e:	8d 04 12             	lea    (%edx,%edx,1),%eax
  805e61:	66 89 43 50          	mov    %ax,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  805e65:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  805e69:	83 ec 0c             	sub    $0xc,%esp
  805e6c:	53                   	push   %ebx
  805e6d:	e8 24 27 00 00       	call   808596 <tcp_rexmit_rto>
  805e72:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805e75:	be 00 00 00 00       	mov    $0x0,%esi
  805e7a:	eb 05                	jmp    805e81 <tcp_slowtmr+0x191>
  805e7c:	be 00 00 00 00       	mov    $0x0,%esi
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  805e81:	8b 43 10             	mov    0x10(%ebx),%eax
  805e84:	83 f8 06             	cmp    $0x6,%eax
  805e87:	75 21                	jne    805eaa <tcp_slowtmr+0x1ba>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805e89:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805e8e:	2b 43 2c             	sub    0x2c(%ebx),%eax
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  805e91:	83 f8 29             	cmp    $0x29,%eax
  805e94:	89 f0                	mov    %esi,%eax
  805e96:	1c ff                	sbb    $0xff,%al
  805e98:	89 c6                	mov    %eax,%esi

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  805e9a:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805e9d:	85 c9                	test   %ecx,%ecx
  805e9f:	0f 85 8f 00 00 00    	jne    805f34 <tcp_slowtmr+0x244>
  805ea5:	e9 e6 00 00 00       	jmp    805f90 <tcp_slowtmr+0x2a0>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  805eaa:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  805eae:	74 7d                	je     805f2d <tcp_slowtmr+0x23d>
  805eb0:	83 f8 04             	cmp    $0x4,%eax
  805eb3:	74 05                	je     805eba <tcp_slowtmr+0x1ca>
  805eb5:	83 f8 07             	cmp    $0x7,%eax
  805eb8:	75 73                	jne    805f2d <tcp_slowtmr+0x23d>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805eba:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805ebf:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805ec2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  805ec5:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805ecb:	8d 91 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%edx
  805ed1:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805ed6:	f7 e2                	mul    %edx
  805ed8:	c1 ea 05             	shr    $0x5,%edx
  805edb:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805ede:	76 0e                	jbe    805eee <tcp_slowtmr+0x1fe>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  805ee0:	83 ec 0c             	sub    $0xc,%esp
  805ee3:	53                   	push   %ebx
  805ee4:	e8 fb fc ff ff       	call   805be4 <tcp_abort>
  805ee9:	83 c4 10             	add    $0x10,%esp
  805eec:	eb 3f                	jmp    805f2d <tcp_slowtmr+0x23d>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  805eee:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  805ef5:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  805efb:	01 ca                	add    %ecx,%edx
  805efd:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805f02:	f7 e2                	mul    %edx
  805f04:	c1 ea 05             	shr    $0x5,%edx
  805f07:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805f0a:	76 21                	jbe    805f2d <tcp_slowtmr+0x23d>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  805f0c:	83 ec 0c             	sub    $0xc,%esp
  805f0f:	53                   	push   %ebx
  805f10:	e8 27 27 00 00       	call   80863c <tcp_keepalive>
        pcb->keep_cnt_sent++;
  805f15:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  805f1c:	83 c4 10             	add    $0x10,%esp
  805f1f:	eb 0c                	jmp    805f2d <tcp_slowtmr+0x23d>
  805f21:	be 01 00 00 00       	mov    $0x1,%esi
  805f26:	eb 05                	jmp    805f2d <tcp_slowtmr+0x23d>

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805f28:	be 01 00 00 00       	mov    $0x1,%esi

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  805f2d:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805f30:	85 c9                	test   %ecx,%ecx
  805f32:	74 29                	je     805f5d <tcp_slowtmr+0x26d>
  805f34:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  805f3a:	2b 53 2c             	sub    0x2c(%ebx),%edx
  805f3d:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  805f41:	8d 04 40             	lea    (%eax,%eax,2),%eax
  805f44:	01 c0                	add    %eax,%eax
  805f46:	39 c2                	cmp    %eax,%edx
  805f48:	72 13                	jb     805f5d <tcp_slowtmr+0x26d>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  805f4a:	83 ec 0c             	sub    $0xc,%esp
  805f4d:	51                   	push   %ecx
  805f4e:	e8 5c f8 ff ff       	call   8057af <tcp_segs_free>
      pcb->ooseq = NULL;
  805f53:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  805f5a:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  805f5d:	8b 43 10             	mov    0x10(%ebx),%eax
  805f60:	83 f8 03             	cmp    $0x3,%eax
  805f63:	75 13                	jne    805f78 <tcp_slowtmr+0x288>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805f65:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805f6a:	2b 43 2c             	sub    0x2c(%ebx),%eax
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  805f6d:	83 f8 29             	cmp    $0x29,%eax
  805f70:	89 f0                	mov    %esi,%eax
  805f72:	1c ff                	sbb    $0xff,%al
  805f74:	89 c6                	mov    %eax,%esi
  805f76:	eb 18                	jmp    805f90 <tcp_slowtmr+0x2a0>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  805f78:	83 f8 09             	cmp    $0x9,%eax
  805f7b:	75 13                	jne    805f90 <tcp_slowtmr+0x2a0>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  805f7d:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805f82:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805f85:	3d f1 00 00 00       	cmp    $0xf1,%eax
  805f8a:	89 f0                	mov    %esi,%eax
  805f8c:	1c ff                	sbb    $0xff,%al
  805f8e:	89 c6                	mov    %eax,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  805f90:	89 f0                	mov    %esi,%eax
  805f92:	84 c0                	test   %al,%al
  805f94:	0f 84 8a 00 00 00    	je     806024 <tcp_slowtmr+0x334>
      tcp_pcb_purge(pcb);      
  805f9a:	83 ec 0c             	sub    $0xc,%esp
  805f9d:	53                   	push   %ebx
  805f9e:	e8 e8 f8 ff ff       	call   80588b <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  805fa3:	83 c4 10             	add    $0x10,%esp
  805fa6:	85 ff                	test   %edi,%edi
  805fa8:	74 27                	je     805fd1 <tcp_slowtmr+0x2e1>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805faa:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  805fb0:	75 17                	jne    805fc9 <tcp_slowtmr+0x2d9>
  805fb2:	83 ec 04             	sub    $0x4,%esp
  805fb5:	68 00 1b 81 00       	push   $0x811b00
  805fba:	68 c1 02 00 00       	push   $0x2c1
  805fbf:	68 0a 1c 81 00       	push   $0x811c0a
  805fc4:	e8 85 84 00 00       	call   80e44e <_panic>
        prev->next = pcb->next;
  805fc9:	8b 43 0c             	mov    0xc(%ebx),%eax
  805fcc:	89 47 0c             	mov    %eax,0xc(%edi)
  805fcf:	eb 27                	jmp    805ff8 <tcp_slowtmr+0x308>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  805fd1:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  805fd7:	74 17                	je     805ff0 <tcp_slowtmr+0x300>
  805fd9:	83 ec 04             	sub    $0x4,%esp
  805fdc:	68 2c 1b 81 00       	push   $0x811b2c
  805fe1:	68 c5 02 00 00       	push   $0x2c5
  805fe6:	68 0a 1c 81 00       	push   $0x811c0a
  805feb:	e8 5e 84 00 00       	call   80e44e <_panic>
        tcp_active_pcbs = pcb->next;
  805ff0:	8b 43 0c             	mov    0xc(%ebx),%eax
  805ff3:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  805ff8:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  805ffe:	85 c0                	test   %eax,%eax
  806000:	74 0d                	je     80600f <tcp_slowtmr+0x31f>
  806002:	83 ec 08             	sub    $0x8,%esp
  806005:	6a fb                	push   $0xfffffffb
  806007:	ff 73 18             	pushl  0x18(%ebx)
  80600a:	ff d0                	call   *%eax
  80600c:	83 c4 10             	add    $0x10,%esp

      pcb2 = pcb->next;
  80600f:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  806012:	83 ec 08             	sub    $0x8,%esp
  806015:	53                   	push   %ebx
  806016:	6a 02                	push   $0x2
  806018:	e8 95 e4 ff ff       	call   8044b2 <memp_free>
  80601d:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  806020:	89 f3                	mov    %esi,%ebx
  806022:	eb 43                	jmp    806067 <tcp_slowtmr+0x377>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  806024:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  806028:	83 c0 01             	add    $0x1,%eax
  80602b:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  80602e:	3a 43 31             	cmp    0x31(%ebx),%al
  806031:	72 2f                	jb     806062 <tcp_slowtmr+0x372>
        pcb->polltmr = 0;
  806033:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  806037:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80603d:	85 c0                	test   %eax,%eax
  80603f:	74 0f                	je     806050 <tcp_slowtmr+0x360>
  806041:	83 ec 08             	sub    $0x8,%esp
  806044:	53                   	push   %ebx
  806045:	ff 73 18             	pushl  0x18(%ebx)
  806048:	ff d0                	call   *%eax
  80604a:	88 45 e3             	mov    %al,-0x1d(%ebp)
  80604d:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  806050:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  806054:	75 0c                	jne    806062 <tcp_slowtmr+0x372>
          tcp_output(pcb);
  806056:	83 ec 0c             	sub    $0xc,%esp
  806059:	53                   	push   %ebx
  80605a:	e8 9b 1f 00 00       	call   807ffa <tcp_output>
  80605f:	83 c4 10             	add    $0x10,%esp
        }
      }
      
      prev = pcb;
  806062:	89 df                	mov    %ebx,%edi
      pcb = pcb->next;
  806064:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  806067:	85 db                	test   %ebx,%ebx
  806069:	0f 85 a5 fc ff ff    	jne    805d14 <tcp_slowtmr+0x24>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  80606f:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
  while (pcb != NULL) {
  806075:	e9 a4 00 00 00       	jmp    80611e <tcp_slowtmr+0x42e>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80607a:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  80607e:	74 17                	je     806097 <tcp_slowtmr+0x3a7>
  806080:	83 ec 04             	sub    $0x4,%esp
  806083:	68 58 1b 81 00       	push   $0x811b58
  806088:	68 e5 02 00 00       	push   $0x2e5
  80608d:	68 0a 1c 81 00       	push   $0x811c0a
  806092:	e8 b7 83 00 00       	call   80e44e <_panic>
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  806097:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80609c:	2b 46 2c             	sub    0x2c(%esi),%eax
  80609f:	3d f0 00 00 00       	cmp    $0xf0,%eax
  8060a4:	76 73                	jbe    806119 <tcp_slowtmr+0x429>
      tcp_pcb_purge(pcb);      
  8060a6:	83 ec 0c             	sub    $0xc,%esp
  8060a9:	56                   	push   %esi
  8060aa:	e8 dc f7 ff ff       	call   80588b <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  8060af:	83 c4 10             	add    $0x10,%esp
  8060b2:	85 db                	test   %ebx,%ebx
  8060b4:	74 27                	je     8060dd <tcp_slowtmr+0x3ed>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  8060b6:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  8060bc:	75 17                	jne    8060d5 <tcp_slowtmr+0x3e5>
  8060be:	83 ec 04             	sub    $0x4,%esp
  8060c1:	68 88 1b 81 00       	push   $0x811b88
  8060c6:	68 f4 02 00 00       	push   $0x2f4
  8060cb:	68 0a 1c 81 00       	push   $0x811c0a
  8060d0:	e8 79 83 00 00       	call   80e44e <_panic>
        prev->next = pcb->next;
  8060d5:	8b 46 0c             	mov    0xc(%esi),%eax
  8060d8:	89 43 0c             	mov    %eax,0xc(%ebx)
  8060db:	eb 27                	jmp    806104 <tcp_slowtmr+0x414>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  8060dd:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  8060e3:	74 17                	je     8060fc <tcp_slowtmr+0x40c>
  8060e5:	83 ec 04             	sub    $0x4,%esp
  8060e8:	68 b0 1b 81 00       	push   $0x811bb0
  8060ed:	68 f8 02 00 00       	push   $0x2f8
  8060f2:	68 0a 1c 81 00       	push   $0x811c0a
  8060f7:	e8 52 83 00 00       	call   80e44e <_panic>
        tcp_tw_pcbs = pcb->next;
  8060fc:	8b 46 0c             	mov    0xc(%esi),%eax
  8060ff:	a3 50 b2 b3 00       	mov    %eax,0xb3b250
      }
      pcb2 = pcb->next;
  806104:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  806107:	83 ec 08             	sub    $0x8,%esp
  80610a:	56                   	push   %esi
  80610b:	6a 02                	push   $0x2
  80610d:	e8 a0 e3 ff ff       	call   8044b2 <memp_free>
  806112:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  806115:	89 fe                	mov    %edi,%esi
  806117:	eb 05                	jmp    80611e <tcp_slowtmr+0x42e>
    } else {
      prev = pcb;
  806119:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  80611b:	8b 76 0c             	mov    0xc(%esi),%esi

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  80611e:	85 f6                	test   %esi,%esi
  806120:	0f 85 54 ff ff ff    	jne    80607a <tcp_slowtmr+0x38a>
  806126:	eb 0e                	jmp    806136 <tcp_slowtmr+0x446>

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  806128:	80 fa 0c             	cmp    $0xc,%dl
  80612b:	0f 85 62 fc ff ff    	jne    805d93 <tcp_slowtmr+0xa3>
  806131:	e9 f2 fd ff ff       	jmp    805f28 <tcp_slowtmr+0x238>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  806136:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806139:	5b                   	pop    %ebx
  80613a:	5e                   	pop    %esi
  80613b:	5f                   	pop    %edi
  80613c:	5d                   	pop    %ebp
  80613d:	c3                   	ret    

0080613e <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  80613e:	55                   	push   %ebp
  80613f:	89 e5                	mov    %esp,%ebp
  806141:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  806144:	e8 ad f5 ff ff       	call   8056f6 <tcp_fasttmr>

  if (++tcp_timer & 1) {
  806149:	0f b6 05 f9 43 b3 00 	movzbl 0xb343f9,%eax
  806150:	83 c0 01             	add    $0x1,%eax
  806153:	a2 f9 43 b3 00       	mov    %al,0xb343f9
  806158:	a8 01                	test   $0x1,%al
  80615a:	74 05                	je     806161 <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80615c:	e8 8f fb ff ff       	call   805cf0 <tcp_slowtmr>
  }
}
  806161:	c9                   	leave  
  806162:	c3                   	ret    

00806163 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  806163:	55                   	push   %ebp
  806164:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  806166:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80616b:	03 05 08 40 81 00    	add    0x814008,%eax
  806171:	a3 08 40 81 00       	mov    %eax,0x814008
  return iss;
}
  806176:	5d                   	pop    %ebp
  806177:	c3                   	ret    

00806178 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  806178:	55                   	push   %ebp
  806179:	89 e5                	mov    %esp,%ebp
  80617b:	57                   	push   %edi
  80617c:	56                   	push   %esi
  80617d:	53                   	push   %ebx
  80617e:	83 ec 28             	sub    $0x28,%esp
  806181:	0f b6 5d 08          	movzbl 0x8(%ebp),%ebx
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  806185:	6a 02                	push   $0x2
  806187:	e8 d0 e2 ff ff       	call   80445c <memp_malloc>
  80618c:	89 c6                	mov    %eax,%esi
  if (pcb == NULL) {
  80618e:	83 c4 10             	add    $0x10,%esp
  806191:	85 c0                	test   %eax,%eax
  806193:	0f 85 bd 00 00 00    	jne    806256 <tcp_alloc+0xde>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  806199:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80619e:	8b 35 40 b2 b3 00    	mov    0xb3b240,%esi
tcp_kill_timewait(void)
{
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  8061a4:	b9 00 00 00 00       	mov    $0x0,%ecx
  inactive = NULL;
  8061a9:	bf 00 00 00 00       	mov    $0x0,%edi
  8061ae:	eb 10                	jmp    8061c0 <tcp_alloc+0x48>
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8061b0:	89 f2                	mov    %esi,%edx
  8061b2:	2b 50 2c             	sub    0x2c(%eax),%edx
  8061b5:	39 ca                	cmp    %ecx,%edx
  8061b7:	72 04                	jb     8061bd <tcp_alloc+0x45>
      inactivity = tcp_ticks - pcb->tmr;
  8061b9:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  8061bb:	89 c7                	mov    %eax,%edi
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8061bd:	8b 40 0c             	mov    0xc(%eax),%eax
  8061c0:	85 c0                	test   %eax,%eax
  8061c2:	75 ec                	jne    8061b0 <tcp_alloc+0x38>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  8061c4:	85 ff                	test   %edi,%edi
  8061c6:	74 0c                	je     8061d4 <tcp_alloc+0x5c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8061c8:	83 ec 0c             	sub    $0xc,%esp
  8061cb:	57                   	push   %edi
  8061cc:	e8 13 fa ff ff       	call   805be4 <tcp_abort>
  8061d1:	83 c4 10             	add    $0x10,%esp
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  8061d4:	83 ec 0c             	sub    $0xc,%esp
  8061d7:	6a 02                	push   $0x2
  8061d9:	e8 7e e2 ff ff       	call   80445c <memp_malloc>
  8061de:	89 c6                	mov    %eax,%esi
    if (pcb == NULL) {
  8061e0:	83 c4 10             	add    $0x10,%esp
  8061e3:	85 c0                	test   %eax,%eax
  8061e5:	75 6f                	jne    806256 <tcp_alloc+0xde>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8061e7:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8061ec:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  8061f2:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  8061f7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  inactive = NULL;
  8061fe:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806205:	eb 21                	jmp    806228 <tcp_alloc+0xb0>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  806207:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  80620b:	38 d3                	cmp    %dl,%bl
  80620d:	72 16                	jb     806225 <tcp_alloc+0xad>
  80620f:	38 ca                	cmp    %cl,%dl
  806211:	77 12                	ja     806225 <tcp_alloc+0xad>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806213:	89 fe                	mov    %edi,%esi
  806215:	2b 70 2c             	sub    0x2c(%eax),%esi
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  806218:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
  80621b:	72 08                	jb     806225 <tcp_alloc+0xad>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
  80621d:	89 d1                	mov    %edx,%ecx
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  80621f:	89 75 e4             	mov    %esi,-0x1c(%ebp)
      inactive = pcb;
  806222:	89 45 e0             	mov    %eax,-0x20(%ebp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806225:	8b 40 0c             	mov    0xc(%eax),%eax
  806228:	85 c0                	test   %eax,%eax
  80622a:	75 db                	jne    806207 <tcp_alloc+0x8f>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  80622c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80622f:	85 c0                	test   %eax,%eax
  806231:	74 0c                	je     80623f <tcp_alloc+0xc7>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  806233:	83 ec 0c             	sub    $0xc,%esp
  806236:	50                   	push   %eax
  806237:	e8 a8 f9 ff ff       	call   805be4 <tcp_abort>
  80623c:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  80623f:	83 ec 0c             	sub    $0xc,%esp
  806242:	6a 02                	push   $0x2
  806244:	e8 13 e2 ff ff       	call   80445c <memp_malloc>
  806249:	89 c6                	mov    %eax,%esi
    }
  }
  if (pcb != NULL) {
  80624b:	83 c4 10             	add    $0x10,%esp
  80624e:	85 c0                	test   %eax,%eax
  806250:	0f 84 96 00 00 00    	je     8062ec <tcp_alloc+0x174>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  806256:	83 ec 04             	sub    $0x4,%esp
  806259:	68 a8 00 00 00       	push   $0xa8
  80625e:	6a 00                	push   $0x0
  806260:	56                   	push   %esi
  806261:	e8 8b 89 00 00       	call   80ebf1 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  806266:	c6 46 14 40          	movb   $0x40,0x14(%esi)
    pcb->snd_buf = TCP_SND_BUF;
  80626a:	66 c7 46 6e 40 5b    	movw   $0x5b40,0x6e(%esi)
    pcb->snd_queuelen = 0;
  806270:	66 c7 46 70 00 00    	movw   $0x0,0x70(%esi)
    pcb->rcv_wnd = TCP_WND;
  806276:	66 c7 46 28 c0 5d    	movw   $0x5dc0,0x28(%esi)
    pcb->rcv_ann_wnd = TCP_WND;
  80627c:	66 c7 46 2a c0 5d    	movw   $0x5dc0,0x2a(%esi)
    pcb->tos = 0;
  806282:	c6 46 0a 00          	movb   $0x0,0xa(%esi)
    pcb->ttl = TCP_TTL;
  806286:	c6 46 0b ff          	movb   $0xff,0xb(%esi)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80628a:	66 c7 46 34 18 02    	movw   $0x218,0x34(%esi)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  806290:	66 c7 46 44 06 00    	movw   $0x6,0x44(%esi)
    pcb->sa = 0;
  806296:	66 c7 46 40 00 00    	movw   $0x0,0x40(%esi)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  80629c:	66 c7 46 42 06 00    	movw   $0x6,0x42(%esi)
    pcb->rtime = -1;
  8062a2:	66 c7 46 32 ff ff    	movw   $0xffff,0x32(%esi)
    pcb->cwnd = 1;
  8062a8:	66 c7 46 4e 01 00    	movw   $0x1,0x4e(%esi)
    iss = tcp_next_iss();
  8062ae:	e8 b0 fe ff ff       	call   806163 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  8062b3:	89 46 64             	mov    %eax,0x64(%esi)
    pcb->snd_nxt = iss;
  8062b6:	89 46 54             	mov    %eax,0x54(%esi)
    pcb->snd_max = iss;
  8062b9:	89 46 58             	mov    %eax,0x58(%esi)
    pcb->lastack = iss;
  8062bc:	89 46 48             	mov    %eax,0x48(%esi)
    pcb->snd_lbb = iss;   
  8062bf:	89 46 68             	mov    %eax,0x68(%esi)
    pcb->tmr = tcp_ticks;
  8062c2:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8062c7:	89 46 2c             	mov    %eax,0x2c(%esi)

    pcb->polltmr = 0;
  8062ca:	c6 46 30 00          	movb   $0x0,0x30(%esi)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  8062ce:	c7 86 88 00 00 00 a8 	movl   $0x805ba8,0x88(%esi)
  8062d5:	5b 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  8062d8:	c7 86 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%esi)
  8062df:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  8062e2:	c6 86 a5 00 00 00 00 	movb   $0x0,0xa5(%esi)
  8062e9:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  8062ec:	89 f0                	mov    %esi,%eax
  8062ee:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8062f1:	5b                   	pop    %ebx
  8062f2:	5e                   	pop    %esi
  8062f3:	5f                   	pop    %edi
  8062f4:	5d                   	pop    %ebp
  8062f5:	c3                   	ret    

008062f6 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  8062f6:	55                   	push   %ebp
  8062f7:	89 e5                	mov    %esp,%ebp
  8062f9:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  8062fc:	6a 40                	push   $0x40
  8062fe:	e8 75 fe ff ff       	call   806178 <tcp_alloc>
}
  806303:	c9                   	leave  
  806304:	c3                   	ret    

00806305 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  806305:	55                   	push   %ebp
  806306:	89 e5                	mov    %esp,%ebp
  806308:	56                   	push   %esi
  806309:	53                   	push   %ebx
  80630a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80630d:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  80630f:	83 ec 0c             	sub    $0xc,%esp
  806312:	ff 75 0c             	pushl  0xc(%ebp)
  806315:	e8 00 02 00 00       	call   80651a <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  80631a:	83 c4 10             	add    $0x10,%esp
  80631d:	85 c0                	test   %eax,%eax
  80631f:	74 14                	je     806335 <tcp_eff_send_mss+0x30>
  806321:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806325:	66 85 c0             	test   %ax,%ax
  806328:	74 0b                	je     806335 <tcp_eff_send_mss+0x30>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  80632a:	83 e8 28             	sub    $0x28,%eax
  80632d:	66 39 c3             	cmp    %ax,%bx
  806330:	0f 46 c3             	cmovbe %ebx,%eax
  806333:	89 c6                	mov    %eax,%esi
  }
  return sendmss;
}
  806335:	89 f0                	mov    %esi,%eax
  806337:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80633a:	5b                   	pop    %ebx
  80633b:	5e                   	pop    %esi
  80633c:	5d                   	pop    %ebp
  80633d:	c3                   	ret    

0080633e <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  80633e:	55                   	push   %ebp
  80633f:	89 e5                	mov    %esp,%ebp
  806341:	57                   	push   %edi
  806342:	56                   	push   %esi
  806343:	53                   	push   %ebx
  806344:	83 ec 1c             	sub    $0x1c,%esp
  806347:	8b 75 0c             	mov    0xc(%ebp),%esi
  80634a:	8b 45 10             	mov    0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80634d:	8b 7d 08             	mov    0x8(%ebp),%edi
  806350:	83 7f 10 00          	cmpl   $0x0,0x10(%edi)
  806354:	74 17                	je     80636d <tcp_connect+0x2f>
  806356:	83 ec 04             	sub    $0x4,%esp
  806359:	68 d8 1b 81 00       	push   $0x811bd8
  80635e:	68 ec 01 00 00       	push   $0x1ec
  806363:	68 0a 1c 81 00       	push   $0x811c0a
  806368:	e8 e1 80 00 00       	call   80e44e <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  80636d:	85 f6                	test   %esi,%esi
  80636f:	0f 84 4c 01 00 00    	je     8064c1 <tcp_connect+0x183>
    pcb->remote_ip = *ipaddr;
  806375:	8b 16                	mov    (%esi),%edx
  806377:	8b 7d 08             	mov    0x8(%ebp),%edi
  80637a:	89 57 04             	mov    %edx,0x4(%edi)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  80637d:	66 89 47 1e          	mov    %ax,0x1e(%edi)
  if (pcb->local_port == 0) {
  806381:	66 83 7f 1c 00       	cmpw   $0x0,0x1c(%edi)
  806386:	75 0c                	jne    806394 <tcp_connect+0x56>
    pcb->local_port = tcp_new_port();
  806388:	e8 ad ef ff ff       	call   80533a <tcp_new_port>
  80638d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806390:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  806394:	e8 ca fd ff ff       	call   806163 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  806399:	8b 7d 08             	mov    0x8(%ebp),%edi
  80639c:	c7 47 24 00 00 00 00 	movl   $0x0,0x24(%edi)
  pcb->snd_nxt = iss;
  8063a3:	89 47 54             	mov    %eax,0x54(%edi)
  pcb->lastack = iss - 1;
  8063a6:	83 e8 01             	sub    $0x1,%eax
  8063a9:	89 47 48             	mov    %eax,0x48(%edi)
  pcb->snd_lbb = iss - 1;
  8063ac:	89 47 68             	mov    %eax,0x68(%edi)
  pcb->rcv_wnd = TCP_WND;
  8063af:	66 c7 47 28 c0 5d    	movw   $0x5dc0,0x28(%edi)
  pcb->rcv_ann_wnd = TCP_WND;
  8063b5:	66 c7 47 2a c0 5d    	movw   $0x5dc0,0x2a(%edi)
  pcb->snd_wnd = TCP_WND;
  8063bb:	66 c7 47 5c c0 5d    	movw   $0x5dc0,0x5c(%edi)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8063c1:	66 c7 47 34 18 02    	movw   $0x218,0x34(%edi)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  8063c7:	83 ec 08             	sub    $0x8,%esp
  8063ca:	56                   	push   %esi
  8063cb:	68 18 02 00 00       	push   $0x218
  8063d0:	e8 30 ff ff ff       	call   806305 <tcp_eff_send_mss>
  8063d5:	8b 7d 08             	mov    0x8(%ebp),%edi
  8063d8:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  8063dc:	66 c7 47 4e 01 00    	movw   $0x1,0x4e(%edi)
  pcb->ssthresh = pcb->mss * 10;
  8063e2:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8063e5:	01 c0                	add    %eax,%eax
  8063e7:	66 89 47 50          	mov    %ax,0x50(%edi)
  pcb->state = SYN_SENT;
  8063eb:	c7 47 10 02 00 00 00 	movl   $0x2,0x10(%edi)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  8063f2:	8b 45 14             	mov    0x14(%ebp),%eax
  8063f5:	89 87 8c 00 00 00    	mov    %eax,0x8c(%edi)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8063fb:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  806401:	83 c4 10             	add    $0x10,%esp
  806404:	39 d7                	cmp    %edx,%edi
  806406:	75 0a                	jne    806412 <tcp_connect+0xd4>
  806408:	8b 47 0c             	mov    0xc(%edi),%eax
  80640b:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  806410:	eb 55                	jmp    806467 <tcp_connect+0x129>
  806412:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  806418:	bf 00 00 00 00       	mov    $0x0,%edi
  80641d:	eb 34                	jmp    806453 <tcp_connect+0x115>
  80641f:	8b 42 0c             	mov    0xc(%edx),%eax
  806422:	39 45 08             	cmp    %eax,0x8(%ebp)
  806425:	0f 94 c1             	sete   %cl
  806428:	89 ce                	mov    %ecx,%esi
  80642a:	85 c0                	test   %eax,%eax
  80642c:	0f 95 c1             	setne  %cl
  80642f:	89 f3                	mov    %esi,%ebx
  806431:	84 cb                	test   %cl,%bl
  806433:	74 17                	je     80644c <tcp_connect+0x10e>
  806435:	89 f8                	mov    %edi,%eax
  806437:	84 c0                	test   %al,%al
  806439:	74 06                	je     806441 <tcp_connect+0x103>
  80643b:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  806441:	8b 45 08             	mov    0x8(%ebp),%eax
  806444:	8b 40 0c             	mov    0xc(%eax),%eax
  806447:	89 42 0c             	mov    %eax,0xc(%edx)
  80644a:	eb 1b                	jmp    806467 <tcp_connect+0x129>
  80644c:	bf 01 00 00 00       	mov    $0x1,%edi
  806451:	89 c2                	mov    %eax,%edx
  806453:	85 d2                	test   %edx,%edx
  806455:	75 c8                	jne    80641f <tcp_connect+0xe1>
  806457:	89 f8                	mov    %edi,%eax
  806459:	84 c0                	test   %al,%al
  80645b:	74 0a                	je     806467 <tcp_connect+0x129>
  80645d:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  806464:	00 00 00 
  TCP_REG(&tcp_active_pcbs, pcb);
  806467:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80646c:	8b 7d 08             	mov    0x8(%ebp),%edi
  80646f:	89 47 0c             	mov    %eax,0xc(%edi)
  806472:	89 3d 3c b2 b3 00    	mov    %edi,0xb3b23c
  806478:	e8 e7 bd ff ff       	call   802264 <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  80647d:	83 ec 0c             	sub    $0xc,%esp
  806480:	68 b4 05 04 02       	push   $0x20405b4
  806485:	e8 66 12 00 00       	call   8076f0 <htonl>
  80648a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  80648d:	83 c4 0c             	add    $0xc,%esp
  806490:	6a 04                	push   $0x4
  806492:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  806495:	50                   	push   %eax
  806496:	6a 00                	push   $0x0
  806498:	6a 02                	push   $0x2
  80649a:	6a 00                	push   $0x0
  80649c:	6a 00                	push   $0x0
  80649e:	ff 75 08             	pushl  0x8(%ebp)
  8064a1:	e8 7b 14 00 00       	call   807921 <tcp_enqueue>
  8064a6:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  8064a8:	83 c4 20             	add    $0x20,%esp
  8064ab:	84 c0                	test   %al,%al
  8064ad:	75 17                	jne    8064c6 <tcp_connect+0x188>
    tcp_output(pcb);
  8064af:	83 ec 0c             	sub    $0xc,%esp
  8064b2:	ff 75 08             	pushl  0x8(%ebp)
  8064b5:	e8 40 1b 00 00       	call   807ffa <tcp_output>
  8064ba:	83 c4 10             	add    $0x10,%esp
  }
  return ret;
  8064bd:	89 f0                	mov    %esi,%eax
  8064bf:	eb 05                	jmp    8064c6 <tcp_connect+0x188>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  8064c1:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  if (ret == ERR_OK) { 
    tcp_output(pcb);
  }
  return ret;
} 
  8064c6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8064c9:	5b                   	pop    %ebx
  8064ca:	5e                   	pop    %esi
  8064cb:	5f                   	pop    %edi
  8064cc:	5d                   	pop    %ebp
  8064cd:	c3                   	ret    

008064ce <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  8064ce:	55                   	push   %ebp
  8064cf:	89 e5                	mov    %esp,%ebp
  8064d1:	53                   	push   %ebx
  8064d2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  8064d5:	8b 45 08             	mov    0x8(%ebp),%eax
  8064d8:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8064da:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  8064dd:	b8 01 00 00 00       	mov    $0x1,%eax
{
  u32_t addr2test;

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8064e2:	83 fb fd             	cmp    $0xfffffffd,%ebx
  8064e5:	77 30                	ja     806517 <ip_addr_isbroadcast+0x49>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  8064e7:	0f b6 41 2e          	movzbl 0x2e(%ecx),%eax
  8064eb:	83 e0 02             	and    $0x2,%eax
  8064ee:	74 27                	je     806517 <ip_addr_isbroadcast+0x49>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  8064f0:	8b 41 04             	mov    0x4(%ecx),%eax
  8064f3:	39 c2                	cmp    %eax,%edx
  8064f5:	74 1b                	je     806512 <ip_addr_isbroadcast+0x44>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  8064f7:	8b 59 08             	mov    0x8(%ecx),%ebx
  8064fa:	31 d0                	xor    %edx,%eax
  8064fc:	89 c1                	mov    %eax,%ecx
          && ((addr2test & ~netif->netmask.addr) ==
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
  8064fe:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806503:	85 d9                	test   %ebx,%ecx
  806505:	75 10                	jne    806517 <ip_addr_isbroadcast+0x49>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806507:	f7 d3                	not    %ebx

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  806509:	21 da                	and    %ebx,%edx
  80650b:	39 da                	cmp    %ebx,%edx
  80650d:	0f 94 c0             	sete   %al
  806510:	eb 05                	jmp    806517 <ip_addr_isbroadcast+0x49>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  806512:	b8 00 00 00 00       	mov    $0x0,%eax
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  806517:	5b                   	pop    %ebx
  806518:	5d                   	pop    %ebp
  806519:	c3                   	ret    

0080651a <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  80651a:	55                   	push   %ebp
  80651b:	89 e5                	mov    %esp,%ebp
  80651d:	56                   	push   %esi
  80651e:	53                   	push   %ebx
  80651f:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806522:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  806528:	eb 1c                	jmp    806546 <ip_route+0x2c>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  80652a:	83 ec 0c             	sub    $0xc,%esp
  80652d:	53                   	push   %ebx
  80652e:	e8 11 e2 ff ff       	call   804744 <netif_is_up>
  806533:	83 c4 10             	add    $0x10,%esp
  806536:	84 c0                	test   %al,%al
  806538:	74 0a                	je     806544 <ip_route+0x2a>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  80653a:	8b 06                	mov    (%esi),%eax
  80653c:	33 43 04             	xor    0x4(%ebx),%eax
  80653f:	85 43 08             	test   %eax,0x8(%ebx)
  806542:	74 2b                	je     80656f <ip_route+0x55>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806544:	8b 1b                	mov    (%ebx),%ebx
  806546:	85 db                	test   %ebx,%ebx
  806548:	75 e0                	jne    80652a <ip_route+0x10>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  80654a:	a1 38 b2 b3 00       	mov    0xb3b238,%eax
  80654f:	85 c0                	test   %eax,%eax
  806551:	74 1e                	je     806571 <ip_route+0x57>
  806553:	83 ec 0c             	sub    $0xc,%esp
  806556:	50                   	push   %eax
  806557:	e8 e8 e1 ff ff       	call   804744 <netif_is_up>
  80655c:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  80655f:	84 c0                	test   %al,%al
  806561:	b8 00 00 00 00       	mov    $0x0,%eax
  806566:	0f 45 05 38 b2 b3 00 	cmovne 0xb3b238,%eax
  80656d:	eb 02                	jmp    806571 <ip_route+0x57>
  80656f:	89 d8                	mov    %ebx,%eax
}
  806571:	8d 65 f8             	lea    -0x8(%ebp),%esp
  806574:	5b                   	pop    %ebx
  806575:	5e                   	pop    %esi
  806576:	5d                   	pop    %ebp
  806577:	c3                   	ret    

00806578 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  806578:	55                   	push   %ebp
  806579:	89 e5                	mov    %esp,%ebp
  80657b:	57                   	push   %edi
  80657c:	56                   	push   %esi
  80657d:	53                   	push   %ebx
  80657e:	83 ec 28             	sub    $0x28,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806581:	8b 45 08             	mov    0x8(%ebp),%eax
  806584:	8b 70 04             	mov    0x4(%eax),%esi
  if (IPH_V(iphdr) != 4) {
  806587:	0f b7 06             	movzwl (%esi),%eax
  80658a:	50                   	push   %eax
  80658b:	e8 53 11 00 00       	call   8076e3 <ntohs>
  806590:	66 c1 e8 0c          	shr    $0xc,%ax
  806594:	83 c4 10             	add    $0x10,%esp
  806597:	66 83 f8 04          	cmp    $0x4,%ax
  80659b:	74 13                	je     8065b0 <ip_input+0x38>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  80659d:	83 ec 0c             	sub    $0xc,%esp
  8065a0:	ff 75 08             	pushl  0x8(%ebp)
  8065a3:	e8 7d e2 ff ff       	call   804825 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  8065a8:	83 c4 10             	add    $0x10,%esp
  8065ab:	e9 bf 02 00 00       	jmp    80686f <ip_input+0x2f7>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  8065b0:	83 ec 0c             	sub    $0xc,%esp
  8065b3:	0f b7 06             	movzwl (%esi),%eax
  8065b6:	50                   	push   %eax
  8065b7:	e8 27 11 00 00       	call   8076e3 <ntohs>
  8065bc:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  8065c0:	83 e0 3c             	and    $0x3c,%eax
  8065c3:	89 c7                	mov    %eax,%edi
  8065c5:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  8065c9:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8065cd:	89 04 24             	mov    %eax,(%esp)
  8065d0:	e8 0e 11 00 00       	call   8076e3 <ntohs>
  8065d5:	89 c3                	mov    %eax,%ebx

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  8065d7:	83 c4 10             	add    $0x10,%esp
  8065da:	8b 55 08             	mov    0x8(%ebp),%edx
  8065dd:	66 3b 7a 0a          	cmp    0xa(%edx),%di
  8065e1:	77 06                	ja     8065e9 <ip_input+0x71>
  8065e3:	66 3b 5a 08          	cmp    0x8(%edx),%bx
  8065e7:	76 13                	jbe    8065fc <ip_input+0x84>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  8065e9:	83 ec 0c             	sub    $0xc,%esp
  8065ec:	ff 75 08             	pushl  0x8(%ebp)
  8065ef:	e8 31 e2 ff ff       	call   804825 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  8065f4:	83 c4 10             	add    $0x10,%esp
  8065f7:	e9 73 02 00 00       	jmp    80686f <ip_input+0x2f7>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  8065fc:	83 ec 08             	sub    $0x8,%esp
  8065ff:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806603:	50                   	push   %eax
  806604:	56                   	push   %esi
  806605:	e8 a7 0f 00 00       	call   8075b1 <inet_chksum>
  80660a:	83 c4 10             	add    $0x10,%esp
  80660d:	66 85 c0             	test   %ax,%ax
  806610:	74 13                	je     806625 <ip_input+0xad>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  806612:	83 ec 0c             	sub    $0xc,%esp
  806615:	ff 75 08             	pushl  0x8(%ebp)
  806618:	e8 08 e2 ff ff       	call   804825 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  80661d:	83 c4 10             	add    $0x10,%esp
  806620:	e9 4a 02 00 00       	jmp    80686f <ip_input+0x2f7>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  806625:	83 ec 08             	sub    $0x8,%esp
  806628:	0f b7 db             	movzwl %bx,%ebx
  80662b:	53                   	push   %ebx
  80662c:	ff 75 08             	pushl  0x8(%ebp)
  80662f:	e8 3a e5 ff ff       	call   804b6e <pbuf_realloc>
  806634:	83 c4 10             	add    $0x10,%esp
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    netif = inp;
  806637:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  80663a:	bf 01 00 00 00       	mov    $0x1,%edi
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  80663f:	8d 46 10             	lea    0x10(%esi),%eax
  806642:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806645:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  806648:	89 de                	mov    %ebx,%esi
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  80664a:	83 ec 0c             	sub    $0xc,%esp
  80664d:	53                   	push   %ebx
  80664e:	e8 f1 e0 ff ff       	call   804744 <netif_is_up>
  806653:	83 c4 10             	add    $0x10,%esp
  806656:	84 c0                	test   %al,%al
  806658:	74 27                	je     806681 <ip_input+0x109>
  80665a:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80665d:	74 22                	je     806681 <ip_input+0x109>
  80665f:	8b 43 04             	mov    0x4(%ebx),%eax
  806662:	85 c0                	test   %eax,%eax
  806664:	74 1b                	je     806681 <ip_input+0x109>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806666:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806669:	3b 41 10             	cmp    0x10(%ecx),%eax
  80666c:	74 35                	je     8066a3 <ip_input+0x12b>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  80666e:	83 ec 08             	sub    $0x8,%esp
  806671:	53                   	push   %ebx
  806672:	ff 75 dc             	pushl  -0x24(%ebp)
  806675:	e8 54 fe ff ff       	call   8064ce <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80667a:	83 c4 10             	add    $0x10,%esp
  80667d:	84 c0                	test   %al,%al
  80667f:	75 22                	jne    8066a3 <ip_input+0x12b>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  806681:	85 ff                	test   %edi,%edi
  806683:	74 08                	je     80668d <ip_input+0x115>
        first = 0;
        netif = netif_list;
  806685:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  80668b:	eb 02                	jmp    80668f <ip_input+0x117>
      } else {
        netif = netif->next;
  80668d:	8b 1b                	mov    (%ebx),%ebx
      }
      if (netif == inp) {
  80668f:	39 f3                	cmp    %esi,%ebx
  806691:	75 02                	jne    806695 <ip_input+0x11d>
        netif = netif->next;
  806693:	8b 1e                	mov    (%esi),%ebx
  806695:	bf 00 00 00 00       	mov    $0x0,%edi
      }
    } while(netif != NULL);
  80669a:	85 db                	test   %ebx,%ebx
  80669c:	75 ac                	jne    80664a <ip_input+0xd2>
  80669e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8066a1:	eb 0b                	jmp    8066ae <ip_input+0x136>
  8066a3:	8b 75 e4             	mov    -0x1c(%ebp),%esi
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  8066a6:	85 db                	test   %ebx,%ebx
  8066a8:	0f 85 a2 01 00 00    	jne    806850 <ip_input+0x2d8>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  8066ae:	83 ec 0c             	sub    $0xc,%esp
  8066b1:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8066b5:	50                   	push   %eax
  8066b6:	e8 28 10 00 00       	call   8076e3 <ntohs>
  8066bb:	83 c4 10             	add    $0x10,%esp
  8066be:	bb 00 00 00 00       	mov    $0x0,%ebx
  8066c3:	3c 11                	cmp    $0x11,%al
  8066c5:	0f 85 85 01 00 00    	jne    806850 <ip_input+0x2d8>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  8066cb:	83 ec 0c             	sub    $0xc,%esp
  8066ce:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8066d2:	0f b7 44 06 02       	movzwl 0x2(%esi,%eax,1),%eax
  8066d7:	50                   	push   %eax
  8066d8:	e8 06 10 00 00       	call   8076e3 <ntohs>
  8066dd:	83 c4 10             	add    $0x10,%esp
  8066e0:	66 83 f8 44          	cmp    $0x44,%ax
  8066e4:	74 3d                	je     806723 <ip_input+0x1ab>
  8066e6:	e9 65 01 00 00       	jmp    806850 <ip_input+0x2d8>
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
         (ip_addr_ismulticast(&(iphdr->src)))) {
  8066eb:	8b 7e 0c             	mov    0xc(%esi),%edi
  8066ee:	83 ec 0c             	sub    $0xc,%esp
  8066f1:	68 00 00 00 f0       	push   $0xf0000000
  8066f6:	e8 16 12 00 00       	call   807911 <ntohl>
  8066fb:	21 c7                	and    %eax,%edi
  8066fd:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806704:	e8 08 12 00 00       	call   807911 <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806709:	83 c4 10             	add    $0x10,%esp
  80670c:	39 c7                	cmp    %eax,%edi
  80670e:	75 16                	jne    806726 <ip_input+0x1ae>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  806710:	83 ec 0c             	sub    $0xc,%esp
  806713:	ff 75 08             	pushl  0x8(%ebp)
  806716:	e8 0a e1 ff ff       	call   804825 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  80671b:	83 c4 10             	add    $0x10,%esp
  80671e:	e9 4c 01 00 00       	jmp    80686f <ip_input+0x2f7>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  806723:	8b 5d 0c             	mov    0xc(%ebp),%ebx
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  806726:	85 db                	test   %ebx,%ebx
  806728:	75 13                	jne    80673d <ip_input+0x1c5>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  80672a:	83 ec 0c             	sub    $0xc,%esp
  80672d:	ff 75 08             	pushl  0x8(%ebp)
  806730:	e8 f0 e0 ff ff       	call   804825 <pbuf_free>
    return ERR_OK;
  806735:	83 c4 10             	add    $0x10,%esp
  806738:	e9 32 01 00 00       	jmp    80686f <ip_input+0x2f7>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  80673d:	0f b7 5e 06          	movzwl 0x6(%esi),%ebx
  806741:	83 ec 0c             	sub    $0xc,%esp
  806744:	68 ff 3f 00 00       	push   $0x3fff
  806749:	e8 88 0f 00 00       	call   8076d6 <htons>
  80674e:	83 c4 10             	add    $0x10,%esp
  806751:	66 85 c3             	test   %ax,%bx
  806754:	74 1c                	je     806772 <ip_input+0x1fa>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  806756:	83 ec 0c             	sub    $0xc,%esp
  806759:	ff 75 08             	pushl  0x8(%ebp)
  80675c:	e8 18 05 00 00       	call   806c79 <ip_reass>
  806761:	89 45 08             	mov    %eax,0x8(%ebp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  806764:	83 c4 10             	add    $0x10,%esp
  806767:	85 c0                	test   %eax,%eax
  806769:	0f 84 00 01 00 00    	je     80686f <ip_input+0x2f7>
      return ERR_OK;
    }
    iphdr = p->payload;
  80676f:	8b 70 04             	mov    0x4(%eax),%esi
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  806772:	83 ec 08             	sub    $0x8,%esp
  806775:	ff 75 0c             	pushl  0xc(%ebp)
  806778:	ff 75 08             	pushl  0x8(%ebp)
  80677b:	e8 e2 74 00 00       	call   80dc62 <raw_input>
  806780:	83 c4 10             	add    $0x10,%esp
  806783:	84 c0                	test   %al,%al
  806785:	0f 85 e4 00 00 00    	jne    80686f <ip_input+0x2f7>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  80678b:	83 ec 0c             	sub    $0xc,%esp
  80678e:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806792:	50                   	push   %eax
  806793:	e8 4b 0f 00 00       	call   8076e3 <ntohs>
  806798:	83 c4 10             	add    $0x10,%esp
  80679b:	0f b6 c0             	movzbl %al,%eax
  80679e:	66 83 f8 06          	cmp    $0x6,%ax
  8067a2:	74 24                	je     8067c8 <ip_input+0x250>
  8067a4:	66 83 f8 11          	cmp    $0x11,%ax
  8067a8:	74 08                	je     8067b2 <ip_input+0x23a>
  8067aa:	66 83 f8 01          	cmp    $0x1,%ax
  8067ae:	75 41                	jne    8067f1 <ip_input+0x279>
  8067b0:	eb 2c                	jmp    8067de <ip_input+0x266>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  8067b2:	83 ec 08             	sub    $0x8,%esp
  8067b5:	ff 75 0c             	pushl  0xc(%ebp)
  8067b8:	ff 75 08             	pushl  0x8(%ebp)
  8067bb:	e8 e5 20 00 00       	call   8088a5 <udp_input>
      break;
  8067c0:	83 c4 10             	add    $0x10,%esp
  8067c3:	e9 a7 00 00 00       	jmp    80686f <ip_input+0x2f7>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  8067c8:	83 ec 08             	sub    $0x8,%esp
  8067cb:	ff 75 0c             	pushl  0xc(%ebp)
  8067ce:	ff 75 08             	pushl  0x8(%ebp)
  8067d1:	e8 19 67 00 00       	call   80ceef <tcp_input>
      break;
  8067d6:	83 c4 10             	add    $0x10,%esp
  8067d9:	e9 91 00 00 00       	jmp    80686f <ip_input+0x2f7>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  8067de:	83 ec 08             	sub    $0x8,%esp
  8067e1:	ff 75 0c             	pushl  0xc(%ebp)
  8067e4:	ff 75 08             	pushl  0x8(%ebp)
  8067e7:	e8 32 77 00 00       	call   80df1e <icmp_input>
      break;
  8067ec:	83 c4 10             	add    $0x10,%esp
  8067ef:	eb 7e                	jmp    80686f <ip_input+0x2f7>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8067f1:	83 ec 08             	sub    $0x8,%esp
  8067f4:	ff 75 0c             	pushl  0xc(%ebp)
  8067f7:	8d 46 10             	lea    0x10(%esi),%eax
  8067fa:	50                   	push   %eax
  8067fb:	e8 ce fc ff ff       	call   8064ce <ip_addr_isbroadcast>
  806800:	83 c4 10             	add    $0x10,%esp
  806803:	84 c0                	test   %al,%al
  806805:	75 39                	jne    806840 <ip_input+0x2c8>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  806807:	8b 5e 10             	mov    0x10(%esi),%ebx
  80680a:	83 ec 0c             	sub    $0xc,%esp
  80680d:	68 00 00 00 f0       	push   $0xf0000000
  806812:	e8 fa 10 00 00       	call   807911 <ntohl>
  806817:	21 c3                	and    %eax,%ebx
  806819:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806820:	e8 ec 10 00 00       	call   807911 <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806825:	83 c4 10             	add    $0x10,%esp
  806828:	39 c3                	cmp    %eax,%ebx
  80682a:	74 14                	je     806840 <ip_input+0x2c8>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  80682c:	8b 45 08             	mov    0x8(%ebp),%eax
  80682f:	89 70 04             	mov    %esi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  806832:	83 ec 08             	sub    $0x8,%esp
  806835:	6a 02                	push   $0x2
  806837:	50                   	push   %eax
  806838:	e8 f3 79 00 00       	call   80e230 <icmp_dest_unreach>
  80683d:	83 c4 10             	add    $0x10,%esp
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  806840:	83 ec 0c             	sub    $0xc,%esp
  806843:	ff 75 08             	pushl  0x8(%ebp)
  806846:	e8 da df ff ff       	call   804825 <pbuf_free>
  80684b:	83 c4 10             	add    $0x10,%esp
  80684e:	eb 1f                	jmp    80686f <ip_input+0x2f7>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806850:	83 ec 08             	sub    $0x8,%esp
  806853:	ff 75 0c             	pushl  0xc(%ebp)
  806856:	8d 46 0c             	lea    0xc(%esi),%eax
  806859:	50                   	push   %eax
  80685a:	e8 6f fc ff ff       	call   8064ce <ip_addr_isbroadcast>
  80685f:	83 c4 10             	add    $0x10,%esp
  806862:	84 c0                	test   %al,%al
  806864:	0f 84 81 fe ff ff    	je     8066eb <ip_input+0x173>
  80686a:	e9 a1 fe ff ff       	jmp    806710 <ip_input+0x198>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  80686f:	b8 00 00 00 00       	mov    $0x0,%eax
  806874:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806877:	5b                   	pop    %ebx
  806878:	5e                   	pop    %esi
  806879:	5f                   	pop    %edi
  80687a:	5d                   	pop    %ebp
  80687b:	c3                   	ret    

0080687c <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  80687c:	55                   	push   %ebp
  80687d:	89 e5                	mov    %esp,%ebp
  80687f:	57                   	push   %edi
  806880:	56                   	push   %esi
  806881:	53                   	push   %ebx
  806882:	83 ec 1c             	sub    $0x1c,%esp
  806885:	8b 75 08             	mov    0x8(%ebp),%esi
  806888:	8b 7d 14             	mov    0x14(%ebp),%edi
  80688b:	8b 45 18             	mov    0x18(%ebp),%eax
  80688e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806891:	8b 45 1c             	mov    0x1c(%ebp),%eax
  806894:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  806897:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80689b:	0f 84 12 01 00 00    	je     8069b3 <ip_output_if+0x137>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  8068a1:	83 ec 08             	sub    $0x8,%esp
  8068a4:	6a 14                	push   $0x14
  8068a6:	56                   	push   %esi
  8068a7:	e8 a7 de ff ff       	call   804753 <pbuf_header>
  8068ac:	83 c4 10             	add    $0x10,%esp
  8068af:	84 c0                	test   %al,%al
  8068b1:	0f 85 40 01 00 00    	jne    8069f7 <ip_output_if+0x17b>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  8068b7:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  8068ba:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  8068bf:	77 17                	ja     8068d8 <ip_output_if+0x5c>
  8068c1:	83 ec 04             	sub    $0x4,%esp
  8068c4:	68 a8 1c 81 00       	push   $0x811ca8
  8068c9:	68 ee 01 00 00       	push   $0x1ee
  8068ce:	68 d5 1c 81 00       	push   $0x811cd5
  8068d3:	e8 76 7b 00 00       	call   80e44e <_panic>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  8068d8:	83 ec 0c             	sub    $0xc,%esp
  8068db:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8068df:	50                   	push   %eax
  8068e0:	e8 fe 0d 00 00       	call   8076e3 <ntohs>
  8068e5:	0f b6 c0             	movzbl %al,%eax
  8068e8:	c1 e7 08             	shl    $0x8,%edi
  8068eb:	09 c7                	or     %eax,%edi
  8068ed:	0f b7 ff             	movzwl %di,%edi
  8068f0:	89 3c 24             	mov    %edi,(%esp)
  8068f3:	e8 de 0d 00 00       	call   8076d6 <htons>
  8068f8:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  8068fc:	0f b7 c0             	movzwl %ax,%eax
  8068ff:	89 04 24             	mov    %eax,(%esp)
  806902:	e8 dc 0d 00 00       	call   8076e3 <ntohs>
  806907:	25 00 ff 00 00       	and    $0xff00,%eax
  80690c:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  806910:	09 d0                	or     %edx,%eax
  806912:	0f b7 c0             	movzwl %ax,%eax
  806915:	89 04 24             	mov    %eax,(%esp)
  806918:	e8 b9 0d 00 00       	call   8076d6 <htons>
  80691d:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806921:	8b 45 10             	mov    0x10(%ebp),%eax
  806924:	8b 00                	mov    (%eax),%eax
  806926:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  806929:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80692d:	80 cc 45             	or     $0x45,%ah
  806930:	89 04 24             	mov    %eax,(%esp)
  806933:	e8 9e 0d 00 00       	call   8076d6 <htons>
  806938:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  80693b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80693f:	89 04 24             	mov    %eax,(%esp)
  806942:	e8 8f 0d 00 00       	call   8076d6 <htons>
  806947:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  80694b:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806951:	0f b7 05 fa 43 b3 00 	movzwl 0xb343fa,%eax
  806958:	89 04 24             	mov    %eax,(%esp)
  80695b:	e8 76 0d 00 00       	call   8076d6 <htons>
  806960:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  806964:	66 83 05 fa 43 b3 00 	addw   $0x1,0xb343fa
  80696b:	01 

    if (ip_addr_isany(src)) {
  80696c:	83 c4 10             	add    $0x10,%esp
  80696f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806973:	74 09                	je     80697e <ip_output_if+0x102>
  806975:	8b 45 0c             	mov    0xc(%ebp),%eax
  806978:	8b 00                	mov    (%eax),%eax
  80697a:	85 c0                	test   %eax,%eax
  80697c:	75 18                	jne    806996 <ip_output_if+0x11a>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  80697e:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  806982:	74 08                	je     80698c <ip_output_if+0x110>
  806984:	8b 45 20             	mov    0x20(%ebp),%eax
  806987:	8b 40 04             	mov    0x4(%eax),%eax
  80698a:	eb 05                	jmp    806991 <ip_output_if+0x115>
  80698c:	b8 00 00 00 00       	mov    $0x0,%eax
  806991:	89 43 0c             	mov    %eax,0xc(%ebx)
  806994:	eb 03                	jmp    806999 <ip_output_if+0x11d>
    } else {
      ip_addr_set(&(iphdr->src), src);
  806996:	89 43 0c             	mov    %eax,0xc(%ebx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806999:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80699f:	83 ec 08             	sub    $0x8,%esp
  8069a2:	6a 14                	push   $0x14
  8069a4:	53                   	push   %ebx
  8069a5:	e8 07 0c 00 00       	call   8075b1 <inet_chksum>
  8069aa:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  8069ae:	83 c4 10             	add    $0x10,%esp
  8069b1:	eb 09                	jmp    8069bc <ip_output_if+0x140>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  8069b3:	8b 46 04             	mov    0x4(%esi),%eax
  8069b6:	83 c0 10             	add    $0x10,%eax
  8069b9:	89 45 10             	mov    %eax,0x10(%ebp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  8069bc:	8b 45 20             	mov    0x20(%ebp),%eax
  8069bf:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  8069c3:	66 85 c0             	test   %ax,%ax
  8069c6:	74 1a                	je     8069e2 <ip_output_if+0x166>
  8069c8:	66 3b 46 08          	cmp    0x8(%esi),%ax
  8069cc:	73 14                	jae    8069e2 <ip_output_if+0x166>
    return ip_frag(p,netif,dest);
  8069ce:	83 ec 04             	sub    $0x4,%esp
  8069d1:	ff 75 10             	pushl  0x10(%ebp)
  8069d4:	ff 75 20             	pushl  0x20(%ebp)
  8069d7:	56                   	push   %esi
  8069d8:	e8 84 07 00 00       	call   807161 <ip_frag>
  8069dd:	83 c4 10             	add    $0x10,%esp
  8069e0:	eb 1a                	jmp    8069fc <ip_output_if+0x180>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  8069e2:	83 ec 04             	sub    $0x4,%esp
  8069e5:	ff 75 10             	pushl  0x10(%ebp)
  8069e8:	56                   	push   %esi
  8069e9:	ff 75 20             	pushl  0x20(%ebp)
  8069ec:	8b 45 20             	mov    0x20(%ebp),%eax
  8069ef:	ff 50 14             	call   *0x14(%eax)
  8069f2:	83 c4 10             	add    $0x10,%esp
  8069f5:	eb 05                	jmp    8069fc <ip_output_if+0x180>
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  8069f7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  }
}
  8069fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8069ff:	5b                   	pop    %ebx
  806a00:	5e                   	pop    %esi
  806a01:	5f                   	pop    %edi
  806a02:	5d                   	pop    %ebp
  806a03:	c3                   	ret    

00806a04 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806a04:	55                   	push   %ebp
  806a05:	89 e5                	mov    %esp,%ebp
  806a07:	57                   	push   %edi
  806a08:	56                   	push   %esi
  806a09:	53                   	push   %ebx
  806a0a:	83 ec 18             	sub    $0x18,%esp
  806a0d:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806a10:	8b 75 18             	mov    0x18(%ebp),%esi
  806a13:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806a16:	ff 75 10             	pushl  0x10(%ebp)
  806a19:	e8 fc fa ff ff       	call   80651a <ip_route>
  806a1e:	83 c4 10             	add    $0x10,%esp
  806a21:	85 c0                	test   %eax,%eax
  806a23:	74 27                	je     806a4c <ip_output+0x48>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806a25:	83 ec 04             	sub    $0x4,%esp
  806a28:	50                   	push   %eax
  806a29:	89 f8                	mov    %edi,%eax
  806a2b:	0f b6 f8             	movzbl %al,%edi
  806a2e:	57                   	push   %edi
  806a2f:	89 f0                	mov    %esi,%eax
  806a31:	0f b6 f0             	movzbl %al,%esi
  806a34:	56                   	push   %esi
  806a35:	0f b6 db             	movzbl %bl,%ebx
  806a38:	53                   	push   %ebx
  806a39:	ff 75 10             	pushl  0x10(%ebp)
  806a3c:	ff 75 0c             	pushl  0xc(%ebp)
  806a3f:	ff 75 08             	pushl  0x8(%ebp)
  806a42:	e8 35 fe ff ff       	call   80687c <ip_output_if>
  806a47:	83 c4 20             	add    $0x20,%esp
  806a4a:	eb 05                	jmp    806a51 <ip_output+0x4d>
          u8_t ttl, u8_t tos, u8_t proto)
{
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
    return ERR_RTE;
  806a4c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
}
  806a51:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806a54:	5b                   	pop    %ebx
  806a55:	5e                   	pop    %esi
  806a56:	5f                   	pop    %edi
  806a57:	5d                   	pop    %ebp
  806a58:	c3                   	ret    

00806a59 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806a59:	55                   	push   %ebp
  806a5a:	89 e5                	mov    %esp,%ebp
  806a5c:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  806a5f:	8b 0d e0 49 b3 00    	mov    0xb349e0,%ecx
  806a65:	39 c1                	cmp    %eax,%ecx
  806a67:	75 0a                	jne    806a73 <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  806a69:	8b 11                	mov    (%ecx),%edx
  806a6b:	89 15 e0 49 b3 00    	mov    %edx,0xb349e0
  806a71:	eb 1f                	jmp    806a92 <ip_reass_dequeue_datagram+0x39>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806a73:	85 d2                	test   %edx,%edx
  806a75:	75 17                	jne    806a8e <ip_reass_dequeue_datagram+0x35>
  806a77:	83 ec 04             	sub    $0x4,%esp
  806a7a:	68 ed 1c 81 00       	push   $0x811ced
  806a7f:	68 29 01 00 00       	push   $0x129
  806a84:	68 06 1d 81 00       	push   $0x811d06
  806a89:	e8 c0 79 00 00       	call   80e44e <_panic>
    prev->next = ipr->next;
  806a8e:	8b 08                	mov    (%eax),%ecx
  806a90:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  806a92:	83 ec 08             	sub    $0x8,%esp
  806a95:	50                   	push   %eax
  806a96:	6a 05                	push   $0x5
  806a98:	e8 15 da ff ff       	call   8044b2 <memp_free>
}
  806a9d:	83 c4 10             	add    $0x10,%esp
  806aa0:	c9                   	leave  
  806aa1:	c3                   	ret    

00806aa2 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806aa2:	55                   	push   %ebp
  806aa3:	89 e5                	mov    %esp,%ebp
  806aa5:	57                   	push   %edi
  806aa6:	56                   	push   %esi
  806aa7:	53                   	push   %ebx
  806aa8:	83 ec 1c             	sub    $0x1c,%esp
  806aab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806aae:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  806ab1:	39 c2                	cmp    %eax,%edx
  806ab3:	75 17                	jne    806acc <ip_reass_free_complete_datagram+0x2a>
  806ab5:	83 ec 04             	sub    $0x4,%esp
  806ab8:	68 23 1d 81 00       	push   $0x811d23
  806abd:	68 99 00 00 00       	push   $0x99
  806ac2:	68 06 1d 81 00       	push   $0x811d06
  806ac7:	e8 82 79 00 00       	call   80e44e <_panic>
  if (prev != NULL) {
  806acc:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806acf:	85 c0                	test   %eax,%eax
  806ad1:	74 1e                	je     806af1 <ip_reass_free_complete_datagram+0x4f>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806ad3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806ad6:	3b 10                	cmp    (%eax),%edx
  806ad8:	74 17                	je     806af1 <ip_reass_free_complete_datagram+0x4f>
  806ada:	83 ec 04             	sub    $0x4,%esp
  806add:	68 2f 1d 81 00       	push   $0x811d2f
  806ae2:	68 9b 00 00 00       	push   $0x9b
  806ae7:	68 06 1d 81 00       	push   $0x811d06
  806aec:	e8 5d 79 00 00       	call   80e44e <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806af1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806af4:	8b 58 04             	mov    0x4(%eax),%ebx
  806af7:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  int pbufs_freed = 0;
  806afa:	be 00 00 00 00       	mov    $0x0,%esi
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
  806aff:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806b04:	75 3a                	jne    806b40 <ip_reass_free_complete_datagram+0x9e>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  806b06:	8b 00                	mov    (%eax),%eax
  806b08:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806b0b:	89 41 04             	mov    %eax,0x4(%ecx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806b0e:	83 ec 04             	sub    $0x4,%esp
  806b11:	6a 14                	push   $0x14
  806b13:	8d 41 08             	lea    0x8(%ecx),%eax
  806b16:	50                   	push   %eax
  806b17:	ff 73 04             	pushl  0x4(%ebx)
  806b1a:	e8 87 81 00 00       	call   80eca6 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806b1f:	83 c4 08             	add    $0x8,%esp
  806b22:	6a 01                	push   $0x1
  806b24:	53                   	push   %ebx
  806b25:	e8 e5 77 00 00       	call   80e30f <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806b2a:	89 1c 24             	mov    %ebx,(%esp)
  806b2d:	e8 52 e1 ff ff       	call   804c84 <pbuf_clen>
  806b32:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806b35:	89 1c 24             	mov    %ebx,(%esp)
  806b38:	e8 e8 dc ff ff       	call   804825 <pbuf_free>
  806b3d:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  806b40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806b43:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806b46:	eb 20                	jmp    806b68 <ip_reass_free_complete_datagram+0xc6>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  806b48:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  806b4b:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806b4d:	83 ec 0c             	sub    $0xc,%esp
  806b50:	53                   	push   %ebx
  806b51:	e8 2e e1 ff ff       	call   804c84 <pbuf_clen>
  806b56:	0f b6 c0             	movzbl %al,%eax
  806b59:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806b5b:	89 1c 24             	mov    %ebx,(%esp)
  806b5e:	e8 c2 dc ff ff       	call   804825 <pbuf_free>
  806b63:	83 c4 10             	add    $0x10,%esp
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  806b66:	89 fb                	mov    %edi,%ebx
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  806b68:	85 db                	test   %ebx,%ebx
  806b6a:	75 dc                	jne    806b48 <ip_reass_free_complete_datagram+0xa6>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  806b6c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806b6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806b72:	e8 e2 fe ff ff       	call   806a59 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806b77:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806b7e:	0f b7 d0             	movzwl %ax,%edx
  806b81:	39 d6                	cmp    %edx,%esi
  806b83:	7e 17                	jle    806b9c <ip_reass_free_complete_datagram+0xfa>
  806b85:	83 ec 04             	sub    $0x4,%esp
  806b88:	68 41 1d 81 00       	push   $0x811d41
  806b8d:	68 bc 00 00 00       	push   $0xbc
  806b92:	68 06 1d 81 00       	push   $0x811d06
  806b97:	e8 b2 78 00 00       	call   80e44e <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  806b9c:	29 f0                	sub    %esi,%eax
  806b9e:	66 a3 dc 49 b3 00    	mov    %ax,0xb349dc

  return pbufs_freed;
}
  806ba4:	89 f0                	mov    %esi,%eax
  806ba6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806ba9:	5b                   	pop    %ebx
  806baa:	5e                   	pop    %esi
  806bab:	5f                   	pop    %edi
  806bac:	5d                   	pop    %ebp
  806bad:	c3                   	ret    

00806bae <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  806bae:	55                   	push   %ebp
  806baf:	89 e5                	mov    %esp,%ebp
  806bb1:	57                   	push   %edi
  806bb2:	56                   	push   %esi
  806bb3:	53                   	push   %ebx
  806bb4:	83 ec 1c             	sub    $0x1c,%esp
  806bb7:	89 c6                	mov    %eax,%esi
  806bb9:	89 55 dc             	mov    %edx,-0x24(%ebp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  806bbc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  806bc3:	8b 0d e0 49 b3 00    	mov    0xb349e0,%ecx
  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
  806bc9:	bb 00 00 00 00       	mov    $0x0,%ebx

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
  806bce:	ba 00 00 00 00       	mov    $0x0,%edx
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  806bd3:	b8 00 00 00 00       	mov    $0x0,%eax
  806bd8:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  806bdb:	eb 39                	jmp    806c16 <ip_reass_remove_oldest_datagram+0x68>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806bdd:	8b 5e 0c             	mov    0xc(%esi),%ebx
  806be0:	39 59 14             	cmp    %ebx,0x14(%ecx)
  806be3:	75 12                	jne    806bf7 <ip_reass_remove_oldest_datagram+0x49>
  806be5:	8b 7e 10             	mov    0x10(%esi),%edi
  806be8:	39 79 18             	cmp    %edi,0x18(%ecx)
  806beb:	75 0a                	jne    806bf7 <ip_reass_remove_oldest_datagram+0x49>
  806bed:	0f b7 7e 04          	movzwl 0x4(%esi),%edi
  806bf1:	66 39 79 0c          	cmp    %di,0xc(%ecx)
  806bf5:	74 16                	je     806c0d <ip_reass_remove_oldest_datagram+0x5f>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  806bf7:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (oldest == NULL) {
  806bfb:	85 c0                	test   %eax,%eax
  806bfd:	74 0c                	je     806c0b <ip_reass_remove_oldest_datagram+0x5d>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
  806bff:	0f b6 58 1f          	movzbl 0x1f(%eax),%ebx
  806c03:	38 59 1f             	cmp    %bl,0x1f(%ecx)
  806c06:	0f 46 c1             	cmovbe %ecx,%eax
  806c09:	eb 02                	jmp    806c0d <ip_reass_remove_oldest_datagram+0x5f>
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
        if (oldest == NULL) {
          oldest = r;
  806c0b:	89 c8                	mov    %ecx,%eax
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  806c0d:	8b 39                	mov    (%ecx),%edi
        prev = r;
  806c0f:	85 ff                	test   %edi,%edi
  806c11:	0f 45 d1             	cmovne %ecx,%edx
  806c14:	89 f9                	mov    %edi,%ecx
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  806c16:	85 c9                	test   %ecx,%ecx
  806c18:	75 c3                	jne    806bdd <ip_reass_remove_oldest_datagram+0x2f>
  806c1a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  806c1d:	85 c0                	test   %eax,%eax
  806c1f:	74 08                	je     806c29 <ip_reass_remove_oldest_datagram+0x7b>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806c21:	e8 7c fe ff ff       	call   806aa2 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806c26:	01 45 e0             	add    %eax,-0x20(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806c29:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806c2c:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  806c2f:	7d 05                	jge    806c36 <ip_reass_remove_oldest_datagram+0x88>
  806c31:	83 fb 01             	cmp    $0x1,%ebx
  806c34:	7f 8d                	jg     806bc3 <ip_reass_remove_oldest_datagram+0x15>
  return pbufs_freed;
}
  806c36:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806c39:	83 c4 1c             	add    $0x1c,%esp
  806c3c:	5b                   	pop    %ebx
  806c3d:	5e                   	pop    %esi
  806c3e:	5f                   	pop    %edi
  806c3f:	5d                   	pop    %ebp
  806c40:	c3                   	ret    

00806c41 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  806c41:	55                   	push   %ebp
  806c42:	89 e5                	mov    %esp,%ebp
  806c44:	56                   	push   %esi
  806c45:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  806c46:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;
  806c4b:	bb 00 00 00 00       	mov    $0x0,%ebx

  r = reassdatagrams;
  while (r != NULL) {
  806c50:	eb 1f                	jmp    806c71 <ip_reass_tmr+0x30>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  806c52:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  806c56:	84 d2                	test   %dl,%dl
  806c58:	74 0c                	je     806c66 <ip_reass_tmr+0x25>
      r->timer--;
  806c5a:	83 ea 01             	sub    $0x1,%edx
  806c5d:	88 50 1f             	mov    %dl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  806c60:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806c62:	8b 00                	mov    (%eax),%eax
  806c64:	eb 0b                	jmp    806c71 <ip_reass_tmr+0x30>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  806c66:	8b 30                	mov    (%eax),%esi
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  806c68:	89 da                	mov    %ebx,%edx
  806c6a:	e8 33 fe ff ff       	call   806aa2 <ip_reass_free_complete_datagram>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  806c6f:	89 f0                	mov    %esi,%eax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  806c71:	85 c0                	test   %eax,%eax
  806c73:	75 dd                	jne    806c52 <ip_reass_tmr+0x11>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  806c75:	5b                   	pop    %ebx
  806c76:	5e                   	pop    %esi
  806c77:	5d                   	pop    %ebp
  806c78:	c3                   	ret    

00806c79 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806c79:	55                   	push   %ebp
  806c7a:	89 e5                	mov    %esp,%ebp
  806c7c:	57                   	push   %edi
  806c7d:	56                   	push   %esi
  806c7e:	53                   	push   %ebx
  806c7f:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806c82:	8b 45 08             	mov    0x8(%ebp),%eax
  806c85:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806c88:	0f b7 03             	movzwl (%ebx),%eax
  806c8b:	50                   	push   %eax
  806c8c:	e8 52 0a 00 00       	call   8076e3 <ntohs>
  806c91:	66 c1 e8 08          	shr    $0x8,%ax
  806c95:	83 e0 0f             	and    $0xf,%eax
  806c98:	83 c4 10             	add    $0x10,%esp
  806c9b:	83 f8 05             	cmp    $0x5,%eax
  806c9e:	0f 85 71 04 00 00    	jne    807115 <ip_reass+0x49c>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806ca4:	83 ec 0c             	sub    $0xc,%esp
  806ca7:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806cab:	50                   	push   %eax
  806cac:	e8 32 0a 00 00       	call   8076e3 <ntohs>
  806cb1:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806cb5:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806cb9:	89 04 24             	mov    %eax,(%esp)
  806cbc:	e8 22 0a 00 00       	call   8076e3 <ntohs>
  806cc1:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  806cc5:	0f b7 03             	movzwl (%ebx),%eax
  806cc8:	89 04 24             	mov    %eax,(%esp)
  806ccb:	e8 13 0a 00 00       	call   8076e3 <ntohs>
  806cd0:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806cd4:	83 c4 04             	add    $0x4,%esp
  806cd7:	ff 75 08             	pushl  0x8(%ebp)
  806cda:	e8 a5 df ff ff       	call   804c84 <pbuf_clen>
  806cdf:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806ce2:	0f b6 f0             	movzbl %al,%esi
  806ce5:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806cec:	01 f0                	add    %esi,%eax
  806cee:	83 c4 10             	add    $0x10,%esp
  806cf1:	83 f8 0a             	cmp    $0xa,%eax
  806cf4:	7e 23                	jle    806d19 <ip_reass+0xa0>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806cf6:	89 f2                	mov    %esi,%edx
  806cf8:	89 d8                	mov    %ebx,%eax
  806cfa:	e8 af fe ff ff       	call   806bae <ip_reass_remove_oldest_datagram>
  806cff:	85 c0                	test   %eax,%eax
  806d01:	0f 84 0e 04 00 00    	je     807115 <ip_reass+0x49c>
  806d07:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806d0e:	01 f0                	add    %esi,%eax
  806d10:	83 f8 0a             	cmp    $0xa,%eax
  806d13:	0f 8f fc 03 00 00    	jg     807115 <ip_reass+0x49c>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806d19:	8b 3d e0 49 b3 00    	mov    0xb349e0,%edi
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  806d1f:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806d24:	eb 1e                	jmp    806d44 <ip_reass+0xcb>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806d26:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806d29:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806d2c:	75 12                	jne    806d40 <ip_reass+0xc7>
  806d2e:	8b 53 10             	mov    0x10(%ebx),%edx
  806d31:	39 57 18             	cmp    %edx,0x18(%edi)
  806d34:	75 0a                	jne    806d40 <ip_reass+0xc7>
  806d36:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  806d3a:	66 39 4f 0c          	cmp    %cx,0xc(%edi)
  806d3e:	74 7f                	je     806dbf <ip_reass+0x146>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806d40:	89 f8                	mov    %edi,%eax
  806d42:	8b 3f                	mov    (%edi),%edi
  806d44:	85 ff                	test   %edi,%edi
  806d46:	75 de                	jne    806d26 <ip_reass+0xad>
  806d48:	89 45 e0             	mov    %eax,-0x20(%ebp)
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  806d4b:	83 ec 0c             	sub    $0xc,%esp
  806d4e:	6a 05                	push   $0x5
  806d50:	e8 07 d7 ff ff       	call   80445c <memp_malloc>
  806d55:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  806d57:	83 c4 10             	add    $0x10,%esp
  806d5a:	85 c0                	test   %eax,%eax
  806d5c:	75 28                	jne    806d86 <ip_reass+0x10d>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  806d5e:	89 f2                	mov    %esi,%edx
  806d60:	89 d8                	mov    %ebx,%eax
  806d62:	e8 47 fe ff ff       	call   806bae <ip_reass_remove_oldest_datagram>
  806d67:	39 c6                	cmp    %eax,%esi
  806d69:	0f 8f a6 03 00 00    	jg     807115 <ip_reass+0x49c>
      ipr = memp_malloc(MEMP_REASSDATA);
  806d6f:	83 ec 0c             	sub    $0xc,%esp
  806d72:	6a 05                	push   $0x5
  806d74:	e8 e3 d6 ff ff       	call   80445c <memp_malloc>
  806d79:	89 c7                	mov    %eax,%edi
    }
    if (ipr == NULL)
  806d7b:	83 c4 10             	add    $0x10,%esp
  806d7e:	85 c0                	test   %eax,%eax
  806d80:	0f 84 8f 03 00 00    	je     807115 <ip_reass+0x49c>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  806d86:	83 ec 04             	sub    $0x4,%esp
  806d89:	6a 20                	push   $0x20
  806d8b:	6a 00                	push   $0x0
  806d8d:	57                   	push   %edi
  806d8e:	e8 5e 7e 00 00       	call   80ebf1 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  806d93:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  806d97:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  806d9c:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  806d9e:	89 3d e0 49 b3 00    	mov    %edi,0xb349e0
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  806da4:	83 c4 0c             	add    $0xc,%esp
  806da7:	6a 14                	push   $0x14
  806da9:	53                   	push   %ebx
  806daa:	8d 47 08             	lea    0x8(%edi),%eax
  806dad:	50                   	push   %eax
  806dae:	e8 f3 7e 00 00       	call   80eca6 <memcpy>

  if (ipr == NULL) {
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
  806db3:	83 c4 10             	add    $0x10,%esp
  806db6:	85 ff                	test   %edi,%edi
  806db8:	75 46                	jne    806e00 <ip_reass+0x187>
  806dba:	e9 56 03 00 00       	jmp    807115 <ip_reass+0x49c>
  806dbf:	89 45 e0             	mov    %eax,-0x20(%ebp)
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806dc2:	83 ec 0c             	sub    $0xc,%esp
  806dc5:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806dc9:	50                   	push   %eax
  806dca:	e8 14 09 00 00       	call   8076e3 <ntohs>
  806dcf:	83 c4 10             	add    $0x10,%esp
  806dd2:	66 a9 ff 1f          	test   $0x1fff,%ax
  806dd6:	75 28                	jne    806e00 <ip_reass+0x187>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  806dd8:	83 ec 0c             	sub    $0xc,%esp
  806ddb:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  806ddf:	50                   	push   %eax
  806de0:	e8 fe 08 00 00       	call   8076e3 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806de5:	83 c4 10             	add    $0x10,%esp
  806de8:	66 a9 ff 1f          	test   $0x1fff,%ax
  806dec:	74 12                	je     806e00 <ip_reass+0x187>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  806dee:	83 ec 04             	sub    $0x4,%esp
  806df1:	6a 14                	push   $0x14
  806df3:	53                   	push   %ebx
  806df4:	8d 47 08             	lea    0x8(%edi),%eax
  806df7:	50                   	push   %eax
  806df8:	e8 a9 7e 00 00       	call   80eca6 <memcpy>
  806dfd:	83 c4 10             	add    $0x10,%esp
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806e00:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806e04:	66 01 05 dc 49 b3 00 	add    %ax,0xb349dc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806e0b:	83 ec 0c             	sub    $0xc,%esp
  806e0e:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806e12:	50                   	push   %eax
  806e13:	e8 cb 08 00 00       	call   8076e3 <ntohs>
  806e18:	83 c4 10             	add    $0x10,%esp
  806e1b:	f6 c4 20             	test   $0x20,%ah
  806e1e:	75 20                	jne    806e40 <ip_reass+0x1c7>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806e20:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    ipr->datagram_len = offset + len;
  806e24:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  806e28:	0f b7 75 da          	movzwl -0x26(%ebp),%esi
  806e2c:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  806e2f:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
  806e33:	66 c1 ea 06          	shr    $0x6,%dx
  806e37:	83 e2 3c             	and    $0x3c,%edx
  806e3a:	29 d0                	sub    %edx,%eax
  806e3c:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806e40:	8b 45 08             	mov    0x8(%ebp),%eax
  806e43:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806e46:	83 ec 0c             	sub    $0xc,%esp
  806e49:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806e4d:	50                   	push   %eax
  806e4e:	e8 90 08 00 00       	call   8076e3 <ntohs>
  806e53:	89 c6                	mov    %eax,%esi
  806e55:	0f b7 03             	movzwl (%ebx),%eax
  806e58:	89 04 24             	mov    %eax,(%esp)
  806e5b:	e8 83 08 00 00       	call   8076e3 <ntohs>
  806e60:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806e64:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806e68:	89 04 24             	mov    %eax,(%esp)
  806e6b:	e8 73 08 00 00       	call   8076e3 <ntohs>
  806e70:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  806e77:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806e7a:	8b 51 04             	mov    0x4(%ecx),%edx
  806e7d:	89 55 dc             	mov    %edx,-0x24(%ebp)
  iprh->next_pbuf = NULL;
  806e80:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  806e86:	66 89 5a 04          	mov    %bx,0x4(%edx)
  iprh->end = offset + len;
  806e8a:	01 de                	add    %ebx,%esi
  806e8c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806e90:	66 c1 e8 06          	shr    $0x6,%ax
  806e94:	83 e0 3c             	and    $0x3c,%eax
  806e97:	29 c6                	sub    %eax,%esi
  806e99:	66 89 75 da          	mov    %si,-0x26(%ebp)
  806e9d:	66 89 72 06          	mov    %si,0x6(%edx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  806ea1:	8b 47 04             	mov    0x4(%edi),%eax
  806ea4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  806ea7:	83 c4 10             	add    $0x10,%esp
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  806eaa:	b9 01 00 00 00       	mov    $0x1,%ecx
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  806eaf:	be 00 00 00 00       	mov    $0x0,%esi
  806eb4:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806eb7:	89 cf                	mov    %ecx,%edi
  806eb9:	eb 6f                	jmp    806f2a <ip_reass+0x2b1>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806ebb:	8b 50 04             	mov    0x4(%eax),%edx
    if (iprh->start < iprh_tmp->start) {
  806ebe:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  806ec2:	66 39 cb             	cmp    %cx,%bx
  806ec5:	73 3c                	jae    806f03 <ip_reass+0x28a>
  806ec7:	89 7d d0             	mov    %edi,-0x30(%ebp)
  806eca:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  806ecd:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  806ed0:	89 01                	mov    %eax,(%ecx)
      if (iprh_prev != NULL) {
  806ed2:	85 f6                	test   %esi,%esi
  806ed4:	74 22                	je     806ef8 <ip_reass+0x27f>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  806ed6:	66 3b 5e 06          	cmp    0x6(%esi),%bx
  806eda:	0f 82 6c 01 00 00    	jb     80704c <ip_reass+0x3d3>
  806ee0:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  806ee4:	66 3b 42 04          	cmp    0x4(%edx),%ax
  806ee8:	0f 87 5e 01 00 00    	ja     80704c <ip_reass+0x3d3>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  806eee:	8b 45 08             	mov    0x8(%ebp),%eax
  806ef1:	89 06                	mov    %eax,(%esi)
  806ef3:	e9 92 00 00 00       	jmp    806f8a <ip_reass+0x311>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  806ef8:	8b 45 08             	mov    0x8(%ebp),%eax
  806efb:	89 47 04             	mov    %eax,0x4(%edi)
  806efe:	e9 87 00 00 00       	jmp    806f8a <ip_reass+0x311>
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  806f03:	66 39 cb             	cmp    %cx,%bx
  806f06:	0f 84 40 01 00 00    	je     80704c <ip_reass+0x3d3>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  806f0c:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  806f10:	0f 82 36 01 00 00    	jb     80704c <ip_reass+0x3d3>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  806f16:	85 f6                	test   %esi,%esi
  806f18:	74 0c                	je     806f26 <ip_reass+0x2ad>
        if (iprh_prev->end != iprh_tmp->start) {
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  806f1a:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  806f1e:	b8 00 00 00 00       	mov    $0x0,%eax
  806f23:	0f 45 f8             	cmovne %eax,%edi
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  806f26:	8b 02                	mov    (%edx),%eax
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806f28:	89 d6                	mov    %edx,%esi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  806f2a:	85 c0                	test   %eax,%eax
  806f2c:	75 8d                	jne    806ebb <ip_reass+0x242>
  806f2e:	e9 fe 01 00 00       	jmp    807131 <ip_reass+0x4b8>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  806f33:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  806f37:	66 39 c3             	cmp    %ax,%bx
  806f3a:	73 17                	jae    806f53 <ip_reass+0x2da>
  806f3c:	83 ec 04             	sub    $0x4,%esp
  806f3f:	68 5c 1d 81 00       	push   $0x811d5c
  806f44:	68 83 01 00 00       	push   $0x183
  806f49:	68 06 1d 81 00       	push   $0x811d06
  806f4e:	e8 fb 74 00 00       	call   80e44e <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  806f53:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806f56:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  806f58:	8b 75 dc             	mov    -0x24(%ebp),%esi
  806f5b:	66 3b 46 04          	cmp    0x4(%esi),%ax
  806f5f:	0f 85 ef 01 00 00    	jne    807154 <ip_reass+0x4db>
  806f65:	eb 23                	jmp    806f8a <ip_reass+0x311>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  806f67:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  806f6b:	74 17                	je     806f84 <ip_reass+0x30b>
  806f6d:	83 ec 04             	sub    $0x4,%esp
  806f70:	68 88 1d 81 00       	push   $0x811d88
  806f75:	68 8c 01 00 00       	push   $0x18c
  806f7a:	68 06 1d 81 00       	push   $0x811d06
  806f7f:	e8 ca 74 00 00       	call   80e44e <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  806f84:	8b 45 08             	mov    0x8(%ebp),%eax
  806f87:	89 47 04             	mov    %eax,0x4(%edi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  806f8a:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  806f8e:	0f 84 c0 01 00 00    	je     807154 <ip_reass+0x4db>
    /* and had no wholes so far */
    if (valid) {
  806f94:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  806f98:	0f 84 b6 01 00 00    	je     807154 <ip_reass+0x4db>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  806f9e:	8b 4f 04             	mov    0x4(%edi),%ecx
  806fa1:	8b 59 04             	mov    0x4(%ecx),%ebx
  806fa4:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  806fa9:	0f 85 a5 01 00 00    	jne    807154 <ip_reass+0x4db>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  806faf:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806fb2:	8b 10                	mov    (%eax),%edx
  806fb4:	89 c6                	mov    %eax,%esi
  806fb6:	eb 15                	jmp    806fcd <ip_reass+0x354>
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  806fb8:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  806fbb:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  806fbf:	66 39 56 06          	cmp    %dx,0x6(%esi)
  806fc3:	0f 85 61 01 00 00    	jne    80712a <ip_reass+0x4b1>
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  806fc9:	8b 10                	mov    (%eax),%edx
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  806fcb:	89 c6                	mov    %eax,%esi
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  806fcd:	85 d2                	test   %edx,%edx
  806fcf:	75 e7                	jne    806fb8 <ip_reass+0x33f>
  806fd1:	e9 6e 01 00 00       	jmp    807144 <ip_reass+0x4cb>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  806fd6:	83 ec 04             	sub    $0x4,%esp
  806fd9:	68 7a 1d 81 00       	push   $0x811d7a
  806fde:	68 ac 01 00 00       	push   $0x1ac
  806fe3:	68 06 1d 81 00       	push   $0x811d06
  806fe8:	e8 61 74 00 00       	call   80e44e <_panic>
          LWIP_ASSERT("sanity check",
  806fed:	3b 5d dc             	cmp    -0x24(%ebp),%ebx
  806ff0:	75 17                	jne    807009 <ip_reass+0x390>
  806ff2:	83 ec 04             	sub    $0x4,%esp
  806ff5:	68 7a 1d 81 00       	push   $0x811d7a
  806ffa:	68 ae 01 00 00       	push   $0x1ae
  806fff:	68 06 1d 81 00       	push   $0x811d06
  807004:	e8 45 74 00 00       	call   80e44e <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  807009:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80700c:	83 38 00             	cmpl   $0x0,(%eax)
  80700f:	74 17                	je     807028 <ip_reass+0x3af>
  807011:	83 ec 04             	sub    $0x4,%esp
  807014:	68 c0 1d 81 00       	push   $0x811dc0
  807019:	68 b0 01 00 00       	push   $0x1b0
  80701e:	68 06 1d 81 00       	push   $0x811d06
  807023:	e8 26 74 00 00       	call   80e44e <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  807028:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80702b:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  80702f:	66 3b 47 1c          	cmp    0x1c(%edi),%ax
  807033:	74 3f                	je     807074 <ip_reass+0x3fb>
  807035:	83 ec 04             	sub    $0x4,%esp
  807038:	68 e4 1d 81 00       	push   $0x811de4
  80703d:	68 b2 01 00 00       	push   $0x1b2
  807042:	68 06 1d 81 00       	push   $0x811d06
  807047:	e8 02 74 00 00       	call   80e44e <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  80704c:	83 ec 0c             	sub    $0xc,%esp
  80704f:	ff 75 08             	pushl  0x8(%ebp)
  807052:	e8 2d dc ff ff       	call   804c84 <pbuf_clen>
  807057:	0f b6 c0             	movzbl %al,%eax
  80705a:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
  pbuf_free(new_p);
  807061:	83 c4 04             	add    $0x4,%esp
  807064:	ff 75 08             	pushl  0x8(%ebp)
  807067:	e8 b9 d7 ff ff       	call   804825 <pbuf_free>
  80706c:	83 c4 10             	add    $0x10,%esp
  80706f:	e9 e0 00 00 00       	jmp    807154 <ip_reass+0x4db>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  807074:	83 c0 14             	add    $0x14,%eax
  807077:	66 89 47 1c          	mov    %ax,0x1c(%edi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  80707b:	8b 71 04             	mov    0x4(%ecx),%esi
  80707e:	8b 1e                	mov    (%esi),%ebx

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  807080:	83 ec 04             	sub    $0x4,%esp
  807083:	6a 14                	push   $0x14
  807085:	8d 47 08             	lea    0x8(%edi),%eax
  807088:	50                   	push   %eax
  807089:	56                   	push   %esi
  80708a:	e8 17 7c 00 00       	call   80eca6 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  80708f:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807093:	89 04 24             	mov    %eax,(%esp)
  807096:	e8 3b 06 00 00       	call   8076d6 <htons>
  80709b:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  80709f:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  8070a5:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  8070ab:	83 c4 08             	add    $0x8,%esp
  8070ae:	6a 14                	push   $0x14
  8070b0:	56                   	push   %esi
  8070b1:	e8 fb 04 00 00       	call   8075b1 <inet_chksum>
  8070b6:	66 89 46 0a          	mov    %ax,0xa(%esi)

    p = ipr->p;
  8070ba:	8b 47 04             	mov    0x4(%edi),%eax
  8070bd:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  8070c0:	83 c4 10             	add    $0x10,%esp
  8070c3:	89 7d dc             	mov    %edi,-0x24(%ebp)
  8070c6:	89 c7                	mov    %eax,%edi
  8070c8:	eb 1d                	jmp    8070e7 <ip_reass+0x46e>
      iprh = (struct ip_reass_helper*)r->payload;
  8070ca:	8b 73 04             	mov    0x4(%ebx),%esi

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  8070cd:	83 ec 08             	sub    $0x8,%esp
  8070d0:	6a ec                	push   $0xffffffec
  8070d2:	53                   	push   %ebx
  8070d3:	e8 7b d6 ff ff       	call   804753 <pbuf_header>
      pbuf_cat(p, r);
  8070d8:	83 c4 08             	add    $0x8,%esp
  8070db:	53                   	push   %ebx
  8070dc:	57                   	push   %edi
  8070dd:	e8 cb db ff ff       	call   804cad <pbuf_cat>
      r = iprh->next_pbuf;
  8070e2:	8b 1e                	mov    (%esi),%ebx
  8070e4:	83 c4 10             	add    $0x10,%esp
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  8070e7:	85 db                	test   %ebx,%ebx
  8070e9:	75 df                	jne    8070ca <ip_reass+0x451>
  8070eb:	8b 7d dc             	mov    -0x24(%ebp),%edi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  8070ee:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8070f1:	89 f8                	mov    %edi,%eax
  8070f3:	e8 61 f9 ff ff       	call   806a59 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  8070f8:	83 ec 0c             	sub    $0xc,%esp
  8070fb:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8070fe:	56                   	push   %esi
  8070ff:	e8 80 db ff ff       	call   804c84 <pbuf_clen>
  807104:	0f b6 c0             	movzbl %al,%eax
  807107:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc

    /* Return the pbuf chain */
    return p;
  80710e:	83 c4 10             	add    $0x10,%esp
  807111:	89 f0                	mov    %esi,%eax
  807113:	eb 44                	jmp    807159 <ip_reass+0x4e0>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  807115:	83 ec 0c             	sub    $0xc,%esp
  807118:	ff 75 08             	pushl  0x8(%ebp)
  80711b:	e8 05 d7 ff ff       	call   804825 <pbuf_free>
  return NULL;
  807120:	83 c4 10             	add    $0x10,%esp
  807123:	b8 00 00 00 00       	mov    $0x0,%eax
  807128:	eb 2f                	jmp    807159 <ip_reass+0x4e0>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  80712a:	b8 00 00 00 00       	mov    $0x0,%eax
  80712f:	eb 28                	jmp    807159 <ip_reass+0x4e0>
  807131:	89 7d d0             	mov    %edi,-0x30(%ebp)
  807134:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  807137:	85 f6                	test   %esi,%esi
  807139:	0f 85 f4 fd ff ff    	jne    806f33 <ip_reass+0x2ba>
  80713f:	e9 23 fe ff ff       	jmp    806f67 <ip_reass+0x2ee>
  807144:	89 75 dc             	mov    %esi,-0x24(%ebp)
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  807147:	85 c9                	test   %ecx,%ecx
  807149:	0f 85 9e fe ff ff    	jne    806fed <ip_reass+0x374>
  80714f:	e9 82 fe ff ff       	jmp    806fd6 <ip_reass+0x35d>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  807154:	b8 00 00 00 00       	mov    $0x0,%eax
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
  807159:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80715c:	5b                   	pop    %ebx
  80715d:	5e                   	pop    %esi
  80715e:	5f                   	pop    %edi
  80715f:	5d                   	pop    %ebp
  807160:	c3                   	ret    

00807161 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  807161:	55                   	push   %ebp
  807162:	89 e5                	mov    %esp,%ebp
  807164:	57                   	push   %edi
  807165:	56                   	push   %esi
  807166:	53                   	push   %ebx
  807167:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  80716a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80716d:	0f b7 58 2c          	movzwl 0x2c(%eax),%ebx
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  807171:	6a 02                	push   $0x2
  807173:	6a 00                	push   $0x0
  807175:	6a 02                	push   $0x2
  807177:	e8 6f d7 ff ff       	call   8048eb <pbuf_alloc>
  80717c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (rambuf == NULL) {
  80717f:	83 c4 10             	add    $0x10,%esp
  807182:	85 c0                	test   %eax,%eax
  807184:	0f 84 9f 01 00 00    	je     807329 <ip_frag+0x1c8>
  80718a:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  80718c:	66 89 58 0a          	mov    %bx,0xa(%eax)
  807190:	66 89 58 08          	mov    %bx,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  807194:	b8 03 44 b3 00       	mov    $0xb34403,%eax
  807199:	83 e0 fc             	and    $0xfffffffc,%eax
  80719c:	89 c7                	mov    %eax,%edi
  80719e:	89 7e 04             	mov    %edi,0x4(%esi)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8071a1:	83 ec 04             	sub    $0x4,%esp
  8071a4:	6a 14                	push   $0x14
  8071a6:	8b 45 08             	mov    0x8(%ebp),%eax
  8071a9:	ff 70 04             	pushl  0x4(%eax)
  8071ac:	57                   	push   %edi
  8071ad:	e8 f4 7a 00 00       	call   80eca6 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8071b2:	0f b7 47 06          	movzwl 0x6(%edi),%eax
  8071b6:	89 04 24             	mov    %eax,(%esp)
  8071b9:	e8 25 05 00 00       	call   8076e3 <ntohs>
  ofo = tmp & IP_OFFMASK;
  8071be:	89 c6                	mov    %eax,%esi
  8071c0:	66 81 e6 ff 1f       	and    $0x1fff,%si
  8071c5:	66 89 75 de          	mov    %si,-0x22(%ebp)
  omf = tmp & IP_MF;
  8071c9:	66 25 00 20          	and    $0x2000,%ax
  8071cd:	66 89 45 dc          	mov    %ax,-0x24(%ebp)

  left = p->tot_len - IP_HLEN;
  8071d1:	8b 45 08             	mov    0x8(%ebp),%eax
  8071d4:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8071d8:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  8071dc:	8d 70 ec             	lea    -0x14(%eax),%esi

  nfb = (mtu - IP_HLEN) / 8;
  8071df:	0f b7 db             	movzwl %bx,%ebx
  8071e2:	8d 43 f3             	lea    -0xd(%ebx),%eax
  8071e5:	83 c4 10             	add    $0x10,%esp
  8071e8:	83 eb 14             	sub    $0x14,%ebx
  8071eb:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  8071ee:	0f 49 c3             	cmovns %ebx,%eax
  8071f1:	c1 f8 03             	sar    $0x3,%eax
  8071f4:	66 89 45 ce          	mov    %ax,-0x32(%ebp)
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  8071f8:	66 c7 45 e4 14 00    	movw   $0x14,-0x1c(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  8071fe:	c1 e0 03             	shl    $0x3,%eax
  807201:	66 89 45 cc          	mov    %ax,-0x34(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807205:	8d 47 14             	lea    0x14(%edi),%eax
  807208:	89 45 d0             	mov    %eax,-0x30(%ebp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  80720b:	e9 fb 00 00 00       	jmp    80730b <ip_frag+0x1aa>
    last = (left <= mtu - IP_HLEN);
  807210:	0f b7 c6             	movzwl %si,%eax
  807213:	89 45 d8             	mov    %eax,-0x28(%ebp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  807216:	0f b7 5d de          	movzwl -0x22(%ebp),%ebx
  80721a:	66 81 e3 ff 1f       	and    $0x1fff,%bx
  80721f:	66 0b 5d dc          	or     -0x24(%ebp),%bx
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807223:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
  while (left) {
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
  807227:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80722a:	7d 0b                	jge    807237 <ip_frag+0xd6>
      tmp = tmp | IP_MF;
  80722c:	80 cf 20             	or     $0x20,%bh

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  80722f:	0f b7 45 cc          	movzwl -0x34(%ebp),%eax
  807233:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807237:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80723b:	50                   	push   %eax
  80723c:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807240:	50                   	push   %eax
  807241:	ff 75 d0             	pushl  -0x30(%ebp)
  807244:	ff 75 08             	pushl  0x8(%ebp)
  807247:	e8 29 dd ff ff       	call   804f75 <pbuf_copy_partial>
  80724c:	66 01 45 e4          	add    %ax,-0x1c(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  807250:	0f b7 db             	movzwl %bx,%ebx
  807253:	89 1c 24             	mov    %ebx,(%esp)
  807256:	e8 7b 04 00 00       	call   8076d6 <htons>
  80725b:	66 89 47 06          	mov    %ax,0x6(%edi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  80725f:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
  807263:	8d 41 14             	lea    0x14(%ecx),%eax
  807266:	0f b7 c0             	movzwl %ax,%eax
  807269:	89 04 24             	mov    %eax,(%esp)
  80726c:	e8 65 04 00 00       	call   8076d6 <htons>
  807271:	66 89 47 02          	mov    %ax,0x2(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  807275:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80727b:	83 c4 08             	add    $0x8,%esp
  80727e:	6a 14                	push   $0x14
  807280:	57                   	push   %edi
  807281:	e8 2b 03 00 00       	call   8075b1 <inet_chksum>
  807286:	66 89 47 0a          	mov    %ax,0xa(%edi)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  80728a:	83 c4 10             	add    $0x10,%esp
  80728d:	8b 55 d8             	mov    -0x28(%ebp),%edx
  807290:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  807293:	7c 15                	jl     8072aa <ip_frag+0x149>
      pbuf_realloc(rambuf, left + IP_HLEN);
  807295:	83 ec 08             	sub    $0x8,%esp
  807298:	8d 46 14             	lea    0x14(%esi),%eax
  80729b:	0f b7 c0             	movzwl %ax,%eax
  80729e:	50                   	push   %eax
  80729f:	ff 75 d4             	pushl  -0x2c(%ebp)
  8072a2:	e8 c7 d8 ff ff       	call   804b6e <pbuf_realloc>
  8072a7:	83 c4 10             	add    $0x10,%esp
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  8072aa:	83 ec 04             	sub    $0x4,%esp
  8072ad:	6a 00                	push   $0x0
  8072af:	6a 00                	push   $0x0
  8072b1:	6a 02                	push   $0x2
  8072b3:	e8 33 d6 ff ff       	call   8048eb <pbuf_alloc>
  8072b8:	89 c3                	mov    %eax,%ebx
    if (header != NULL) {
  8072ba:	83 c4 10             	add    $0x10,%esp
  8072bd:	85 c0                	test   %eax,%eax
  8072bf:	74 35                	je     8072f6 <ip_frag+0x195>
      pbuf_chain(header, rambuf);
  8072c1:	83 ec 08             	sub    $0x8,%esp
  8072c4:	ff 75 d4             	pushl  -0x2c(%ebp)
  8072c7:	50                   	push   %eax
  8072c8:	e8 4c da ff ff       	call   804d19 <pbuf_chain>
      netif->output(netif, header, dest);
  8072cd:	83 c4 0c             	add    $0xc,%esp
  8072d0:	ff 75 10             	pushl  0x10(%ebp)
  8072d3:	53                   	push   %ebx
  8072d4:	ff 75 0c             	pushl  0xc(%ebp)
  8072d7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8072da:	ff 50 14             	call   *0x14(%eax)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  8072dd:	89 1c 24             	mov    %ebx,(%esp)
  8072e0:	e8 40 d5 ff ff       	call   804825 <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  8072e5:	66 2b 75 e6          	sub    -0x1a(%ebp),%si
    ofo += nfb;
  8072e9:	0f b7 4d ce          	movzwl -0x32(%ebp),%ecx
  8072ed:	66 01 4d de          	add    %cx,-0x22(%ebp)
  8072f1:	83 c4 10             	add    $0x10,%esp
  8072f4:	eb 15                	jmp    80730b <ip_frag+0x1aa>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  8072f6:	83 ec 0c             	sub    $0xc,%esp
  8072f9:	ff 75 d4             	pushl  -0x2c(%ebp)
  8072fc:	e8 24 d5 ff ff       	call   804825 <pbuf_free>
      return ERR_MEM;
  807301:	83 c4 10             	add    $0x10,%esp
  807304:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807309:	eb 23                	jmp    80732e <ip_frag+0x1cd>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  80730b:	66 85 f6             	test   %si,%si
  80730e:	0f 85 fc fe ff ff    	jne    807210 <ip_frag+0xaf>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  807314:	83 ec 0c             	sub    $0xc,%esp
  807317:	ff 75 d4             	pushl  -0x2c(%ebp)
  80731a:	e8 06 d5 ff ff       	call   804825 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  80731f:	83 c4 10             	add    $0x10,%esp
  807322:	b8 00 00 00 00       	mov    $0x0,%eax
  807327:	eb 05                	jmp    80732e <ip_frag+0x1cd>
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  807329:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  80732e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807331:	5b                   	pop    %ebx
  807332:	5e                   	pop    %esi
  807333:	5f                   	pop    %edi
  807334:	5d                   	pop    %ebp
  807335:	c3                   	ret    

00807336 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  807336:	55                   	push   %ebp
  807337:	89 e5                	mov    %esp,%ebp
  807339:	57                   	push   %edi
  80733a:	56                   	push   %esi
  80733b:	53                   	push   %ebx
  80733c:	83 ec 1c             	sub    $0x1c,%esp
  80733f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  807342:	89 c3                	mov    %eax,%ebx
  while (len > 1) {
  807344:	89 d7                	mov    %edx,%edi
{
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  807346:	be 00 00 00 00       	mov    $0x0,%esi
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80734b:	eb 17                	jmp    807364 <lwip_standard_chksum+0x2e>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80734d:	0f b6 03             	movzbl (%ebx),%eax
  807350:	c1 e0 08             	shl    $0x8,%eax
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  807353:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  807357:	09 c8                	or     %ecx,%eax
  807359:	83 c3 02             	add    $0x2,%ebx
    octetptr++;
    acc += src;
  80735c:	0f b7 c0             	movzwl %ax,%eax
  80735f:	01 c6                	add    %eax,%esi
    len -= 2;
  807361:	83 ef 02             	sub    $0x2,%edi
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  807364:	66 83 ff 01          	cmp    $0x1,%di
  807368:	77 e3                	ja     80734d <lwip_standard_chksum+0x17>
  80736a:	89 d0                	mov    %edx,%eax
  80736c:	66 d1 e8             	shr    %ax
  80736f:	0f b7 c8             	movzwl %ax,%ecx
  807372:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  807375:	8d 0c 4f             	lea    (%edi,%ecx,2),%ecx
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  807378:	f7 d8                	neg    %eax
  80737a:	8d 14 42             	lea    (%edx,%eax,2),%edx
  80737d:	66 85 d2             	test   %dx,%dx
  807380:	74 0b                	je     80738d <lwip_standard_chksum+0x57>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
    acc += src;
  807382:	0f b6 01             	movzbl (%ecx),%eax
  807385:	c1 e0 08             	shl    $0x8,%eax
  807388:	0f b7 c0             	movzwl %ax,%eax
  80738b:	01 c6                	add    %eax,%esi
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80738d:	89 f0                	mov    %esi,%eax
  80738f:	c1 e8 10             	shr    $0x10,%eax
  807392:	0f b7 f6             	movzwl %si,%esi
  807395:	01 c6                	add    %eax,%esi
  if ((acc & 0xffff0000) != 0) {
  807397:	f7 c6 00 00 ff ff    	test   $0xffff0000,%esi
  80739d:	74 0a                	je     8073a9 <lwip_standard_chksum+0x73>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80739f:	89 f0                	mov    %esi,%eax
  8073a1:	c1 e8 10             	shr    $0x10,%eax
  8073a4:	0f b7 f6             	movzwl %si,%esi
  8073a7:	01 c6                	add    %eax,%esi
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  8073a9:	83 ec 0c             	sub    $0xc,%esp
  8073ac:	0f b7 f6             	movzwl %si,%esi
  8073af:	56                   	push   %esi
  8073b0:	e8 21 03 00 00       	call   8076d6 <htons>
}
  8073b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8073b8:	5b                   	pop    %ebx
  8073b9:	5e                   	pop    %esi
  8073ba:	5f                   	pop    %edi
  8073bb:	5d                   	pop    %ebp
  8073bc:	c3                   	ret    

008073bd <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  8073bd:	55                   	push   %ebp
  8073be:	89 e5                	mov    %esp,%ebp
  8073c0:	57                   	push   %edi
  8073c1:	56                   	push   %esi
  8073c2:	53                   	push   %ebx
  8073c3:	83 ec 1c             	sub    $0x1c,%esp
  8073c6:	8b 75 08             	mov    0x8(%ebp),%esi
  8073c9:	8b 45 14             	mov    0x14(%ebp),%eax
  8073cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8073cf:	8b 45 18             	mov    0x18(%ebp),%eax
  8073d2:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  8073d5:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  8073da:	bb 00 00 00 00       	mov    $0x0,%ebx
  8073df:	89 f8                	mov    %edi,%eax
  8073e1:	89 df                	mov    %ebx,%edi
  8073e3:	89 c3                	mov    %eax,%ebx
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  8073e5:	eb 3d                	jmp    807424 <inet_chksum_pseudo+0x67>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  8073e7:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8073eb:	8b 46 04             	mov    0x4(%esi),%eax
  8073ee:	e8 43 ff ff ff       	call   807336 <lwip_standard_chksum>
  8073f3:	0f b7 c0             	movzwl %ax,%eax
  8073f6:	01 f8                	add    %edi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  8073f8:	89 c7                	mov    %eax,%edi
  8073fa:	c1 ef 10             	shr    $0x10,%edi
  8073fd:	0f b7 c0             	movzwl %ax,%eax
  807400:	01 c7                	add    %eax,%edi
    if (q->len % 2 != 0) {
  807402:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807406:	74 1a                	je     807422 <inet_chksum_pseudo+0x65>
      swapped = 1 - swapped;
  807408:	b8 01 00 00 00       	mov    $0x1,%eax
  80740d:	29 d8                	sub    %ebx,%eax
  80740f:	89 c3                	mov    %eax,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
  807411:	89 fa                	mov    %edi,%edx
  807413:	c1 e2 08             	shl    $0x8,%edx
  807416:	0f b7 d2             	movzwl %dx,%edx
  807419:	89 f8                	mov    %edi,%eax
  80741b:	0f b6 c4             	movzbl %ah,%eax
  80741e:	09 c2                	or     %eax,%edx
  807420:	89 d7                	mov    %edx,%edi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807422:	8b 36                	mov    (%esi),%esi
  807424:	85 f6                	test   %esi,%esi
  807426:	75 bf                	jne    8073e7 <inet_chksum_pseudo+0x2a>
  807428:	89 d8                	mov    %ebx,%eax
  80742a:	89 fb                	mov    %edi,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80742c:	84 c0                	test   %al,%al
  80742e:	74 0d                	je     80743d <inet_chksum_pseudo+0x80>
    acc = SWAP_BYTES_IN_WORD(acc);
  807430:	89 f8                	mov    %edi,%eax
  807432:	c1 e0 08             	shl    $0x8,%eax
  807435:	0f b7 c0             	movzwl %ax,%eax
  807438:	0f b6 df             	movzbl %bh,%ebx
  80743b:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  80743d:	8b 45 0c             	mov    0xc(%ebp),%eax
  807440:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807442:	8b 45 10             	mov    0x10(%ebp),%eax
  807445:	8b 00                	mov    (%eax),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  807447:	0f b7 ca             	movzwl %dx,%ecx
  80744a:	c1 ea 10             	shr    $0x10,%edx
  80744d:	01 ca                	add    %ecx,%edx
  80744f:	0f b7 c8             	movzwl %ax,%ecx
  807452:	01 ca                	add    %ecx,%edx
  807454:	c1 e8 10             	shr    $0x10,%eax
  807457:	01 d0                	add    %edx,%eax
  807459:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  80745b:	83 ec 0c             	sub    $0xc,%esp
  80745e:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807462:	50                   	push   %eax
  807463:	e8 6e 02 00 00       	call   8076d6 <htons>
  807468:	0f b7 c0             	movzwl %ax,%eax
  80746b:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  80746d:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807471:	89 04 24             	mov    %eax,(%esp)
  807474:	e8 5d 02 00 00       	call   8076d6 <htons>
  807479:	0f b7 c0             	movzwl %ax,%eax
  80747c:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80747e:	89 d8                	mov    %ebx,%eax
  807480:	c1 e8 10             	shr    $0x10,%eax
  807483:	0f b7 db             	movzwl %bx,%ebx
  807486:	01 d8                	add    %ebx,%eax
  acc = FOLD_U32T(acc);
  807488:	89 c2                	mov    %eax,%edx
  80748a:	c1 ea 10             	shr    $0x10,%edx
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  80748d:	01 d0                	add    %edx,%eax
  80748f:	f7 d0                	not    %eax
}
  807491:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807494:	5b                   	pop    %ebx
  807495:	5e                   	pop    %esi
  807496:	5f                   	pop    %edi
  807497:	5d                   	pop    %ebp
  807498:	c3                   	ret    

00807499 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  807499:	55                   	push   %ebp
  80749a:	89 e5                	mov    %esp,%ebp
  80749c:	57                   	push   %edi
  80749d:	56                   	push   %esi
  80749e:	53                   	push   %ebx
  80749f:	83 ec 1c             	sub    $0x1c,%esp
  8074a2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8074a5:	8b 45 14             	mov    0x14(%ebp),%eax
  8074a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8074ab:	8b 45 18             	mov    0x18(%ebp),%eax
  8074ae:	89 45 d8             	mov    %eax,-0x28(%ebp)
  8074b1:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  8074b5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  8074b9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8074c0:	eb 6d                	jmp    80752f <inet_chksum_pseudo_partial+0x96>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  8074c2:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  8074c6:	66 39 fe             	cmp    %di,%si
  8074c9:	0f 46 fe             	cmovbe %esi,%edi
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  8074cc:	0f b7 d7             	movzwl %di,%edx
  8074cf:	8b 43 04             	mov    0x4(%ebx),%eax
  8074d2:	e8 5f fe ff ff       	call   807336 <lwip_standard_chksum>
  8074d7:	0f b7 c0             	movzwl %ax,%eax
  8074da:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  8074dd:	29 fe                	sub    %edi,%esi
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  8074df:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  8074e4:	76 17                	jbe    8074fd <inet_chksum_pseudo_partial+0x64>
  8074e6:	83 ec 04             	sub    $0x4,%esp
  8074e9:	68 11 1e 81 00       	push   $0x811e11
  8074ee:	68 60 01 00 00       	push   $0x160
  8074f3:	68 1c 1e 81 00       	push   $0x811e1c
  8074f8:	e8 51 6f 00 00       	call   80e44e <_panic>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  8074fd:	89 c2                	mov    %eax,%edx
  8074ff:	c1 ea 10             	shr    $0x10,%edx
  807502:	0f b7 c0             	movzwl %ax,%eax
  807505:	01 d0                	add    %edx,%eax
  807507:	89 c2                	mov    %eax,%edx
  807509:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  80750c:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807510:	74 1b                	je     80752d <inet_chksum_pseudo_partial+0x94>
      swapped = 1 - swapped;
  807512:	b8 01 00 00 00       	mov    $0x1,%eax
  807517:	2a 45 e3             	sub    -0x1d(%ebp),%al
  80751a:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80751d:	89 d0                	mov    %edx,%eax
  80751f:	c1 e2 08             	shl    $0x8,%edx
  807522:	0f b7 d2             	movzwl %dx,%edx
  807525:	0f b6 c4             	movzbl %ah,%eax
  807528:	09 c2                	or     %eax,%edx
  80752a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80752d:	8b 1b                	mov    (%ebx),%ebx
  80752f:	85 db                	test   %ebx,%ebx
  807531:	74 05                	je     807538 <inet_chksum_pseudo_partial+0x9f>
  807533:	66 85 f6             	test   %si,%si
  807536:	75 8a                	jne    8074c2 <inet_chksum_pseudo_partial+0x29>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807538:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80753c:	74 13                	je     807551 <inet_chksum_pseudo_partial+0xb8>
    acc = SWAP_BYTES_IN_WORD(acc);
  80753e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807541:	89 c8                	mov    %ecx,%eax
  807543:	c1 e0 08             	shl    $0x8,%eax
  807546:	0f b7 c0             	movzwl %ax,%eax
  807549:	0f b6 d5             	movzbl %ch,%edx
  80754c:	09 d0                	or     %edx,%eax
  80754e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  807551:	8b 45 0c             	mov    0xc(%ebp),%eax
  807554:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807556:	8b 45 10             	mov    0x10(%ebp),%eax
  807559:	8b 00                	mov    (%eax),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  80755b:	0f b7 ca             	movzwl %dx,%ecx
  80755e:	c1 ea 10             	shr    $0x10,%edx
  807561:	01 ca                	add    %ecx,%edx
  807563:	0f b7 d8             	movzwl %ax,%ebx
  807566:	01 d3                	add    %edx,%ebx
  807568:	c1 e8 10             	shr    $0x10,%eax
  80756b:	01 c3                	add    %eax,%ebx
  80756d:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  807570:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons((u16_t)proto);
  807572:	83 ec 0c             	sub    $0xc,%esp
  807575:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807579:	50                   	push   %eax
  80757a:	e8 57 01 00 00       	call   8076d6 <htons>
  80757f:	0f b7 d0             	movzwl %ax,%edx
  807582:	8d 1c 32             	lea    (%edx,%esi,1),%ebx
  acc += (u32_t)htons(proto_len);
  807585:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  807589:	89 04 24             	mov    %eax,(%esp)
  80758c:	e8 45 01 00 00       	call   8076d6 <htons>
  807591:	0f b7 d0             	movzwl %ax,%edx
  807594:	01 da                	add    %ebx,%edx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807596:	89 d0                	mov    %edx,%eax
  807598:	c1 e8 10             	shr    $0x10,%eax
  80759b:	0f b7 d2             	movzwl %dx,%edx
  80759e:	01 d0                	add    %edx,%eax
  acc = FOLD_U32T(acc);
  8075a0:	89 c2                	mov    %eax,%edx
  8075a2:	c1 ea 10             	shr    $0x10,%edx
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  8075a5:	01 d0                	add    %edx,%eax
  8075a7:	f7 d0                	not    %eax
}
  8075a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8075ac:	5b                   	pop    %ebx
  8075ad:	5e                   	pop    %esi
  8075ae:	5f                   	pop    %edi
  8075af:	5d                   	pop    %ebp
  8075b0:	c3                   	ret    

008075b1 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  8075b1:	55                   	push   %ebp
  8075b2:	89 e5                	mov    %esp,%ebp
  8075b4:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  8075b7:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  8075bb:	8b 45 08             	mov    0x8(%ebp),%eax
  8075be:	e8 73 fd ff ff       	call   807336 <lwip_standard_chksum>
  8075c3:	f7 d0                	not    %eax
}
  8075c5:	c9                   	leave  
  8075c6:	c3                   	ret    

008075c7 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  8075c7:	55                   	push   %ebp
  8075c8:	89 e5                	mov    %esp,%ebp
  8075ca:	57                   	push   %edi
  8075cb:	56                   	push   %esi
  8075cc:	53                   	push   %ebx
  8075cd:	83 ec 0c             	sub    $0xc,%esp
  8075d0:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  8075d3:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  8075d8:	bb 00 00 00 00       	mov    $0x0,%ebx
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  8075dd:	eb 3b                	jmp    80761a <inet_chksum_pbuf+0x53>
    acc += LWIP_CHKSUM(q->payload, q->len);
  8075df:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8075e3:	8b 46 04             	mov    0x4(%esi),%eax
  8075e6:	e8 4b fd ff ff       	call   807336 <lwip_standard_chksum>
  8075eb:	0f b7 c0             	movzwl %ax,%eax
  8075ee:	01 c3                	add    %eax,%ebx
    acc = FOLD_U32T(acc);
  8075f0:	89 d8                	mov    %ebx,%eax
  8075f2:	c1 e8 10             	shr    $0x10,%eax
  8075f5:	0f b7 db             	movzwl %bx,%ebx
  8075f8:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  8075fa:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  8075fe:	74 18                	je     807618 <inet_chksum_pbuf+0x51>
      swapped = 1 - swapped;
  807600:	b8 01 00 00 00       	mov    $0x1,%eax
  807605:	89 f9                	mov    %edi,%ecx
  807607:	29 c8                	sub    %ecx,%eax
  807609:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80760b:	89 da                	mov    %ebx,%edx
  80760d:	c1 e2 08             	shl    $0x8,%edx
  807610:	0f b7 d2             	movzwl %dx,%edx
  807613:	0f b6 df             	movzbl %bh,%ebx
  807616:	09 d3                	or     %edx,%ebx
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807618:	8b 36                	mov    (%esi),%esi
  80761a:	85 f6                	test   %esi,%esi
  80761c:	75 c1                	jne    8075df <inet_chksum_pbuf+0x18>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  80761e:	89 f8                	mov    %edi,%eax
  807620:	84 c0                	test   %al,%al
  807622:	74 0d                	je     807631 <inet_chksum_pbuf+0x6a>
    acc = SWAP_BYTES_IN_WORD(acc);
  807624:	89 da                	mov    %ebx,%edx
  807626:	c1 e2 08             	shl    $0x8,%edx
  807629:	0f b7 d2             	movzwl %dx,%edx
  80762c:	0f b6 df             	movzbl %bh,%ebx
  80762f:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  807631:	89 d8                	mov    %ebx,%eax
  807633:	f7 d0                	not    %eax
}
  807635:	83 c4 0c             	add    $0xc,%esp
  807638:	5b                   	pop    %ebx
  807639:	5e                   	pop    %esi
  80763a:	5f                   	pop    %edi
  80763b:	5d                   	pop    %ebp
  80763c:	c3                   	ret    

0080763d <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  80763d:	55                   	push   %ebp
  80763e:	89 e5                	mov    %esp,%ebp
  807640:	57                   	push   %edi
  807641:	56                   	push   %esi
  807642:	53                   	push   %ebx
  807643:	83 ec 14             	sub    $0x14,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807646:	8b 45 08             	mov    0x8(%ebp),%eax
  807649:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  80764c:	8d 7d f0             	lea    -0x10(%ebp),%edi
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  80764f:	c7 45 e0 e4 49 b3 00 	movl   $0xb349e4,-0x20(%ebp)
  807656:	0f b6 0f             	movzbl (%edi),%ecx
  807659:	ba 00 00 00 00       	mov    $0x0,%edx
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  80765e:	0f b6 d9             	movzbl %cl,%ebx
  807661:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  807664:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
  807667:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80766a:	66 c1 e8 0b          	shr    $0xb,%ax
  80766e:	89 c3                	mov    %eax,%ebx
  807670:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807673:	01 c0                	add    %eax,%eax
  807675:	29 c1                	sub    %eax,%ecx
  807677:	89 c8                	mov    %ecx,%eax
      *ap /= (u8_t)10;
  807679:	89 d9                	mov    %ebx,%ecx
      inv[i++] = '0' + rem;
  80767b:	8d 72 01             	lea    0x1(%edx),%esi
  80767e:	0f b6 d2             	movzbl %dl,%edx
  807681:	83 c0 30             	add    $0x30,%eax
  807684:	88 44 15 ed          	mov    %al,-0x13(%ebp,%edx,1)
  807688:	89 f2                	mov    %esi,%edx
    } while(*ap);
  80768a:	84 db                	test   %bl,%bl
  80768c:	75 d0                	jne    80765e <inet_ntoa+0x21>
  80768e:	c6 07 00             	movb   $0x0,(%edi)
  807691:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  807694:	eb 0d                	jmp    8076a3 <inet_ntoa+0x66>
    while(i--)
      *rp++ = inv[i];
  807696:	0f b6 c2             	movzbl %dl,%eax
  807699:	0f b6 44 05 ed       	movzbl -0x13(%ebp,%eax,1),%eax
  80769e:	88 01                	mov    %al,(%ecx)
  8076a0:	83 c1 01             	add    $0x1,%ecx
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  8076a3:	83 ea 01             	sub    $0x1,%edx
  8076a6:	80 fa ff             	cmp    $0xff,%dl
  8076a9:	75 eb                	jne    807696 <inet_ntoa+0x59>
  8076ab:	89 f0                	mov    %esi,%eax
  8076ad:	0f b6 f0             	movzbl %al,%esi
  8076b0:	03 75 e0             	add    -0x20(%ebp),%esi
      *rp++ = inv[i];
    *rp++ = '.';
  8076b3:	8d 46 01             	lea    0x1(%esi),%eax
  8076b6:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8076b9:	c6 06 2e             	movb   $0x2e,(%esi)
    ap++;
  8076bc:	83 c7 01             	add    $0x1,%edi
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  8076bf:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8076c2:	39 c7                	cmp    %eax,%edi
  8076c4:	75 90                	jne    807656 <inet_ntoa+0x19>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  8076c6:	c6 06 00             	movb   $0x0,(%esi)
  return str;
}
  8076c9:	b8 e4 49 b3 00       	mov    $0xb349e4,%eax
  8076ce:	83 c4 14             	add    $0x14,%esp
  8076d1:	5b                   	pop    %ebx
  8076d2:	5e                   	pop    %esi
  8076d3:	5f                   	pop    %edi
  8076d4:	5d                   	pop    %ebp
  8076d5:	c3                   	ret    

008076d6 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  8076d6:	55                   	push   %ebp
  8076d7:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  8076d9:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  8076dd:	66 c1 c0 08          	rol    $0x8,%ax
}
  8076e1:	5d                   	pop    %ebp
  8076e2:	c3                   	ret    

008076e3 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  8076e3:	55                   	push   %ebp
  8076e4:	89 e5                	mov    %esp,%ebp
  return htons(n);
  8076e6:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  8076ea:	66 c1 c0 08          	rol    $0x8,%ax
}
  8076ee:	5d                   	pop    %ebp
  8076ef:	c3                   	ret    

008076f0 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  8076f0:	55                   	push   %ebp
  8076f1:	89 e5                	mov    %esp,%ebp
  8076f3:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
  8076f6:	89 d1                	mov    %edx,%ecx
  8076f8:	c1 e1 18             	shl    $0x18,%ecx
  8076fb:	89 d0                	mov    %edx,%eax
  8076fd:	c1 e8 18             	shr    $0x18,%eax
  807700:	09 c8                	or     %ecx,%eax
  807702:	89 d1                	mov    %edx,%ecx
  807704:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80770a:	c1 e1 08             	shl    $0x8,%ecx
  80770d:	09 c8                	or     %ecx,%eax
  80770f:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  807715:	c1 ea 08             	shr    $0x8,%edx
  807718:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  80771a:	5d                   	pop    %ebp
  80771b:	c3                   	ret    

0080771c <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  80771c:	55                   	push   %ebp
  80771d:	89 e5                	mov    %esp,%ebp
  80771f:	57                   	push   %edi
  807720:	56                   	push   %esi
  807721:	53                   	push   %ebx
  807722:	83 ec 20             	sub    $0x20,%esp
  807725:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  807728:	0f be 10             	movsbl (%eax),%edx
inet_aton(const char *cp, struct in_addr *addr)
{
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  80772b:	8d 5d e4             	lea    -0x1c(%ebp),%ebx
  80772e:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  807731:	0f b6 ca             	movzbl %dl,%ecx
  807734:	83 e9 30             	sub    $0x30,%ecx
  807737:	83 f9 09             	cmp    $0x9,%ecx
  80773a:	0f 87 94 01 00 00    	ja     8078d4 <inet_aton+0x1b8>
      return (0);
    val = 0;
    base = 10;
  807740:	c7 45 dc 0a 00 00 00 	movl   $0xa,-0x24(%ebp)
    if (c == '0') {
  807747:	83 fa 30             	cmp    $0x30,%edx
  80774a:	75 2b                	jne    807777 <inet_aton+0x5b>
      c = *++cp;
  80774c:	0f b6 50 01          	movzbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  807750:	89 d1                	mov    %edx,%ecx
  807752:	83 e1 df             	and    $0xffffffdf,%ecx
  807755:	80 f9 58             	cmp    $0x58,%cl
  807758:	74 0f                	je     807769 <inet_aton+0x4d>
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
  80775a:	83 c0 01             	add    $0x1,%eax
  80775d:	0f be d2             	movsbl %dl,%edx
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
      } else
        base = 8;
  807760:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  807767:	eb 0e                	jmp    807777 <inet_aton+0x5b>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
  807769:	0f be 50 02          	movsbl 0x2(%eax),%edx
  80776d:	8d 40 02             	lea    0x2(%eax),%eax
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
  807770:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
  807777:	83 c0 01             	add    $0x1,%eax
  80777a:	be 00 00 00 00       	mov    $0x0,%esi
  80777f:	eb 03                	jmp    807784 <inet_aton+0x68>
  807781:	83 c0 01             	add    $0x1,%eax
  807784:	8d 58 ff             	lea    -0x1(%eax),%ebx
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  807787:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80778a:	0f b6 fa             	movzbl %dl,%edi
  80778d:	8d 4f d0             	lea    -0x30(%edi),%ecx
  807790:	83 f9 09             	cmp    $0x9,%ecx
  807793:	77 0d                	ja     8077a2 <inet_aton+0x86>
        val = (val * base) + (int)(c - '0');
  807795:	0f af 75 dc          	imul   -0x24(%ebp),%esi
  807799:	8d 74 32 d0          	lea    -0x30(%edx,%esi,1),%esi
        c = *++cp;
  80779d:	0f be 10             	movsbl (%eax),%edx
  8077a0:	eb df                	jmp    807781 <inet_aton+0x65>
      } else if (base == 16 && isxdigit(c)) {
  8077a2:	83 7d dc 10          	cmpl   $0x10,-0x24(%ebp)
  8077a6:	75 32                	jne    8077da <inet_aton+0xbe>
  8077a8:	8d 4f 9f             	lea    -0x61(%edi),%ecx
  8077ab:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  8077ae:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8077b1:	81 e1 df 00 00 00    	and    $0xdf,%ecx
  8077b7:	83 e9 41             	sub    $0x41,%ecx
  8077ba:	83 f9 05             	cmp    $0x5,%ecx
  8077bd:	77 1b                	ja     8077da <inet_aton+0xbe>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  8077bf:	c1 e6 04             	shl    $0x4,%esi
  8077c2:	83 c2 0a             	add    $0xa,%edx
  8077c5:	83 7d d8 1a          	cmpl   $0x1a,-0x28(%ebp)
  8077c9:	19 c9                	sbb    %ecx,%ecx
  8077cb:	83 e1 20             	and    $0x20,%ecx
  8077ce:	83 c1 41             	add    $0x41,%ecx
  8077d1:	29 ca                	sub    %ecx,%edx
  8077d3:	09 d6                	or     %edx,%esi
        c = *++cp;
  8077d5:	0f be 10             	movsbl (%eax),%edx
  8077d8:	eb a7                	jmp    807781 <inet_aton+0x65>
      } else
        break;
    }
    if (c == '.') {
  8077da:	83 fa 2e             	cmp    $0x2e,%edx
  8077dd:	75 23                	jne    807802 <inet_aton+0xe6>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  8077df:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8077e2:	8d 7d f0             	lea    -0x10(%ebp),%edi
  8077e5:	39 f8                	cmp    %edi,%eax
  8077e7:	0f 84 ee 00 00 00    	je     8078db <inet_aton+0x1bf>
        return (0);
      *pp++ = val;
  8077ed:	83 c0 04             	add    $0x4,%eax
  8077f0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8077f3:	89 70 fc             	mov    %esi,-0x4(%eax)
      c = *++cp;
  8077f6:	8d 43 01             	lea    0x1(%ebx),%eax
  8077f9:	0f be 53 01          	movsbl 0x1(%ebx),%edx
    } else
      break;
  }
  8077fd:	e9 2f ff ff ff       	jmp    807731 <inet_aton+0x15>
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807802:	85 d2                	test   %edx,%edx
  807804:	74 25                	je     80782b <inet_aton+0x10f>
  807806:	8d 4f e0             	lea    -0x20(%edi),%ecx
    return (0);
  807809:	b8 00 00 00 00       	mov    $0x0,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  80780e:	83 f9 5f             	cmp    $0x5f,%ecx
  807811:	0f 87 d0 00 00 00    	ja     8078e7 <inet_aton+0x1cb>
  807817:	83 fa 20             	cmp    $0x20,%edx
  80781a:	74 0f                	je     80782b <inet_aton+0x10f>
  80781c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80781f:	83 ea 09             	sub    $0x9,%edx
  807822:	83 fa 04             	cmp    $0x4,%edx
  807825:	0f 87 bc 00 00 00    	ja     8078e7 <inet_aton+0x1cb>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  80782b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80782e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807831:	29 c2                	sub    %eax,%edx
  807833:	c1 fa 02             	sar    $0x2,%edx
  807836:	83 c2 01             	add    $0x1,%edx
  807839:	83 fa 02             	cmp    $0x2,%edx
  80783c:	74 20                	je     80785e <inet_aton+0x142>
  80783e:	83 fa 02             	cmp    $0x2,%edx
  807841:	7f 0f                	jg     807852 <inet_aton+0x136>

  case 0:
    return (0);       /* initial nondigit */
  807843:	b8 00 00 00 00       	mov    $0x0,%eax
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  807848:	85 d2                	test   %edx,%edx
  80784a:	0f 84 97 00 00 00    	je     8078e7 <inet_aton+0x1cb>
  807850:	eb 67                	jmp    8078b9 <inet_aton+0x19d>
  807852:	83 fa 03             	cmp    $0x3,%edx
  807855:	74 1e                	je     807875 <inet_aton+0x159>
  807857:	83 fa 04             	cmp    $0x4,%edx
  80785a:	74 38                	je     807894 <inet_aton+0x178>
  80785c:	eb 5b                	jmp    8078b9 <inet_aton+0x19d>
  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
      return (0);
  80785e:	b8 00 00 00 00       	mov    $0x0,%eax

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  807863:	81 fe ff ff ff 00    	cmp    $0xffffff,%esi
  807869:	77 7c                	ja     8078e7 <inet_aton+0x1cb>
      return (0);
    val |= parts[0] << 24;
  80786b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80786e:	c1 e0 18             	shl    $0x18,%eax
  807871:	09 c6                	or     %eax,%esi
    break;
  807873:	eb 44                	jmp    8078b9 <inet_aton+0x19d>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
      return (0);
  807875:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= parts[0] << 24;
    break;

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  80787a:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  807880:	77 65                	ja     8078e7 <inet_aton+0x1cb>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  807882:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807885:	c1 e2 18             	shl    $0x18,%edx
  807888:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80788b:	c1 e0 10             	shl    $0x10,%eax
  80788e:	09 d0                	or     %edx,%eax
  807890:	09 c6                	or     %eax,%esi
    break;
  807892:	eb 25                	jmp    8078b9 <inet_aton+0x19d>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
      return (0);
  807894:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
    break;

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  807899:	81 fe ff 00 00 00    	cmp    $0xff,%esi
  80789f:	77 46                	ja     8078e7 <inet_aton+0x1cb>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  8078a1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8078a4:	c1 e2 18             	shl    $0x18,%edx
  8078a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8078aa:	c1 e0 10             	shl    $0x10,%eax
  8078ad:	09 c2                	or     %eax,%edx
  8078af:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8078b2:	c1 e0 08             	shl    $0x8,%eax
  8078b5:	09 d0                	or     %edx,%eax
  8078b7:	09 c6                	or     %eax,%esi
    break;
  }
  if (addr)
  8078b9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8078bd:	74 23                	je     8078e2 <inet_aton+0x1c6>
    addr->s_addr = htonl(val);
  8078bf:	56                   	push   %esi
  8078c0:	e8 2b fe ff ff       	call   8076f0 <htonl>
  8078c5:	83 c4 04             	add    $0x4,%esp
  8078c8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8078cb:	89 03                	mov    %eax,(%ebx)
  return (1);
  8078cd:	b8 01 00 00 00       	mov    $0x1,%eax
  8078d2:	eb 13                	jmp    8078e7 <inet_aton+0x1cb>
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
  8078d4:	b8 00 00 00 00       	mov    $0x0,%eax
  8078d9:	eb 0c                	jmp    8078e7 <inet_aton+0x1cb>
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
  8078db:	b8 00 00 00 00       	mov    $0x0,%eax
  8078e0:	eb 05                	jmp    8078e7 <inet_aton+0x1cb>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
    addr->s_addr = htonl(val);
  return (1);
  8078e2:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8078e7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8078ea:	5b                   	pop    %ebx
  8078eb:	5e                   	pop    %esi
  8078ec:	5f                   	pop    %edi
  8078ed:	5d                   	pop    %ebp
  8078ee:	c3                   	ret    

008078ef <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  8078ef:	55                   	push   %ebp
  8078f0:	89 e5                	mov    %esp,%ebp
  8078f2:	83 ec 10             	sub    $0x10,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  8078f5:	8d 45 fc             	lea    -0x4(%ebp),%eax
  8078f8:	50                   	push   %eax
  8078f9:	ff 75 08             	pushl  0x8(%ebp)
  8078fc:	e8 1b fe ff ff       	call   80771c <inet_aton>
  807901:	83 c4 08             	add    $0x8,%esp
    return (val.s_addr);
  807904:	85 c0                	test   %eax,%eax
  807906:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80790b:	0f 45 45 fc          	cmovne -0x4(%ebp),%eax
  }
  return (INADDR_NONE);
}
  80790f:	c9                   	leave  
  807910:	c3                   	ret    

00807911 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807911:	55                   	push   %ebp
  807912:	89 e5                	mov    %esp,%ebp
  return htonl(n);
  807914:	ff 75 08             	pushl  0x8(%ebp)
  807917:	e8 d4 fd ff ff       	call   8076f0 <htonl>
  80791c:	83 c4 04             	add    $0x4,%esp
}
  80791f:	c9                   	leave  
  807920:	c3                   	ret    

00807921 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807921:	55                   	push   %ebp
  807922:	89 e5                	mov    %esp,%ebp
  807924:	57                   	push   %edi
  807925:	56                   	push   %esi
  807926:	53                   	push   %ebx
  807927:	83 ec 3c             	sub    $0x3c,%esp
  80792a:	8b 7d 08             	mov    0x8(%ebp),%edi
  80792d:	8b 45 10             	mov    0x10(%ebp),%eax
  807930:	89 c6                	mov    %eax,%esi
  807932:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  807935:	8b 45 14             	mov    0x14(%ebp),%eax
  807938:	89 c2                	mov    %eax,%edx
  80793a:	89 45 bc             	mov    %eax,-0x44(%ebp)
  80793d:	8b 45 18             	mov    0x18(%ebp),%eax
  807940:	89 c3                	mov    %eax,%ebx
  807942:	89 45 b8             	mov    %eax,-0x48(%ebp)
  807945:	8b 45 20             	mov    0x20(%ebp),%eax
  807948:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  80794c:	88 55 dd             	mov    %dl,-0x23(%ebp)
  80794f:	89 da                	mov    %ebx,%edx
  807951:	88 45 dc             	mov    %al,-0x24(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807954:	66 85 f6             	test   %si,%si
  807957:	74 1b                	je     807974 <tcp_enqueue+0x53>
  807959:	84 c0                	test   %al,%al
  80795b:	74 17                	je     807974 <tcp_enqueue+0x53>
  80795d:	83 ec 04             	sub    $0x4,%esp
  807960:	68 40 1e 81 00       	push   $0x811e40
  807965:	68 90 00 00 00       	push   $0x90
  80796a:	68 e2 1f 81 00       	push   $0x811fe2
  80796f:	e8 da 6a 00 00       	call   80e44e <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807974:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807978:	74 1d                	je     807997 <tcp_enqueue+0x76>
  80797a:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80797e:	74 17                	je     807997 <tcp_enqueue+0x76>
  807980:	83 ec 04             	sub    $0x4,%esp
  807983:	68 80 1e 81 00       	push   $0x811e80
  807988:	68 92 00 00 00       	push   $0x92
  80798d:	68 e2 1f 81 00       	push   $0x811fe2
  807992:	e8 b7 6a 00 00       	call   80e44e <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  807997:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  80799b:	66 3b 4f 6e          	cmp    0x6e(%edi),%cx
  80799f:	76 0e                	jbe    8079af <tcp_enqueue+0x8e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  8079a1:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  8079a5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8079aa:	e9 d1 05 00 00       	jmp    807f80 <tcp_enqueue+0x65f>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  8079af:	8b 4f 68             	mov    0x68(%edi),%ecx
  8079b2:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  8079b5:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  8079b9:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  8079bd:	66 83 f9 1f          	cmp    $0x1f,%cx
  8079c1:	76 0e                	jbe    8079d1 <tcp_enqueue+0xb0>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  8079c3:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  8079c7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8079cc:	e9 af 05 00 00       	jmp    807f80 <tcp_enqueue+0x65f>
  }
  if (queuelen != 0) {
  8079d1:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  8079d6:	74 23                	je     8079fb <tcp_enqueue+0xda>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  8079d8:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8079dc:	75 29                	jne    807a07 <tcp_enqueue+0xe6>
  8079de:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8079e2:	75 23                	jne    807a07 <tcp_enqueue+0xe6>
  8079e4:	83 ec 04             	sub    $0x4,%esp
  8079e7:	68 c8 1e 81 00       	push   $0x811ec8
  8079ec:	68 ae 00 00 00       	push   $0xae
  8079f1:	68 e2 1f 81 00       	push   $0x811fe2
  8079f6:	e8 53 6a 00 00       	call   80e44e <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  8079fb:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8079ff:	75 41                	jne    807a42 <tcp_enqueue+0x121>
  807a01:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807a05:	75 3b                	jne    807a42 <tcp_enqueue+0x121>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807a07:	c0 e8 02             	shr    $0x2,%al
  807a0a:	c1 e0 0c             	shl    $0xc,%eax
  807a0d:	66 05 00 50          	add    $0x5000,%ax
  807a11:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
  807a15:	8b 45 0c             	mov    0xc(%ebp),%eax
  807a18:	89 45 cc             	mov    %eax,-0x34(%ebp)
  807a1b:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807a1f:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  807a23:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
  807a27:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  807a2e:	be 00 00 00 00       	mov    $0x0,%esi
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807a33:	83 e2 01             	and    $0x1,%edx
  807a36:	88 55 c9             	mov    %dl,-0x37(%ebp)
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807a39:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807a3d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807a40:	eb 17                	jmp    807a59 <tcp_enqueue+0x138>
  }
  if (queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807a42:	83 ec 04             	sub    $0x4,%esp
  807a45:	68 04 1f 81 00       	push   $0x811f04
  807a4a:	68 b1 00 00 00       	push   $0xb1
  807a4f:	68 e2 1f 81 00       	push   $0x811fe2
  807a54:	e8 f5 69 00 00       	call   80e44e <_panic>
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  807a59:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  807a5d:	66 39 47 34          	cmp    %ax,0x34(%edi)
  807a61:	66 0f 46 47 34       	cmovbe 0x34(%edi),%ax
  807a66:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  807a6a:	83 ec 0c             	sub    $0xc,%esp
  807a6d:	6a 04                	push   $0x4
  807a6f:	e8 e8 c9 ff ff       	call   80445c <memp_malloc>
  807a74:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  807a76:	83 c4 10             	add    $0x10,%esp
  807a79:	85 c0                	test   %eax,%eax
  807a7b:	0f 84 91 04 00 00    	je     807f12 <tcp_enqueue+0x5f1>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  807a81:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  807a87:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  807a8e:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  807a92:	75 1f                	jne    807ab3 <tcp_enqueue+0x192>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807a94:	85 f6                	test   %esi,%esi
  807a96:	75 17                	jne    807aaf <tcp_enqueue+0x18e>
  807a98:	83 ec 04             	sub    $0x4,%esp
  807a9b:	68 fa 1f 81 00       	push   $0x811ffa
  807aa0:	68 ce 00 00 00       	push   $0xce
  807aa5:	68 e2 1f 81 00       	push   $0x811fe2
  807aaa:	e8 9f 69 00 00       	call   80e44e <_panic>
      useg->next = seg;
  807aaf:	89 06                	mov    %eax,(%esi)
  807ab1:	eb 03                	jmp    807ab6 <tcp_enqueue+0x195>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  807ab3:	89 45 d0             	mov    %eax,-0x30(%ebp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  807ab6:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807aba:	74 5f                	je     807b1b <tcp_enqueue+0x1fa>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807abc:	83 ec 04             	sub    $0x4,%esp
  807abf:	6a 00                	push   $0x0
  807ac1:	ff 75 d4             	pushl  -0x2c(%ebp)
  807ac4:	6a 00                	push   $0x0
  807ac6:	e8 20 ce ff ff       	call   8048eb <pbuf_alloc>
  807acb:	89 43 04             	mov    %eax,0x4(%ebx)
  807ace:	83 c4 10             	add    $0x10,%esp
  807ad1:	85 c0                	test   %eax,%eax
  807ad3:	0f 84 39 04 00 00    	je     807f12 <tcp_enqueue+0x5f1>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807ad9:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
  807add:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  807ae1:	73 17                	jae    807afa <tcp_enqueue+0x1d9>
  807ae3:	83 ec 04             	sub    $0x4,%esp
  807ae6:	68 38 1f 81 00       	push   $0x811f38
  807aeb:	68 df 00 00 00       	push   $0xdf
  807af0:	68 e2 1f 81 00       	push   $0x811fe2
  807af5:	e8 54 69 00 00       	call   80e44e <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  807afa:	83 ec 0c             	sub    $0xc,%esp
  807afd:	50                   	push   %eax
  807afe:	e8 81 d1 ff ff       	call   804c84 <pbuf_clen>
  807b03:	0f b6 c0             	movzbl %al,%eax
  807b06:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      seg->dataptr = seg->p->payload;
  807b0a:	8b 43 04             	mov    0x4(%ebx),%eax
  807b0d:	8b 40 04             	mov    0x4(%eax),%eax
  807b10:	89 43 08             	mov    %eax,0x8(%ebx)
  807b13:	83 c4 10             	add    $0x10,%esp
  807b16:	e9 00 01 00 00       	jmp    807c1b <tcp_enqueue+0x2fa>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807b1b:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  807b1f:	74 7c                	je     807b9d <tcp_enqueue+0x27c>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807b21:	83 ec 04             	sub    $0x4,%esp
  807b24:	6a 00                	push   $0x0
  807b26:	0f b7 75 e2          	movzwl -0x1e(%ebp),%esi
  807b2a:	0f b7 c6             	movzwl %si,%eax
  807b2d:	50                   	push   %eax
  807b2e:	6a 00                	push   $0x0
  807b30:	e8 b6 cd ff ff       	call   8048eb <pbuf_alloc>
  807b35:	89 43 04             	mov    %eax,0x4(%ebx)
  807b38:	83 c4 10             	add    $0x10,%esp
  807b3b:	85 c0                	test   %eax,%eax
  807b3d:	0f 84 cf 03 00 00    	je     807f12 <tcp_enqueue+0x5f1>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807b43:	66 3b 70 0a          	cmp    0xa(%eax),%si
  807b47:	76 17                	jbe    807b60 <tcp_enqueue+0x23f>
  807b49:	83 ec 04             	sub    $0x4,%esp
  807b4c:	68 60 1f 81 00       	push   $0x811f60
  807b51:	68 ea 00 00 00       	push   $0xea
  807b56:	68 e2 1f 81 00       	push   $0x811fe2
  807b5b:	e8 ee 68 00 00       	call   80e44e <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  807b60:	83 ec 0c             	sub    $0xc,%esp
  807b63:	50                   	push   %eax
  807b64:	e8 1b d1 ff ff       	call   804c84 <pbuf_clen>
  807b69:	0f b6 c0             	movzbl %al,%eax
  807b6c:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      if (arg != NULL) {
  807b70:	83 c4 10             	add    $0x10,%esp
  807b73:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807b77:	74 19                	je     807b92 <tcp_enqueue+0x271>
        MEMCPY(seg->p->payload, ptr, seglen);
  807b79:	83 ec 04             	sub    $0x4,%esp
  807b7c:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807b80:	50                   	push   %eax
  807b81:	ff 75 cc             	pushl  -0x34(%ebp)
  807b84:	8b 43 04             	mov    0x4(%ebx),%eax
  807b87:	ff 70 04             	pushl  0x4(%eax)
  807b8a:	e8 17 71 00 00       	call   80eca6 <memcpy>
  807b8f:	83 c4 10             	add    $0x10,%esp
      }
      seg->dataptr = seg->p->payload;
  807b92:	8b 43 04             	mov    0x4(%ebx),%eax
  807b95:	8b 40 04             	mov    0x4(%eax),%eax
  807b98:	89 43 08             	mov    %eax,0x8(%ebx)
  807b9b:	eb 7e                	jmp    807c1b <tcp_enqueue+0x2fa>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  807b9d:	83 ec 04             	sub    $0x4,%esp
  807ba0:	6a 01                	push   $0x1
  807ba2:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807ba6:	50                   	push   %eax
  807ba7:	6a 00                	push   $0x0
  807ba9:	e8 3d cd ff ff       	call   8048eb <pbuf_alloc>
  807bae:	89 c6                	mov    %eax,%esi
  807bb0:	83 c4 10             	add    $0x10,%esp
  807bb3:	85 c0                	test   %eax,%eax
  807bb5:	0f 84 57 03 00 00    	je     807f12 <tcp_enqueue+0x5f1>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
  807bbb:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807bbf:	83 c0 01             	add    $0x1,%eax
  807bc2:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  807bc6:	8b 45 cc             	mov    -0x34(%ebp),%eax
  807bc9:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  807bcc:	89 43 08             	mov    %eax,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  807bcf:	83 ec 04             	sub    $0x4,%esp
  807bd2:	6a 00                	push   $0x0
  807bd4:	6a 00                	push   $0x0
  807bd6:	6a 00                	push   $0x0
  807bd8:	e8 0e cd ff ff       	call   8048eb <pbuf_alloc>
  807bdd:	89 43 04             	mov    %eax,0x4(%ebx)
  807be0:	83 c4 10             	add    $0x10,%esp
  807be3:	85 c0                	test   %eax,%eax
  807be5:	75 11                	jne    807bf8 <tcp_enqueue+0x2d7>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  807be7:	83 ec 0c             	sub    $0xc,%esp
  807bea:	56                   	push   %esi
  807beb:	e8 35 cc ff ff       	call   804825 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  807bf0:	83 c4 10             	add    $0x10,%esp
  807bf3:	e9 1a 03 00 00       	jmp    807f12 <tcp_enqueue+0x5f1>
      }
      queuelen += pbuf_clen(seg->p);
  807bf8:	83 ec 0c             	sub    $0xc,%esp
  807bfb:	50                   	push   %eax
  807bfc:	e8 83 d0 ff ff       	call   804c84 <pbuf_clen>
  807c01:	0f b6 c0             	movzbl %al,%eax
  807c04:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  807c08:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  807c0c:	83 c4 08             	add    $0x8,%esp
  807c0f:	56                   	push   %esi
  807c10:	ff 73 04             	pushl  0x4(%ebx)
  807c13:	e8 95 d0 ff ff       	call   804cad <pbuf_cat>
  807c18:	83 c4 10             	add    $0x10,%esp
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807c1b:	66 83 7d e0 20       	cmpw   $0x20,-0x20(%ebp)
  807c20:	0f 87 ec 02 00 00    	ja     807f12 <tcp_enqueue+0x5f1>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  807c26:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807c2a:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807c2e:	83 ec 08             	sub    $0x8,%esp
  807c31:	6a 14                	push   $0x14
  807c33:	ff 73 04             	pushl  0x4(%ebx)
  807c36:	e8 18 cb ff ff       	call   804753 <pbuf_header>
  807c3b:	83 c4 10             	add    $0x10,%esp
  807c3e:	84 c0                	test   %al,%al
  807c40:	0f 85 cc 02 00 00    	jne    807f12 <tcp_enqueue+0x5f1>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  807c46:	8b 43 04             	mov    0x4(%ebx),%eax
  807c49:	8b 70 04             	mov    0x4(%eax),%esi
  807c4c:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807c4f:	83 ec 0c             	sub    $0xc,%esp
  807c52:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807c56:	50                   	push   %eax
  807c57:	e8 7a fa ff ff       	call   8076d6 <htons>
  807c5c:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807c5f:	8b 73 10             	mov    0x10(%ebx),%esi
  807c62:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807c66:	89 04 24             	mov    %eax,(%esp)
  807c69:	e8 68 fa ff ff       	call   8076d6 <htons>
  807c6e:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807c72:	8b 73 10             	mov    0x10(%ebx),%esi
  807c75:	83 c4 04             	add    $0x4,%esp
  807c78:	ff 75 d8             	pushl  -0x28(%ebp)
  807c7b:	e8 70 fa ff ff       	call   8076f0 <htonl>
  807c80:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807c83:	8b 43 10             	mov    0x10(%ebx),%eax
  807c86:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807c8c:	8b 73 10             	mov    0x10(%ebx),%esi
  807c8f:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807c93:	89 04 24             	mov    %eax,(%esp)
  807c96:	e8 48 fa ff ff       	call   8076e3 <ntohs>
  807c9b:	83 e0 c0             	and    $0xffffffc0,%eax
  807c9e:	0f b6 55 dd          	movzbl -0x23(%ebp),%edx
  807ca2:	09 d0                	or     %edx,%eax
  807ca4:	0f b7 c0             	movzwl %ax,%eax
  807ca7:	89 04 24             	mov    %eax,(%esp)
  807caa:	e8 27 fa ff ff       	call   8076d6 <htons>
  807caf:	66 89 46 0c          	mov    %ax,0xc(%esi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  807cb3:	83 c4 10             	add    $0x10,%esp
  807cb6:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807cba:	75 27                	jne    807ce3 <tcp_enqueue+0x3c2>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  807cbc:	8b 73 10             	mov    0x10(%ebx),%esi
  807cbf:	83 ec 0c             	sub    $0xc,%esp
  807cc2:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807cc6:	50                   	push   %eax
  807cc7:	e8 17 fa ff ff       	call   8076e3 <ntohs>
  807ccc:	83 e0 3f             	and    $0x3f,%eax
  807ccf:	80 cc 50             	or     $0x50,%ah
  807cd2:	89 04 24             	mov    %eax,(%esp)
  807cd5:	e8 fc f9 ff ff       	call   8076d6 <htons>
  807cda:	66 89 46 0c          	mov    %ax,0xc(%esi)
  807cde:	83 c4 10             	add    $0x10,%esp
  807ce1:	eb 3a                	jmp    807d1d <tcp_enqueue+0x3fc>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807ce3:	8b 73 10             	mov    0x10(%ebx),%esi
  807ce6:	83 ec 0c             	sub    $0xc,%esp
  807ce9:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807ced:	50                   	push   %eax
  807cee:	e8 f0 f9 ff ff       	call   8076e3 <ntohs>
  807cf3:	83 e0 3f             	and    $0x3f,%eax
  807cf6:	66 0b 45 ca          	or     -0x36(%ebp),%ax
  807cfa:	0f b7 c0             	movzwl %ax,%eax
  807cfd:	89 04 24             	mov    %eax,(%esp)
  807d00:	e8 d1 f9 ff ff       	call   8076d6 <htons>
  807d05:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807d09:	83 c4 0c             	add    $0xc,%esp
  807d0c:	ff 75 d4             	pushl  -0x2c(%ebp)
  807d0f:	ff 75 1c             	pushl  0x1c(%ebp)
  807d12:	ff 73 08             	pushl  0x8(%ebx)
  807d15:	e8 8c 6f 00 00       	call   80eca6 <memcpy>
  807d1a:	83 c4 10             	add    $0x10,%esp
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  807d1d:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  807d21:	0f b7 c1             	movzwl %cx,%eax
  807d24:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807d27:	01 45 cc             	add    %eax,-0x34(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  807d2a:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  807d2e:	0f 94 45 e4          	sete   -0x1c(%ebp)
  807d32:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  807d36:	89 de                	mov    %ebx,%esi

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  807d38:	66 29 4d de          	sub    %cx,-0x22(%ebp)
  807d3c:	0f 85 17 fd ff ff    	jne    807a59 <tcp_enqueue+0x138>
  807d42:	84 c0                	test   %al,%al
  807d44:	0f 85 0f fd ff ff    	jne    807a59 <tcp_enqueue+0x138>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807d4a:	8b 77 74             	mov    0x74(%edi),%esi
  807d4d:	85 f6                	test   %esi,%esi
  807d4f:	75 07                	jne    807d58 <tcp_enqueue+0x437>
  807d51:	e9 ff 00 00 00       	jmp    807e55 <tcp_enqueue+0x534>
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807d56:	89 c6                	mov    %eax,%esi
  807d58:	8b 06                	mov    (%esi),%eax
  807d5a:	85 c0                	test   %eax,%eax
  807d5c:	75 f8                	jne    807d56 <tcp_enqueue+0x435>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  807d5e:	85 f6                	test   %esi,%esi
  807d60:	0f 84 ef 00 00 00    	je     807e55 <tcp_enqueue+0x534>
    TCP_TCPLEN(useg) != 0 &&
  807d66:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807d6a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807d6d:	83 ec 0c             	sub    $0xc,%esp
  807d70:	8b 46 10             	mov    0x10(%esi),%eax
  807d73:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807d77:	50                   	push   %eax
  807d78:	e8 66 f9 ff ff       	call   8076e3 <ntohs>
  807d7d:	83 c4 10             	add    $0x10,%esp
  807d80:	ba 01 00 00 00       	mov    $0x1,%edx
  807d85:	a8 01                	test   $0x1,%al
  807d87:	75 1b                	jne    807da4 <tcp_enqueue+0x483>
  807d89:	83 ec 0c             	sub    $0xc,%esp
  807d8c:	8b 46 10             	mov    0x10(%esi),%eax
  807d8f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807d93:	50                   	push   %eax
  807d94:	e8 4a f9 ff ff       	call   8076e3 <ntohs>
  807d99:	66 d1 e8             	shr    %ax
  807d9c:	89 c2                	mov    %eax,%edx
  807d9e:	83 e2 01             	and    $0x1,%edx
  807da1:	83 c4 10             	add    $0x10,%esp
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  807da4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807da7:	01 d0                	add    %edx,%eax
  807da9:	0f 84 c7 01 00 00    	je     807f76 <tcp_enqueue+0x655>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807daf:	83 ec 0c             	sub    $0xc,%esp
  807db2:	8b 46 10             	mov    0x10(%esi),%eax
  807db5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807db9:	50                   	push   %eax
  807dba:	e8 24 f9 ff ff       	call   8076e3 <ntohs>
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  807dbf:	83 c4 10             	add    $0x10,%esp
  807dc2:	a8 03                	test   $0x3,%al
  807dc4:	0f 85 ac 01 00 00    	jne    807f76 <tcp_enqueue+0x655>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807dca:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807dce:	0f 85 a2 01 00 00    	jne    807f76 <tcp_enqueue+0x655>
    !(flags & (TCP_SYN | TCP_FIN)) &&
  807dd4:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  807dd8:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807ddb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807ddf:	01 d0                	add    %edx,%eax
  807de1:	0f b7 57 34          	movzwl 0x34(%edi),%edx
  807de5:	39 d0                	cmp    %edx,%eax
  807de7:	0f 8f 89 01 00 00    	jg     807f76 <tcp_enqueue+0x655>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  807ded:	83 ec 08             	sub    $0x8,%esp
  807df0:	6a ec                	push   $0xffffffec
  807df2:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807df5:	ff 70 04             	pushl  0x4(%eax)
  807df8:	e8 56 c9 ff ff       	call   804753 <pbuf_header>
  807dfd:	83 c4 10             	add    $0x10,%esp
  807e00:	84 c0                	test   %al,%al
  807e02:	74 17                	je     807e1b <tcp_enqueue+0x4fa>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  807e04:	83 ec 04             	sub    $0x4,%esp
  807e07:	68 07 20 81 00       	push   $0x812007
  807e0c:	68 52 01 00 00       	push   $0x152
  807e11:	68 e2 1f 81 00       	push   $0x811fe2
  807e16:	e8 33 66 00 00       	call   80e44e <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  807e1b:	83 ec 08             	sub    $0x8,%esp
  807e1e:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807e21:	ff 70 04             	pushl  0x4(%eax)
  807e24:	ff 76 04             	pushl  0x4(%esi)
  807e27:	e8 81 ce ff ff       	call   804cad <pbuf_cat>
    useg->len += queue->len;
  807e2c:	8b 55 d0             	mov    -0x30(%ebp),%edx
  807e2f:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807e33:	66 01 46 0c          	add    %ax,0xc(%esi)
    useg->next = queue->next;
  807e37:	8b 02                	mov    (%edx),%eax
  807e39:	89 06                	mov    %eax,(%esi)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  807e3b:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  807e3e:	39 da                	cmp    %ebx,%edx
  807e40:	b8 00 00 00 00       	mov    $0x0,%eax
  807e45:	0f 44 d8             	cmove  %eax,%ebx
    }
    memp_free(MEMP_TCP_SEG, queue);
  807e48:	52                   	push   %edx
  807e49:	6a 04                	push   $0x4
  807e4b:	e8 62 c6 ff ff       	call   8044b2 <memp_free>
  807e50:	83 c4 10             	add    $0x10,%esp
  807e53:	eb 1f                	jmp    807e74 <tcp_enqueue+0x553>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  807e55:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807e58:	89 47 74             	mov    %eax,0x74(%edi)
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  807e5b:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
  807e5f:	83 e2 03             	and    $0x3,%edx
    ++len;
  807e62:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807e66:	83 c0 01             	add    $0x1,%eax
  807e69:	84 d2                	test   %dl,%dl
  807e6b:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  807e70:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  }
  if (flags & TCP_FIN) {
  807e74:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  807e78:	74 04                	je     807e7e <tcp_enqueue+0x55d>
    pcb->flags |= TF_FIN;
  807e7a:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  }
  pcb->snd_lbb += len;
  807e7e:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  807e82:	0f b7 c2             	movzwl %dx,%eax
  807e85:	01 47 68             	add    %eax,0x68(%edi)

  pcb->snd_buf -= len;
  807e88:	66 29 57 6e          	sub    %dx,0x6e(%edi)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  807e8c:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807e90:	66 89 47 70          	mov    %ax,0x70(%edi)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  807e94:	66 85 c0             	test   %ax,%ax
  807e97:	74 23                	je     807ebc <tcp_enqueue+0x59b>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807e99:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807e9d:	75 1d                	jne    807ebc <tcp_enqueue+0x59b>
  807e9f:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807ea3:	75 17                	jne    807ebc <tcp_enqueue+0x59b>
  807ea5:	83 ec 04             	sub    $0x4,%esp
  807ea8:	68 94 1f 81 00       	push   $0x811f94
  807ead:	68 7a 01 00 00       	push   $0x17a
  807eb2:	68 e2 1f 81 00       	push   $0x811fe2
  807eb7:	e8 92 65 00 00       	call   80e44e <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807ebc:	85 db                	test   %ebx,%ebx
  807ebe:	0f 84 8f 00 00 00    	je     807f53 <tcp_enqueue+0x632>
  807ec4:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  807ec9:	0f 84 84 00 00 00    	je     807f53 <tcp_enqueue+0x632>
  807ecf:	8b 5b 10             	mov    0x10(%ebx),%ebx
  807ed2:	85 db                	test   %ebx,%ebx
  807ed4:	0f 84 80 00 00 00    	je     807f5a <tcp_enqueue+0x639>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  807eda:	b8 00 00 00 00       	mov    $0x0,%eax
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807edf:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  807ee3:	0f 85 97 00 00 00    	jne    807f80 <tcp_enqueue+0x65f>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  807ee9:	83 ec 0c             	sub    $0xc,%esp
  807eec:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  807ef0:	50                   	push   %eax
  807ef1:	e8 ed f7 ff ff       	call   8076e3 <ntohs>
  807ef6:	83 c8 08             	or     $0x8,%eax
  807ef9:	0f b7 c0             	movzwl %ax,%eax
  807efc:	89 04 24             	mov    %eax,(%esp)
  807eff:	e8 d2 f7 ff ff       	call   8076d6 <htons>
  807f04:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  807f08:	83 c4 10             	add    $0x10,%esp
  }

  return ERR_OK;
  807f0b:	b8 00 00 00 00       	mov    $0x0,%eax
  807f10:	eb 6e                	jmp    807f80 <tcp_enqueue+0x65f>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  807f12:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  807f16:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807f19:	85 c0                	test   %eax,%eax
  807f1b:	74 0c                	je     807f29 <tcp_enqueue+0x608>
    tcp_segs_free(queue);
  807f1d:	83 ec 0c             	sub    $0xc,%esp
  807f20:	50                   	push   %eax
  807f21:	e8 89 d8 ff ff       	call   8057af <tcp_segs_free>
  807f26:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  807f29:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  807f2e:	74 31                	je     807f61 <tcp_enqueue+0x640>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807f30:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807f34:	75 32                	jne    807f68 <tcp_enqueue+0x647>
  807f36:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807f3a:	75 33                	jne    807f6f <tcp_enqueue+0x64e>
  807f3c:	83 ec 04             	sub    $0x4,%esp
  807f3f:	68 94 1f 81 00       	push   $0x811f94
  807f44:	68 8d 01 00 00       	push   $0x18d
  807f49:	68 e2 1f 81 00       	push   $0x811fe2
  807f4e:	e8 fb 64 00 00       	call   80e44e <_panic>
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  807f53:	b8 00 00 00 00       	mov    $0x0,%eax
  807f58:	eb 26                	jmp    807f80 <tcp_enqueue+0x65f>
  807f5a:	b8 00 00 00 00       	mov    $0x0,%eax
  807f5f:	eb 1f                	jmp    807f80 <tcp_enqueue+0x65f>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  807f61:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f66:	eb 18                	jmp    807f80 <tcp_enqueue+0x65f>
  807f68:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f6d:	eb 11                	jmp    807f80 <tcp_enqueue+0x65f>
  807f6f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f74:	eb 0a                	jmp    807f80 <tcp_enqueue+0x65f>
      /* initialize list with this segment */
      pcb->unsent = queue;
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  807f76:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807f79:	89 06                	mov    %eax,(%esi)
  807f7b:	e9 db fe ff ff       	jmp    807e5b <tcp_enqueue+0x53a>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  807f80:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807f83:	5b                   	pop    %ebx
  807f84:	5e                   	pop    %esi
  807f85:	5f                   	pop    %edi
  807f86:	5d                   	pop    %ebp
  807f87:	c3                   	ret    

00807f88 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  807f88:	55                   	push   %ebp
  807f89:	89 e5                	mov    %esp,%ebp
  807f8b:	83 ec 0c             	sub    $0xc,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  807f8e:	6a 00                	push   $0x0
  807f90:	6a 00                	push   $0x0
  807f92:	6a 01                	push   $0x1
  807f94:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  807f98:	50                   	push   %eax
  807f99:	6a 00                	push   $0x0
  807f9b:	6a 00                	push   $0x0
  807f9d:	ff 75 08             	pushl  0x8(%ebp)
  807fa0:	e8 7c f9 ff ff       	call   807921 <tcp_enqueue>
}
  807fa5:	c9                   	leave  
  807fa6:	c3                   	ret    

00807fa7 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  807fa7:	55                   	push   %ebp
  807fa8:	89 e5                	mov    %esp,%ebp
  807faa:	56                   	push   %esi
  807fab:	53                   	push   %ebx
  807fac:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807faf:	8b 55 10             	mov    0x10(%ebp),%edx
  807fb2:	8b 5d 14             	mov    0x14(%ebp),%ebx
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  807fb5:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  807fb8:	8d 70 fe             	lea    -0x2(%eax),%esi
  807fbb:	83 fe 02             	cmp    $0x2,%esi
  807fbe:	76 05                	jbe    807fc5 <tcp_write+0x1e>
  807fc0:	83 f8 07             	cmp    $0x7,%eax
  807fc3:	75 29                	jne    807fee <tcp_write+0x47>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  807fc5:	b8 00 00 00 00       	mov    $0x0,%eax
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  807fca:	66 85 d2             	test   %dx,%dx
  807fcd:	74 24                	je     807ff3 <tcp_write+0x4c>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  807fcf:	83 ec 04             	sub    $0x4,%esp
  807fd2:	6a 00                	push   $0x0
  807fd4:	6a 00                	push   $0x0
  807fd6:	0f b6 db             	movzbl %bl,%ebx
  807fd9:	53                   	push   %ebx
  807fda:	6a 00                	push   $0x0
  807fdc:	0f b7 d2             	movzwl %dx,%edx
  807fdf:	52                   	push   %edx
  807fe0:	ff 75 0c             	pushl  0xc(%ebp)
  807fe3:	51                   	push   %ecx
  807fe4:	e8 38 f9 ff ff       	call   807921 <tcp_enqueue>
  807fe9:	83 c4 20             	add    $0x20,%esp
  807fec:	eb 05                	jmp    807ff3 <tcp_write+0x4c>
    }
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  807fee:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  }
}
  807ff3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  807ff6:	5b                   	pop    %ebx
  807ff7:	5e                   	pop    %esi
  807ff8:	5d                   	pop    %ebp
  807ff9:	c3                   	ret    

00807ffa <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  807ffa:	55                   	push   %ebp
  807ffb:	89 e5                	mov    %esp,%ebp
  807ffd:	57                   	push   %edi
  807ffe:	56                   	push   %esi
  807fff:	53                   	push   %ebx
  808000:	83 ec 1c             	sub    $0x1c,%esp
  808003:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  808006:	39 3d 58 b2 b3 00    	cmp    %edi,0xb3b258
  80800c:	0f 84 36 04 00 00    	je     808448 <tcp_output+0x44e>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  808012:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  808016:	66 39 47 4e          	cmp    %ax,0x4e(%edi)
  80801a:	66 0f 46 47 4e       	cmovbe 0x4e(%edi),%ax
  80801f:	0f b7 c0             	movzwl %ax,%eax
  808022:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  808025:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  808028:	8b 47 78             	mov    0x78(%edi),%eax
  80802b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80802e:	8b 55 dc             	mov    -0x24(%ebp),%edx
  if (useg != NULL) {
  808031:	85 c0                	test   %eax,%eax
  808033:	75 06                	jne    80803b <tcp_output+0x41>
  808035:	eb 0d                	jmp    808044 <tcp_output+0x4a>
    for (; useg->next != NULL; useg = useg->next);
  808037:	89 c2                	mov    %eax,%edx
  808039:	eb 00                	jmp    80803b <tcp_output+0x41>
  80803b:	8b 02                	mov    (%edx),%eax
  80803d:	85 c0                	test   %eax,%eax
  80803f:	75 f6                	jne    808037 <tcp_output+0x3d>
  808041:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  808044:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  808048:	75 0b                	jne    808055 <tcp_output+0x5b>

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80804a:	8d 47 04             	lea    0x4(%edi),%eax
  80804d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808050:	e9 8c 03 00 00       	jmp    8083e1 <tcp_output+0x3e7>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  808055:	85 db                	test   %ebx,%ebx
  808057:	74 1f                	je     808078 <tcp_output+0x7e>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  808059:	83 ec 0c             	sub    $0xc,%esp
  80805c:	8b 43 10             	mov    0x10(%ebx),%eax
  80805f:	ff 70 04             	pushl  0x4(%eax)
  808062:	e8 aa f8 ff ff       	call   807911 <ntohl>
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  808067:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80806b:	2b 57 48             	sub    0x48(%edi),%edx
  80806e:	01 d0                	add    %edx,%eax
  808070:	83 c4 10             	add    $0x10,%esp
  808073:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  808076:	73 d2                	jae    80804a <tcp_output+0x50>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808078:	83 ec 04             	sub    $0x4,%esp
  80807b:	6a 00                	push   $0x0
  80807d:	6a 14                	push   $0x14
  80807f:	6a 01                	push   $0x1
  808081:	e8 65 c8 ff ff       	call   8048eb <pbuf_alloc>
  808086:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  808088:	83 c4 10             	add    $0x10,%esp
  80808b:	85 c0                	test   %eax,%eax
  80808d:	0f 84 bc 03 00 00    	je     80844f <tcp_output+0x455>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  808093:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  808097:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  80809a:	83 ec 0c             	sub    $0xc,%esp
  80809d:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8080a1:	50                   	push   %eax
  8080a2:	e8 2f f6 ff ff       	call   8076d6 <htons>
  8080a7:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  8080aa:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  8080ae:	89 04 24             	mov    %eax,(%esp)
  8080b1:	e8 20 f6 ff ff       	call   8076d6 <htons>
  8080b6:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  8080ba:	83 c4 04             	add    $0x4,%esp
  8080bd:	ff 77 54             	pushl  0x54(%edi)
  8080c0:	e8 2b f6 ff ff       	call   8076f0 <htonl>
  8080c5:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  8080c8:	83 c4 04             	add    $0x4,%esp
  8080cb:	ff 77 24             	pushl  0x24(%edi)
  8080ce:	e8 1d f6 ff ff       	call   8076f0 <htonl>
  8080d3:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  8080d6:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8080da:	89 04 24             	mov    %eax,(%esp)
  8080dd:	e8 01 f6 ff ff       	call   8076e3 <ntohs>
  8080e2:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8080e7:	83 c8 10             	or     $0x10,%eax
  8080ea:	89 04 24             	mov    %eax,(%esp)
  8080ed:	e8 e4 f5 ff ff       	call   8076d6 <htons>
  8080f2:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8080f6:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8080fa:	89 04 24             	mov    %eax,(%esp)
  8080fd:	e8 d4 f5 ff ff       	call   8076d6 <htons>
  808102:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  808106:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80810c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808110:	89 04 24             	mov    %eax,(%esp)
  808113:	e8 cb f5 ff ff       	call   8076e3 <ntohs>
  808118:	83 e0 3f             	and    $0x3f,%eax
  80811b:	80 cc 50             	or     $0x50,%ah
  80811e:	89 04 24             	mov    %eax,(%esp)
  808121:	e8 b0 f5 ff ff       	call   8076d6 <htons>
  808126:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80812a:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  808130:	8d 47 04             	lea    0x4(%edi),%eax
  808133:	89 c1                	mov    %eax,%ecx
  808135:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808139:	89 04 24             	mov    %eax,(%esp)
  80813c:	6a 06                	push   $0x6
  80813e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808141:	51                   	push   %ecx
  808142:	57                   	push   %edi
  808143:	56                   	push   %esi
  808144:	e8 74 f2 ff ff       	call   8073bd <inet_chksum_pseudo>
  808149:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80814d:	83 c4 18             	add    $0x18,%esp
  808150:	6a 06                	push   $0x6
  808152:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808156:	50                   	push   %eax
  808157:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80815b:	50                   	push   %eax
  80815c:	ff 75 e4             	pushl  -0x1c(%ebp)
  80815f:	57                   	push   %edi
  808160:	56                   	push   %esi
  808161:	e8 9e e8 ff ff       	call   806a04 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  808166:	83 c4 14             	add    $0x14,%esp
  808169:	56                   	push   %esi
  80816a:	e8 b6 c6 ff ff       	call   804825 <pbuf_free>

    return ERR_OK;
  80816f:	83 c4 10             	add    $0x10,%esp
  808172:	b8 00 00 00 00       	mov    $0x0,%eax
  808177:	e9 ed 02 00 00       	jmp    808469 <tcp_output+0x46f>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  80817c:	83 ec 0c             	sub    $0xc,%esp
  80817f:	8b 43 10             	mov    0x10(%ebx),%eax
  808182:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808186:	50                   	push   %eax
  808187:	e8 57 f5 ff ff       	call   8076e3 <ntohs>
  80818c:	83 c4 10             	add    $0x10,%esp
  80818f:	a8 04                	test   $0x4,%al
  808191:	74 17                	je     8081aa <tcp_output+0x1b0>
  808193:	83 ec 04             	sub    $0x4,%esp
  808196:	68 1b 20 81 00       	push   $0x81201b
  80819b:	68 05 02 00 00       	push   $0x205
  8081a0:	68 e2 1f 81 00       	push   $0x811fe2
  8081a5:	e8 a4 62 00 00       	call   80e44e <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  8081aa:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8081ae:	74 1c                	je     8081cc <tcp_output+0x1d2>
  8081b0:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  8081b4:	a8 40                	test   $0x40,%al
  8081b6:	75 14                	jne    8081cc <tcp_output+0x1d2>
  8081b8:	8b 57 74             	mov    0x74(%edi),%edx
  8081bb:	85 d2                	test   %edx,%edx
  8081bd:	0f 84 93 02 00 00    	je     808456 <tcp_output+0x45c>
  8081c3:	83 3a 00             	cmpl   $0x0,(%edx)
  8081c6:	0f 84 8a 02 00 00    	je     808456 <tcp_output+0x45c>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  8081cc:	8b 03                	mov    (%ebx),%eax
  8081ce:	89 47 74             	mov    %eax,0x74(%edi)

    if (pcb->state != SYN_SENT) {
  8081d1:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  8081d5:	74 29                	je     808200 <tcp_output+0x206>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  8081d7:	8b 73 10             	mov    0x10(%ebx),%esi
  8081da:	83 ec 0c             	sub    $0xc,%esp
  8081dd:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8081e1:	50                   	push   %eax
  8081e2:	e8 fc f4 ff ff       	call   8076e3 <ntohs>
  8081e7:	83 c8 10             	or     $0x10,%eax
  8081ea:	0f b7 c0             	movzwl %ax,%eax
  8081ed:	89 04 24             	mov    %eax,(%esp)
  8081f0:	e8 e1 f4 ff ff       	call   8076d6 <htons>
  8081f5:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8081f9:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  8081fd:	83 c4 10             	add    $0x10,%esp
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  808200:	8b 73 10             	mov    0x10(%ebx),%esi
  808203:	83 ec 0c             	sub    $0xc,%esp
  808206:	ff 77 24             	pushl  0x24(%edi)
  808209:	e8 e2 f4 ff ff       	call   8076f0 <htonl>
  80820e:	89 46 08             	mov    %eax,0x8(%esi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808211:	8b 73 10             	mov    0x10(%ebx),%esi
  808214:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  808218:	89 04 24             	mov    %eax,(%esp)
  80821b:	e8 b6 f4 ff ff       	call   8076d6 <htons>
  808220:	66 89 46 0e          	mov    %ax,0xe(%esi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  808224:	83 c4 10             	add    $0x10,%esp
  808227:	85 ff                	test   %edi,%edi
  808229:	74 05                	je     808230 <tcp_output+0x236>
  80822b:	83 3f 00             	cmpl   $0x0,(%edi)
  80822e:	75 27                	jne    808257 <tcp_output+0x25d>
    netif = ip_route(&(pcb->remote_ip));
  808230:	83 ec 0c             	sub    $0xc,%esp
  808233:	ff 75 e4             	pushl  -0x1c(%ebp)
  808236:	e8 df e2 ff ff       	call   80651a <ip_route>
    if (netif == NULL) {
  80823b:	83 c4 10             	add    $0x10,%esp
  80823e:	85 c0                	test   %eax,%eax
  808240:	0f 84 a2 00 00 00    	je     8082e8 <tcp_output+0x2ee>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  808246:	83 f8 fc             	cmp    $0xfffffffc,%eax
  808249:	74 05                	je     808250 <tcp_output+0x256>
  80824b:	8b 40 04             	mov    0x4(%eax),%eax
  80824e:	eb 05                	jmp    808255 <tcp_output+0x25b>
  808250:	b8 00 00 00 00       	mov    $0x0,%eax
  808255:	89 07                	mov    %eax,(%edi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  808257:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  80825c:	75 06                	jne    808264 <tcp_output+0x26a>
    pcb->rtime = 0;
  80825e:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

  if (pcb->rttest == 0) {
  808264:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  808268:	75 1c                	jne    808286 <tcp_output+0x28c>
    pcb->rttest = tcp_ticks;
  80826a:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80826f:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  808272:	83 ec 0c             	sub    $0xc,%esp
  808275:	8b 43 10             	mov    0x10(%ebx),%eax
  808278:	ff 70 04             	pushl  0x4(%eax)
  80827b:	e8 91 f6 ff ff       	call   807911 <ntohl>
  808280:	89 47 3c             	mov    %eax,0x3c(%edi)
  808283:	83 c4 10             	add    $0x10,%esp
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  808286:	8b 53 04             	mov    0x4(%ebx),%edx
  808289:	8b 43 10             	mov    0x10(%ebx),%eax
  80828c:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  80828f:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  808293:	8b 53 04             	mov    0x4(%ebx),%edx
  808296:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  80829a:	8b 43 04             	mov    0x4(%ebx),%eax
  80829d:	8b 53 10             	mov    0x10(%ebx),%edx
  8082a0:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  8082a3:	8b 43 10             	mov    0x10(%ebx),%eax
  8082a6:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8082ac:	8b 73 10             	mov    0x10(%ebx),%esi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  8082af:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8082b2:	83 ec 0c             	sub    $0xc,%esp
  8082b5:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  8082b9:	52                   	push   %edx
  8082ba:	6a 06                	push   $0x6
  8082bc:	ff 75 e4             	pushl  -0x1c(%ebp)
  8082bf:	57                   	push   %edi
  8082c0:	50                   	push   %eax
  8082c1:	e8 f7 f0 ff ff       	call   8073bd <inet_chksum_pseudo>
  8082c6:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  8082ca:	83 c4 18             	add    $0x18,%esp
  8082cd:	6a 06                	push   $0x6
  8082cf:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  8082d3:	50                   	push   %eax
  8082d4:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  8082d8:	50                   	push   %eax
  8082d9:	ff 75 e4             	pushl  -0x1c(%ebp)
  8082dc:	57                   	push   %edi
  8082dd:	ff 73 04             	pushl  0x4(%ebx)
  8082e0:	e8 1f e7 ff ff       	call   806a04 <ip_output>
  8082e5:	83 c4 20             	add    $0x20,%esp
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8082e8:	83 ec 0c             	sub    $0xc,%esp
  8082eb:	8b 43 10             	mov    0x10(%ebx),%eax
  8082ee:	ff 70 04             	pushl  0x4(%eax)
  8082f1:	e8 1b f6 ff ff       	call   807911 <ntohl>
  8082f6:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8082f9:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8082fd:	8b 43 10             	mov    0x10(%ebx),%eax
  808300:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808304:	89 04 24             	mov    %eax,(%esp)
  808307:	e8 d7 f3 ff ff       	call   8076e3 <ntohs>
  80830c:	83 c4 10             	add    $0x10,%esp
  80830f:	ba 01 00 00 00       	mov    $0x1,%edx
  808314:	a8 01                	test   $0x1,%al
  808316:	75 1b                	jne    808333 <tcp_output+0x339>
  808318:	83 ec 0c             	sub    $0xc,%esp
  80831b:	8b 43 10             	mov    0x10(%ebx),%eax
  80831e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808322:	50                   	push   %eax
  808323:	e8 bb f3 ff ff       	call   8076e3 <ntohs>
  808328:	66 d1 e8             	shr    %ax
  80832b:	89 c2                	mov    %eax,%edx
  80832d:	83 e2 01             	and    $0x1,%edx
  808330:	83 c4 10             	add    $0x10,%esp
  808333:	01 d6                	add    %edx,%esi
  808335:	03 75 e0             	add    -0x20(%ebp),%esi
  808338:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  80833b:	39 77 58             	cmp    %esi,0x58(%edi)
  80833e:	79 03                	jns    808343 <tcp_output+0x349>
      pcb->snd_max = pcb->snd_nxt;
  808340:	89 77 58             	mov    %esi,0x58(%edi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  808343:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  808347:	83 ec 0c             	sub    $0xc,%esp
  80834a:	8b 43 10             	mov    0x10(%ebx),%eax
  80834d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808351:	50                   	push   %eax
  808352:	e8 8c f3 ff ff       	call   8076e3 <ntohs>
  808357:	83 c4 10             	add    $0x10,%esp
  80835a:	ba 01 00 00 00       	mov    $0x1,%edx
  80835f:	a8 01                	test   $0x1,%al
  808361:	75 1b                	jne    80837e <tcp_output+0x384>
  808363:	83 ec 0c             	sub    $0xc,%esp
  808366:	8b 43 10             	mov    0x10(%ebx),%eax
  808369:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80836d:	50                   	push   %eax
  80836e:	e8 70 f3 ff ff       	call   8076e3 <ntohs>
  808373:	66 d1 e8             	shr    %ax
  808376:	89 c2                	mov    %eax,%edx
  808378:	83 e2 01             	and    $0x1,%edx
  80837b:	83 c4 10             	add    $0x10,%esp
  80837e:	01 f2                	add    %esi,%edx
  808380:	74 50                	je     8083d2 <tcp_output+0x3d8>
      seg->next = NULL;
  808382:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  808388:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80838c:	75 08                	jne    808396 <tcp_output+0x39c>
        pcb->unacked = seg;
  80838e:	89 5f 78             	mov    %ebx,0x78(%edi)
  808391:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808394:	eb 48                	jmp    8083de <tcp_output+0x3e4>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  808396:	83 ec 0c             	sub    $0xc,%esp
  808399:	8b 43 10             	mov    0x10(%ebx),%eax
  80839c:	ff 70 04             	pushl  0x4(%eax)
  80839f:	e8 6d f5 ff ff       	call   807911 <ntohl>
  8083a4:	89 c6                	mov    %eax,%esi
  8083a6:	83 c4 04             	add    $0x4,%esp
  8083a9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8083ac:	8b 40 10             	mov    0x10(%eax),%eax
  8083af:	ff 70 04             	pushl  0x4(%eax)
  8083b2:	e8 5a f5 ff ff       	call   807911 <ntohl>
  8083b7:	83 c4 10             	add    $0x10,%esp
  8083ba:	39 c6                	cmp    %eax,%esi
  8083bc:	79 0a                	jns    8083c8 <tcp_output+0x3ce>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  8083be:	8b 47 78             	mov    0x78(%edi),%eax
  8083c1:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  8083c3:	89 5f 78             	mov    %ebx,0x78(%edi)
  8083c6:	eb 16                	jmp    8083de <tcp_output+0x3e4>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  8083c8:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8083cb:	89 18                	mov    %ebx,(%eax)
  8083cd:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  8083d0:	eb 0c                	jmp    8083de <tcp_output+0x3e4>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  8083d2:	83 ec 0c             	sub    $0xc,%esp
  8083d5:	53                   	push   %ebx
  8083d6:	e8 90 d3 ff ff       	call   80576b <tcp_seg_free>
  8083db:	83 c4 10             	add    $0x10,%esp
    }
    seg = pcb->unsent;
  8083de:	8b 5f 74             	mov    0x74(%edi),%ebx
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  8083e1:	85 db                	test   %ebx,%ebx
  8083e3:	74 58                	je     80843d <tcp_output+0x443>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  8083e5:	83 ec 0c             	sub    $0xc,%esp
  8083e8:	8b 43 10             	mov    0x10(%ebx),%eax
  8083eb:	ff 70 04             	pushl  0x4(%eax)
  8083ee:	e8 1e f5 ff ff       	call   807911 <ntohl>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  8083f3:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  8083f7:	2b 57 48             	sub    0x48(%edi),%edx
  8083fa:	01 d0                	add    %edx,%eax
  8083fc:	83 c4 10             	add    $0x10,%esp
  8083ff:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  808402:	0f 83 74 fd ff ff    	jae    80817c <tcp_output+0x182>
  808408:	eb 54                	jmp    80845e <tcp_output+0x464>
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  80840a:	83 ec 0c             	sub    $0xc,%esp
  80840d:	8b 43 10             	mov    0x10(%ebx),%eax
  808410:	ff 70 04             	pushl  0x4(%eax)
  808413:	e8 f9 f4 ff ff       	call   807911 <ntohl>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808418:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80841c:	2b 57 48             	sub    0x48(%edi),%edx
  80841f:	01 d0                	add    %edx,%eax
  808421:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  808425:	83 c4 10             	add    $0x10,%esp
  808428:	39 d0                	cmp    %edx,%eax
  80842a:	76 11                	jbe    80843d <tcp_output+0x443>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  80842c:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  808433:	00 00 00 
    pcb->persist_backoff = 1;
  808436:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  80843d:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  808441:	b8 00 00 00 00       	mov    $0x0,%eax
  808446:	eb 21                	jmp    808469 <tcp_output+0x46f>
  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  808448:	b8 00 00 00 00       	mov    $0x0,%eax
  80844d:	eb 1a                	jmp    808469 <tcp_output+0x46f>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    if (p == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  80844f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808454:	eb 13                	jmp    808469 <tcp_output+0x46f>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808456:	a8 a0                	test   $0xa0,%al
  808458:	0f 85 6e fd ff ff    	jne    8081cc <tcp_output+0x1d2>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80845e:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  808465:	75 d6                	jne    80843d <tcp_output+0x443>
  808467:	eb a1                	jmp    80840a <tcp_output+0x410>
    pcb->persist_backoff = 1;
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
  808469:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80846c:	5b                   	pop    %ebx
  80846d:	5e                   	pop    %esi
  80846e:	5f                   	pop    %edi
  80846f:	5d                   	pop    %ebp
  808470:	c3                   	ret    

00808471 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  808471:	55                   	push   %ebp
  808472:	89 e5                	mov    %esp,%ebp
  808474:	57                   	push   %edi
  808475:	56                   	push   %esi
  808476:	53                   	push   %ebx
  808477:	83 ec 20             	sub    $0x20,%esp
  80847a:	8b 7d 18             	mov    0x18(%ebp),%edi
  80847d:	8b 45 1c             	mov    0x1c(%ebp),%eax
  808480:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808483:	6a 00                	push   $0x0
  808485:	6a 14                	push   $0x14
  808487:	6a 01                	push   $0x1
  808489:	e8 5d c4 ff ff       	call   8048eb <pbuf_alloc>
  if (p == NULL) {
  80848e:	83 c4 10             	add    $0x10,%esp
  808491:	85 c0                	test   %eax,%eax
  808493:	0f 84 f5 00 00 00    	je     80858e <tcp_rst+0x11d>
  808499:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80849b:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8084a0:	77 17                	ja     8084b9 <tcp_rst+0x48>
  8084a2:	83 ec 04             	sub    $0x4,%esp
  8084a5:	68 b4 1f 81 00       	push   $0x811fb4
  8084aa:	68 be 02 00 00       	push   $0x2be
  8084af:	68 e2 1f 81 00       	push   $0x811fe2
  8084b4:	e8 95 5f 00 00       	call   80e44e <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8084b9:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  8084bc:	83 ec 0c             	sub    $0xc,%esp
  8084bf:	0f b7 ff             	movzwl %di,%edi
  8084c2:	57                   	push   %edi
  8084c3:	e8 0e f2 ff ff       	call   8076d6 <htons>
  8084c8:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  8084cb:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8084cf:	89 04 24             	mov    %eax,(%esp)
  8084d2:	e8 ff f1 ff ff       	call   8076d6 <htons>
  8084d7:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  8084db:	83 c4 04             	add    $0x4,%esp
  8084de:	ff 75 08             	pushl  0x8(%ebp)
  8084e1:	e8 0a f2 ff ff       	call   8076f0 <htonl>
  8084e6:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  8084e9:	83 c4 04             	add    $0x4,%esp
  8084ec:	ff 75 0c             	pushl  0xc(%ebp)
  8084ef:	e8 fc f1 ff ff       	call   8076f0 <htonl>
  8084f4:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  8084f7:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8084fb:	89 04 24             	mov    %eax,(%esp)
  8084fe:	e8 e0 f1 ff ff       	call   8076e3 <ntohs>
  808503:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808508:	83 c8 14             	or     $0x14,%eax
  80850b:	89 04 24             	mov    %eax,(%esp)
  80850e:	e8 c3 f1 ff ff       	call   8076d6 <htons>
  808513:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808517:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  80851e:	e8 b3 f1 ff ff       	call   8076d6 <htons>
  808523:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808527:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80852d:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808531:	89 04 24             	mov    %eax,(%esp)
  808534:	e8 aa f1 ff ff       	call   8076e3 <ntohs>
  808539:	83 e0 3f             	and    $0x3f,%eax
  80853c:	80 cc 50             	or     $0x50,%ah
  80853f:	89 04 24             	mov    %eax,(%esp)
  808542:	e8 8f f1 ff ff       	call   8076d6 <htons>
  808547:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80854b:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808551:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808555:	89 04 24             	mov    %eax,(%esp)
  808558:	6a 06                	push   $0x6
  80855a:	ff 75 14             	pushl  0x14(%ebp)
  80855d:	ff 75 10             	pushl  0x10(%ebp)
  808560:	56                   	push   %esi
  808561:	e8 57 ee ff ff       	call   8073bd <inet_chksum_pseudo>
  808566:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  80856a:	83 c4 18             	add    $0x18,%esp
  80856d:	6a 06                	push   $0x6
  80856f:	6a 00                	push   $0x0
  808571:	68 ff 00 00 00       	push   $0xff
  808576:	ff 75 14             	pushl  0x14(%ebp)
  808579:	ff 75 10             	pushl  0x10(%ebp)
  80857c:	56                   	push   %esi
  80857d:	e8 82 e4 ff ff       	call   806a04 <ip_output>
  pbuf_free(p);
  808582:	83 c4 14             	add    $0x14,%esp
  808585:	56                   	push   %esi
  808586:	e8 9a c2 ff ff       	call   804825 <pbuf_free>
  80858b:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  80858e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808591:	5b                   	pop    %ebx
  808592:	5e                   	pop    %esi
  808593:	5f                   	pop    %edi
  808594:	5d                   	pop    %ebp
  808595:	c3                   	ret    

00808596 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  808596:	55                   	push   %ebp
  808597:	89 e5                	mov    %esp,%ebp
  808599:	53                   	push   %ebx
  80859a:	83 ec 04             	sub    $0x4,%esp
  80859d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8085a0:	8b 53 78             	mov    0x78(%ebx),%edx
  8085a3:	85 d2                	test   %edx,%edx
  8085a5:	75 04                	jne    8085ab <tcp_rexmit_rto+0x15>
  8085a7:	eb 41                	jmp    8085ea <tcp_rexmit_rto+0x54>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  8085a9:	89 c2                	mov    %eax,%edx
  8085ab:	8b 02                	mov    (%edx),%eax
  8085ad:	85 c0                	test   %eax,%eax
  8085af:	75 f8                	jne    8085a9 <tcp_rexmit_rto+0x13>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  8085b1:	8b 43 74             	mov    0x74(%ebx),%eax
  8085b4:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  8085b6:	8b 43 78             	mov    0x78(%ebx),%eax
  8085b9:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  8085bc:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8085c3:	83 ec 0c             	sub    $0xc,%esp
  8085c6:	8b 40 10             	mov    0x10(%eax),%eax
  8085c9:	ff 70 04             	pushl  0x4(%eax)
  8085cc:	e8 40 f3 ff ff       	call   807911 <ntohl>
  8085d1:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  8085d4:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  8085d8:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  8085df:	89 1c 24             	mov    %ebx,(%esp)
  8085e2:	e8 13 fa ff ff       	call   807ffa <tcp_output>
  8085e7:	83 c4 10             	add    $0x10,%esp
}
  8085ea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8085ed:	c9                   	leave  
  8085ee:	c3                   	ret    

008085ef <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  8085ef:	55                   	push   %ebp
  8085f0:	89 e5                	mov    %esp,%ebp
  8085f2:	53                   	push   %ebx
  8085f3:	83 ec 04             	sub    $0x4,%esp
  8085f6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8085f9:	8b 43 78             	mov    0x78(%ebx),%eax
  8085fc:	85 c0                	test   %eax,%eax
  8085fe:	74 37                	je     808637 <tcp_rexmit+0x48>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808600:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808602:	8b 4b 74             	mov    0x74(%ebx),%ecx
  808605:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808607:	8b 43 78             	mov    0x78(%ebx),%eax
  80860a:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80860d:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808610:	83 ec 0c             	sub    $0xc,%esp
  808613:	8b 40 10             	mov    0x10(%eax),%eax
  808616:	ff 70 04             	pushl  0x4(%eax)
  808619:	e8 f3 f2 ff ff       	call   807911 <ntohl>
  80861e:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808621:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  808625:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80862c:	89 1c 24             	mov    %ebx,(%esp)
  80862f:	e8 c6 f9 ff ff       	call   807ffa <tcp_output>
  808634:	83 c4 10             	add    $0x10,%esp
}
  808637:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80863a:	c9                   	leave  
  80863b:	c3                   	ret    

0080863c <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  80863c:	55                   	push   %ebp
  80863d:	89 e5                	mov    %esp,%ebp
  80863f:	57                   	push   %edi
  808640:	56                   	push   %esi
  808641:	53                   	push   %ebx
  808642:	83 ec 20             	sub    $0x20,%esp
  808645:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808648:	6a 00                	push   $0x0
  80864a:	6a 14                	push   $0x14
  80864c:	6a 01                	push   $0x1
  80864e:	e8 98 c2 ff ff       	call   8048eb <pbuf_alloc>
   
  if(p == NULL) {
  808653:	83 c4 10             	add    $0x10,%esp
  808656:	85 c0                	test   %eax,%eax
  808658:	0f 84 f8 00 00 00    	je     808756 <tcp_keepalive+0x11a>
  80865e:	89 c7                	mov    %eax,%edi
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808660:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808665:	77 17                	ja     80867e <tcp_keepalive+0x42>
  808667:	83 ec 04             	sub    $0x4,%esp
  80866a:	68 b4 1f 81 00       	push   $0x811fb4
  80866f:	68 3a 03 00 00       	push   $0x33a
  808674:	68 e2 1f 81 00       	push   $0x811fe2
  808679:	e8 d0 5d 00 00       	call   80e44e <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80867e:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808681:	83 ec 0c             	sub    $0xc,%esp
  808684:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808688:	50                   	push   %eax
  808689:	e8 48 f0 ff ff       	call   8076d6 <htons>
  80868e:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808691:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808695:	89 04 24             	mov    %eax,(%esp)
  808698:	e8 39 f0 ff ff       	call   8076d6 <htons>
  80869d:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  8086a1:	8b 46 54             	mov    0x54(%esi),%eax
  8086a4:	83 e8 01             	sub    $0x1,%eax
  8086a7:	89 04 24             	mov    %eax,(%esp)
  8086aa:	e8 41 f0 ff ff       	call   8076f0 <htonl>
  8086af:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8086b2:	83 c4 04             	add    $0x4,%esp
  8086b5:	ff 76 24             	pushl  0x24(%esi)
  8086b8:	e8 33 f0 ff ff       	call   8076f0 <htonl>
  8086bd:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8086c0:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8086c4:	89 04 24             	mov    %eax,(%esp)
  8086c7:	e8 17 f0 ff ff       	call   8076e3 <ntohs>
  8086cc:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8086d1:	89 04 24             	mov    %eax,(%esp)
  8086d4:	e8 fd ef ff ff       	call   8076d6 <htons>
  8086d9:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8086dd:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  8086e1:	89 04 24             	mov    %eax,(%esp)
  8086e4:	e8 ed ef ff ff       	call   8076d6 <htons>
  8086e9:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  8086ed:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  8086f3:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8086f7:	89 04 24             	mov    %eax,(%esp)
  8086fa:	e8 e4 ef ff ff       	call   8076e3 <ntohs>
  8086ff:	83 e0 3f             	and    $0x3f,%eax
  808702:	80 cc 50             	or     $0x50,%ah
  808705:	89 04 24             	mov    %eax,(%esp)
  808708:	e8 c9 ef ff ff       	call   8076d6 <htons>
  80870d:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808711:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808717:	8d 46 04             	lea    0x4(%esi),%eax
  80871a:	89 c2                	mov    %eax,%edx
  80871c:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808720:	89 04 24             	mov    %eax,(%esp)
  808723:	6a 06                	push   $0x6
  808725:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  808728:	52                   	push   %edx
  808729:	56                   	push   %esi
  80872a:	57                   	push   %edi
  80872b:	e8 8d ec ff ff       	call   8073bd <inet_chksum_pseudo>
  808730:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808734:	83 c4 18             	add    $0x18,%esp
  808737:	6a 06                	push   $0x6
  808739:	6a 00                	push   $0x0
  80873b:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80873f:	50                   	push   %eax
  808740:	ff 75 e4             	pushl  -0x1c(%ebp)
  808743:	56                   	push   %esi
  808744:	57                   	push   %edi
  808745:	e8 ba e2 ff ff       	call   806a04 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80874a:	83 c4 14             	add    $0x14,%esp
  80874d:	57                   	push   %edi
  80874e:	e8 d2 c0 ff ff       	call   804825 <pbuf_free>
  808753:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808756:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808759:	5b                   	pop    %ebx
  80875a:	5e                   	pop    %esi
  80875b:	5f                   	pop    %edi
  80875c:	5d                   	pop    %ebp
  80875d:	c3                   	ret    

0080875e <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  80875e:	55                   	push   %ebp
  80875f:	89 e5                	mov    %esp,%ebp
  808761:	57                   	push   %edi
  808762:	56                   	push   %esi
  808763:	53                   	push   %ebx
  808764:	83 ec 1c             	sub    $0x1c,%esp
  808767:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  80876a:	8b 46 78             	mov    0x78(%esi),%eax
  80876d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808770:	85 c0                	test   %eax,%eax
  808772:	75 0e                	jne    808782 <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  808774:	8b 46 74             	mov    0x74(%esi),%eax
  808777:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  80877a:	85 c0                	test   %eax,%eax
  80877c:	0f 84 1b 01 00 00    	je     80889d <tcp_zero_window_probe+0x13f>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  808782:	83 ec 04             	sub    $0x4,%esp
  808785:	6a 00                	push   $0x0
  808787:	6a 15                	push   $0x15
  808789:	6a 01                	push   $0x1
  80878b:	e8 5b c1 ff ff       	call   8048eb <pbuf_alloc>
  808790:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808792:	83 c4 10             	add    $0x10,%esp
  808795:	85 c0                	test   %eax,%eax
  808797:	0f 84 00 01 00 00    	je     80889d <tcp_zero_window_probe+0x13f>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80879d:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8087a2:	77 17                	ja     8087bb <tcp_zero_window_probe+0x5d>
  8087a4:	83 ec 04             	sub    $0x4,%esp
  8087a7:	68 b4 1f 81 00       	push   $0x811fb4
  8087ac:	68 8d 03 00 00       	push   $0x38d
  8087b1:	68 e2 1f 81 00       	push   $0x811fe2
  8087b6:	e8 93 5c 00 00       	call   80e44e <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8087bb:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  8087be:	83 ec 0c             	sub    $0xc,%esp
  8087c1:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  8087c5:	50                   	push   %eax
  8087c6:	e8 0b ef ff ff       	call   8076d6 <htons>
  8087cb:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8087ce:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  8087d2:	89 04 24             	mov    %eax,(%esp)
  8087d5:	e8 fc ee ff ff       	call   8076d6 <htons>
  8087da:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  8087de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8087e1:	8b 40 10             	mov    0x10(%eax),%eax
  8087e4:	8b 40 04             	mov    0x4(%eax),%eax
  8087e7:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8087ea:	83 c4 04             	add    $0x4,%esp
  8087ed:	ff 76 24             	pushl  0x24(%esi)
  8087f0:	e8 fb ee ff ff       	call   8076f0 <htonl>
  8087f5:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8087f8:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8087fc:	89 04 24             	mov    %eax,(%esp)
  8087ff:	e8 df ee ff ff       	call   8076e3 <ntohs>
  808804:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808809:	89 04 24             	mov    %eax,(%esp)
  80880c:	e8 c5 ee ff ff       	call   8076d6 <htons>
  808811:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808815:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808819:	89 04 24             	mov    %eax,(%esp)
  80881c:	e8 b5 ee ff ff       	call   8076d6 <htons>
  808821:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808825:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80882b:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80882f:	89 04 24             	mov    %eax,(%esp)
  808832:	e8 ac ee ff ff       	call   8076e3 <ntohs>
  808837:	83 e0 3f             	and    $0x3f,%eax
  80883a:	80 cc 50             	or     $0x50,%ah
  80883d:	89 04 24             	mov    %eax,(%esp)
  808840:	e8 91 ee ff ff       	call   8076d6 <htons>
  808845:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  808849:	8b 47 04             	mov    0x4(%edi),%eax
  80884c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80884f:	8b 51 08             	mov    0x8(%ecx),%edx
  808852:	0f b6 12             	movzbl (%edx),%edx
  808855:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  808858:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80885e:	8d 46 04             	lea    0x4(%esi),%eax
  808861:	89 c1                	mov    %eax,%ecx
  808863:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808867:	89 04 24             	mov    %eax,(%esp)
  80886a:	6a 06                	push   $0x6
  80886c:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80886f:	51                   	push   %ecx
  808870:	56                   	push   %esi
  808871:	57                   	push   %edi
  808872:	e8 46 eb ff ff       	call   8073bd <inet_chksum_pseudo>
  808877:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80887b:	83 c4 18             	add    $0x18,%esp
  80887e:	6a 06                	push   $0x6
  808880:	6a 00                	push   $0x0
  808882:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808886:	50                   	push   %eax
  808887:	ff 75 e4             	pushl  -0x1c(%ebp)
  80888a:	56                   	push   %esi
  80888b:	57                   	push   %edi
  80888c:	e8 73 e1 ff ff       	call   806a04 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808891:	83 c4 14             	add    $0x14,%esp
  808894:	57                   	push   %edi
  808895:	e8 8b bf ff ff       	call   804825 <pbuf_free>
  80889a:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80889d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8088a0:	5b                   	pop    %ebx
  8088a1:	5e                   	pop    %esi
  8088a2:	5f                   	pop    %edi
  8088a3:	5d                   	pop    %ebp
  8088a4:	c3                   	ret    

008088a5 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  8088a5:	55                   	push   %ebp
  8088a6:	89 e5                	mov    %esp,%ebp
  8088a8:	57                   	push   %edi
  8088a9:	56                   	push   %esi
  8088aa:	53                   	push   %ebx
  8088ab:	83 ec 38             	sub    $0x38,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  8088ae:	8b 45 08             	mov    0x8(%ebp),%eax
  8088b1:	8b 78 04             	mov    0x4(%eax),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  8088b4:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  8088b8:	0f b7 07             	movzwl (%edi),%eax
  8088bb:	50                   	push   %eax
  8088bc:	e8 22 ee ff ff       	call   8076e3 <ntohs>
  8088c1:	66 c1 e8 08          	shr    $0x8,%ax
  8088c5:	83 e0 0f             	and    $0xf,%eax
  8088c8:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  8088cf:	83 c4 10             	add    $0x10,%esp
  8088d2:	39 c3                	cmp    %eax,%ebx
  8088d4:	7c 29                	jl     8088ff <udp_input+0x5a>
  8088d6:	83 ec 0c             	sub    $0xc,%esp
  8088d9:	0f b7 07             	movzwl (%edi),%eax
  8088dc:	50                   	push   %eax
  8088dd:	e8 01 ee ff ff       	call   8076e3 <ntohs>
  8088e2:	83 c4 08             	add    $0x8,%esp
  8088e5:	66 c1 e8 06          	shr    $0x6,%ax
  8088e9:	83 e0 3c             	and    $0x3c,%eax
  8088ec:	f7 d8                	neg    %eax
  8088ee:	98                   	cwtl   
  8088ef:	50                   	push   %eax
  8088f0:	ff 75 08             	pushl  0x8(%ebp)
  8088f3:	e8 5b be ff ff       	call   804753 <pbuf_header>
  8088f8:	83 c4 10             	add    $0x10,%esp
  8088fb:	84 c0                	test   %al,%al
  8088fd:	74 13                	je     808912 <udp_input+0x6d>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  8088ff:	83 ec 0c             	sub    $0xc,%esp
  808902:	ff 75 08             	pushl  0x8(%ebp)
  808905:	e8 1b bf ff ff       	call   804825 <pbuf_free>
    goto end;
  80890a:	83 c4 10             	add    $0x10,%esp
  80890d:	e9 ce 02 00 00       	jmp    808be0 <udp_input+0x33b>
  }

  udphdr = (struct udp_hdr *)p->payload;
  808912:	8b 45 08             	mov    0x8(%ebp),%eax
  808915:	8b 40 04             	mov    0x4(%eax),%eax
  808918:	89 c6                	mov    %eax,%esi
  80891a:	89 45 d0             	mov    %eax,-0x30(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  80891d:	83 ec 0c             	sub    $0xc,%esp
  808920:	0f b7 00             	movzwl (%eax),%eax
  808923:	50                   	push   %eax
  808924:	e8 ba ed ff ff       	call   8076e3 <ntohs>
  808929:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  dest = ntohs(udphdr->dest);
  80892d:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  808931:	89 04 24             	mov    %eax,(%esp)
  808934:	e8 aa ed ff ff       	call   8076e3 <ntohs>
  808939:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  80893b:	83 c4 10             	add    $0x10,%esp
  80893e:	66 83 f8 44          	cmp    $0x44,%ax
  808942:	75 49                	jne    80898d <udp_input+0xe8>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  808944:	66 83 7d da 43       	cmpw   $0x43,-0x26(%ebp)
  808949:	0f 85 06 01 00 00    	jne    808a55 <udp_input+0x1b0>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  80894f:	8b 45 0c             	mov    0xc(%ebp),%eax
  808952:	8b 40 20             	mov    0x20(%eax),%eax
  808955:	85 c0                	test   %eax,%eax
  808957:	0f 84 f8 00 00 00    	je     808a55 <udp_input+0x1b0>
  80895d:	8b 40 08             	mov    0x8(%eax),%eax
  808960:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808963:	85 c0                	test   %eax,%eax
  808965:	0f 84 ea 00 00 00    	je     808a55 <udp_input+0x1b0>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  80896b:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80896e:	0f 84 f7 00 00 00    	je     808a6b <udp_input+0x1c6>
  808974:	8b 40 04             	mov    0x4(%eax),%eax
  808977:	85 c0                	test   %eax,%eax
  808979:	0f 84 ec 00 00 00    	je     808a6b <udp_input+0x1c6>
  80897f:	3b 47 0c             	cmp    0xc(%edi),%eax
  808982:	0f 85 cd 00 00 00    	jne    808a55 <udp_input+0x1b0>
  808988:	e9 de 00 00 00       	jmp    808a6b <udp_input+0x1c6>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80898d:	8b 1d 54 b2 b3 00    	mov    0xb3b254,%ebx
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    local_match = 0;
    uncon_pcb = NULL;
  808993:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  80899a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8089a1:	8d 47 10             	lea    0x10(%edi),%eax
  8089a4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8089a7:	89 7d dc             	mov    %edi,-0x24(%ebp)
  8089aa:	0f b7 7d da          	movzwl -0x26(%ebp),%edi
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8089ae:	e9 91 00 00 00       	jmp    808a44 <udp_input+0x19f>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  8089b3:	66 3b 73 12          	cmp    0x12(%ebx),%si
  8089b7:	0f 85 81 00 00 00    	jne    808a3e <udp_input+0x199>
  8089bd:	85 db                	test   %ebx,%ebx
  8089bf:	74 23                	je     8089e4 <udp_input+0x13f>
          (ip_addr_isany(&pcb->local_ip) ||
  8089c1:	8b 03                	mov    (%ebx),%eax
  8089c3:	85 c0                	test   %eax,%eax
  8089c5:	74 1d                	je     8089e4 <udp_input+0x13f>
  8089c7:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8089ca:	3b 42 10             	cmp    0x10(%edx),%eax
  8089cd:	74 15                	je     8089e4 <udp_input+0x13f>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8089cf:	83 ec 08             	sub    $0x8,%esp
  8089d2:	ff 75 0c             	pushl  0xc(%ebp)
  8089d5:	ff 75 d4             	pushl  -0x2c(%ebp)
  8089d8:	e8 f1 da ff ff       	call   8064ce <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  8089dd:	83 c4 10             	add    $0x10,%esp
  8089e0:	84 c0                	test   %al,%al
  8089e2:	74 5a                	je     808a3e <udp_input+0x199>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  8089e4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  8089e8:	0f 85 db 01 00 00    	jne    808bc9 <udp_input+0x324>
  8089ee:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  8089f2:	83 e0 04             	and    $0x4,%eax
  8089f5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8089f8:	0f 44 c3             	cmove  %ebx,%eax
  8089fb:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8089fe:	e9 c6 01 00 00       	jmp    808bc9 <udp_input+0x324>
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  808a03:	83 fb fc             	cmp    $0xfffffffc,%ebx
  808a06:	74 0f                	je     808a17 <udp_input+0x172>
          (ip_addr_isany(&pcb->remote_ip) ||
  808a08:	8b 43 04             	mov    0x4(%ebx),%eax
  808a0b:	85 c0                	test   %eax,%eax
  808a0d:	74 08                	je     808a17 <udp_input+0x172>
  808a0f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  808a12:	3b 41 0c             	cmp    0xc(%ecx),%eax
  808a15:	75 27                	jne    808a3e <udp_input+0x199>
  808a17:	8b 7d dc             	mov    -0x24(%ebp),%edi
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  808a1a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808a1d:	85 d2                	test   %edx,%edx
  808a1f:	0f 84 b3 01 00 00    	je     808bd8 <udp_input+0x333>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  808a25:	8b 43 0c             	mov    0xc(%ebx),%eax
  808a28:	89 42 0c             	mov    %eax,0xc(%edx)
          pcb->next = udp_pcbs;
  808a2b:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808a30:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  808a33:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  808a39:	e9 9a 01 00 00       	jmp    808bd8 <udp_input+0x333>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808a3e:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  808a41:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808a44:	85 db                	test   %ebx,%ebx
  808a46:	0f 85 67 ff ff ff    	jne    8089b3 <udp_input+0x10e>
  808a4c:	8b 7d dc             	mov    -0x24(%ebp),%edi
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  808a4f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  808a53:	75 16                	jne    808a6b <udp_input+0x1c6>
  808a55:	8b 45 0c             	mov    0xc(%ebp),%eax
  808a58:	8b 57 10             	mov    0x10(%edi),%edx
  808a5b:	39 50 04             	cmp    %edx,0x4(%eax)
  808a5e:	0f 85 55 01 00 00    	jne    808bb9 <udp_input+0x314>
  808a64:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  808a6b:	8b 45 d0             	mov    -0x30(%ebp),%eax
  808a6e:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  808a73:	74 38                	je     808aad <udp_input+0x208>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  808a75:	83 ec 0c             	sub    $0xc,%esp
  808a78:	8b 45 08             	mov    0x8(%ebp),%eax
  808a7b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  808a7f:	50                   	push   %eax
  808a80:	6a 11                	push   $0x11
  808a82:	8d 47 10             	lea    0x10(%edi),%eax
  808a85:	50                   	push   %eax
  808a86:	8d 47 0c             	lea    0xc(%edi),%eax
  808a89:	50                   	push   %eax
  808a8a:	ff 75 08             	pushl  0x8(%ebp)
  808a8d:	e8 2b e9 ff ff       	call   8073bd <inet_chksum_pseudo>
  808a92:	83 c4 20             	add    $0x20,%esp
  808a95:	66 85 c0             	test   %ax,%ax
  808a98:	74 13                	je     808aad <udp_input+0x208>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  808a9a:	83 ec 0c             	sub    $0xc,%esp
  808a9d:	ff 75 08             	pushl  0x8(%ebp)
  808aa0:	e8 80 bd ff ff       	call   804825 <pbuf_free>
          goto end;
  808aa5:	83 c4 10             	add    $0x10,%esp
  808aa8:	e9 33 01 00 00       	jmp    808be0 <udp_input+0x33b>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  808aad:	83 ec 08             	sub    $0x8,%esp
  808ab0:	6a f8                	push   $0xfffffff8
  808ab2:	ff 75 08             	pushl  0x8(%ebp)
  808ab5:	e8 99 bc ff ff       	call   804753 <pbuf_header>
  808aba:	83 c4 10             	add    $0x10,%esp
  808abd:	84 c0                	test   %al,%al
  808abf:	74 17                	je     808ad8 <udp_input+0x233>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808ac1:	83 ec 04             	sub    $0x4,%esp
  808ac4:	68 07 20 81 00       	push   $0x812007
  808ac9:	68 0a 01 00 00       	push   $0x10a
  808ace:	68 32 20 81 00       	push   $0x812032
  808ad3:	e8 76 59 00 00       	call   80e44e <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  808ad8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  808adb:	85 c9                	test   %ecx,%ecx
  808add:	74 37                	je     808b16 <udp_input+0x271>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  808adf:	8b 41 18             	mov    0x18(%ecx),%eax
  808ae2:	85 c0                	test   %eax,%eax
  808ae4:	74 1d                	je     808b03 <udp_input+0x25e>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  808ae6:	83 ec 0c             	sub    $0xc,%esp
  808ae9:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
  808aed:	52                   	push   %edx
  808aee:	83 c7 0c             	add    $0xc,%edi
  808af1:	57                   	push   %edi
  808af2:	ff 75 08             	pushl  0x8(%ebp)
  808af5:	51                   	push   %ecx
  808af6:	ff 71 1c             	pushl  0x1c(%ecx)
  808af9:	ff d0                	call   *%eax
  808afb:	83 c4 20             	add    $0x20,%esp
  808afe:	e9 dd 00 00 00       	jmp    808be0 <udp_input+0x33b>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  808b03:	83 ec 0c             	sub    $0xc,%esp
  808b06:	ff 75 08             	pushl  0x8(%ebp)
  808b09:	e8 17 bd ff ff       	call   804825 <pbuf_free>
        goto end;
  808b0e:	83 c4 10             	add    $0x10,%esp
  808b11:	e9 ca 00 00 00       	jmp    808be0 <udp_input+0x33b>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808b16:	83 ec 08             	sub    $0x8,%esp
  808b19:	ff 75 0c             	pushl  0xc(%ebp)
  808b1c:	8d 47 10             	lea    0x10(%edi),%eax
  808b1f:	50                   	push   %eax
  808b20:	e8 a9 d9 ff ff       	call   8064ce <ip_addr_isbroadcast>
  808b25:	83 c4 10             	add    $0x10,%esp
  808b28:	84 c0                	test   %al,%al
  808b2a:	75 7d                	jne    808ba9 <udp_input+0x304>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808b2c:	8b 5f 10             	mov    0x10(%edi),%ebx
  808b2f:	83 ec 0c             	sub    $0xc,%esp
  808b32:	68 00 00 00 f0       	push   $0xf0000000
  808b37:	e8 d5 ed ff ff       	call   807911 <ntohl>
  808b3c:	21 c3                	and    %eax,%ebx
  808b3e:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808b45:	e8 c7 ed ff ff       	call   807911 <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808b4a:	83 c4 10             	add    $0x10,%esp
  808b4d:	39 c3                	cmp    %eax,%ebx
  808b4f:	74 58                	je     808ba9 <udp_input+0x304>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808b51:	83 ec 0c             	sub    $0xc,%esp
  808b54:	0f b7 07             	movzwl (%edi),%eax
  808b57:	50                   	push   %eax
  808b58:	e8 86 eb ff ff       	call   8076e3 <ntohs>
  808b5d:	83 c4 08             	add    $0x8,%esp
  808b60:	66 c1 e8 08          	shr    $0x8,%ax
  808b64:	83 e0 0f             	and    $0xf,%eax
  808b67:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808b6e:	50                   	push   %eax
  808b6f:	ff 75 08             	pushl  0x8(%ebp)
  808b72:	e8 dc bb ff ff       	call   804753 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808b77:	83 c4 10             	add    $0x10,%esp
  808b7a:	8b 45 08             	mov    0x8(%ebp),%eax
  808b7d:	3b 78 04             	cmp    0x4(%eax),%edi
  808b80:	74 17                	je     808b99 <udp_input+0x2f4>
  808b82:	83 ec 04             	sub    $0x4,%esp
  808b85:	68 46 20 81 00       	push   $0x812046
  808b8a:	68 25 01 00 00       	push   $0x125
  808b8f:	68 32 20 81 00       	push   $0x812032
  808b94:	e8 b5 58 00 00       	call   80e44e <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808b99:	83 ec 08             	sub    $0x8,%esp
  808b9c:	6a 03                	push   $0x3
  808b9e:	ff 75 08             	pushl  0x8(%ebp)
  808ba1:	e8 8a 56 00 00       	call   80e230 <icmp_dest_unreach>
  808ba6:	83 c4 10             	add    $0x10,%esp
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  808ba9:	83 ec 0c             	sub    $0xc,%esp
  808bac:	ff 75 08             	pushl  0x8(%ebp)
  808baf:	e8 71 bc ff ff       	call   804825 <pbuf_free>
  808bb4:	83 c4 10             	add    $0x10,%esp
  808bb7:	eb 27                	jmp    808be0 <udp_input+0x33b>
    }
  } else {
    pbuf_free(p);
  808bb9:	83 ec 0c             	sub    $0xc,%esp
  808bbc:	ff 75 08             	pushl  0x8(%ebp)
  808bbf:	e8 61 bc ff ff       	call   804825 <pbuf_free>
  808bc4:	83 c4 10             	add    $0x10,%esp
  }
end:
  PERF_STOP("udp_input");
}
  808bc7:	eb 17                	jmp    808be0 <udp_input+0x33b>
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  808bc9:	66 3b 7b 14          	cmp    0x14(%ebx),%di
  808bcd:	0f 85 6b fe ff ff    	jne    808a3e <udp_input+0x199>
  808bd3:	e9 2b fe ff ff       	jmp    808a03 <udp_input+0x15e>
  808bd8:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  808bdb:	e9 8b fe ff ff       	jmp    808a6b <udp_input+0x1c6>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  808be0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808be3:	5b                   	pop    %ebx
  808be4:	5e                   	pop    %esi
  808be5:	5f                   	pop    %edi
  808be6:	5d                   	pop    %ebp
  808be7:	c3                   	ret    

00808be8 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808be8:	55                   	push   %ebp
  808be9:	89 e5                	mov    %esp,%ebp
  808beb:	57                   	push   %edi
  808bec:	56                   	push   %esi
  808bed:	53                   	push   %ebx
  808bee:	83 ec 0c             	sub    $0xc,%esp
  808bf1:	8b 55 08             	mov    0x8(%ebp),%edx
  808bf4:	8b 7d 0c             	mov    0xc(%ebp),%edi
  808bf7:	8b 75 10             	mov    0x10(%ebp),%esi
  808bfa:	89 f1                	mov    %esi,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808bfc:	a1 54 b2 b3 00       	mov    0xb3b254,%eax

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  808c01:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808c06:	eb 27                	jmp    808c2f <udp_bind+0x47>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  808c08:	39 d0                	cmp    %edx,%eax
  808c0a:	75 20                	jne    808c2c <udp_bind+0x44>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808c0c:	84 db                	test   %bl,%bl
  808c0e:	74 17                	je     808c27 <udp_bind+0x3f>
  808c10:	83 ec 04             	sub    $0x4,%esp
  808c13:	68 5a 20 81 00       	push   $0x81205a
  808c18:	68 41 02 00 00       	push   $0x241
  808c1d:	68 32 20 81 00       	push   $0x812032
  808c22:	e8 27 58 00 00       	call   80e44e <_panic>
      /* pcb already in list, just rebind */
      rebind = 1;
  808c27:	bb 01 00 00 00       	mov    $0x1,%ebx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808c2c:	8b 40 0c             	mov    0xc(%eax),%eax
  808c2f:	85 c0                	test   %eax,%eax
  808c31:	75 d5                	jne    808c08 <udp_bind+0x20>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808c33:	85 ff                	test   %edi,%edi
  808c35:	74 04                	je     808c3b <udp_bind+0x53>
  808c37:	8b 07                	mov    (%edi),%eax
  808c39:	eb 05                	jmp    808c40 <udp_bind+0x58>
  808c3b:	b8 00 00 00 00       	mov    $0x0,%eax
  808c40:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808c42:	66 85 f6             	test   %si,%si
  808c45:	75 2e                	jne    808c75 <udp_bind+0x8d>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808c47:	8b 35 54 b2 b3 00    	mov    0xb3b254,%esi
  808c4d:	89 f0                	mov    %esi,%eax
  if (port == 0) {
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  808c4f:	b9 00 10 00 00       	mov    $0x1000,%ecx
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808c54:	eb 10                	jmp    808c66 <udp_bind+0x7e>
      if (ipcb->local_port == port) {
  808c56:	66 3b 48 12          	cmp    0x12(%eax),%cx
  808c5a:	75 07                	jne    808c63 <udp_bind+0x7b>
        /* port is already used by another udp_pcb */
        port++;
  808c5c:	83 c1 01             	add    $0x1,%ecx
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  808c5f:	89 f0                	mov    %esi,%eax
  808c61:	eb 03                	jmp    808c66 <udp_bind+0x7e>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808c63:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808c66:	85 c0                	test   %eax,%eax
  808c68:	74 07                	je     808c71 <udp_bind+0x89>
  808c6a:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808c6f:	75 e5                	jne    808c56 <udp_bind+0x6e>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  808c71:	85 c0                	test   %eax,%eax
  808c73:	75 22                	jne    808c97 <udp_bind+0xaf>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808c75:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808c79:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }
  pcb->local_port = port;
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  808c7e:	84 db                	test   %bl,%bl
  808c80:	75 1a                	jne    808c9c <udp_bind+0xb4>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  808c82:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808c87:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808c8a:	89 15 54 b2 b3 00    	mov    %edx,0xb3b254
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808c90:	b8 00 00 00 00       	mov    $0x0,%eax
  808c95:	eb 05                	jmp    808c9c <udp_bind+0xb4>
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  808c97:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  808c9c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808c9f:	5b                   	pop    %ebx
  808ca0:	5e                   	pop    %esi
  808ca1:	5f                   	pop    %edi
  808ca2:	5d                   	pop    %ebp
  808ca3:	c3                   	ret    

00808ca4 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  808ca4:	55                   	push   %ebp
  808ca5:	89 e5                	mov    %esp,%ebp
  808ca7:	57                   	push   %edi
  808ca8:	56                   	push   %esi
  808ca9:	53                   	push   %ebx
  808caa:	83 ec 1c             	sub    $0x1c,%esp
  808cad:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808cb0:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  808cb3:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808cb8:	75 17                	jne    808cd1 <udp_sendto_if+0x2d>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808cba:	83 ec 04             	sub    $0x4,%esp
  808cbd:	6a 00                	push   $0x0
  808cbf:	53                   	push   %ebx
  808cc0:	53                   	push   %ebx
  808cc1:	e8 22 ff ff ff       	call   808be8 <udp_bind>
    if (err != ERR_OK) {
  808cc6:	83 c4 10             	add    $0x10,%esp
  808cc9:	84 c0                	test   %al,%al
  808ccb:	0f 85 54 01 00 00    	jne    808e25 <udp_sendto_if+0x181>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  808cd1:	83 ec 08             	sub    $0x8,%esp
  808cd4:	6a 08                	push   $0x8
  808cd6:	ff 75 0c             	pushl  0xc(%ebp)
  808cd9:	e8 75 ba ff ff       	call   804753 <pbuf_header>
  808cde:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  808ce1:	8b 75 0c             	mov    0xc(%ebp),%esi
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  808ce4:	84 c0                	test   %al,%al
  808ce6:	74 2a                	je     808d12 <udp_sendto_if+0x6e>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  808ce8:	83 ec 04             	sub    $0x4,%esp
  808ceb:	6a 00                	push   $0x0
  808ced:	6a 08                	push   $0x8
  808cef:	6a 01                	push   $0x1
  808cf1:	e8 f5 bb ff ff       	call   8048eb <pbuf_alloc>
  808cf6:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  808cf8:	83 c4 10             	add    $0x10,%esp
  808cfb:	85 c0                	test   %eax,%eax
  808cfd:	0f 84 1d 01 00 00    	je     808e20 <udp_sendto_if+0x17c>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  808d03:	83 ec 08             	sub    $0x8,%esp
  808d06:	ff 75 0c             	pushl  0xc(%ebp)
  808d09:	50                   	push   %eax
  808d0a:	e8 0a c0 ff ff       	call   804d19 <pbuf_chain>
  808d0f:	83 c4 10             	add    $0x10,%esp
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808d12:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  808d17:	77 17                	ja     808d30 <udp_sendto_if+0x8c>
  808d19:	83 ec 04             	sub    $0x4,%esp
  808d1c:	68 68 20 81 00       	push   $0x812068
  808d21:	68 b2 01 00 00       	push   $0x1b2
  808d26:	68 32 20 81 00       	push   $0x812032
  808d2b:	e8 1e 57 00 00       	call   80e44e <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  808d30:	8b 46 04             	mov    0x4(%esi),%eax
  808d33:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  udphdr->src = htons(pcb->local_port);
  808d36:	83 ec 0c             	sub    $0xc,%esp
  808d39:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  808d3d:	50                   	push   %eax
  808d3e:	e8 93 e9 ff ff       	call   8076d6 <htons>
  808d43:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808d46:	66 89 01             	mov    %ax,(%ecx)
  udphdr->dest = htons(dst_port);
  808d49:	0f b7 ff             	movzwl %di,%edi
  808d4c:	89 3c 24             	mov    %edi,(%esp)
  808d4f:	e8 82 e9 ff ff       	call   8076d6 <htons>
  808d54:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808d57:	66 89 41 02          	mov    %ax,0x2(%ecx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  808d5b:	66 c7 41 06 00 00    	movw   $0x0,0x6(%ecx)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  808d61:	89 df                	mov    %ebx,%edi
  808d63:	83 c4 10             	add    $0x10,%esp
  808d66:	85 db                	test   %ebx,%ebx
  808d68:	74 06                	je     808d70 <udp_sendto_if+0xcc>
  808d6a:	8b 03                	mov    (%ebx),%eax
  808d6c:	85 c0                	test   %eax,%eax
  808d6e:	75 08                	jne    808d78 <udp_sendto_if+0xd4>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  808d70:	8b 45 18             	mov    0x18(%ebp),%eax
  808d73:	8d 78 04             	lea    0x4(%eax),%edi
  808d76:	eb 2c                	jmp    808da4 <udp_sendto_if+0x100>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  808d78:	8b 55 18             	mov    0x18(%ebp),%edx
  808d7b:	3b 42 04             	cmp    0x4(%edx),%eax
  808d7e:	74 24                	je     808da4 <udp_sendto_if+0x100>
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  808d80:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  808d85:	3b 75 0c             	cmp    0xc(%ebp),%esi
  808d88:	0f 84 97 00 00 00    	je     808e25 <udp_sendto_if+0x181>
        /* free the header pbuf */
        pbuf_free(q);
  808d8e:	83 ec 0c             	sub    $0xc,%esp
  808d91:	56                   	push   %esi
  808d92:	e8 8e ba ff ff       	call   804825 <pbuf_free>
  808d97:	83 c4 10             	add    $0x10,%esp
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  808d9a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  808d9f:	e9 81 00 00 00       	jmp    808e25 <udp_sendto_if+0x181>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  808da4:	83 ec 0c             	sub    $0xc,%esp
  808da7:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808dab:	50                   	push   %eax
  808dac:	e8 25 e9 ff ff       	call   8076d6 <htons>
  808db1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808db4:	66 89 42 04          	mov    %ax,0x4(%edx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  808db8:	83 c4 10             	add    $0x10,%esp
  808dbb:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  808dbf:	75 29                	jne    808dea <udp_sendto_if+0x146>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808dc1:	83 ec 0c             	sub    $0xc,%esp
  808dc4:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808dc8:	50                   	push   %eax
  808dc9:	6a 11                	push   $0x11
  808dcb:	ff 75 10             	pushl  0x10(%ebp)
  808dce:	57                   	push   %edi
  808dcf:	56                   	push   %esi
  808dd0:	e8 e8 e5 ff ff       	call   8073bd <inet_chksum_pseudo>
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  808dd5:	83 c4 20             	add    $0x20,%esp
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808dd8:	66 85 c0             	test   %ax,%ax
  808ddb:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  808de0:	0f 44 c2             	cmove  %edx,%eax
  808de3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808de6:	66 89 42 06          	mov    %ax,0x6(%edx)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  808dea:	83 ec 04             	sub    $0x4,%esp
  808ded:	ff 75 18             	pushl  0x18(%ebp)
  808df0:	6a 11                	push   $0x11
  808df2:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  808df6:	50                   	push   %eax
  808df7:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  808dfb:	50                   	push   %eax
  808dfc:	ff 75 10             	pushl  0x10(%ebp)
  808dff:	57                   	push   %edi
  808e00:	56                   	push   %esi
  808e01:	e8 76 da ff ff       	call   80687c <ip_output_if>
  808e06:	89 c3                	mov    %eax,%ebx
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  808e08:	83 c4 20             	add    $0x20,%esp
  808e0b:	3b 75 0c             	cmp    0xc(%ebp),%esi
  808e0e:	74 15                	je     808e25 <udp_sendto_if+0x181>
    /* free the header pbuf */
    pbuf_free(q);
  808e10:	83 ec 0c             	sub    $0xc,%esp
  808e13:	56                   	push   %esi
  808e14:	e8 0c ba ff ff       	call   804825 <pbuf_free>
  808e19:	83 c4 10             	add    $0x10,%esp
    q = NULL;
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  808e1c:	89 d8                	mov    %ebx,%eax
  808e1e:	eb 05                	jmp    808e25 <udp_sendto_if+0x181>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  808e20:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  808e25:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808e28:	5b                   	pop    %ebx
  808e29:	5e                   	pop    %esi
  808e2a:	5f                   	pop    %edi
  808e2b:	5d                   	pop    %ebp
  808e2c:	c3                   	ret    

00808e2d <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  808e2d:	55                   	push   %ebp
  808e2e:	89 e5                	mov    %esp,%ebp
  808e30:	56                   	push   %esi
  808e31:	53                   	push   %ebx
  808e32:	8b 75 10             	mov    0x10(%ebp),%esi
  808e35:	8b 5d 14             	mov    0x14(%ebp),%ebx

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  808e38:	83 ec 0c             	sub    $0xc,%esp
  808e3b:	56                   	push   %esi
  808e3c:	e8 d9 d6 ff ff       	call   80651a <ip_route>
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  808e41:	83 c4 10             	add    $0x10,%esp
  808e44:	85 c0                	test   %eax,%eax
  808e46:	74 19                	je     808e61 <udp_sendto+0x34>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  808e48:	83 ec 0c             	sub    $0xc,%esp
  808e4b:	50                   	push   %eax
  808e4c:	0f b7 db             	movzwl %bx,%ebx
  808e4f:	53                   	push   %ebx
  808e50:	56                   	push   %esi
  808e51:	ff 75 0c             	pushl  0xc(%ebp)
  808e54:	ff 75 08             	pushl  0x8(%ebp)
  808e57:	e8 48 fe ff ff       	call   808ca4 <udp_sendto_if>
  808e5c:	83 c4 20             	add    $0x20,%esp
  808e5f:	eb 05                	jmp    808e66 <udp_sendto+0x39>

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  808e61:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
}
  808e66:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808e69:	5b                   	pop    %ebx
  808e6a:	5e                   	pop    %esi
  808e6b:	5d                   	pop    %ebp
  808e6c:	c3                   	ret    

00808e6d <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  808e6d:	55                   	push   %ebp
  808e6e:	89 e5                	mov    %esp,%ebp
  808e70:	83 ec 08             	sub    $0x8,%esp
  808e73:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  808e76:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  808e7a:	52                   	push   %edx
  808e7b:	8d 50 04             	lea    0x4(%eax),%edx
  808e7e:	52                   	push   %edx
  808e7f:	ff 75 0c             	pushl  0xc(%ebp)
  808e82:	50                   	push   %eax
  808e83:	e8 a5 ff ff ff       	call   808e2d <udp_sendto>
}
  808e88:	c9                   	leave  
  808e89:	c3                   	ret    

00808e8a <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808e8a:	55                   	push   %ebp
  808e8b:	89 e5                	mov    %esp,%ebp
  808e8d:	57                   	push   %edi
  808e8e:	56                   	push   %esi
  808e8f:	53                   	push   %ebx
  808e90:	83 ec 0c             	sub    $0xc,%esp
  808e93:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808e96:	8b 75 0c             	mov    0xc(%ebp),%esi
  808e99:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  808e9c:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808ea1:	75 13                	jne    808eb6 <udp_connect+0x2c>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808ea3:	83 ec 04             	sub    $0x4,%esp
  808ea6:	6a 00                	push   $0x0
  808ea8:	53                   	push   %ebx
  808ea9:	53                   	push   %ebx
  808eaa:	e8 39 fd ff ff       	call   808be8 <udp_bind>
    if (err != ERR_OK)
  808eaf:	83 c4 10             	add    $0x10,%esp
  808eb2:	84 c0                	test   %al,%al
  808eb4:	75 3d                	jne    808ef3 <udp_connect+0x69>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  808eb6:	85 f6                	test   %esi,%esi
  808eb8:	74 04                	je     808ebe <udp_connect+0x34>
  808eba:	8b 06                	mov    (%esi),%eax
  808ebc:	eb 05                	jmp    808ec3 <udp_connect+0x39>
  808ebe:	b8 00 00 00 00       	mov    $0x0,%eax
  808ec3:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  808ec6:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  808eca:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808ece:	8b 15 54 b2 b3 00    	mov    0xb3b254,%edx
  808ed4:	89 d0                	mov    %edx,%eax
  808ed6:	eb 07                	jmp    808edf <udp_connect+0x55>
    if (pcb == ipcb) {
  808ed8:	39 d8                	cmp    %ebx,%eax
  808eda:	74 12                	je     808eee <udp_connect+0x64>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808edc:	8b 40 0c             	mov    0xc(%eax),%eax
  808edf:	85 c0                	test   %eax,%eax
  808ee1:	75 f5                	jne    808ed8 <udp_connect+0x4e>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  808ee3:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  808ee6:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  return ERR_OK;
  808eec:	eb 05                	jmp    808ef3 <udp_connect+0x69>

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
  808eee:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
  808ef3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808ef6:	5b                   	pop    %ebx
  808ef7:	5e                   	pop    %esi
  808ef8:	5f                   	pop    %edi
  808ef9:	5d                   	pop    %ebp
  808efa:	c3                   	ret    

00808efb <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  808efb:	55                   	push   %ebp
  808efc:	89 e5                	mov    %esp,%ebp
  808efe:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  808f01:	8b 15 a4 1c 81 00    	mov    0x811ca4,%edx
  808f07:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  808f0a:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  808f10:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  808f14:	5d                   	pop    %ebp
  808f15:	c3                   	ret    

00808f16 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  808f16:	55                   	push   %ebp
  808f17:	89 e5                	mov    %esp,%ebp
  808f19:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  808f1c:	8b 55 0c             	mov    0xc(%ebp),%edx
  808f1f:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  808f22:	8b 55 10             	mov    0x10(%ebp),%edx
  808f25:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  808f28:	5d                   	pop    %ebp
  808f29:	c3                   	ret    

00808f2a <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  808f2a:	55                   	push   %ebp
  808f2b:	89 e5                	mov    %esp,%ebp
  808f2d:	83 ec 08             	sub    $0x8,%esp
  808f30:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  808f33:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808f38:	39 c8                	cmp    %ecx,%eax
  808f3a:	75 1e                	jne    808f5a <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  808f3c:	8b 40 0c             	mov    0xc(%eax),%eax
  808f3f:	a3 54 b2 b3 00       	mov    %eax,0xb3b254
  808f44:	eb 18                	jmp    808f5e <udp_remove+0x34>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  808f46:	8b 50 0c             	mov    0xc(%eax),%edx
  808f49:	39 d1                	cmp    %edx,%ecx
  808f4b:	75 0a                	jne    808f57 <udp_remove+0x2d>
  808f4d:	85 d2                	test   %edx,%edx
  808f4f:	74 06                	je     808f57 <udp_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  808f51:	8b 51 0c             	mov    0xc(%ecx),%edx
  808f54:	89 50 0c             	mov    %edx,0xc(%eax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  808f57:	8b 40 0c             	mov    0xc(%eax),%eax
  808f5a:	85 c0                	test   %eax,%eax
  808f5c:	75 e8                	jne    808f46 <udp_remove+0x1c>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  808f5e:	83 ec 08             	sub    $0x8,%esp
  808f61:	51                   	push   %ecx
  808f62:	6a 01                	push   $0x1
  808f64:	e8 49 b5 ff ff       	call   8044b2 <memp_free>
}
  808f69:	83 c4 10             	add    $0x10,%esp
  808f6c:	c9                   	leave  
  808f6d:	c3                   	ret    

00808f6e <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  808f6e:	55                   	push   %ebp
  808f6f:	89 e5                	mov    %esp,%ebp
  808f71:	53                   	push   %ebx
  808f72:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  808f75:	6a 01                	push   $0x1
  808f77:	e8 e0 b4 ff ff       	call   80445c <memp_malloc>
  808f7c:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  808f7e:	83 c4 10             	add    $0x10,%esp
  808f81:	85 c0                	test   %eax,%eax
  808f83:	74 14                	je     808f99 <udp_new+0x2b>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  808f85:	83 ec 04             	sub    $0x4,%esp
  808f88:	6a 20                	push   $0x20
  808f8a:	6a 00                	push   $0x0
  808f8c:	50                   	push   %eax
  808f8d:	e8 5f 5c 00 00       	call   80ebf1 <memset>
    pcb->ttl = UDP_TTL;
  808f92:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  808f96:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  808f99:	89 d8                	mov    %ebx,%eax
  808f9b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808f9e:	c9                   	leave  
  808f9f:	c3                   	ret    

00808fa0 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  808fa0:	55                   	push   %ebp
  808fa1:	89 e5                	mov    %esp,%ebp
  808fa3:	56                   	push   %esi
  808fa4:	53                   	push   %ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  808fa5:	85 c0                	test   %eax,%eax
  808fa7:	75 17                	jne    808fc0 <free_etharp_q+0x20>
  808fa9:	83 ec 04             	sub    $0x4,%esp
  808fac:	68 a8 17 81 00       	push   $0x8117a8
  808fb1:	68 93 00 00 00       	push   $0x93
  808fb6:	68 96 20 81 00       	push   $0x812096
  808fbb:	e8 8e 54 00 00       	call   80e44e <_panic>
  808fc0:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  808fc2:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  808fc6:	75 17                	jne    808fdf <free_etharp_q+0x3f>
  808fc8:	83 ec 04             	sub    $0x4,%esp
  808fcb:	68 ae 20 81 00       	push   $0x8120ae
  808fd0:	68 94 00 00 00       	push   $0x94
  808fd5:	68 96 20 81 00       	push   $0x812096
  808fda:	e8 6f 54 00 00       	call   80e44e <_panic>
  while (q) {
    r = q;
    q = q->next;
  808fdf:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  808fe1:	8b 43 04             	mov    0x4(%ebx),%eax
  808fe4:	85 c0                	test   %eax,%eax
  808fe6:	75 17                	jne    808fff <free_etharp_q+0x5f>
  808fe8:	83 ec 04             	sub    $0x4,%esp
  808feb:	68 bb 20 81 00       	push   $0x8120bb
  808ff0:	68 98 00 00 00       	push   $0x98
  808ff5:	68 96 20 81 00       	push   $0x812096
  808ffa:	e8 4f 54 00 00       	call   80e44e <_panic>
    pbuf_free(r->p);
  808fff:	83 ec 0c             	sub    $0xc,%esp
  809002:	50                   	push   %eax
  809003:	e8 1d b8 ff ff       	call   804825 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  809008:	83 c4 08             	add    $0x8,%esp
  80900b:	53                   	push   %ebx
  80900c:	6a 0a                	push   $0xa
  80900e:	e8 9f b4 ff ff       	call   8044b2 <memp_free>
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
    r = q;
    q = q->next;
  809013:	89 f3                	mov    %esi,%ebx
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  809015:	83 c4 10             	add    $0x10,%esp
  809018:	85 f6                	test   %esi,%esi
  80901a:	75 c3                	jne    808fdf <free_etharp_q+0x3f>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  80901c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80901f:	5b                   	pop    %ebx
  809020:	5e                   	pop    %esi
  809021:	5d                   	pop    %ebp
  809022:	c3                   	ret    

00809023 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  809023:	55                   	push   %ebp
  809024:	89 e5                	mov    %esp,%ebp
  809026:	57                   	push   %edi
  809027:	56                   	push   %esi
  809028:	53                   	push   %ebx
  809029:	83 ec 1c             	sub    $0x1c,%esp
  80902c:	89 d7                	mov    %edx,%edi
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  80902e:	85 c0                	test   %eax,%eax
  809030:	74 2e                	je     809060 <find_entry+0x3d>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  809032:	0f b6 15 00 4a b3 00 	movzbl 0xb34a00,%edx
  809039:	0f b6 ca             	movzbl %dl,%ecx
  80903c:	6b d9 1c             	imul   $0x1c,%ecx,%ebx
  80903f:	83 bb 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ebx)
  809046:	75 37                	jne    80907f <find_entry+0x5c>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  809048:	8b 8b 24 4a b3 00    	mov    0xb34a24(%ebx),%ecx
  80904e:	39 08                	cmp    %ecx,(%eax)
  809050:	75 4c                	jne    80909e <find_entry+0x7b>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  809052:	89 d0                	mov    %edx,%eax
  809054:	e9 22 02 00 00       	jmp    80927b <find_entry+0x258>
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  809059:	80 f9 0a             	cmp    $0xa,%cl
  80905c:	75 78                	jne    8090d6 <find_entry+0xb3>
  80905e:	eb 5b                	jmp    8090bb <find_entry+0x98>
  809060:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  809064:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  809068:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  80906c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  809070:	ba 00 00 00 00       	mov    $0x0,%edx
  809075:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809079:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  80907d:	eb 3c                	jmp    8090bb <find_entry+0x98>
  80907f:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  809083:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  809087:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  80908b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  80908f:	ba 00 00 00 00       	mov    $0x0,%edx
  809094:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809098:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  80909c:	eb 1d                	jmp    8090bb <find_entry+0x98>
  80909e:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  8090a2:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  8090a6:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  8090aa:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  8090ae:	ba 00 00 00 00       	mov    $0x0,%edx
  8090b3:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  8090b7:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  8090bb:	0f b6 ca             	movzbl %dl,%ecx
  8090be:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  8090c1:	83 b9 30 4a b3 00 00 	cmpl   $0x0,0xb34a30(%ecx)
  8090c8:	75 07                	jne    8090d1 <find_entry+0xae>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  8090ca:	89 d1                	mov    %edx,%ecx
  8090cc:	e9 a3 00 00 00       	jmp    809174 <find_entry+0x151>
  8090d1:	b9 0a 00 00 00       	mov    $0xa,%ecx
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  8090d6:	0f b6 da             	movzbl %dl,%ebx
  8090d9:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8090dc:	8b b6 30 4a b3 00    	mov    0xb34a30(%esi),%esi
  8090e2:	83 fe 01             	cmp    $0x1,%esi
  8090e5:	75 55                	jne    80913c <find_entry+0x119>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8090e7:	85 c0                	test   %eax,%eax
  8090e9:	74 1a                	je     809105 <find_entry+0xe2>
  8090eb:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8090ee:	8b b6 24 4a b3 00    	mov    0xb34a24(%esi),%esi
  8090f4:	39 30                	cmp    %esi,(%eax)
  8090f6:	75 0d                	jne    809105 <find_entry+0xe2>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  8090f8:	88 15 00 4a b3 00    	mov    %dl,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  8090fe:	89 d0                	mov    %edx,%eax
  809100:	e9 76 01 00 00       	jmp    80927b <find_entry+0x258>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  809105:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  809108:	83 be 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%esi)
  80910f:	74 14                	je     809125 <find_entry+0x102>
        if (arp_table[i].ctime >= age_queue) {
  809111:	0f b6 9e 34 4a b3 00 	movzbl 0xb34a34(%esi),%ebx
  809118:	3a 5d e7             	cmp    -0x19(%ebp),%bl
  80911b:	72 57                	jb     809174 <find_entry+0x151>
          old_queue = i;
  80911d:	88 55 e4             	mov    %dl,-0x1c(%ebp)
          age_queue = arp_table[i].ctime;
  809120:	88 5d e7             	mov    %bl,-0x19(%ebp)
  809123:	eb 4f                	jmp    809174 <find_entry+0x151>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  809125:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  809128:	0f b6 9b 34 4a b3 00 	movzbl 0xb34a34(%ebx),%ebx
  80912f:	3a 5d e3             	cmp    -0x1d(%ebp),%bl
  809132:	72 40                	jb     809174 <find_entry+0x151>
          old_pending = i;
  809134:	88 55 e2             	mov    %dl,-0x1e(%ebp)
          age_pending = arp_table[i].ctime;
  809137:	88 5d e3             	mov    %bl,-0x1d(%ebp)
  80913a:	eb 38                	jmp    809174 <find_entry+0x151>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80913c:	83 fe 02             	cmp    $0x2,%esi
  80913f:	75 33                	jne    809174 <find_entry+0x151>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809141:	85 c0                	test   %eax,%eax
  809143:	74 1a                	je     80915f <find_entry+0x13c>
  809145:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  809148:	8b b6 24 4a b3 00    	mov    0xb34a24(%esi),%esi
  80914e:	39 30                	cmp    %esi,(%eax)
  809150:	75 0d                	jne    80915f <find_entry+0x13c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  809152:	88 15 00 4a b3 00    	mov    %dl,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  809158:	89 d0                	mov    %edx,%eax
  80915a:	e9 1c 01 00 00       	jmp    80927b <find_entry+0x258>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  80915f:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  809162:	0f b6 9b 34 4a b3 00 	movzbl 0xb34a34(%ebx),%ebx
  809169:	3a 5d e6             	cmp    -0x1a(%ebp),%bl
  80916c:	72 06                	jb     809174 <find_entry+0x151>
        old_stable = i;
  80916e:	88 55 e5             	mov    %dl,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  809171:	88 5d e6             	mov    %bl,-0x1a(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809174:	83 c2 01             	add    $0x1,%edx
  809177:	80 fa 09             	cmp    $0x9,%dl
  80917a:	0f 86 d9 fe ff ff    	jbe    809059 <find_entry+0x36>
  809180:	89 fa                	mov    %edi,%edx
  809182:	89 c3                	mov    %eax,%ebx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  809184:	80 f9 0a             	cmp    $0xa,%cl
  809187:	75 0e                	jne    809197 <find_entry+0x174>
  809189:	f6 c2 01             	test   $0x1,%dl
  80918c:	0f 85 de 00 00 00    	jne    809270 <find_entry+0x24d>
  809192:	e9 bd 00 00 00       	jmp    809254 <find_entry+0x231>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809197:	f6 c2 02             	test   $0x2,%dl
  80919a:	0f 85 bb 00 00 00    	jne    80925b <find_entry+0x238>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  8091a0:	89 ce                	mov    %ecx,%esi
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  8091a2:	80 f9 09             	cmp    $0x9,%cl
  8091a5:	7e 5f                	jle    809206 <find_entry+0x1e3>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  8091a7:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  8091ab:	3c 09                	cmp    $0x9,%al
  8091ad:	7f 28                	jg     8091d7 <find_entry+0x1b4>
    /* recycle oldest stable*/
    i = old_stable;
  8091af:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  8091b1:	0f b6 c0             	movzbl %al,%eax
  8091b4:	6b c0 1c             	imul   $0x1c,%eax,%eax
  8091b7:	83 b8 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%eax)
  8091be:	74 46                	je     809206 <find_entry+0x1e3>
  8091c0:	83 ec 04             	sub    $0x4,%esp
  8091c3:	68 c8 20 81 00       	push   $0x8120c8
  8091c8:	68 75 01 00 00       	push   $0x175
  8091cd:	68 96 20 81 00       	push   $0x812096
  8091d2:	e8 77 52 00 00       	call   80e44e <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  8091d7:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
    /* recycle oldest pending */
    i = old_pending;
  8091db:	89 c6                	mov    %eax,%esi
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  8091dd:	3c 09                	cmp    $0x9,%al
  8091df:	7e 25                	jle    809206 <find_entry+0x1e3>
    /* recycle oldest pending */
    i = old_pending;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  8091e1:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8091e5:	3c 09                	cmp    $0x9,%al
  8091e7:	7f 79                	jg     809262 <find_entry+0x23f>
    /* recycle oldest pending */
    i = old_queue;
  8091e9:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  8091eb:	0f b6 f8             	movzbl %al,%edi
  8091ee:	6b ff 1c             	imul   $0x1c,%edi,%edi
  8091f1:	8b 87 20 4a b3 00    	mov    0xb34a20(%edi),%eax
  8091f7:	e8 a4 fd ff ff       	call   808fa0 <free_etharp_q>
    arp_table[i].q = NULL;
  8091fc:	c7 87 20 4a b3 00 00 	movl   $0x0,0xb34a20(%edi)
  809203:	00 00 00 
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  809206:	89 f0                	mov    %esi,%eax
  809208:	3c 09                	cmp    $0x9,%al
  80920a:	76 17                	jbe    809223 <find_entry+0x200>
  80920c:	83 ec 04             	sub    $0x4,%esp
  80920f:	68 df 20 81 00       	push   $0x8120df
  809214:	68 8b 01 00 00       	push   $0x18b
  809219:	68 96 20 81 00       	push   $0x812096
  80921e:	e8 2b 52 00 00       	call   80e44e <_panic>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  809223:	89 f0                	mov    %esi,%eax
  809225:	0f b6 c0             	movzbl %al,%eax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  809228:	6b d0 1c             	imul   $0x1c,%eax,%edx
  80922b:	c7 82 30 4a b3 00 00 	movl   $0x0,0xb34a30(%edx)
  809232:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  809235:	85 db                	test   %ebx,%ebx
  809237:	74 08                	je     809241 <find_entry+0x21e>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  809239:	8b 0b                	mov    (%ebx),%ecx
  80923b:	89 8a 24 4a b3 00    	mov    %ecx,0xb34a24(%edx)
  }
  arp_table[i].ctime = 0;
  809241:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809244:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  80924b:	89 f0                	mov    %esi,%eax
  80924d:	a2 00 4a b3 00       	mov    %al,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  809252:	eb 27                	jmp    80927b <find_entry+0x258>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809254:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809259:	eb 20                	jmp    80927b <find_entry+0x258>
  80925b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809260:	eb 19                	jmp    80927b <find_entry+0x258>
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  809262:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809267:	eb 12                	jmp    80927b <find_entry+0x258>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809269:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80926e:	eb 0b                	jmp    80927b <find_entry+0x258>
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809270:	f6 c2 02             	test   $0x2,%dl
  809273:	0f 84 2e ff ff ff    	je     8091a7 <find_entry+0x184>
  809279:	eb ee                	jmp    809269 <find_entry+0x246>
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  80927b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80927e:	5b                   	pop    %ebx
  80927f:	5e                   	pop    %esi
  809280:	5f                   	pop    %edi
  809281:	5d                   	pop    %ebp
  809282:	c3                   	ret    

00809283 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  809283:	55                   	push   %ebp
  809284:	89 e5                	mov    %esp,%ebp
  809286:	57                   	push   %edi
  809287:	56                   	push   %esi
  809288:	53                   	push   %ebx
  809289:	83 ec 1c             	sub    $0x1c,%esp
  80928c:	89 c6                	mov    %eax,%esi
  80928e:	89 55 e0             	mov    %edx,-0x20(%ebp)
  809291:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  809294:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809297:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  80929b:	74 17                	je     8092b4 <etharp_send_ip+0x31>
  80929d:	83 ec 04             	sub    $0x4,%esp
  8092a0:	68 0c 21 81 00       	push   $0x81210c
  8092a5:	68 b3 01 00 00       	push   $0x1b3
  8092aa:	68 96 20 81 00       	push   $0x812096
  8092af:	e8 9a 51 00 00       	call   80e44e <_panic>
  8092b4:	ba 06 00 00 00       	mov    $0x6,%edx
  8092b9:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  8092bc:	83 ea 01             	sub    $0x1,%edx
    ethhdr->dest.addr[k] = dst->addr[k];
  8092bf:	0f b6 c2             	movzbl %dl,%eax
  8092c2:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  8092c6:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  8092c9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8092cc:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  8092d0:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  8092d4:	84 d2                	test   %dl,%dl
  8092d6:	75 e4                	jne    8092bc <etharp_send_ip+0x39>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  8092d8:	83 ec 0c             	sub    $0xc,%esp
  8092db:	68 00 08 00 00       	push   $0x800
  8092e0:	e8 f1 e3 ff ff       	call   8076d6 <htons>
  8092e5:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  8092e9:	83 c4 08             	add    $0x8,%esp
  8092ec:	ff 75 e0             	pushl  -0x20(%ebp)
  8092ef:	56                   	push   %esi
  8092f0:	ff 56 18             	call   *0x18(%esi)
}
  8092f3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8092f6:	5b                   	pop    %ebx
  8092f7:	5e                   	pop    %esi
  8092f8:	5f                   	pop    %edi
  8092f9:	5d                   	pop    %ebp
  8092fa:	c3                   	ret    

008092fb <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  8092fb:	55                   	push   %ebp
  8092fc:	89 e5                	mov    %esp,%ebp
  8092fe:	57                   	push   %edi
  8092ff:	56                   	push   %esi
  809300:	53                   	push   %ebx
  809301:	83 ec 1c             	sub    $0x1c,%esp
  809304:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809307:	89 cb                	mov    %ecx,%ebx
  809309:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80930c:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80930f:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809313:	74 17                	je     80932c <update_arp_entry+0x31>
  809315:	83 ec 04             	sub    $0x4,%esp
  809318:	68 50 21 81 00       	push   $0x812150
  80931d:	68 d9 01 00 00       	push   $0x1d9
  809322:	68 96 20 81 00       	push   $0x812096
  809327:	e8 22 51 00 00       	call   80e44e <_panic>
  80932c:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80932e:	85 d2                	test   %edx,%edx
  809330:	0f 84 ed 00 00 00    	je     809423 <update_arp_entry+0x128>
  809336:	83 3a 00             	cmpl   $0x0,(%edx)
  809339:	0f 84 eb 00 00 00    	je     80942a <update_arp_entry+0x12f>
      ip_addr_isbroadcast(ipaddr, netif) ||
  80933f:	83 ec 08             	sub    $0x8,%esp
  809342:	ff 75 e4             	pushl  -0x1c(%ebp)
  809345:	52                   	push   %edx
  809346:	e8 83 d1 ff ff       	call   8064ce <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80934b:	83 c4 10             	add    $0x10,%esp
  80934e:	84 c0                	test   %al,%al
  809350:	0f 85 db 00 00 00    	jne    809431 <update_arp_entry+0x136>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  809356:	8b 3e                	mov    (%esi),%edi
  809358:	83 ec 0c             	sub    $0xc,%esp
  80935b:	68 00 00 00 f0       	push   $0xf0000000
  809360:	e8 ac e5 ff ff       	call   807911 <ntohl>
  809365:	21 c7                	and    %eax,%edi
  809367:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80936e:	e8 9e e5 ff ff       	call   807911 <ntohl>
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  809373:	83 c4 10             	add    $0x10,%esp
  809376:	39 c7                	cmp    %eax,%edi
  809378:	0f 84 ba 00 00 00    	je     809438 <update_arp_entry+0x13d>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  80937e:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  809382:	89 f0                	mov    %esi,%eax
  809384:	e8 9a fc ff ff       	call   809023 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  809389:	84 c0                	test   %al,%al
  80938b:	0f 88 ac 00 00 00    	js     80943d <update_arp_entry+0x142>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  809391:	0f be f0             	movsbl %al,%esi
  809394:	6b c6 1c             	imul   $0x1c,%esi,%eax
  809397:	c7 80 30 4a b3 00 02 	movl   $0x2,0xb34a30(%eax)
  80939e:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  8093a1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8093a4:	89 88 38 4a b3 00    	mov    %ecx,0xb34a38(%eax)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  8093aa:	ba 06 00 00 00       	mov    $0x6,%edx
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8093af:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8093b2:	05 20 4a b3 00       	add    $0xb34a20,%eax
  8093b7:	89 d7                	mov    %edx,%edi

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
  8093b9:	83 ef 01             	sub    $0x1,%edi
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8093bc:	89 f9                	mov    %edi,%ecx
  8093be:	0f b6 c9             	movzbl %cl,%ecx
  8093c1:	0f b6 14 0b          	movzbl (%ebx,%ecx,1),%edx
  8093c5:	88 54 01 08          	mov    %dl,0x8(%ecx,%eax,1)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  8093c9:	89 f9                	mov    %edi,%ecx
  8093cb:	84 c9                	test   %cl,%cl
  8093cd:	75 ea                	jne    8093b9 <update_arp_entry+0xbe>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  8093cf:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8093d2:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  8093d9:	89 c6                	mov    %eax,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  8093db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8093de:	83 c0 25             	add    $0x25,%eax
  8093e1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  8093e4:	eb 31                	jmp    809417 <update_arp_entry+0x11c>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  8093e6:	8b 10                	mov    (%eax),%edx
  8093e8:	89 96 20 4a b3 00    	mov    %edx,0xb34a20(%esi)
    /* get the packet pointer */
    p = q->p;
  8093ee:	8b 78 04             	mov    0x4(%eax),%edi
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  8093f1:	83 ec 08             	sub    $0x8,%esp
  8093f4:	50                   	push   %eax
  8093f5:	6a 0a                	push   $0xa
  8093f7:	e8 b6 b0 ff ff       	call   8044b2 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  8093fc:	89 1c 24             	mov    %ebx,(%esp)
  8093ff:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809402:	89 fa                	mov    %edi,%edx
  809404:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809407:	e8 77 fe ff ff       	call   809283 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  80940c:	89 3c 24             	mov    %edi,(%esp)
  80940f:	e8 11 b4 ff ff       	call   804825 <pbuf_free>
  809414:	83 c4 10             	add    $0x10,%esp
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809417:	8b 86 20 4a b3 00    	mov    0xb34a20(%esi),%eax
  80941d:	85 c0                	test   %eax,%eax
  80941f:	75 c5                	jne    8093e6 <update_arp_entry+0xeb>
  809421:	eb 1a                	jmp    80943d <update_arp_entry+0x142>
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  809423:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809428:	eb 13                	jmp    80943d <update_arp_entry+0x142>
  80942a:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80942f:	eb 0c                	jmp    80943d <update_arp_entry+0x142>
  809431:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809436:	eb 05                	jmp    80943d <update_arp_entry+0x142>
  809438:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  80943d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809440:	5b                   	pop    %ebx
  809441:	5e                   	pop    %esi
  809442:	5f                   	pop    %edi
  809443:	5d                   	pop    %ebp
  809444:	c3                   	ret    

00809445 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  809445:	55                   	push   %ebp
  809446:	89 e5                	mov    %esp,%ebp
  809448:	57                   	push   %edi
  809449:	56                   	push   %esi
  80944a:	53                   	push   %ebx
  80944b:	83 ec 0c             	sub    $0xc,%esp
  80944e:	bb 34 4a b3 00       	mov    $0xb34a34,%ebx
  809453:	bf 4c 4b b3 00       	mov    $0xb34b4c,%edi
  809458:	89 de                	mov    %ebx,%esi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80945a:	0f b6 03             	movzbl (%ebx),%eax
  80945d:	83 c0 01             	add    $0x1,%eax
  809460:	88 03                	mov    %al,(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  809462:	8b 53 fc             	mov    -0x4(%ebx),%edx
  809465:	3c ef                	cmp    $0xef,%al
  809467:	76 05                	jbe    80946e <etharp_tmr+0x29>
  809469:	83 fa 02             	cmp    $0x2,%edx
  80946c:	74 09                	je     809477 <etharp_tmr+0x32>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  80946e:	3c 01                	cmp    $0x1,%al
  809470:	76 1f                	jbe    809491 <etharp_tmr+0x4c>
  809472:	83 fa 01             	cmp    $0x1,%edx
  809475:	75 1a                	jne    809491 <etharp_tmr+0x4c>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  809477:	8b 46 ec             	mov    -0x14(%esi),%eax
  80947a:	85 c0                	test   %eax,%eax
  80947c:	74 0c                	je     80948a <etharp_tmr+0x45>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  80947e:	e8 1d fb ff ff       	call   808fa0 <free_etharp_q>
        arp_table[i].q = NULL;
  809483:	c7 46 ec 00 00 00 00 	movl   $0x0,-0x14(%esi)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  80948a:	c7 46 fc 00 00 00 00 	movl   $0x0,-0x4(%esi)
  809491:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809494:	39 fb                	cmp    %edi,%ebx
  809496:	75 c0                	jne    809458 <etharp_tmr+0x13>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  809498:	83 c4 0c             	add    $0xc,%esp
  80949b:	5b                   	pop    %ebx
  80949c:	5e                   	pop    %esi
  80949d:	5f                   	pop    %edi
  80949e:	5d                   	pop    %ebp
  80949f:	c3                   	ret    

008094a0 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  8094a0:	55                   	push   %ebp
  8094a1:	89 e5                	mov    %esp,%ebp
  8094a3:	53                   	push   %ebx
  8094a4:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  8094a7:	ba 02 00 00 00       	mov    $0x2,%edx
  8094ac:	8b 45 0c             	mov    0xc(%ebp),%eax
  8094af:	e8 6f fb ff ff       	call   809023 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  8094b4:	84 c0                	test   %al,%al
  8094b6:	78 29                	js     8094e1 <etharp_find_addr+0x41>
  8094b8:	0f be d0             	movsbl %al,%edx
  8094bb:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  8094be:	83 b9 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ecx)
  8094c5:	75 21                	jne    8094e8 <etharp_find_addr+0x48>
      *eth_ret = &arp_table[i].ethaddr;
  8094c7:	89 ca                	mov    %ecx,%edx
  8094c9:	8d 99 28 4a b3 00    	lea    0xb34a28(%ecx),%ebx
  8094cf:	8b 4d 10             	mov    0x10(%ebp),%ecx
  8094d2:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  8094d4:	81 c2 24 4a b3 00    	add    $0xb34a24,%edx
  8094da:	8b 4d 14             	mov    0x14(%ebp),%ecx
  8094dd:	89 11                	mov    %edx,(%ecx)
      return i;
  8094df:	eb 0c                	jmp    8094ed <etharp_find_addr+0x4d>
  }
  return -1;
  8094e1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8094e6:	eb 05                	jmp    8094ed <etharp_find_addr+0x4d>
  8094e8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8094ed:	83 c4 04             	add    $0x4,%esp
  8094f0:	5b                   	pop    %ebx
  8094f1:	5d                   	pop    %ebp
  8094f2:	c3                   	ret    

008094f3 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  8094f3:	55                   	push   %ebp
  8094f4:	89 e5                	mov    %esp,%ebp
  8094f6:	83 ec 08             	sub    $0x8,%esp
  8094f9:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8094fc:	85 c0                	test   %eax,%eax
  8094fe:	75 17                	jne    809517 <etharp_ip_input+0x24>
  809500:	83 ec 04             	sub    $0x4,%esp
  809503:	68 02 14 81 00       	push   $0x811402
  809508:	68 48 02 00 00       	push   $0x248
  80950d:	68 96 20 81 00       	push   $0x812096
  809512:	e8 37 4f 00 00       	call   80e44e <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  809517:	8b 55 0c             	mov    0xc(%ebp),%edx
  80951a:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80951d:	8b 4a 1c             	mov    0x1c(%edx),%ecx
  809520:	33 48 04             	xor    0x4(%eax),%ecx
  809523:	85 48 08             	test   %ecx,0x8(%eax)
  809526:	75 13                	jne    80953b <etharp_ip_input+0x48>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  809528:	8d 4a 06             	lea    0x6(%edx),%ecx
  80952b:	83 c2 1c             	add    $0x1c,%edx
  80952e:	83 ec 0c             	sub    $0xc,%esp
  809531:	6a 00                	push   $0x0
  809533:	e8 c3 fd ff ff       	call   8092fb <update_arp_entry>
  809538:	83 c4 10             	add    $0x10,%esp
}
  80953b:	c9                   	leave  
  80953c:	c3                   	ret    

0080953d <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  80953d:	55                   	push   %ebp
  80953e:	89 e5                	mov    %esp,%ebp
  809540:	57                   	push   %edi
  809541:	56                   	push   %esi
  809542:	53                   	push   %ebx
  809543:	83 ec 1c             	sub    $0x1c,%esp
  809546:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809549:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80954d:	75 17                	jne    809566 <etharp_arp_input+0x29>
  80954f:	83 ec 04             	sub    $0x4,%esp
  809552:	68 02 14 81 00       	push   $0x811402
  809557:	68 75 02 00 00       	push   $0x275
  80955c:	68 96 20 81 00       	push   $0x812096
  809561:	e8 e8 4e 00 00       	call   80e44e <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  809566:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  80956b:	77 11                	ja     80957e <etharp_arp_input+0x41>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80956d:	83 ec 0c             	sub    $0xc,%esp
  809570:	53                   	push   %ebx
  809571:	e8 af b2 ff ff       	call   804825 <pbuf_free>
    return;
  809576:	83 c4 10             	add    $0x10,%esp
  809579:	e9 b4 01 00 00       	jmp    809732 <etharp_arp_input+0x1f5>
  }

  hdr = p->payload;
  80957e:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809581:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  809585:	83 ec 0c             	sub    $0xc,%esp
  809588:	6a 01                	push   $0x1
  80958a:	e8 47 e1 ff ff       	call   8076d6 <htons>
  80958f:	83 c4 10             	add    $0x10,%esp
  809592:	66 39 c7             	cmp    %ax,%di
  809595:	75 4b                	jne    8095e2 <etharp_arp_input+0xa5>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809597:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  80959b:	83 ec 0c             	sub    $0xc,%esp
  80959e:	68 04 06 00 00       	push   $0x604
  8095a3:	e8 2e e1 ff ff       	call   8076d6 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8095a8:	83 c4 10             	add    $0x10,%esp
  8095ab:	66 39 c7             	cmp    %ax,%di
  8095ae:	75 32                	jne    8095e2 <etharp_arp_input+0xa5>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8095b0:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  8095b4:	83 ec 0c             	sub    $0xc,%esp
  8095b7:	68 00 08 00 00       	push   $0x800
  8095bc:	e8 15 e1 ff ff       	call   8076d6 <htons>

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8095c1:	83 c4 10             	add    $0x10,%esp
  8095c4:	66 39 c7             	cmp    %ax,%di
  8095c7:	75 19                	jne    8095e2 <etharp_arp_input+0xa5>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  8095c9:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  8095cd:	83 ec 0c             	sub    $0xc,%esp
  8095d0:	68 06 08 00 00       	push   $0x806
  8095d5:	e8 fc e0 ff ff       	call   8076d6 <htons>
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8095da:	83 c4 10             	add    $0x10,%esp
  8095dd:	66 39 c7             	cmp    %ax,%di
  8095e0:	74 11                	je     8095f3 <etharp_arp_input+0xb6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8095e2:	83 ec 0c             	sub    $0xc,%esp
  8095e5:	53                   	push   %ebx
  8095e6:	e8 3a b2 ff ff       	call   804825 <pbuf_free>
    return;
  8095eb:	83 c4 10             	add    $0x10,%esp
  8095ee:	e9 3f 01 00 00       	jmp    809732 <etharp_arp_input+0x1f5>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  8095f3:	83 ec 04             	sub    $0x4,%esp
  8095f6:	6a 04                	push   $0x4
  8095f8:	8d 46 1c             	lea    0x1c(%esi),%eax
  8095fb:	50                   	push   %eax
  8095fc:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8095ff:	50                   	push   %eax
  809600:	e8 a1 56 00 00       	call   80eca6 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  809605:	83 c4 0c             	add    $0xc,%esp
  809608:	6a 04                	push   $0x4
  80960a:	8d 46 26             	lea    0x26(%esi),%eax
  80960d:	50                   	push   %eax
  80960e:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809611:	50                   	push   %eax
  809612:	e8 8f 56 00 00       	call   80eca6 <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  809617:	8b 45 08             	mov    0x8(%ebp),%eax
  80961a:	8b 40 04             	mov    0x4(%eax),%eax
  80961d:	83 c4 10             	add    $0x10,%esp
  809620:	85 c0                	test   %eax,%eax
  809622:	74 3c                	je     809660 <etharp_arp_input+0x123>
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  }

  /* ARP message directed to us? */
  if (for_us) {
  809624:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  809627:	75 37                	jne    809660 <etharp_arp_input+0x123>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  809629:	8d 4e 16             	lea    0x16(%esi),%ecx
  80962c:	83 ec 0c             	sub    $0xc,%esp
  80962f:	6a 01                	push   $0x1
  809631:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809634:	8b 45 08             	mov    0x8(%ebp),%eax
  809637:	e8 bf fc ff ff       	call   8092fb <update_arp_entry>
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  80963c:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  809640:	89 04 24             	mov    %eax,(%esp)
  809643:	e8 8e e0 ff ff       	call   8076d6 <htons>
  809648:	83 c4 10             	add    $0x10,%esp
  80964b:	66 83 f8 01          	cmp    $0x1,%ax
  80964f:	74 40                	je     809691 <etharp_arp_input+0x154>
  809651:	66 83 f8 02          	cmp    $0x2,%ax
  809655:	0f 84 b9 00 00 00    	je     809714 <etharp_arp_input+0x1d7>
  80965b:	e9 c6 00 00 00       	jmp    809726 <etharp_arp_input+0x1e9>
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  809660:	8d 4e 16             	lea    0x16(%esi),%ecx
  809663:	83 ec 0c             	sub    $0xc,%esp
  809666:	6a 00                	push   $0x0
  809668:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80966b:	8b 45 08             	mov    0x8(%ebp),%eax
  80966e:	e8 88 fc ff ff       	call   8092fb <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  809673:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  809677:	89 04 24             	mov    %eax,(%esp)
  80967a:	e8 57 e0 ff ff       	call   8076d6 <htons>
  80967f:	83 c4 10             	add    $0x10,%esp
  809682:	66 83 f8 02          	cmp    $0x2,%ax
  809686:	0f 85 9a 00 00 00    	jne    809726 <etharp_arp_input+0x1e9>
  80968c:	e9 83 00 00 00       	jmp    809714 <etharp_arp_input+0x1d7>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  809691:	83 ec 0c             	sub    $0xc,%esp
  809694:	6a 02                	push   $0x2
  809696:	e8 3b e0 ff ff       	call   8076d6 <htons>
  80969b:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  80969f:	8b 46 1c             	mov    0x1c(%esi),%eax
  8096a2:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  8096a5:	8b 45 08             	mov    0x8(%ebp),%eax
  8096a8:	8b 40 04             	mov    0x4(%eax),%eax
  8096ab:	89 46 1c             	mov    %eax,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8096ae:	83 c4 10             	add    $0x10,%esp
  8096b1:	ba 06 00 00 00       	mov    $0x6,%edx
  8096b6:	8b 45 08             	mov    0x8(%ebp),%eax
  8096b9:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  8096bd:	74 17                	je     8096d6 <etharp_arp_input+0x199>
  8096bf:	83 ec 04             	sub    $0x4,%esp
  8096c2:	68 0c 21 81 00       	push   $0x81210c
  8096c7:	68 c7 02 00 00       	push   $0x2c7
  8096cc:	68 96 20 81 00       	push   $0x812096
  8096d1:	e8 78 4d 00 00       	call   80e44e <_panic>
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  8096d6:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  8096d9:	0f b6 c2             	movzbl %dl,%eax
  8096dc:	0f b6 4c 06 16       	movzbl 0x16(%esi,%eax,1),%ecx
  8096e1:	88 4c 06 20          	mov    %cl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  8096e5:	88 0c 06             	mov    %cl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  8096e8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8096eb:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  8096ef:	88 4c 06 16          	mov    %cl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  8096f3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8096f6:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  8096fa:	88 4c 06 06          	mov    %cl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  8096fe:	84 d2                	test   %dl,%dl
  809700:	75 d4                	jne    8096d6 <etharp_arp_input+0x199>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  809702:	83 ec 08             	sub    $0x8,%esp
  809705:	53                   	push   %ebx
  809706:	ff 75 08             	pushl  0x8(%ebp)
  809709:	8b 45 08             	mov    0x8(%ebp),%eax
  80970c:	ff 50 18             	call   *0x18(%eax)
  80970f:	83 c4 10             	add    $0x10,%esp
  809712:	eb 12                	jmp    809726 <etharp_arp_input+0x1e9>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  809714:	83 ec 08             	sub    $0x8,%esp
  809717:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80971a:	50                   	push   %eax
  80971b:	ff 75 08             	pushl  0x8(%ebp)
  80971e:	e8 d6 a1 ff ff       	call   8038f9 <dhcp_arp_reply>
#endif
    break;
  809723:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  809726:	83 ec 0c             	sub    $0xc,%esp
  809729:	53                   	push   %ebx
  80972a:	e8 f6 b0 ff ff       	call   804825 <pbuf_free>
  80972f:	83 c4 10             	add    $0x10,%esp
}
  809732:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809735:	5b                   	pop    %ebx
  809736:	5e                   	pop    %esi
  809737:	5f                   	pop    %edi
  809738:	5d                   	pop    %ebp
  809739:	c3                   	ret    

0080973a <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80973a:	55                   	push   %ebp
  80973b:	89 e5                	mov    %esp,%ebp
  80973d:	57                   	push   %edi
  80973e:	56                   	push   %esi
  80973f:	53                   	push   %ebx
  809740:	83 ec 10             	sub    $0x10,%esp
  809743:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  809746:	6a 00                	push   $0x0
  809748:	6a 2a                	push   $0x2a
  80974a:	6a 02                	push   $0x2
  80974c:	e8 9a b1 ff ff       	call   8048eb <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  809751:	83 c4 10             	add    $0x10,%esp
  809754:	85 c0                	test   %eax,%eax
  809756:	0f 84 ec 00 00 00    	je     809848 <etharp_request+0x10e>
  80975c:	89 c7                	mov    %eax,%edi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80975e:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  809763:	77 17                	ja     80977c <etharp_request+0x42>
  809765:	83 ec 04             	sub    $0x4,%esp
  809768:	68 78 21 81 00       	push   $0x812178
  80976d:	68 1c 04 00 00       	push   $0x41c
  809772:	68 96 20 81 00       	push   $0x812096
  809777:	e8 d2 4c 00 00       	call   80e44e <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  80977c:	8b 58 04             	mov    0x4(%eax),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  80977f:	83 ec 0c             	sub    $0xc,%esp
  809782:	6a 01                	push   $0x1
  809784:	e8 4d df ff ff       	call   8076d6 <htons>
  809789:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80978d:	83 c4 10             	add    $0x10,%esp
  809790:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  809794:	74 17                	je     8097ad <etharp_request+0x73>
  809796:	83 ec 04             	sub    $0x4,%esp
  809799:	68 0c 21 81 00       	push   $0x81210c
  80979e:	68 23 04 00 00       	push   $0x423
  8097a3:	68 96 20 81 00       	push   $0x812096
  8097a8:	e8 a1 4c 00 00       	call   80e44e <_panic>
  8097ad:	ba 06 00 00 00       	mov    $0x6,%edx
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  8097b2:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  8097b5:	0f b6 c2             	movzbl %dl,%eax
  8097b8:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  8097bd:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  8097c1:	0f b6 88 f8 21 81 00 	movzbl 0x8121f8(%eax),%ecx
  8097c8:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  8097cc:	0f b6 88 00 22 81 00 	movzbl 0x812200(%eax),%ecx
  8097d3:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  8097d6:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  8097db:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  8097df:	84 d2                	test   %dl,%dl
  8097e1:	75 cf                	jne    8097b2 <etharp_request+0x78>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  8097e3:	8b 46 04             	mov    0x4(%esi),%eax
  8097e6:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  8097e9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8097ec:	8b 00                	mov    (%eax),%eax
  8097ee:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  8097f1:	83 ec 0c             	sub    $0xc,%esp
  8097f4:	6a 01                	push   $0x1
  8097f6:	e8 db de ff ff       	call   8076d6 <htons>
  8097fb:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  8097ff:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809806:	e8 cb de ff ff       	call   8076d6 <htons>
  80980b:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80980f:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809816:	e8 bb de ff ff       	call   8076d6 <htons>
  80981b:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80981f:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809826:	e8 ab de ff ff       	call   8076d6 <htons>
  80982b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  80982f:	83 c4 08             	add    $0x8,%esp
  809832:	57                   	push   %edi
  809833:	56                   	push   %esi
  809834:	ff 56 18             	call   *0x18(%esi)
  809837:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  809839:	89 3c 24             	mov    %edi,(%esp)
  80983c:	e8 e4 af ff ff       	call   804825 <pbuf_free>
  809841:	83 c4 10             	add    $0x10,%esp
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
  809844:	89 d8                	mov    %ebx,%eax
  809846:	eb 05                	jmp    80984d <etharp_request+0x113>
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  809848:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80984d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809850:	5b                   	pop    %ebx
  809851:	5e                   	pop    %esi
  809852:	5f                   	pop    %edi
  809853:	5d                   	pop    %ebp
  809854:	c3                   	ret    

00809855 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  809855:	55                   	push   %ebp
  809856:	89 e5                	mov    %esp,%ebp
  809858:	57                   	push   %edi
  809859:	56                   	push   %esi
  80985a:	53                   	push   %ebx
  80985b:	83 ec 24             	sub    $0x24,%esp
  80985e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  809861:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  809864:	ff 75 08             	pushl  0x8(%ebp)
  809867:	53                   	push   %ebx
  809868:	e8 61 cc ff ff       	call   8064ce <ip_addr_isbroadcast>
  80986d:	83 c4 10             	add    $0x10,%esp
  809870:	84 c0                	test   %al,%al
  809872:	0f 85 a9 01 00 00    	jne    809a21 <etharp_query+0x1cc>
      ip_addr_ismulticast(ipaddr) ||
  809878:	8b 33                	mov    (%ebx),%esi
  80987a:	83 ec 0c             	sub    $0xc,%esp
  80987d:	68 00 00 00 f0       	push   $0xf0000000
  809882:	e8 8a e0 ff ff       	call   807911 <ntohl>
  809887:	21 c6                	and    %eax,%esi
  809889:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809890:	e8 7c e0 ff ff       	call   807911 <ntohl>
  809895:	83 c4 10             	add    $0x10,%esp
  809898:	85 db                	test   %ebx,%ebx
  80989a:	0f 84 88 01 00 00    	je     809a28 <etharp_query+0x1d3>
  8098a0:	39 c6                	cmp    %eax,%esi
  8098a2:	0f 84 80 01 00 00    	je     809a28 <etharp_query+0x1d3>
      ip_addr_isany(ipaddr)) {
  8098a8:	83 3b 00             	cmpl   $0x0,(%ebx)
  8098ab:	0f 84 7e 01 00 00    	je     809a2f <etharp_query+0x1da>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  8098b1:	ba 01 00 00 00       	mov    $0x1,%edx
  8098b6:	89 d8                	mov    %ebx,%eax
  8098b8:	e8 66 f7 ff ff       	call   809023 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  8098bd:	84 c0                	test   %al,%al
  8098bf:	0f 88 c4 01 00 00    	js     809a89 <etharp_query+0x234>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  8098c5:	0f be f0             	movsbl %al,%esi
  8098c8:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8098cb:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  8098d1:	85 c0                	test   %eax,%eax
  8098d3:	75 0f                	jne    8098e4 <etharp_query+0x8f>
    arp_table[i].state = ETHARP_STATE_PENDING;
  8098d5:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8098d8:	c7 80 30 4a b3 00 01 	movl   $0x1,0xb34a30(%eax)
  8098df:	00 00 00 
  8098e2:	eb 28                	jmp    80990c <etharp_query+0xb7>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  8098e4:	8d 50 ff             	lea    -0x1(%eax),%edx
  8098e7:	83 fa 01             	cmp    $0x1,%edx
  8098ea:	76 17                	jbe    809903 <etharp_query+0xae>
  8098ec:	83 ec 04             	sub    $0x4,%esp
  8098ef:	68 ac 21 81 00       	push   $0x8121ac
  8098f4:	68 92 03 00 00       	push   $0x392
  8098f9:	68 96 20 81 00       	push   $0x812096
  8098fe:	e8 4b 4b 00 00       	call   80e44e <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809903:	85 ff                	test   %edi,%edi
  809905:	74 05                	je     80990c <etharp_query+0xb7>
  809907:	83 f8 01             	cmp    $0x1,%eax
  80990a:	75 13                	jne    80991f <etharp_query+0xca>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80990c:	83 ec 08             	sub    $0x8,%esp
  80990f:	53                   	push   %ebx
  809910:	ff 75 08             	pushl  0x8(%ebp)
  809913:	e8 22 fe ff ff       	call   80973a <etharp_request>
  809918:	89 c3                	mov    %eax,%ebx
  80991a:	83 c4 10             	add    $0x10,%esp
  80991d:	eb 05                	jmp    809924 <etharp_query+0xcf>
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  80991f:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  809924:	85 ff                	test   %edi,%edi
  809926:	0f 84 0a 01 00 00    	je     809a36 <etharp_query+0x1e1>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80992c:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80992f:	8b 90 30 4a b3 00    	mov    0xb34a30(%eax),%edx
  809935:	83 fa 02             	cmp    $0x2,%edx
  809938:	75 24                	jne    80995e <etharp_query+0x109>
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  80993a:	8b 45 08             	mov    0x8(%ebp),%eax
  80993d:	8d 48 25             	lea    0x25(%eax),%ecx
  if (q != NULL) {
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  809940:	83 ec 0c             	sub    $0xc,%esp
  809943:	6b c6 1c             	imul   $0x1c,%esi,%eax
  809946:	05 28 4a b3 00       	add    $0xb34a28,%eax
  80994b:	50                   	push   %eax
  80994c:	89 fa                	mov    %edi,%edx
  80994e:	8b 45 08             	mov    0x8(%ebp),%eax
  809951:	e8 2d f9 ff ff       	call   809283 <etharp_send_ip>
  809956:	83 c4 10             	add    $0x10,%esp
  809959:	e9 2b 01 00 00       	jmp    809a89 <etharp_query+0x234>
  80995e:	89 d8                	mov    %ebx,%eax
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809960:	83 fa 01             	cmp    $0x1,%edx
  809963:	0f 85 20 01 00 00    	jne    809a89 <etharp_query+0x234>
  809969:	89 f8                	mov    %edi,%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  80996b:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  80996f:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  809973:	75 20                	jne    809995 <etharp_query+0x140>
  809975:	83 38 00             	cmpl   $0x0,(%eax)
  809978:	0f 84 03 01 00 00    	je     809a81 <etharp_query+0x22c>
  80997e:	83 ec 04             	sub    $0x4,%esp
  809981:	68 f2 20 81 00       	push   $0x8120f2
  809986:	68 b1 03 00 00       	push   $0x3b1
  80998b:	68 96 20 81 00       	push   $0x812096
  809990:	e8 b9 4a 00 00       	call   80e44e <_panic>
        if(p->type != PBUF_ROM) {
  809995:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809999:	0f 85 9b 00 00 00    	jne    809a3a <etharp_query+0x1e5>
          copy_needed = 1;
          break;
        }
        p = p->next;
  80999f:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  8099a1:	85 c0                	test   %eax,%eax
  8099a3:	75 c6                	jne    80996b <etharp_query+0x116>
  8099a5:	e9 b0 00 00 00       	jmp    809a5a <etharp_query+0x205>
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
        if(p != NULL) {
          if (pbuf_copy(p, q) != ERR_OK) {
  8099aa:	83 ec 08             	sub    $0x8,%esp
  8099ad:	57                   	push   %edi
  8099ae:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8099b1:	57                   	push   %edi
  8099b2:	e8 32 b4 ff ff       	call   804de9 <pbuf_copy>
  8099b7:	83 c4 10             	add    $0x10,%esp
  8099ba:	84 c0                	test   %al,%al
  8099bc:	0f 84 a4 00 00 00    	je     809a66 <etharp_query+0x211>
            pbuf_free(p);
  8099c2:	83 ec 0c             	sub    $0xc,%esp
  8099c5:	ff 75 e4             	pushl  -0x1c(%ebp)
  8099c8:	e8 58 ae ff ff       	call   804825 <pbuf_free>
  8099cd:	83 c4 10             	add    $0x10,%esp
  8099d0:	e9 a8 00 00 00       	jmp    809a7d <etharp_query+0x228>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
        if (new_entry != NULL) {
          new_entry->next = 0;
  8099d5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  8099db:	89 78 04             	mov    %edi,0x4(%eax)
          if(arp_table[i].q != NULL) {
  8099de:	6b d6 1c             	imul   $0x1c,%esi,%edx
  8099e1:	8b 8a 20 4a b3 00    	mov    0xb34a20(%edx),%ecx
  8099e7:	85 c9                	test   %ecx,%ecx
  8099e9:	75 04                	jne    8099ef <etharp_query+0x19a>
  8099eb:	eb 14                	jmp    809a01 <etharp_query+0x1ac>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
              r = r->next;
  8099ed:	89 d1                	mov    %edx,%ecx
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  8099ef:	8b 11                	mov    (%ecx),%edx
  8099f1:	85 d2                	test   %edx,%edx
  8099f3:	75 f8                	jne    8099ed <etharp_query+0x198>
              r = r->next;
            }
            r->next = new_entry;
  8099f5:	89 01                	mov    %eax,(%ecx)
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  8099f7:	b8 00 00 00 00       	mov    $0x0,%eax
  8099fc:	e9 88 00 00 00       	jmp    809a89 <etharp_query+0x234>
              r = r->next;
            }
            r->next = new_entry;
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  809a01:	6b f6 1c             	imul   $0x1c,%esi,%esi
  809a04:	89 86 20 4a b3 00    	mov    %eax,0xb34a20(%esi)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  809a0a:	b8 00 00 00 00       	mov    $0x0,%eax
  809a0f:	eb 78                	jmp    809a89 <etharp_query+0x234>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  809a11:	83 ec 0c             	sub    $0xc,%esp
  809a14:	57                   	push   %edi
  809a15:	e8 0b ae ff ff       	call   804825 <pbuf_free>
  809a1a:	83 c4 10             	add    $0x10,%esp
  809a1d:	89 d8                	mov    %ebx,%eax
  809a1f:	eb 68                	jmp    809a89 <etharp_query+0x234>
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  809a21:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809a26:	eb 61                	jmp    809a89 <etharp_query+0x234>
  809a28:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809a2d:	eb 5a                	jmp    809a89 <etharp_query+0x234>
  809a2f:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809a34:	eb 53                	jmp    809a89 <etharp_query+0x234>
  809a36:	89 d8                	mov    %ebx,%eax
  809a38:	eb 4f                	jmp    809a89 <etharp_query+0x234>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809a3a:	83 ec 04             	sub    $0x4,%esp
  809a3d:	6a 00                	push   $0x0
  809a3f:	0f b7 d2             	movzwl %dx,%edx
  809a42:	52                   	push   %edx
  809a43:	6a 03                	push   $0x3
  809a45:	e8 a1 ae ff ff       	call   8048eb <pbuf_alloc>
  809a4a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(p != NULL) {
  809a4d:	83 c4 10             	add    $0x10,%esp
  809a50:	85 c0                	test   %eax,%eax
  809a52:	0f 85 52 ff ff ff    	jne    8099aa <etharp_query+0x155>
  809a58:	eb 23                	jmp    809a7d <etharp_query+0x228>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  809a5a:	83 ec 0c             	sub    $0xc,%esp
  809a5d:	57                   	push   %edi
  809a5e:	e8 39 b2 ff ff       	call   804c9c <pbuf_ref>
  809a63:	83 c4 10             	add    $0x10,%esp
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809a66:	83 ec 0c             	sub    $0xc,%esp
  809a69:	6a 0a                	push   $0xa
  809a6b:	e8 ec a9 ff ff       	call   80445c <memp_malloc>
        if (new_entry != NULL) {
  809a70:	83 c4 10             	add    $0x10,%esp
  809a73:	85 c0                	test   %eax,%eax
  809a75:	0f 85 5a ff ff ff    	jne    8099d5 <etharp_query+0x180>
  809a7b:	eb 94                	jmp    809a11 <etharp_query+0x1bc>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  809a7d:	89 d8                	mov    %ebx,%eax
  809a7f:	eb 08                	jmp    809a89 <etharp_query+0x234>
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
        if(p->type != PBUF_ROM) {
  809a81:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809a85:	75 b3                	jne    809a3a <etharp_query+0x1e5>
  809a87:	eb d1                	jmp    809a5a <etharp_query+0x205>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  809a89:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809a8c:	5b                   	pop    %ebx
  809a8d:	5e                   	pop    %esi
  809a8e:	5f                   	pop    %edi
  809a8f:	5d                   	pop    %ebp
  809a90:	c3                   	ret    

00809a91 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  809a91:	55                   	push   %ebp
  809a92:	89 e5                	mov    %esp,%ebp
  809a94:	57                   	push   %edi
  809a95:	56                   	push   %esi
  809a96:	53                   	push   %ebx
  809a97:	83 ec 24             	sub    $0x24,%esp
  809a9a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809a9d:	8b 75 10             	mov    0x10(%ebp),%esi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  809aa0:	6a 0e                	push   $0xe
  809aa2:	ff 75 0c             	pushl  0xc(%ebp)
  809aa5:	e8 a9 ac ff ff       	call   804753 <pbuf_header>
  809aaa:	83 c4 10             	add    $0x10,%esp
  809aad:	84 c0                	test   %al,%al
  809aaf:	0f 85 bd 00 00 00    	jne    809b72 <etharp_output+0xe1>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809ab5:	83 ec 08             	sub    $0x8,%esp
  809ab8:	53                   	push   %ebx
  809ab9:	56                   	push   %esi
  809aba:	e8 0f ca ff ff       	call   8064ce <ip_addr_isbroadcast>
  809abf:	83 c4 10             	add    $0x10,%esp
  809ac2:	84 c0                	test   %al,%al
  809ac4:	0f 85 8d 00 00 00    	jne    809b57 <etharp_output+0xc6>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  809aca:	8b 3e                	mov    (%esi),%edi
  809acc:	83 ec 0c             	sub    $0xc,%esp
  809acf:	68 00 00 00 f0       	push   $0xf0000000
  809ad4:	e8 38 de ff ff       	call   807911 <ntohl>
  809ad9:	21 c7                	and    %eax,%edi
  809adb:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809ae2:	e8 2a de ff ff       	call   807911 <ntohl>
  809ae7:	83 c4 10             	add    $0x10,%esp
  809aea:	39 c7                	cmp    %eax,%edi
  809aec:	75 44                	jne    809b32 <etharp_output+0xa1>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  809aee:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  809af2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  809af6:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  809afa:	83 ec 0c             	sub    $0xc,%esp
  809afd:	ff 36                	pushl  (%esi)
  809aff:	e8 0d de ff ff       	call   807911 <ntohl>
  809b04:	c1 e8 10             	shr    $0x10,%eax
  809b07:	83 e0 7f             	and    $0x7f,%eax
  809b0a:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809b0d:	83 c4 04             	add    $0x4,%esp
  809b10:	ff 36                	pushl  (%esi)
  809b12:	e8 fa dd ff ff       	call   807911 <ntohl>
  809b17:	c1 e8 08             	shr    $0x8,%eax
  809b1a:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809b1d:	83 c4 04             	add    $0x4,%esp
  809b20:	ff 36                	pushl  (%esi)
  809b22:	e8 ea dd ff ff       	call   807911 <ntohl>
  809b27:	88 45 e7             	mov    %al,-0x19(%ebp)
  809b2a:	83 c4 10             	add    $0x10,%esp
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  809b2d:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809b30:	eb 2a                	jmp    809b5c <etharp_output+0xcb>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809b32:	8b 06                	mov    (%esi),%eax
  809b34:	33 43 04             	xor    0x4(%ebx),%eax
  809b37:	85 43 08             	test   %eax,0x8(%ebx)
  809b3a:	74 09                	je     809b45 <etharp_output+0xb4>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  809b3c:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809b40:	74 37                	je     809b79 <etharp_output+0xe8>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  809b42:	8d 73 0c             	lea    0xc(%ebx),%esi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  809b45:	83 ec 04             	sub    $0x4,%esp
  809b48:	ff 75 0c             	pushl  0xc(%ebp)
  809b4b:	56                   	push   %esi
  809b4c:	53                   	push   %ebx
  809b4d:	e8 03 fd ff ff       	call   809855 <etharp_query>
  809b52:	83 c4 10             	add    $0x10,%esp
  809b55:	eb 27                	jmp    809b7e <etharp_output+0xed>
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  809b57:	b8 00 22 81 00       	mov    $0x812200,%eax
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809b5c:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809b5f:	83 ec 0c             	sub    $0xc,%esp
  809b62:	50                   	push   %eax
  809b63:	8b 55 0c             	mov    0xc(%ebp),%edx
  809b66:	89 d8                	mov    %ebx,%eax
  809b68:	e8 16 f7 ff ff       	call   809283 <etharp_send_ip>
  809b6d:	83 c4 10             	add    $0x10,%esp
  809b70:	eb 0c                	jmp    809b7e <etharp_output+0xed>
  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  809b72:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809b77:	eb 05                	jmp    809b7e <etharp_output+0xed>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  809b79:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
  809b7e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809b81:	5b                   	pop    %ebx
  809b82:	5e                   	pop    %esi
  809b83:	5f                   	pop    %edi
  809b84:	5d                   	pop    %ebp
  809b85:	c3                   	ret    

00809b86 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809b86:	55                   	push   %ebp
  809b87:	89 e5                	mov    %esp,%ebp
  809b89:	56                   	push   %esi
  809b8a:	53                   	push   %ebx
  809b8b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809b8e:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809b91:	83 ec 0c             	sub    $0xc,%esp
  809b94:	8b 43 04             	mov    0x4(%ebx),%eax
  809b97:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809b9b:	50                   	push   %eax
  809b9c:	e8 35 db ff ff       	call   8076d6 <htons>
  809ba1:	83 c4 10             	add    $0x10,%esp
  809ba4:	66 3d 00 08          	cmp    $0x800,%ax
  809ba8:	74 08                	je     809bb2 <ethernet_input+0x2c>
  809baa:	66 3d 06 08          	cmp    $0x806,%ax
  809bae:	74 44                	je     809bf4 <ethernet_input+0x6e>
  809bb0:	eb 55                	jmp    809c07 <ethernet_input+0x81>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  809bb2:	83 ec 08             	sub    $0x8,%esp
  809bb5:	53                   	push   %ebx
  809bb6:	56                   	push   %esi
  809bb7:	e8 37 f9 ff ff       	call   8094f3 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809bbc:	83 c4 08             	add    $0x8,%esp
  809bbf:	6a f2                	push   $0xfffffff2
  809bc1:	53                   	push   %ebx
  809bc2:	e8 8c ab ff ff       	call   804753 <pbuf_header>
  809bc7:	83 c4 10             	add    $0x10,%esp
  809bca:	84 c0                	test   %al,%al
  809bcc:	74 17                	je     809be5 <ethernet_input+0x5f>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809bce:	83 ec 04             	sub    $0x4,%esp
  809bd1:	68 d4 21 81 00       	push   $0x8121d4
  809bd6:	68 7e 04 00 00       	push   $0x47e
  809bdb:	68 96 20 81 00       	push   $0x812096
  809be0:	e8 69 48 00 00       	call   80e44e <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  809be5:	83 ec 08             	sub    $0x8,%esp
  809be8:	56                   	push   %esi
  809be9:	53                   	push   %ebx
  809bea:	e8 89 c9 ff ff       	call   806578 <ip_input>
      }
      break;
  809bef:	83 c4 10             	add    $0x10,%esp
  809bf2:	eb 1f                	jmp    809c13 <ethernet_input+0x8d>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809bf4:	83 ec 04             	sub    $0x4,%esp
  809bf7:	53                   	push   %ebx
  809bf8:	8d 46 25             	lea    0x25(%esi),%eax
  809bfb:	50                   	push   %eax
  809bfc:	56                   	push   %esi
  809bfd:	e8 3b f9 ff ff       	call   80953d <etharp_arp_input>
      break;
  809c02:	83 c4 10             	add    $0x10,%esp
  809c05:	eb 0c                	jmp    809c13 <ethernet_input+0x8d>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809c07:	83 ec 0c             	sub    $0xc,%esp
  809c0a:	53                   	push   %ebx
  809c0b:	e8 15 ac ff ff       	call   804825 <pbuf_free>
      p = NULL;
      break;
  809c10:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809c13:	b8 00 00 00 00       	mov    $0x0,%eax
  809c18:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809c1b:	5b                   	pop    %ebx
  809c1c:	5e                   	pop    %esi
  809c1d:	5d                   	pop    %ebp
  809c1e:	c3                   	ret    

00809c1f <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809c1f:	55                   	push   %ebp
  809c20:	89 e5                	mov    %esp,%ebp
  809c22:	53                   	push   %ebx
  809c23:	83 ec 10             	sub    $0x10,%esp
  809c26:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809c29:	ff 73 04             	pushl  0x4(%ebx)
  809c2c:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809c2e:	89 1c 24             	mov    %ebx,(%esp)
  809c31:	e8 f6 64 00 00       	call   81012c <free>
}
  809c36:	83 c4 10             	add    $0x10,%esp
  809c39:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809c3c:	c9                   	leave  
  809c3d:	c3                   	ret    

00809c3e <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809c3e:	55                   	push   %ebp
  809c3f:	89 e5                	mov    %esp,%ebp
  809c41:	83 ec 08             	sub    $0x8,%esp
  809c44:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809c47:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809c4c:	89 c8                	mov    %ecx,%eax
  809c4e:	f7 e2                	mul    %edx
  809c50:	c1 ea 08             	shr    $0x8,%edx
  809c53:	89 d0                	mov    %edx,%eax
  809c55:	c1 e0 08             	shl    $0x8,%eax
  809c58:	01 c2                	add    %eax,%edx
  809c5a:	89 c8                	mov    %ecx,%eax
  809c5c:	29 d0                	sub    %edx,%eax
  809c5e:	8b 04 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%eax
  809c65:	eb 2a                	jmp    809c91 <timeout_cleanup+0x53>
	if (t->tid == tid) {
  809c67:	3b 08                	cmp    (%eax),%ecx
  809c69:	75 23                	jne    809c8e <timeout_cleanup+0x50>
	    LIST_REMOVE(t, link);
  809c6b:	8b 50 08             	mov    0x8(%eax),%edx
  809c6e:	85 d2                	test   %edx,%edx
  809c70:	74 06                	je     809c78 <timeout_cleanup+0x3a>
  809c72:	8b 48 0c             	mov    0xc(%eax),%ecx
  809c75:	89 4a 0c             	mov    %ecx,0xc(%edx)
  809c78:	8b 50 0c             	mov    0xc(%eax),%edx
  809c7b:	8b 48 08             	mov    0x8(%eax),%ecx
  809c7e:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  809c80:	83 ec 0c             	sub    $0xc,%esp
  809c83:	50                   	push   %eax
  809c84:	e8 a3 64 00 00       	call   81012c <free>
	    goto done;
  809c89:	83 c4 10             	add    $0x10,%esp
  809c8c:	eb 07                	jmp    809c95 <timeout_cleanup+0x57>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809c8e:	8b 40 08             	mov    0x8(%eax),%eax
  809c91:	85 c0                	test   %eax,%eax
  809c93:	75 d2                	jne    809c67 <timeout_cleanup+0x29>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  809c95:	c9                   	leave  
  809c96:	c3                   	ret    

00809c97 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  809c97:	55                   	push   %ebp
  809c98:	89 e5                	mov    %esp,%ebp
  809c9a:	56                   	push   %esi
  809c9b:	53                   	push   %ebx
  809c9c:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809ca2:	b8 80 9d b3 00       	mov    $0xb39d80,%eax
  809ca7:	be 80 b1 b3 00       	mov    $0xb3b180,%esi
  809cac:	89 c1                	mov    %eax,%ecx
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  809cae:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809cb4:	89 50 0c             	mov    %edx,0xc(%eax)
  809cb7:	85 d2                	test   %edx,%edx
  809cb9:	74 06                	je     809cc1 <sys_init+0x2a>
  809cbb:	8d 58 0c             	lea    0xc(%eax),%ebx
  809cbe:	89 5a 10             	mov    %ebx,0x10(%edx)
  809cc1:	c7 41 10 60 9d b3 00 	movl   $0xb39d60,0x10(%ecx)
  809cc8:	83 c0 14             	add    $0x14,%eax
  809ccb:	89 ca                	mov    %ecx,%edx

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  809ccd:	39 f0                	cmp    %esi,%eax
  809ccf:	75 db                	jne    809cac <sys_init+0x15>
  809cd1:	c7 05 60 9d b3 00 6c 	movl   $0xb3b16c,0xb39d60
  809cd8:	b1 b3 00 
  809cdb:	8b 15 44 4f b3 00    	mov    0xb34f44,%edx
  809ce1:	b8 60 4f b3 00       	mov    $0xb34f60,%eax
  809ce6:	be 60 9d b3 00       	mov    $0xb39d60,%esi
  809ceb:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  809ced:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809cf3:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  809cf9:	85 d2                	test   %edx,%edx
  809cfb:	74 0c                	je     809d09 <sys_init+0x72>
  809cfd:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  809d03:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  809d09:	c7 81 98 00 00 00 44 	movl   $0xb34f44,0x98(%ecx)
  809d10:	4f b3 00 
  809d13:	05 9c 00 00 00       	add    $0x9c,%eax
  809d18:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  809d1a:	39 f0                	cmp    %esi,%eax
  809d1c:	75 cd                	jne    809ceb <sys_init+0x54>
  809d1e:	c7 05 44 4f b3 00 c4 	movl   $0xb39cc4,0xb34f44
  809d25:	9c b3 00 
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  809d28:	5b                   	pop    %ebx
  809d29:	5e                   	pop    %esi
  809d2a:	5d                   	pop    %ebp
  809d2b:	c3                   	ret    

00809d2c <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  809d2c:	55                   	push   %ebp
  809d2d:	89 e5                	mov    %esp,%ebp
  809d2f:	53                   	push   %ebx
  809d30:	83 ec 04             	sub    $0x4,%esp
  809d33:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  809d36:	a1 60 9d b3 00       	mov    0xb39d60,%eax
    if (!se) {
  809d3b:	85 c0                	test   %eax,%eax
  809d3d:	75 17                	jne    809d56 <sys_sem_new+0x2a>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  809d3f:	83 ec 0c             	sub    $0xc,%esp
  809d42:	68 08 22 81 00       	push   $0x812208
  809d47:	e8 db 47 00 00       	call   80e527 <cprintf>
	return SYS_SEM_NULL;
  809d4c:	83 c4 10             	add    $0x10,%esp
  809d4f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809d54:	eb 52                	jmp    809da8 <sys_sem_new+0x7c>
    }
    LIST_REMOVE(se, link);
  809d56:	8b 48 0c             	mov    0xc(%eax),%ecx
  809d59:	85 c9                	test   %ecx,%ecx
  809d5b:	74 06                	je     809d63 <sys_sem_new+0x37>
  809d5d:	8b 58 10             	mov    0x10(%eax),%ebx
  809d60:	89 59 10             	mov    %ebx,0x10(%ecx)
  809d63:	8b 48 10             	mov    0x10(%eax),%ecx
  809d66:	8b 58 0c             	mov    0xc(%eax),%ebx
  809d69:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  809d6b:	83 38 00             	cmpl   $0x0,(%eax)
  809d6e:	75 19                	jne    809d89 <sys_sem_new+0x5d>
  809d70:	68 7d 23 81 00       	push   $0x81237d
  809d75:	68 87 23 81 00       	push   $0x812387
  809d7a:	68 8d 00 00 00       	push   $0x8d
  809d7f:	68 9c 23 81 00       	push   $0x81239c
  809d84:	e8 c5 46 00 00       	call   80e44e <_panic>
    se->freed = 0;
  809d89:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  809d8f:	0f b6 d2             	movzbl %dl,%edx
  809d92:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  809d96:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  809d9a:	2d 80 9d b3 00       	sub    $0xb39d80,%eax
  809d9f:	c1 f8 02             	sar    $0x2,%eax
  809da2:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  809da8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809dab:	c9                   	leave  
  809dac:	c3                   	ret    

00809dad <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  809dad:	55                   	push   %ebp
  809dae:	89 e5                	mov    %esp,%ebp
  809db0:	83 ec 08             	sub    $0x8,%esp
  809db3:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809db6:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809db9:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  809dc0:	00 
  809dc1:	74 19                	je     809ddc <sys_sem_free+0x2f>
  809dc3:	68 b9 23 81 00       	push   $0x8123b9
  809dc8:	68 87 23 81 00       	push   $0x812387
  809dcd:	68 98 00 00 00       	push   $0x98
  809dd2:	68 9c 23 81 00       	push   $0x81239c
  809dd7:	e8 72 46 00 00       	call   80e44e <_panic>
    sems[sem].freed = 1;
  809ddc:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809ddf:	c1 e2 02             	shl    $0x2,%edx
  809de2:	8d 8a 80 9d b3 00    	lea    0xb39d80(%edx),%ecx
  809de8:	c7 82 80 9d b3 00 01 	movl   $0x1,0xb39d80(%edx)
  809def:	00 00 00 
    sems[sem].gen++;
  809df2:	83 41 04 01          	addl   $0x1,0x4(%ecx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  809df6:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809dfc:	89 51 0c             	mov    %edx,0xc(%ecx)
  809dff:	85 d2                	test   %edx,%edx
  809e01:	74 0d                	je     809e10 <sys_sem_free+0x63>
  809e03:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  809e06:	8d 0c 8d 8c 9d b3 00 	lea    0xb39d8c(,%ecx,4),%ecx
  809e0d:	89 4a 10             	mov    %ecx,0x10(%edx)
  809e10:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809e17:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  809e1a:	8d 0c 8d 80 9d b3 00 	lea    0xb39d80(,%ecx,4),%ecx
  809e21:	89 0d 60 9d b3 00    	mov    %ecx,0xb39d60
  809e27:	01 d0                	add    %edx,%eax
  809e29:	c7 04 85 90 9d b3 00 	movl   $0xb39d60,0xb39d90(,%eax,4)
  809e30:	60 9d b3 00 
}
  809e34:	c9                   	leave  
  809e35:	c3                   	ret    

00809e36 <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  809e36:	55                   	push   %ebp
  809e37:	89 e5                	mov    %esp,%ebp
  809e39:	56                   	push   %esi
  809e3a:	53                   	push   %ebx
  809e3b:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  809e3e:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  809e44:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  809e4b:	74 16                	je     809e63 <sys_mbox_free+0x2d>
  809e4d:	68 ca 23 81 00       	push   $0x8123ca
  809e52:	68 87 23 81 00       	push   $0x812387
  809e57:	6a 62                	push   $0x62
  809e59:	68 9c 23 81 00       	push   $0x81239c
  809e5e:	e8 eb 45 00 00       	call   80e44e <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  809e63:	83 ec 0c             	sub    $0xc,%esp
  809e66:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  809e6c:	ff b6 ec 4f b3 00    	pushl  0xb34fec(%esi)
  809e72:	e8 36 ff ff ff       	call   809dad <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  809e77:	83 c4 04             	add    $0x4,%esp
  809e7a:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  809e80:	e8 28 ff ff ff       	call   809dad <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  809e85:	a1 44 4f b3 00       	mov    0xb34f44,%eax
  809e8a:	89 86 f4 4f b3 00    	mov    %eax,0xb34ff4(%esi)
  809e90:	83 c4 10             	add    $0x10,%esp
  809e93:	85 c0                	test   %eax,%eax
  809e95:	74 12                	je     809ea9 <sys_mbox_free+0x73>
  809e97:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  809e9d:	81 c2 f4 4f b3 00    	add    $0xb34ff4,%edx
  809ea3:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809ea9:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  809eaf:	8d 83 60 4f b3 00    	lea    0xb34f60(%ebx),%eax
  809eb5:	a3 44 4f b3 00       	mov    %eax,0xb34f44
  809eba:	c7 83 f8 4f b3 00 44 	movl   $0xb34f44,0xb34ff8(%ebx)
  809ec1:	4f b3 00 
    mboxes[mbox].freed = 1;
  809ec4:	c7 83 60 4f b3 00 01 	movl   $0x1,0xb34f60(%ebx)
  809ecb:	00 00 00 
}
  809ece:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809ed1:	5b                   	pop    %ebx
  809ed2:	5e                   	pop    %esi
  809ed3:	5d                   	pop    %ebp
  809ed4:	c3                   	ret    

00809ed5 <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  809ed5:	55                   	push   %ebp
  809ed6:	89 e5                	mov    %esp,%ebp
  809ed8:	56                   	push   %esi
  809ed9:	53                   	push   %ebx
    assert(size < MBOXSLOTS);
  809eda:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  809ede:	7e 16                	jle    809ef6 <sys_mbox_new+0x21>
  809ee0:	68 de 23 81 00       	push   $0x8123de
  809ee5:	68 87 23 81 00       	push   $0x812387
  809eea:	6a 45                	push   $0x45
  809eec:	68 9c 23 81 00       	push   $0x81239c
  809ef1:	e8 58 45 00 00       	call   80e44e <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  809ef6:	8b 1d 44 4f b3 00    	mov    0xb34f44,%ebx
    if (!mbe) {
  809efc:	85 db                	test   %ebx,%ebx
  809efe:	75 1a                	jne    809f1a <sys_mbox_new+0x45>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  809f00:	83 ec 0c             	sub    $0xc,%esp
  809f03:	68 30 22 81 00       	push   $0x812230
  809f08:	e8 1a 46 00 00       	call   80e527 <cprintf>
	return SYS_MBOX_NULL;
  809f0d:	83 c4 10             	add    $0x10,%esp
  809f10:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809f15:	e9 b7 00 00 00       	jmp    809fd1 <sys_mbox_new+0xfc>
    }
    LIST_REMOVE(mbe, link);
  809f1a:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  809f20:	85 c0                	test   %eax,%eax
  809f22:	74 0c                	je     809f30 <sys_mbox_new+0x5b>
  809f24:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  809f2a:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809f30:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  809f36:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  809f3c:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  809f3e:	83 3b 00             	cmpl   $0x0,(%ebx)
  809f41:	75 16                	jne    809f59 <sys_mbox_new+0x84>
  809f43:	68 ef 23 81 00       	push   $0x8123ef
  809f48:	68 87 23 81 00       	push   $0x812387
  809f4d:	6a 4c                	push   $0x4c
  809f4f:	68 9c 23 81 00       	push   $0x81239c
  809f54:	e8 f5 44 00 00       	call   80e44e <_panic>
    mbe->freed = 0;
  809f59:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  809f5f:	89 d8                	mov    %ebx,%eax
  809f61:	2d 60 4f b3 00       	sub    $0xb34f60,%eax
  809f66:	c1 f8 02             	sar    $0x2,%eax
  809f69:	69 f0 97 6f f9 96    	imul   $0x96f96f97,%eax,%esi
    mbe->head = -1;
  809f6f:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  809f76:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  809f7d:	83 ec 0c             	sub    $0xc,%esp
  809f80:	6a 00                	push   $0x0
  809f82:	e8 a5 fd ff ff       	call   809d2c <sys_sem_new>
  809f87:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  809f8d:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  809f94:	e8 93 fd ff ff       	call   809d2c <sys_sem_new>
  809f99:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  809f9f:	83 c4 10             	add    $0x10,%esp
  809fa2:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  809fa9:	74 05                	je     809fb0 <sys_mbox_new+0xdb>
  809fab:	83 f8 ff             	cmp    $0xffffffff,%eax
  809fae:	75 1f                	jne    809fcf <sys_mbox_new+0xfa>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  809fb0:	83 ec 0c             	sub    $0xc,%esp
  809fb3:	56                   	push   %esi
  809fb4:	e8 7d fe ff ff       	call   809e36 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  809fb9:	c7 04 24 58 22 81 00 	movl   $0x812258,(%esp)
  809fc0:	e8 62 45 00 00       	call   80e527 <cprintf>
	return SYS_MBOX_NULL;
  809fc5:	83 c4 10             	add    $0x10,%esp
  809fc8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809fcd:	eb 02                	jmp    809fd1 <sys_mbox_new+0xfc>
    }
    return i;
  809fcf:	89 f0                	mov    %esi,%eax
}
  809fd1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809fd4:	5b                   	pop    %ebx
  809fd5:	5e                   	pop    %esi
  809fd6:	5d                   	pop    %ebp
  809fd7:	c3                   	ret    

00809fd8 <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  809fd8:	55                   	push   %ebp
  809fd9:	89 e5                	mov    %esp,%ebp
  809fdb:	83 ec 08             	sub    $0x8,%esp
  809fde:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809fe1:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809fe4:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  809feb:	00 
  809fec:	74 19                	je     80a007 <sys_sem_signal+0x2f>
  809fee:	68 b9 23 81 00       	push   $0x8123b9
  809ff3:	68 87 23 81 00       	push   $0x812387
  809ff8:	68 a1 00 00 00       	push   $0xa1
  809ffd:	68 9c 23 81 00       	push   $0x81239c
  80a002:	e8 47 44 00 00       	call   80e44e <_panic>
    sems[sem].counter++;
  80a007:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a00a:	8d 14 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%edx
  80a011:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a016:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a01b:	74 27                	je     80a044 <sys_sem_signal+0x6c>
	sems[sem].waiters = 0;
  80a01d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a024:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a027:	66 c7 04 8d 8a 9d b3 	movw   $0x0,0xb39d8a(,%ecx,4)
  80a02e:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a031:	83 ec 0c             	sub    $0xc,%esp
  80a034:	8d 04 8d 88 9d b3 00 	lea    0xb39d88(,%ecx,4),%eax
  80a03b:	50                   	push   %eax
  80a03c:	e8 b9 04 00 00       	call   80a4fa <thread_wakeup>
  80a041:	83 c4 10             	add    $0x10,%esp
    }
}
  80a044:	c9                   	leave  
  80a045:	c3                   	ret    

0080a046 <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80a046:	55                   	push   %ebp
  80a047:	89 e5                	mov    %esp,%ebp
  80a049:	57                   	push   %edi
  80a04a:	56                   	push   %esi
  80a04b:	53                   	push   %ebx
  80a04c:	83 ec 1c             	sub    $0x1c,%esp
  80a04f:	8b 75 0c             	mov    0xc(%ebp),%esi
    assert(!sems[sem].freed);
  80a052:	8b 45 08             	mov    0x8(%ebp),%eax
  80a055:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a058:	83 3c 85 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%eax,4)
  80a05f:	00 
  80a060:	74 19                	je     80a07b <sys_arch_sem_wait+0x35>
  80a062:	68 b9 23 81 00       	push   $0x8123b9
  80a067:	68 87 23 81 00       	push   $0x812387
  80a06c:	68 ac 00 00 00       	push   $0xac
  80a071:	68 9c 23 81 00       	push   $0x81239c
  80a076:	e8 d3 43 00 00       	call   80e44e <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80a07b:	8b 45 08             	mov    0x8(%ebp),%eax
  80a07e:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a081:	8b 04 85 84 9d b3 00 	mov    0xb39d84(,%eax,4),%eax
  80a088:	89 45 dc             	mov    %eax,-0x24(%ebp)

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
    assert(!sems[sem].freed);
    u32_t waited = 0;
  80a08b:	bf 00 00 00 00       	mov    $0x0,%edi

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80a090:	8b 45 08             	mov    0x8(%ebp),%eax
  80a093:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a096:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80a099:	e9 92 00 00 00       	jmp    80a130 <sys_arch_sem_wait+0xea>
	if (sems[sem].counter > 0) {
  80a09e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a0a1:	0f b7 04 85 88 9d b3 	movzwl 0xb39d88(,%eax,4),%eax
  80a0a8:	00 
  80a0a9:	66 85 c0             	test   %ax,%ax
  80a0ac:	74 18                	je     80a0c6 <sys_arch_sem_wait+0x80>
	    sems[sem].counter--;
  80a0ae:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a0b1:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  80a0b4:	83 e8 01             	sub    $0x1,%eax
  80a0b7:	66 89 04 95 88 9d b3 	mov    %ax,0xb39d88(,%edx,4)
  80a0be:	00 
	    return waited;
  80a0bf:	89 f8                	mov    %edi,%eax
  80a0c1:	e9 86 00 00 00       	jmp    80a14c <sys_arch_sem_wait+0x106>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a0c6:	83 fe fe             	cmp    $0xfffffffe,%esi
  80a0c9:	74 7c                	je     80a147 <sys_arch_sem_wait+0x101>
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80a0cb:	e8 d0 4f 00 00       	call   80f0a0 <sys_time_msec>
  80a0d0:	89 c1                	mov    %eax,%ecx
  80a0d2:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a0d5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a0da:	85 f6                	test   %esi,%esi
  80a0dc:	74 06                	je     80a0e4 <sys_arch_sem_wait+0x9e>
  80a0de:	89 f0                	mov    %esi,%eax
  80a0e0:	29 f8                	sub    %edi,%eax
  80a0e2:	01 c8                	add    %ecx,%eax
	    sems[sem].waiters = 1;
  80a0e4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a0e7:	8d 1c 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%ebx
  80a0ee:	66 c7 43 0a 01 00    	movw   $0x1,0xa(%ebx)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a0f4:	83 ec 04             	sub    $0x4,%esp
  80a0f7:	50                   	push   %eax
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
	    uint32_t cur_v = sems[sem].v;
  80a0f8:	8d 43 08             	lea    0x8(%ebx),%eax
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a0fb:	ff 73 08             	pushl  0x8(%ebx)
  80a0fe:	50                   	push   %eax
  80a0ff:	e8 0d 06 00 00       	call   80a711 <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80a104:	83 c4 10             	add    $0x10,%esp
  80a107:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80a10a:	3b 43 04             	cmp    0x4(%ebx),%eax
  80a10d:	74 17                	je     80a126 <sys_arch_sem_wait+0xe0>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a10f:	83 ec 0c             	sub    $0xc,%esp
  80a112:	68 84 22 81 00       	push   $0x812284
  80a117:	e8 0b 44 00 00       	call   80e527 <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a11c:	83 c4 10             	add    $0x10,%esp
  80a11f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a124:	eb 26                	jmp    80a14c <sys_arch_sem_wait+0x106>
	    }
	    uint32_t b = sys_time_msec();
  80a126:	e8 75 4f 00 00       	call   80f0a0 <sys_time_msec>
	    waited += (b - a);
  80a12b:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a12e:	01 c7                	add    %eax,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80a130:	85 f6                	test   %esi,%esi
  80a132:	0f 84 66 ff ff ff    	je     80a09e <sys_arch_sem_wait+0x58>
  80a138:	39 f7                	cmp    %esi,%edi
  80a13a:	0f 82 5e ff ff ff    	jb     80a09e <sys_arch_sem_wait+0x58>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  80a140:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a145:	eb 05                	jmp    80a14c <sys_arch_sem_wait+0x106>
    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
  80a147:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80a14c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a14f:	5b                   	pop    %ebx
  80a150:	5e                   	pop    %esi
  80a151:	5f                   	pop    %edi
  80a152:	5d                   	pop    %ebp
  80a153:	c3                   	ret    

0080a154 <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80a154:	55                   	push   %ebp
  80a155:	89 e5                	mov    %esp,%ebp
  80a157:	57                   	push   %edi
  80a158:	56                   	push   %esi
  80a159:	53                   	push   %ebx
  80a15a:	83 ec 0c             	sub    $0xc,%esp
  80a15d:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a160:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a166:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a16d:	74 16                	je     80a185 <sys_mbox_trypost+0x31>
  80a16f:	68 ca 23 81 00       	push   $0x8123ca
  80a174:	68 87 23 81 00       	push   $0x812387
  80a179:	6a 72                	push   $0x72
  80a17b:	68 9c 23 81 00       	push   $0x81239c
  80a180:	e8 c9 42 00 00       	call   80e44e <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a185:	83 ec 08             	sub    $0x8,%esp
  80a188:	6a 00                	push   $0x0
  80a18a:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a190:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  80a196:	e8 ab fe ff ff       	call   80a046 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a19b:	8b 96 68 4f b3 00    	mov    0xb34f68(%esi),%edx
  80a1a1:	8b 8e 64 4f b3 00    	mov    0xb34f64(%esi),%ecx
  80a1a7:	83 c4 10             	add    $0x10,%esp
  80a1aa:	39 ca                	cmp    %ecx,%edx
  80a1ac:	74 5c                	je     80a20a <sys_mbox_trypost+0xb6>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a1ae:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a1b4:	8d 42 01             	lea    0x1(%edx),%eax
  80a1b7:	89 c7                	mov    %eax,%edi
  80a1b9:	c1 ff 1f             	sar    $0x1f,%edi
  80a1bc:	c1 ef 1b             	shr    $0x1b,%edi
  80a1bf:	01 f8                	add    %edi,%eax
  80a1c1:	83 e0 1f             	and    $0x1f,%eax
  80a1c4:	29 f8                	sub    %edi,%eax
  80a1c6:	89 86 68 4f b3 00    	mov    %eax,0xb34f68(%esi)
    mboxes[mbox].msg[slot] = msg;
  80a1cc:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a1cf:	01 d0                	add    %edx,%eax
  80a1d1:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a1d4:	89 34 85 6c 4f b3 00 	mov    %esi,0xb34f6c(,%eax,4)

    if (mboxes[mbox].head == -1)
  80a1db:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80a1de:	75 0c                	jne    80a1ec <sys_mbox_trypost+0x98>
	mboxes[mbox].head = slot;
  80a1e0:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a1e6:	89 90 64 4f b3 00    	mov    %edx,0xb34f64(%eax)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80a1ec:	83 ec 0c             	sub    $0xc,%esp
  80a1ef:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a1f5:	ff b3 ec 4f b3 00    	pushl  0xb34fec(%ebx)
  80a1fb:	e8 d8 fd ff ff       	call   809fd8 <sys_sem_signal>

    return ERR_OK;
  80a200:	83 c4 10             	add    $0x10,%esp
  80a203:	b8 00 00 00 00       	mov    $0x0,%eax
  80a208:	eb 05                	jmp    80a20f <sys_mbox_trypost+0xbb>
{
    assert(!mboxes[mbox].freed);

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
    if (mboxes[mbox].nextq == mboxes[mbox].head)
	return ERR_MEM;
  80a20a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	mboxes[mbox].head = slot;

    sys_sem_signal(mboxes[mbox].queued_msg);

    return ERR_OK;
}
  80a20f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a212:	5b                   	pop    %ebx
  80a213:	5e                   	pop    %esi
  80a214:	5f                   	pop    %edi
  80a215:	5d                   	pop    %ebp
  80a216:	c3                   	ret    

0080a217 <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80a217:	55                   	push   %ebp
  80a218:	89 e5                	mov    %esp,%ebp
  80a21a:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a21d:	ff 75 0c             	pushl  0xc(%ebp)
  80a220:	ff 75 08             	pushl  0x8(%ebp)
  80a223:	e8 2c ff ff ff       	call   80a154 <sys_mbox_trypost>
  80a228:	83 c4 10             	add    $0x10,%esp
  80a22b:	84 c0                	test   %al,%al
  80a22d:	74 16                	je     80a245 <sys_mbox_post+0x2e>
  80a22f:	68 b0 22 81 00       	push   $0x8122b0
  80a234:	68 87 23 81 00       	push   $0x812387
  80a239:	6a 6c                	push   $0x6c
  80a23b:	68 9c 23 81 00       	push   $0x81239c
  80a240:	e8 09 42 00 00       	call   80e44e <_panic>
}
  80a245:	c9                   	leave  
  80a246:	c3                   	ret    

0080a247 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80a247:	55                   	push   %ebp
  80a248:	89 e5                	mov    %esp,%ebp
  80a24a:	57                   	push   %edi
  80a24b:	56                   	push   %esi
  80a24c:	53                   	push   %ebx
  80a24d:	83 ec 0c             	sub    $0xc,%esp
  80a250:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a253:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a256:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a25c:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a263:	74 19                	je     80a27e <sys_arch_mbox_fetch+0x37>
  80a265:	68 ca 23 81 00       	push   $0x8123ca
  80a26a:	68 87 23 81 00       	push   $0x812387
  80a26f:	68 ce 00 00 00       	push   $0xce
  80a274:	68 9c 23 81 00       	push   $0x81239c
  80a279:	e8 d0 41 00 00       	call   80e44e <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a27e:	83 ec 08             	sub    $0x8,%esp
  80a281:	ff 75 10             	pushl  0x10(%ebp)
  80a284:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a28a:	ff b0 ec 4f b3 00    	pushl  0xb34fec(%eax)
  80a290:	e8 b1 fd ff ff       	call   80a046 <sys_arch_sem_wait>
  80a295:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a297:	83 c4 10             	add    $0x10,%esp
  80a29a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a29d:	0f 84 86 00 00 00    	je     80a329 <sys_arch_mbox_fetch+0xe2>
	return waited;

    int slot = mboxes[mbox].head;
  80a2a3:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a2a9:	8b 80 64 4f b3 00    	mov    0xb34f64(%eax),%eax
    if (slot == -1)
  80a2af:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a2b2:	75 17                	jne    80a2cb <sys_arch_mbox_fetch+0x84>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a2b4:	83 ec 04             	sub    $0x4,%esp
  80a2b7:	68 d8 22 81 00       	push   $0x8122d8
  80a2bc:	68 d6 00 00 00       	push   $0xd6
  80a2c1:	68 9c 23 81 00       	push   $0x81239c
  80a2c6:	e8 83 41 00 00       	call   80e44e <_panic>
    if (msg)
  80a2cb:	85 ff                	test   %edi,%edi
  80a2cd:	74 0e                	je     80a2dd <sys_arch_mbox_fetch+0x96>
	*msg = mboxes[mbox].msg[slot];
  80a2cf:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a2d2:	01 c2                	add    %eax,%edx
  80a2d4:	8b 14 95 6c 4f b3 00 	mov    0xb34f6c(,%edx,4),%edx
  80a2db:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a2dd:	83 c0 01             	add    $0x1,%eax
  80a2e0:	99                   	cltd   
  80a2e1:	c1 ea 1b             	shr    $0x1b,%edx
  80a2e4:	01 d0                	add    %edx,%eax
  80a2e6:	83 e0 1f             	and    $0x1f,%eax
  80a2e9:	29 d0                	sub    %edx,%eax
  80a2eb:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a2f1:	89 82 64 4f b3 00    	mov    %eax,0xb34f64(%edx)
  80a2f7:	81 c2 60 4f b3 00    	add    $0xb34f60,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a2fd:	3b 42 08             	cmp    0x8(%edx),%eax
  80a300:	75 10                	jne    80a312 <sys_arch_mbox_fetch+0xcb>
	mboxes[mbox].head = -1;
  80a302:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a308:	c7 80 64 4f b3 00 ff 	movl   $0xffffffff,0xb34f64(%eax)
  80a30f:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80a312:	83 ec 0c             	sub    $0xc,%esp
  80a315:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a31b:	ff b3 f0 4f b3 00    	pushl  0xb34ff0(%ebx)
  80a321:	e8 b2 fc ff ff       	call   809fd8 <sys_sem_signal>
    return waited;
  80a326:	83 c4 10             	add    $0x10,%esp
}
  80a329:	89 f0                	mov    %esi,%eax
  80a32b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a32e:	5b                   	pop    %ebx
  80a32f:	5e                   	pop    %esi
  80a330:	5f                   	pop    %edi
  80a331:	5d                   	pop    %ebp
  80a332:	c3                   	ret    

0080a333 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80a333:	55                   	push   %ebp
  80a334:	89 e5                	mov    %esp,%ebp
  80a336:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a339:	6a fe                	push   $0xfffffffe
  80a33b:	ff 75 0c             	pushl  0xc(%ebp)
  80a33e:	ff 75 08             	pushl  0x8(%ebp)
  80a341:	e8 01 ff ff ff       	call   80a247 <sys_arch_mbox_fetch>
}
  80a346:	c9                   	leave  
  80a347:	c3                   	ret    

0080a348 <sys_thread_new>:
}

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80a348:	55                   	push   %ebp
  80a349:	89 e5                	mov    %esp,%ebp
  80a34b:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a34e:	6a 08                	push   $0x8
  80a350:	e8 85 5e 00 00       	call   8101da <malloc>
    if (lt == 0)
  80a355:	83 c4 10             	add    $0x10,%esp
  80a358:	85 c0                	test   %eax,%eax
  80a35a:	75 17                	jne    80a373 <sys_thread_new+0x2b>
	panic("sys_thread_new: cannot allocate thread struct");
  80a35c:	83 ec 04             	sub    $0x4,%esp
  80a35f:	68 00 23 81 00       	push   $0x812300
  80a364:	68 fd 00 00 00       	push   $0xfd
  80a369:	68 9c 23 81 00       	push   $0x81239c
  80a36e:	e8 db 40 00 00       	call   80e44e <_panic>

    if (stacksize > PGSIZE)
  80a373:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a37a:	7e 17                	jle    80a393 <sys_thread_new+0x4b>
	panic("large stack %d", stacksize);
  80a37c:	ff 75 14             	pushl  0x14(%ebp)
  80a37f:	68 fa 23 81 00       	push   $0x8123fa
  80a384:	68 00 01 00 00       	push   $0x100
  80a389:	68 9c 23 81 00       	push   $0x81239c
  80a38e:	e8 bb 40 00 00       	call   80e44e <_panic>

    lt->func = thread;
  80a393:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a396:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a398:	8b 55 10             	mov    0x10(%ebp),%edx
  80a39b:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a39e:	50                   	push   %eax
  80a39f:	68 1f 9c 80 00       	push   $0x809c1f
  80a3a4:	ff 75 08             	pushl  0x8(%ebp)
  80a3a7:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a3aa:	50                   	push   %eax
  80a3ab:	e8 b8 01 00 00       	call   80a568 <thread_create>

    if (r < 0)
  80a3b0:	83 c4 10             	add    $0x10,%esp
  80a3b3:	85 c0                	test   %eax,%eax
  80a3b5:	79 1e                	jns    80a3d5 <sys_thread_new+0x8d>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a3b7:	83 ec 0c             	sub    $0xc,%esp
  80a3ba:	50                   	push   %eax
  80a3bb:	e8 d9 04 00 00       	call   80a899 <e2s>
  80a3c0:	50                   	push   %eax
  80a3c1:	68 30 23 81 00       	push   $0x812330
  80a3c6:	68 09 01 00 00       	push   $0x109
  80a3cb:	68 9c 23 81 00       	push   $0x81239c
  80a3d0:	e8 79 40 00 00       	call   80e44e <_panic>

    return tid;
}
  80a3d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a3d8:	c9                   	leave  
  80a3d9:	c3                   	ret    

0080a3da <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a3da:	55                   	push   %ebp
  80a3db:	89 e5                	mov    %esp,%ebp
  80a3dd:	57                   	push   %edi
  80a3de:	56                   	push   %esi
  80a3df:	53                   	push   %ebx
  80a3e0:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a3e3:	e8 06 01 00 00       	call   80a4ee <thread_id>
  80a3e8:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a3ea:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a3ef:	f7 e2                	mul    %edx
  80a3f1:	c1 ea 08             	shr    $0x8,%edx
  80a3f4:	89 d7                	mov    %edx,%edi
  80a3f6:	c1 e2 08             	shl    $0x8,%edx
  80a3f9:	01 d7                	add    %edx,%edi
  80a3fb:	89 f0                	mov    %esi,%eax
  80a3fd:	29 f8                	sub    %edi,%eax
  80a3ff:	89 c7                	mov    %eax,%edi
  80a401:	8b 1c 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%ebx
  80a408:	eb 0b                	jmp    80a415 <sys_arch_timeouts+0x3b>
	if (t->tid == tid)
  80a40a:	3b 33                	cmp    (%ebx),%esi
  80a40c:	0f 84 a4 00 00 00    	je     80a4b6 <sys_arch_timeouts+0xdc>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a412:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a415:	85 db                	test   %ebx,%ebx
  80a417:	75 f1                	jne    80a40a <sys_arch_timeouts+0x30>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80a419:	83 ec 0c             	sub    $0xc,%esp
  80a41c:	6a 10                	push   $0x10
  80a41e:	e8 b7 5d 00 00       	call   8101da <malloc>
  80a423:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a425:	83 c4 10             	add    $0x10,%esp
  80a428:	85 c0                	test   %eax,%eax
  80a42a:	75 17                	jne    80a443 <sys_arch_timeouts+0x69>
	panic("sys_arch_timeouts: cannot malloc");
  80a42c:	83 ec 04             	sub    $0x4,%esp
  80a42f:	68 5c 23 81 00       	push   $0x81235c
  80a434:	68 2c 01 00 00       	push   $0x12c
  80a439:	68 9c 23 81 00       	push   $0x81239c
  80a43e:	e8 0b 40 00 00       	call   80e44e <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80a443:	83 ec 0c             	sub    $0xc,%esp
  80a446:	68 3e 9c 80 00       	push   $0x809c3e
  80a44b:	e8 ec 00 00 00       	call   80a53c <thread_onhalt>
    if (r < 0)
  80a450:	83 c4 10             	add    $0x10,%esp
  80a453:	85 c0                	test   %eax,%eax
  80a455:	79 1e                	jns    80a475 <sys_arch_timeouts+0x9b>
	panic("thread_onhalt failed: %s", e2s(r));
  80a457:	83 ec 0c             	sub    $0xc,%esp
  80a45a:	50                   	push   %eax
  80a45b:	e8 39 04 00 00       	call   80a899 <e2s>
  80a460:	50                   	push   %eax
  80a461:	68 09 24 81 00       	push   $0x812409
  80a466:	68 30 01 00 00       	push   $0x130
  80a46b:	68 9c 23 81 00       	push   $0x81239c
  80a470:	e8 d9 3f 00 00       	call   80e44e <_panic>

    t->tid = tid;
  80a475:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a477:	83 ec 04             	sub    $0x4,%esp
  80a47a:	6a 04                	push   $0x4
  80a47c:	6a 00                	push   $0x0
  80a47e:	8d 43 04             	lea    0x4(%ebx),%eax
  80a481:	50                   	push   %eax
  80a482:	e8 6a 47 00 00       	call   80ebf1 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a487:	8b 04 bd 40 4b b3 00 	mov    0xb34b40(,%edi,4),%eax
  80a48e:	89 43 08             	mov    %eax,0x8(%ebx)
  80a491:	83 c4 10             	add    $0x10,%esp
  80a494:	85 c0                	test   %eax,%eax
  80a496:	74 0d                	je     80a4a5 <sys_arch_timeouts+0xcb>
  80a498:	8b 04 bd 40 4b b3 00 	mov    0xb34b40(,%edi,4),%eax
  80a49f:	8d 53 08             	lea    0x8(%ebx),%edx
  80a4a2:	89 50 0c             	mov    %edx,0xc(%eax)
  80a4a5:	89 1c bd 40 4b b3 00 	mov    %ebx,0xb34b40(,%edi,4)
  80a4ac:	8d 04 bd 40 4b b3 00 	lea    0xb34b40(,%edi,4),%eax
  80a4b3:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a4b6:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a4b9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a4bc:	5b                   	pop    %ebx
  80a4bd:	5e                   	pop    %esi
  80a4be:	5f                   	pop    %edi
  80a4bf:	5d                   	pop    %ebp
  80a4c0:	c3                   	ret    

0080a4c1 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80a4c1:	55                   	push   %ebp
  80a4c2:	89 e5                	mov    %esp,%ebp
}
  80a4c4:	5d                   	pop    %ebp
  80a4c5:	c3                   	ret    

0080a4c6 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80a4c6:	55                   	push   %ebp
  80a4c7:	89 e5                	mov    %esp,%ebp
}
  80a4c9:	5d                   	pop    %ebp
  80a4ca:	c3                   	ret    

0080a4cb <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80a4cb:	55                   	push   %ebp
  80a4cc:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a4ce:	c7 05 88 b1 b3 00 00 	movl   $0x0,0xb3b188
  80a4d5:	00 00 00 
    tq->tq_last = 0;
  80a4d8:	c7 05 8c b1 b3 00 00 	movl   $0x0,0xb3b18c
  80a4df:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80a4e2:	c7 05 94 b1 b3 00 00 	movl   $0x0,0xb3b194
  80a4e9:	00 00 00 
}
  80a4ec:	5d                   	pop    %ebp
  80a4ed:	c3                   	ret    

0080a4ee <thread_id>:

uint32_t
thread_id(void) {
  80a4ee:	55                   	push   %ebp
  80a4ef:	89 e5                	mov    %esp,%ebp
    return cur_tc->tc_tid;
  80a4f1:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a4f6:	8b 00                	mov    (%eax),%eax
}
  80a4f8:	5d                   	pop    %ebp
  80a4f9:	c3                   	ret    

0080a4fa <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a4fa:	55                   	push   %ebp
  80a4fb:	89 e5                	mov    %esp,%ebp
  80a4fd:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a500:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
    while (tc) {
  80a505:	eb 0c                	jmp    80a513 <thread_wakeup+0x19>
	if (tc->tc_wait_addr == addr)
  80a507:	39 50 48             	cmp    %edx,0x48(%eax)
  80a50a:	75 04                	jne    80a510 <thread_wakeup+0x16>
	    tc->tc_wakeup = 1;
  80a50c:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80a510:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80a513:	85 c0                	test   %eax,%eax
  80a515:	75 f0                	jne    80a507 <thread_wakeup+0xd>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80a517:	5d                   	pop    %ebp
  80a518:	c3                   	ret    

0080a519 <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80a519:	55                   	push   %ebp
  80a51a:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80a51c:	8b 15 88 b1 b3 00    	mov    0xb3b188,%edx
    int n = 0;
  80a522:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80a527:	eb 0d                	jmp    80a536 <thread_wakeups_pending+0x1d>
	if (tc->tc_wakeup)
  80a529:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80a52d:	80 f9 01             	cmp    $0x1,%cl
  80a530:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80a533:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80a536:	85 d2                	test   %edx,%edx
  80a538:	75 ef                	jne    80a529 <thread_wakeups_pending+0x10>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80a53a:	5d                   	pop    %ebp
  80a53b:	c3                   	ret    

0080a53c <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a53c:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a541:	8b 50 60             	mov    0x60(%eax),%edx
  80a544:	83 fa 03             	cmp    $0x3,%edx
  80a547:	7f 17                	jg     80a560 <thread_onhalt+0x24>
    }
    return n;
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80a549:	55                   	push   %ebp
  80a54a:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a54c:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a54f:	89 48 60             	mov    %ecx,0x60(%eax)
  80a552:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a555:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a559:	b8 00 00 00 00       	mov    $0x0,%eax
  80a55e:	eb 06                	jmp    80a566 <thread_onhalt+0x2a>
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;
  80a560:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a565:	c3                   	ret    

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
    return 0;
}
  80a566:	5d                   	pop    %ebp
  80a567:	c3                   	ret    

0080a568 <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a568:	55                   	push   %ebp
  80a569:	89 e5                	mov    %esp,%ebp
  80a56b:	57                   	push   %edi
  80a56c:	56                   	push   %esi
  80a56d:	53                   	push   %ebx
  80a56e:	83 ec 18             	sub    $0x18,%esp
  80a571:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a574:	6a 68                	push   $0x68
  80a576:	e8 5f 5c 00 00       	call   8101da <malloc>
    if (!tc)
  80a57b:	83 c4 10             	add    $0x10,%esp
  80a57e:	85 c0                	test   %eax,%eax
  80a580:	0f 84 f4 00 00 00    	je     80a67a <thread_create+0x112>
  80a586:	89 c3                	mov    %eax,%ebx
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a588:	83 ec 04             	sub    $0x4,%esp
  80a58b:	6a 68                	push   $0x68
  80a58d:	6a 00                	push   $0x0
  80a58f:	50                   	push   %eax
  80a590:	e8 5c 46 00 00       	call   80ebf1 <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80a595:	83 c4 0c             	add    $0xc,%esp
  80a598:	6a 1f                	push   $0x1f
  80a59a:	ff 75 0c             	pushl  0xc(%ebp)
  80a59d:	8d 43 08             	lea    0x8(%ebx),%eax
  80a5a0:	50                   	push   %eax
  80a5a1:	e8 48 45 00 00       	call   80eaee <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a5a6:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80a5aa:	8b 15 94 b1 b3 00    	mov    0xb3b194,%edx
  80a5b0:	8d 42 01             	lea    0x1(%edx),%eax
  80a5b3:	a3 94 b1 b3 00       	mov    %eax,0xb3b194
    if (max_tid == (uint32_t)~0)
  80a5b8:	83 c4 10             	add    $0x10,%esp
  80a5bb:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a5be:	75 14                	jne    80a5d4 <thread_create+0x6c>
	panic("alloc_tid: no more thread ids");
  80a5c0:	83 ec 04             	sub    $0x4,%esp
  80a5c3:	68 22 24 81 00       	push   $0x812422
  80a5c8:	6a 54                	push   $0x54
  80a5ca:	68 40 24 81 00       	push   $0x812440
  80a5cf:	e8 7a 3e 00 00       	call   80e44e <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a5d4:	89 13                	mov    %edx,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a5d6:	83 ec 0c             	sub    $0xc,%esp
  80a5d9:	68 00 10 00 00       	push   $0x1000
  80a5de:	e8 f7 5b 00 00       	call   8101da <malloc>
  80a5e3:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a5e6:	83 c4 10             	add    $0x10,%esp
  80a5e9:	85 c0                	test   %eax,%eax
  80a5eb:	75 16                	jne    80a603 <thread_create+0x9b>
	free(tc);
  80a5ed:	83 ec 0c             	sub    $0xc,%esp
  80a5f0:	53                   	push   %ebx
  80a5f1:	e8 36 5b 00 00       	call   81012c <free>
	return -E_NO_MEM;
  80a5f6:	83 c4 10             	add    $0x10,%esp
  80a5f9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a5fe:	e9 83 00 00 00       	jmp    80a686 <thread_create+0x11e>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a603:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a609:	83 ec 04             	sub    $0x4,%esp
  80a60c:	6a 04                	push   $0x4
  80a60e:	6a 00                	push   $0x0
  80a610:	57                   	push   %edi
  80a611:	e8 db 45 00 00       	call   80ebf1 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a616:	83 c4 0c             	add    $0xc,%esp
  80a619:	6a 18                	push   $0x18
  80a61b:	6a 00                	push   $0x0
  80a61d:	8d 43 30             	lea    0x30(%ebx),%eax
  80a620:	50                   	push   %eax
  80a621:	e8 cb 45 00 00       	call   80ebf1 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a626:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a629:	c7 43 30 12 a8 80 00 	movl   $0x80a812,0x30(%ebx)
    tc->tc_entry = entry;
  80a630:	8b 45 10             	mov    0x10(%ebp),%eax
  80a633:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a636:	8b 45 14             	mov    0x14(%ebp),%eax
  80a639:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a63c:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a643:	83 c4 10             	add    $0x10,%esp
  80a646:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a64d:	75 0e                	jne    80a65d <thread_create+0xf5>
	tq->tq_first = tc;
  80a64f:	89 1d 88 b1 b3 00    	mov    %ebx,0xb3b188
	tq->tq_last = tc;
  80a655:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c
  80a65b:	eb 0e                	jmp    80a66b <thread_create+0x103>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a65d:	a1 8c b1 b3 00       	mov    0xb3b18c,%eax
  80a662:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a665:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c

    threadq_push(&thread_queue, tc);

    if (tid)
  80a66b:	85 f6                	test   %esi,%esi
  80a66d:	74 12                	je     80a681 <thread_create+0x119>
	*tid = tc->tc_tid;
  80a66f:	8b 03                	mov    (%ebx),%eax
  80a671:	89 06                	mov    %eax,(%esi)
    return 0;
  80a673:	b8 00 00 00 00       	mov    $0x0,%eax
  80a678:	eb 0c                	jmp    80a686 <thread_create+0x11e>
int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
    struct thread_context *tc = malloc(sizeof(struct thread_context));
    if (!tc)
	return -E_NO_MEM;
  80a67a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a67f:	eb 05                	jmp    80a686 <thread_create+0x11e>

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a681:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a686:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a689:	5b                   	pop    %ebx
  80a68a:	5e                   	pop    %esi
  80a68b:	5f                   	pop    %edi
  80a68c:	5d                   	pop    %ebp
  80a68d:	c3                   	ret    

0080a68e <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80a68e:	55                   	push   %ebp
  80a68f:	89 e5                	mov    %esp,%ebp
  80a691:	53                   	push   %ebx
  80a692:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a695:	8b 1d 88 b1 b3 00    	mov    0xb3b188,%ebx
  80a69b:	85 db                	test   %ebx,%ebx
  80a69d:	74 6d                	je     80a70c <thread_yield+0x7e>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a69f:	8b 43 64             	mov    0x64(%ebx),%eax
  80a6a2:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
    tc->tc_queue_link = 0;
  80a6a7:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80a6ae:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a6b3:	85 c0                	test   %eax,%eax
  80a6b5:	74 42                	je     80a6f9 <thread_yield+0x6b>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80a6b7:	83 ec 0c             	sub    $0xc,%esp
  80a6ba:	83 c0 30             	add    $0x30,%eax
  80a6bd:	50                   	push   %eax
  80a6be:	e8 6d 01 00 00       	call   80a830 <jos_setjmp>
  80a6c3:	83 c4 10             	add    $0x10,%esp
  80a6c6:	85 c0                	test   %eax,%eax
  80a6c8:	75 42                	jne    80a70c <thread_yield+0x7e>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80a6ca:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a6cf:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a6d6:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a6dd:	75 0c                	jne    80a6eb <thread_yield+0x5d>
	tq->tq_first = tc;
  80a6df:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
	tq->tq_last = tc;
  80a6e4:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
  80a6e9:	eb 0e                	jmp    80a6f9 <thread_yield+0x6b>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a6eb:	8b 15 8c b1 b3 00    	mov    0xb3b18c,%edx
  80a6f1:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a6f4:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
    }

    cur_tc = next_tc;
  80a6f9:	89 1d 90 b1 b3 00    	mov    %ebx,0xb3b190
    jos_longjmp(&cur_tc->tc_jb, 1);
  80a6ff:	8d 43 30             	lea    0x30(%ebx),%eax
  80a702:	ba 01 00 00 00       	mov    $0x1,%edx
  80a707:	e8 54 01 00 00       	call   80a860 <jos_longjmp>
}
  80a70c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a70f:	c9                   	leave  
  80a710:	c3                   	ret    

0080a711 <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80a711:	55                   	push   %ebp
  80a712:	89 e5                	mov    %esp,%ebp
  80a714:	57                   	push   %edi
  80a715:	56                   	push   %esi
  80a716:	53                   	push   %ebx
  80a717:	83 ec 0c             	sub    $0xc,%esp
  80a71a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a71d:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80a720:	e8 7b 49 00 00       	call   80f0a0 <sys_time_msec>
  80a725:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80a727:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a72c:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a72f:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
    uint32_t s = sys_time_msec();
    uint32_t p = s;
  80a733:	89 f0                	mov    %esi,%eax

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80a735:	eb 22                	jmp    80a759 <thread_wait+0x48>
	if (p < s)
	    break;
	if (addr && *addr != val)
  80a737:	85 db                	test   %ebx,%ebx
  80a739:	74 07                	je     80a742 <thread_wait+0x31>
  80a73b:	8b 03                	mov    (%ebx),%eax
  80a73d:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80a740:	75 1f                	jne    80a761 <thread_wait+0x50>
	    break;
	if (cur_tc->tc_wakeup)
  80a742:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a747:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80a74b:	84 c0                	test   %al,%al
  80a74d:	75 12                	jne    80a761 <thread_wait+0x50>
	    break;

	thread_yield();
  80a74f:	e8 3a ff ff ff       	call   80a68e <thread_yield>
	p = sys_time_msec();
  80a754:	e8 47 49 00 00       	call   80f0a0 <sys_time_msec>

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
	if (p < s)
  80a759:	39 f0                	cmp    %esi,%eax
  80a75b:	72 04                	jb     80a761 <thread_wait+0x50>
  80a75d:	39 f8                	cmp    %edi,%eax
  80a75f:	72 d6                	jb     80a737 <thread_wait+0x26>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80a761:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a766:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a76d:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80a771:	83 c4 0c             	add    $0xc,%esp
  80a774:	5b                   	pop    %ebx
  80a775:	5e                   	pop    %esi
  80a776:	5f                   	pop    %edi
  80a777:	5d                   	pop    %ebp
  80a778:	c3                   	ret    

0080a779 <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80a779:	55                   	push   %ebp
  80a77a:	89 e5                	mov    %esp,%ebp
  80a77c:	56                   	push   %esi
  80a77d:	53                   	push   %ebx
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a77e:	8b 1d 80 b1 b3 00    	mov    0xb3b180,%ebx
  80a784:	85 db                	test   %ebx,%ebx
  80a786:	74 40                	je     80a7c8 <thread_halt+0x4f>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a788:	8b 43 64             	mov    0x64(%ebx),%eax
  80a78b:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
    tc->tc_queue_link = 0;
  80a790:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80a797:	be 00 00 00 00       	mov    $0x0,%esi
  80a79c:	eb 0f                	jmp    80a7ad <thread_halt+0x34>
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
  80a79e:	83 ec 0c             	sub    $0xc,%esp
  80a7a1:	ff 33                	pushl  (%ebx)
  80a7a3:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a7a7:	83 c6 01             	add    $0x1,%esi
  80a7aa:	83 c4 10             	add    $0x10,%esp
  80a7ad:	3b 73 60             	cmp    0x60(%ebx),%esi
  80a7b0:	7c ec                	jl     80a79e <thread_halt+0x25>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80a7b2:	83 ec 0c             	sub    $0xc,%esp
  80a7b5:	ff 73 04             	pushl  0x4(%ebx)
  80a7b8:	e8 6f 59 00 00       	call   81012c <free>
    free(tc);
  80a7bd:	89 1c 24             	mov    %ebx,(%esp)
  80a7c0:	e8 67 59 00 00       	call   81012c <free>
  80a7c5:	83 c4 10             	add    $0x10,%esp
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80a7c8:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a7cd:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a7d4:	83 3d 80 b1 b3 00 00 	cmpl   $0x0,0xb3b180
  80a7db:	75 0c                	jne    80a7e9 <thread_halt+0x70>
	tq->tq_first = tc;
  80a7dd:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
	tq->tq_last = tc;
  80a7e2:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
  80a7e7:	eb 0e                	jmp    80a7f7 <thread_halt+0x7e>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a7e9:	8b 15 84 b1 b3 00    	mov    0xb3b184,%edx
  80a7ef:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a7f2:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
    cur_tc = NULL;
  80a7f7:	c7 05 90 b1 b3 00 00 	movl   $0x0,0xb3b190
  80a7fe:	00 00 00 
    thread_yield();
  80a801:	e8 88 fe ff ff       	call   80a68e <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80a806:	e8 29 3c 00 00       	call   80e434 <exit>
}
  80a80b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a80e:	5b                   	pop    %ebx
  80a80f:	5e                   	pop    %esi
  80a810:	5d                   	pop    %ebp
  80a811:	c3                   	ret    

0080a812 <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80a812:	55                   	push   %ebp
  80a813:	89 e5                	mov    %esp,%ebp
  80a815:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80a818:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a81d:	ff 70 2c             	pushl  0x2c(%eax)
  80a820:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80a823:	e8 51 ff ff ff       	call   80a779 <thread_halt>
}
  80a828:	83 c4 10             	add    $0x10,%esp
  80a82b:	c9                   	leave  
  80a82c:	c3                   	ret    
  80a82d:	66 90                	xchg   %ax,%ax
  80a82f:	90                   	nop

0080a830 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80a830:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80a834:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80a837:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80a839:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80a83d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80a840:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80a843:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80a846:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80a849:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80a84c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80a851:	c3                   	ret    
  80a852:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80a859:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080a860 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80a860:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80a862:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80a865:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80a868:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80a86b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80a86e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80a871:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80a873:	ff e1                	jmp    *%ecx

0080a875 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80a875:	55                   	push   %ebp
  80a876:	89 e5                	mov    %esp,%ebp
  80a878:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80a87b:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
};

void
perror(const char *s) {
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80a880:	ff 34 85 20 40 81 00 	pushl  0x814020(,%eax,4)
  80a887:	ff 75 08             	pushl  0x8(%ebp)
  80a88a:	68 5b 24 81 00       	push   $0x81245b
  80a88f:	e8 93 3c 00 00       	call   80e527 <cprintf>
}
  80a894:	83 c4 10             	add    $0x10,%esp
  80a897:	c9                   	leave  
  80a898:	c3                   	ret    

0080a899 <e2s>:

const char *
e2s(int err) {
  80a899:	55                   	push   %ebp
  80a89a:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80a89c:	8b 45 08             	mov    0x8(%ebp),%eax
  80a89f:	8b 04 85 20 40 81 00 	mov    0x814020(,%eax,4),%eax
}
  80a8a6:	5d                   	pop    %ebp
  80a8a7:	c3                   	ret    

0080a8a8 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80a8a8:	55                   	push   %ebp
  80a8a9:	89 e5                	mov    %esp,%ebp
  80a8ab:	57                   	push   %edi
  80a8ac:	56                   	push   %esi
  80a8ad:	53                   	push   %ebx
  80a8ae:	83 ec 20             	sub    $0x20,%esp
  80a8b1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80a8b4:	6a 07                	push   $0x7
  80a8b6:	68 00 00 00 10       	push   $0x10000000
  80a8bb:	6a 00                	push   $0x0
  80a8bd:	e8 ed 45 00 00       	call   80eeaf <sys_page_alloc>
    if (r < 0)
  80a8c2:	83 c4 10             	add    $0x10,%esp
  80a8c5:	85 c0                	test   %eax,%eax
  80a8c7:	79 14                	jns    80a8dd <low_level_output+0x35>
	panic("jif: could not allocate page of memory");
  80a8c9:	83 ec 04             	sub    $0x4,%esp
  80a8cc:	68 40 29 81 00       	push   $0x812940
  80a8d1:	6a 55                	push   $0x55
  80a8d3:	68 91 29 81 00       	push   $0x812991
  80a8d8:	e8 71 3b 00 00       	call   80e44e <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80a8dd:	8b 45 08             	mov    0x8(%ebp),%eax
  80a8e0:	8b 40 1c             	mov    0x1c(%eax),%eax
  80a8e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80a8e6:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80a8eb:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a8f0:	eb 46                	jmp    80a938 <low_level_output+0x90>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80a8f2:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a8f6:	0f b7 d0             	movzwl %ax,%edx
  80a8f9:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
  80a8fc:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80a902:	7e 16                	jle    80a91a <low_level_output+0x72>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80a904:	83 ec 0c             	sub    $0xc,%esp
  80a907:	56                   	push   %esi
  80a908:	52                   	push   %edx
  80a909:	68 68 29 81 00       	push   $0x812968
  80a90e:	6a 64                	push   $0x64
  80a910:	68 91 29 81 00       	push   $0x812991
  80a915:	e8 34 3b 00 00       	call   80e44e <_panic>
	memcpy(&txbuf[txsize], q->payload, q->len);
  80a91a:	83 ec 04             	sub    $0x4,%esp
  80a91d:	0f b7 c0             	movzwl %ax,%eax
  80a920:	50                   	push   %eax
  80a921:	ff 73 04             	pushl  0x4(%ebx)
  80a924:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80a927:	50                   	push   %eax
  80a928:	e8 79 43 00 00       	call   80eca6 <memcpy>
	txsize += q->len;
  80a92d:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a931:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a933:	8b 1b                	mov    (%ebx),%ebx
  80a935:	83 c4 10             	add    $0x10,%esp
  80a938:	85 db                	test   %ebx,%ebx
  80a93a:	75 b6                	jne    80a8f2 <low_level_output+0x4a>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80a93c:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80a942:	6a 07                	push   $0x7
  80a944:	68 00 00 00 10       	push   $0x10000000
  80a949:	6a 0b                	push   $0xb
  80a94b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a94e:	ff 70 04             	pushl  0x4(%eax)
  80a951:	e8 e4 4a 00 00       	call   80f43a <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80a956:	83 c4 08             	add    $0x8,%esp
  80a959:	68 00 00 00 10       	push   $0x10000000
  80a95e:	6a 00                	push   $0x0
  80a960:	e8 cf 45 00 00       	call   80ef34 <sys_page_unmap>

    return ERR_OK;
}
  80a965:	b8 00 00 00 00       	mov    $0x0,%eax
  80a96a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a96d:	5b                   	pop    %ebx
  80a96e:	5e                   	pop    %esi
  80a96f:	5f                   	pop    %edi
  80a970:	5d                   	pop    %ebp
  80a971:	c3                   	ret    

0080a972 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80a972:	55                   	push   %ebp
  80a973:	89 e5                	mov    %esp,%ebp
  80a975:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80a978:	ff 75 10             	pushl  0x10(%ebp)
  80a97b:	ff 75 0c             	pushl  0xc(%ebp)
  80a97e:	ff 75 08             	pushl  0x8(%ebp)
  80a981:	e8 0b f1 ff ff       	call   809a91 <etharp_output>
}
  80a986:	c9                   	leave  
  80a987:	c3                   	ret    

0080a988 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80a988:	55                   	push   %ebp
  80a989:	89 e5                	mov    %esp,%ebp
  80a98b:	57                   	push   %edi
  80a98c:	56                   	push   %esi
  80a98d:	53                   	push   %ebx
  80a98e:	83 ec 20             	sub    $0x20,%esp
  80a991:	8b 75 0c             	mov    0xc(%ebp),%esi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80a994:	8b 45 08             	mov    0x8(%ebp),%eax
  80a997:	8b 40 1c             	mov    0x1c(%eax),%eax
  80a99a:	89 45 d8             	mov    %eax,-0x28(%ebp)
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
    s16_t len = pkt->jp_len;
  80a99d:	8b 06                	mov    (%esi),%eax
  80a99f:	89 c3                	mov    %eax,%ebx

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80a9a1:	6a 03                	push   $0x3
  80a9a3:	0f b7 c0             	movzwl %ax,%eax
  80a9a6:	50                   	push   %eax
  80a9a7:	6a 03                	push   $0x3
  80a9a9:	e8 3d 9f ff ff       	call   8048eb <pbuf_alloc>
  80a9ae:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80a9b1:	83 c4 10             	add    $0x10,%esp
  80a9b4:	85 c0                	test   %eax,%eax
  80a9b6:	0f 84 b8 00 00 00    	je     80aa74 <jif_input+0xec>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80a9bc:	8d 56 04             	lea    0x4(%esi),%edx
  80a9bf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a9c2:	89 c6                	mov    %eax,%esi
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
  80a9c4:	bf 00 00 00 00       	mov    $0x0,%edi
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
	if (bytes > (len - copied))
  80a9c9:	0f bf c3             	movswl %bx,%eax
  80a9cc:	89 45 e0             	mov    %eax,-0x20(%ebp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80a9cf:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
	if (bytes > (len - copied))
  80a9d3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a9d6:	29 f8                	sub    %edi,%eax
  80a9d8:	39 c3                	cmp    %eax,%ebx
  80a9da:	0f 4f d8             	cmovg  %eax,%ebx
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80a9dd:	83 ec 04             	sub    $0x4,%esp
  80a9e0:	53                   	push   %ebx
  80a9e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a9e4:	01 f8                	add    %edi,%eax
  80a9e6:	50                   	push   %eax
  80a9e7:	ff 76 04             	pushl  0x4(%esi)
  80a9ea:	e8 b7 42 00 00       	call   80eca6 <memcpy>
	copied += bytes;
  80a9ef:	01 df                	add    %ebx,%edi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a9f1:	8b 36                	mov    (%esi),%esi
  80a9f3:	83 c4 10             	add    $0x10,%esp
  80a9f6:	85 f6                	test   %esi,%esi
  80a9f8:	75 d5                	jne    80a9cf <jif_input+0x47>
  80a9fa:	eb 54                	jmp    80aa50 <jif_input+0xc8>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80a9fc:	83 ec 08             	sub    $0x8,%esp
  80a9ff:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80aa02:	57                   	push   %edi
  80aa03:	ff 75 08             	pushl  0x8(%ebp)
  80aa06:	e8 e8 ea ff ff       	call   8094f3 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80aa0b:	83 c4 08             	add    $0x8,%esp
  80aa0e:	6a f2                	push   $0xfffffff2
  80aa10:	57                   	push   %edi
  80aa11:	e8 3d 9d ff ff       	call   804753 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80aa16:	83 c4 08             	add    $0x8,%esp
  80aa19:	ff 75 08             	pushl  0x8(%ebp)
  80aa1c:	57                   	push   %edi
  80aa1d:	8b 45 08             	mov    0x8(%ebp),%eax
  80aa20:	ff 50 10             	call   *0x10(%eax)
	break;
  80aa23:	83 c4 10             	add    $0x10,%esp
  80aa26:	eb 4c                	jmp    80aa74 <jif_input+0xec>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80aa28:	83 ec 04             	sub    $0x4,%esp
  80aa2b:	ff 75 dc             	pushl  -0x24(%ebp)
  80aa2e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80aa31:	ff 30                	pushl  (%eax)
  80aa33:	ff 75 08             	pushl  0x8(%ebp)
  80aa36:	e8 02 eb ff ff       	call   80953d <etharp_arp_input>
	break;
  80aa3b:	83 c4 10             	add    $0x10,%esp
  80aa3e:	eb 34                	jmp    80aa74 <jif_input+0xec>

    default:
	pbuf_free(p);
  80aa40:	83 ec 0c             	sub    $0xc,%esp
  80aa43:	ff 75 dc             	pushl  -0x24(%ebp)
  80aa46:	e8 da 9d ff ff       	call   804825 <pbuf_free>
  80aa4b:	83 c4 10             	add    $0x10,%esp
  80aa4e:	eb 24                	jmp    80aa74 <jif_input+0xec>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80aa50:	83 ec 0c             	sub    $0xc,%esp
  80aa53:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80aa56:	8b 40 04             	mov    0x4(%eax),%eax
  80aa59:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80aa5d:	50                   	push   %eax
  80aa5e:	e8 73 cc ff ff       	call   8076d6 <htons>
  80aa63:	83 c4 10             	add    $0x10,%esp
  80aa66:	66 3d 00 08          	cmp    $0x800,%ax
  80aa6a:	74 90                	je     80a9fc <jif_input+0x74>
  80aa6c:	66 3d 06 08          	cmp    $0x806,%ax
  80aa70:	74 b6                	je     80aa28 <jif_input+0xa0>
  80aa72:	eb cc                	jmp    80aa40 <jif_input+0xb8>
	break;

    default:
	pbuf_free(p);
    }
}
  80aa74:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aa77:	5b                   	pop    %ebx
  80aa78:	5e                   	pop    %esi
  80aa79:	5f                   	pop    %edi
  80aa7a:	5d                   	pop    %ebp
  80aa7b:	c3                   	ret    

0080aa7c <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80aa7c:	55                   	push   %ebp
  80aa7d:	89 e5                	mov    %esp,%ebp
  80aa7f:	57                   	push   %edi
  80aa80:	56                   	push   %esi
  80aa81:	53                   	push   %ebx
  80aa82:	83 ec 28             	sub    $0x28,%esp
  80aa85:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80aa88:	6a 08                	push   $0x8
  80aa8a:	e8 a6 97 ff ff       	call   804235 <mem_malloc>

    if (jif == NULL) {
  80aa8f:	83 c4 10             	add    $0x10,%esp
  80aa92:	85 c0                	test   %eax,%eax
  80aa94:	0f 84 81 00 00 00    	je     80ab1b <jif_init+0x9f>
  80aa9a:	89 c6                	mov    %eax,%esi
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80aa9c:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80aa9f:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80aaa2:	c7 43 14 72 a9 80 00 	movl   $0x80a972,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80aaa9:	c7 43 18 a8 a8 80 00 	movl   $0x80a8a8,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80aab0:	83 ec 04             	sub    $0x4,%esp
  80aab3:	6a 02                	push   $0x2
  80aab5:	68 84 36 81 00       	push   $0x813684
  80aaba:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80aabd:	50                   	push   %eax
  80aabe:	e8 e3 41 00 00       	call   80eca6 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80aac3:	8d 43 25             	lea    0x25(%ebx),%eax
  80aac6:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80aac8:	8b 07                	mov    (%edi),%eax
  80aaca:	89 46 04             	mov    %eax,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80aacd:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80aad1:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80aad7:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  80aadb:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80aadf:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80aae3:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80aae7:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80aaeb:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80aaef:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80aaf3:	c7 04 24 8b 0d 81 00 	movl   $0x810d8b,(%esp)
  80aafa:	e8 f0 cd ff ff       	call   8078ef <inet_addr>
  80aaff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80ab02:	83 c4 0c             	add    $0xc,%esp
  80ab05:	6a 00                	push   $0x0
  80ab07:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ab0a:	50                   	push   %eax
  80ab0b:	53                   	push   %ebx
  80ab0c:	e8 44 ed ff ff       	call   809855 <etharp_query>

    return ERR_OK;
  80ab11:	83 c4 10             	add    $0x10,%esp
  80ab14:	b8 00 00 00 00       	mov    $0x0,%eax
  80ab19:	eb 05                	jmp    80ab20 <jif_init+0xa4>

    jif = mem_malloc(sizeof(struct jif));

    if (jif == NULL) {
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  80ab1b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);

    return ERR_OK;
}
  80ab20:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ab23:	5b                   	pop    %ebx
  80ab24:	5e                   	pop    %esi
  80ab25:	5f                   	pop    %edi
  80ab26:	5d                   	pop    %ebp
  80ab27:	c3                   	ret    

0080ab28 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80ab28:	55                   	push   %ebp
  80ab29:	89 e5                	mov    %esp,%ebp
  80ab2b:	56                   	push   %esi
  80ab2c:	53                   	push   %ebx
  80ab2d:	83 ec 28             	sub    $0x28,%esp
  80ab30:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80ab33:	ff 75 10             	pushl  0x10(%ebp)
  80ab36:	ff 75 08             	pushl  0x8(%ebp)
  80ab39:	e8 02 0f 00 00       	call   80ba40 <netconn_alloc>
  
  if (conn != NULL ) {
  80ab3e:	83 c4 10             	add    $0x10,%esp
  80ab41:	85 c0                	test   %eax,%eax
  80ab43:	0f 84 bd 00 00 00    	je     80ac06 <netconn_new_with_proto_and_callback+0xde>
  80ab49:	89 c3                	mov    %eax,%ebx
    msg.function = do_newconn;
  80ab4b:	c7 45 e4 47 b9 80 00 	movl   $0x80b947,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80ab52:	89 f0                	mov    %esi,%eax
  80ab54:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80ab57:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80ab5a:	83 ec 0c             	sub    $0xc,%esp
  80ab5d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ab60:	50                   	push   %eax
  80ab61:	e8 9d 78 ff ff       	call   802403 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80ab66:	83 c4 10             	add    $0x10,%esp
  80ab69:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80ab6d:	0f 84 9a 00 00 00    	je     80ac0d <netconn_new_with_proto_and_callback+0xe5>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80ab73:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80ab77:	74 14                	je     80ab8d <netconn_new_with_proto_and_callback+0x65>
  80ab79:	83 ec 04             	sub    $0x4,%esp
  80ab7c:	68 a8 29 81 00       	push   $0x8129a8
  80ab81:	6a 52                	push   $0x52
  80ab83:	68 5a 2a 81 00       	push   $0x812a5a
  80ab88:	e8 c1 38 00 00       	call   80e44e <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ab8d:	8b 43 10             	mov    0x10(%ebx),%eax
  80ab90:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ab93:	75 14                	jne    80aba9 <netconn_new_with_proto_and_callback+0x81>
  80ab95:	83 ec 04             	sub    $0x4,%esp
  80ab98:	68 71 2a 81 00       	push   $0x812a71
  80ab9d:	6a 53                	push   $0x53
  80ab9f:	68 5a 2a 81 00       	push   $0x812a5a
  80aba4:	e8 a5 38 00 00       	call   80e44e <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80aba9:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80abad:	75 14                	jne    80abc3 <netconn_new_with_proto_and_callback+0x9b>
  80abaf:	83 ec 04             	sub    $0x4,%esp
  80abb2:	68 8a 2a 81 00       	push   $0x812a8a
  80abb7:	6a 54                	push   $0x54
  80abb9:	68 5a 2a 81 00       	push   $0x812a5a
  80abbe:	e8 8b 38 00 00       	call   80e44e <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80abc3:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80abc7:	74 14                	je     80abdd <netconn_new_with_proto_and_callback+0xb5>
  80abc9:	83 ec 04             	sub    $0x4,%esp
  80abcc:	68 cc 29 81 00       	push   $0x8129cc
  80abd1:	6a 55                	push   $0x55
  80abd3:	68 5a 2a 81 00       	push   $0x812a5a
  80abd8:	e8 71 38 00 00       	call   80e44e <_panic>
      sys_sem_free(conn->op_completed);
  80abdd:	83 ec 0c             	sub    $0xc,%esp
  80abe0:	50                   	push   %eax
  80abe1:	e8 c7 f1 ff ff       	call   809dad <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80abe6:	83 c4 04             	add    $0x4,%esp
  80abe9:	ff 73 14             	pushl  0x14(%ebx)
  80abec:	e8 45 f2 ff ff       	call   809e36 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80abf1:	83 c4 08             	add    $0x8,%esp
  80abf4:	53                   	push   %ebx
  80abf5:	6a 07                	push   $0x7
  80abf7:	e8 b6 98 ff ff       	call   8044b2 <memp_free>
      return NULL;
  80abfc:	83 c4 10             	add    $0x10,%esp
  80abff:	b8 00 00 00 00       	mov    $0x0,%eax
  80ac04:	eb 09                	jmp    80ac0f <netconn_new_with_proto_and_callback+0xe7>
    }
  }
  return conn;
  80ac06:	b8 00 00 00 00       	mov    $0x0,%eax
  80ac0b:	eb 02                	jmp    80ac0f <netconn_new_with_proto_and_callback+0xe7>
  80ac0d:	89 d8                	mov    %ebx,%eax
}
  80ac0f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ac12:	5b                   	pop    %ebx
  80ac13:	5e                   	pop    %esi
  80ac14:	5d                   	pop    %ebp
  80ac15:	c3                   	ret    

0080ac16 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80ac16:	55                   	push   %ebp
  80ac17:	89 e5                	mov    %esp,%ebp
  80ac19:	53                   	push   %ebx
  80ac1a:	83 ec 24             	sub    $0x24,%esp
  80ac1d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80ac20:	85 db                	test   %ebx,%ebx
  80ac22:	74 28                	je     80ac4c <netconn_delete+0x36>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80ac24:	c7 45 e4 88 bc 80 00 	movl   $0x80bc88,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ac2b:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80ac2e:	83 ec 0c             	sub    $0xc,%esp
  80ac31:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ac34:	50                   	push   %eax
  80ac35:	e8 c9 77 ff ff       	call   802403 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80ac3a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80ac41:	89 1c 24             	mov    %ebx,(%esp)
  80ac44:	e8 b0 0e 00 00       	call   80baf9 <netconn_free>

  return ERR_OK;
  80ac49:	83 c4 10             	add    $0x10,%esp
}
  80ac4c:	b8 00 00 00 00       	mov    $0x0,%eax
  80ac51:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ac54:	c9                   	leave  
  80ac55:	c3                   	ret    

0080ac56 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80ac56:	55                   	push   %ebp
  80ac57:	89 e5                	mov    %esp,%ebp
  80ac59:	83 ec 08             	sub    $0x8,%esp
  80ac5c:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80ac5f:	85 c0                	test   %eax,%eax
  80ac61:	75 17                	jne    80ac7a <netconn_type+0x24>
  80ac63:	83 ec 04             	sub    $0x4,%esp
  80ac66:	68 9f 2a 81 00       	push   $0x812a9f
  80ac6b:	68 84 00 00 00       	push   $0x84
  80ac70:	68 5a 2a 81 00       	push   $0x812a5a
  80ac75:	e8 d4 37 00 00       	call   80e44e <_panic>
  80ac7a:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80ac7c:	c9                   	leave  
  80ac7d:	c3                   	ret    

0080ac7e <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80ac7e:	55                   	push   %ebp
  80ac7f:	89 e5                	mov    %esp,%ebp
  80ac81:	53                   	push   %ebx
  80ac82:	83 ec 24             	sub    $0x24,%esp
  80ac85:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ac88:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ac8b:	8b 45 10             	mov    0x10(%ebp),%eax
  80ac8e:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80ac91:	85 db                	test   %ebx,%ebx
  80ac93:	75 17                	jne    80acac <netconn_getaddr+0x2e>
  80ac95:	83 ec 04             	sub    $0x4,%esp
  80ac98:	68 ba 2a 81 00       	push   $0x812aba
  80ac9d:	68 98 00 00 00       	push   $0x98
  80aca2:	68 5a 2a 81 00       	push   $0x812a5a
  80aca7:	e8 a2 37 00 00       	call   80e44e <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80acac:	85 d2                	test   %edx,%edx
  80acae:	75 17                	jne    80acc7 <netconn_getaddr+0x49>
  80acb0:	83 ec 04             	sub    $0x4,%esp
  80acb3:	68 d8 2a 81 00       	push   $0x812ad8
  80acb8:	68 99 00 00 00       	push   $0x99
  80acbd:	68 5a 2a 81 00       	push   $0x812a5a
  80acc2:	e8 87 37 00 00       	call   80e44e <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80acc7:	85 c0                	test   %eax,%eax
  80acc9:	75 17                	jne    80ace2 <netconn_getaddr+0x64>
  80accb:	83 ec 04             	sub    $0x4,%esp
  80acce:	68 f6 2a 81 00       	push   $0x812af6
  80acd3:	68 9a 00 00 00       	push   $0x9a
  80acd8:	68 5a 2a 81 00       	push   $0x812a5a
  80acdd:	e8 6c 37 00 00       	call   80e44e <_panic>

  msg.function = do_getaddr;
  80ace2:	c7 45 e4 d7 c0 80 00 	movl   $0x80c0d7,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ace9:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80acec:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80acef:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80acf2:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80acf5:	83 ec 0c             	sub    $0xc,%esp
  80acf8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80acfb:	50                   	push   %eax
  80acfc:	e8 02 77 ff ff       	call   802403 <tcpip_apimsg>

  return conn->err;
  80ad01:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ad05:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad08:	c9                   	leave  
  80ad09:	c3                   	ret    

0080ad0a <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ad0a:	55                   	push   %ebp
  80ad0b:	89 e5                	mov    %esp,%ebp
  80ad0d:	53                   	push   %ebx
  80ad0e:	83 ec 24             	sub    $0x24,%esp
  80ad11:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ad14:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad17:	85 db                	test   %ebx,%ebx
  80ad19:	75 17                	jne    80ad32 <netconn_bind+0x28>
  80ad1b:	83 ec 04             	sub    $0x4,%esp
  80ad1e:	68 14 2b 81 00       	push   $0x812b14
  80ad23:	68 b5 00 00 00       	push   $0xb5
  80ad28:	68 5a 2a 81 00       	push   $0x812a5a
  80ad2d:	e8 1c 37 00 00       	call   80e44e <_panic>

  msg.function = do_bind;
  80ad32:	c7 45 e4 31 bd 80 00 	movl   $0x80bd31,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad39:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ad3c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ad3f:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80ad42:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80ad46:	83 ec 0c             	sub    $0xc,%esp
  80ad49:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad4c:	50                   	push   %eax
  80ad4d:	e8 b1 76 ff ff       	call   802403 <tcpip_apimsg>
  return conn->err;
  80ad52:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ad56:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad59:	c9                   	leave  
  80ad5a:	c3                   	ret    

0080ad5b <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ad5b:	55                   	push   %ebp
  80ad5c:	89 e5                	mov    %esp,%ebp
  80ad5e:	53                   	push   %ebx
  80ad5f:	83 ec 24             	sub    $0x24,%esp
  80ad62:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ad65:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad68:	85 db                	test   %ebx,%ebx
  80ad6a:	75 17                	jne    80ad83 <netconn_connect+0x28>
  80ad6c:	83 ec 04             	sub    $0x4,%esp
  80ad6f:	68 2f 2b 81 00       	push   $0x812b2f
  80ad74:	68 cc 00 00 00       	push   $0xcc
  80ad79:	68 5a 2a 81 00       	push   $0x812a5a
  80ad7e:	e8 cb 36 00 00       	call   80e44e <_panic>

  msg.function = do_connect;
  80ad83:	c7 45 e4 c1 bd 80 00 	movl   $0x80bdc1,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad8a:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ad8d:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ad90:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80ad93:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80ad97:	83 ec 0c             	sub    $0xc,%esp
  80ad9a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad9d:	50                   	push   %eax
  80ad9e:	e8 60 76 ff ff       	call   802403 <tcpip_apimsg>
  return conn->err;
  80ada3:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ada7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80adaa:	c9                   	leave  
  80adab:	c3                   	ret    

0080adac <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80adac:	55                   	push   %ebp
  80adad:	89 e5                	mov    %esp,%ebp
  80adaf:	53                   	push   %ebx
  80adb0:	83 ec 24             	sub    $0x24,%esp
  80adb3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80adb6:	85 db                	test   %ebx,%ebx
  80adb8:	75 17                	jne    80add1 <netconn_disconnect+0x25>
  80adba:	83 ec 04             	sub    $0x4,%esp
  80adbd:	68 f0 29 81 00       	push   $0x8129f0
  80adc2:	68 e2 00 00 00       	push   $0xe2
  80adc7:	68 5a 2a 81 00       	push   $0x812a5a
  80adcc:	e8 7d 36 00 00       	call   80e44e <_panic>

  msg.function = do_disconnect;
  80add1:	c7 45 e4 76 be 80 00 	movl   $0x80be76,-0x1c(%ebp)
  msg.msg.conn = conn;
  80add8:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80addb:	83 ec 0c             	sub    $0xc,%esp
  80adde:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ade1:	50                   	push   %eax
  80ade2:	e8 1c 76 ff ff       	call   802403 <tcpip_apimsg>
  return conn->err;
  80ade7:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80adeb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80adee:	c9                   	leave  
  80adef:	c3                   	ret    

0080adf0 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80adf0:	55                   	push   %ebp
  80adf1:	89 e5                	mov    %esp,%ebp
  80adf3:	53                   	push   %ebx
  80adf4:	83 ec 24             	sub    $0x24,%esp
  80adf7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80adfa:	85 db                	test   %ebx,%ebx
  80adfc:	75 17                	jne    80ae15 <netconn_listen_with_backlog+0x25>
  80adfe:	83 ec 04             	sub    $0x4,%esp
  80ae01:	68 4d 2b 81 00       	push   $0x812b4d
  80ae06:	68 fa 00 00 00       	push   $0xfa
  80ae0b:	68 5a 2a 81 00       	push   $0x812a5a
  80ae10:	e8 39 36 00 00       	call   80e44e <_panic>

  msg.function = do_listen;
  80ae15:	c7 45 e4 b1 be 80 00 	movl   $0x80beb1,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ae1c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80ae1f:	83 ec 0c             	sub    $0xc,%esp
  80ae22:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ae25:	50                   	push   %eax
  80ae26:	e8 d8 75 ff ff       	call   802403 <tcpip_apimsg>
  return conn->err;
  80ae2b:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ae2f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ae32:	c9                   	leave  
  80ae33:	c3                   	ret    

0080ae34 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80ae34:	55                   	push   %ebp
  80ae35:	89 e5                	mov    %esp,%ebp
  80ae37:	53                   	push   %ebx
  80ae38:	83 ec 14             	sub    $0x14,%esp
  80ae3b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80ae3e:	85 db                	test   %ebx,%ebx
  80ae40:	75 17                	jne    80ae59 <netconn_accept+0x25>
  80ae42:	83 ec 04             	sub    $0x4,%esp
  80ae45:	68 6a 2b 81 00       	push   $0x812b6a
  80ae4a:	68 10 01 00 00       	push   $0x110
  80ae4f:	68 5a 2a 81 00       	push   $0x812a5a
  80ae54:	e8 f5 35 00 00       	call   80e44e <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80ae59:	8b 43 18             	mov    0x18(%ebx),%eax
  80ae5c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ae5f:	75 17                	jne    80ae78 <netconn_accept+0x44>
  80ae61:	83 ec 04             	sub    $0x4,%esp
  80ae64:	68 14 2a 81 00       	push   $0x812a14
  80ae69:	68 11 01 00 00       	push   $0x111
  80ae6e:	68 5a 2a 81 00       	push   $0x812a5a
  80ae73:	e8 d6 35 00 00       	call   80e44e <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80ae78:	83 ec 04             	sub    $0x4,%esp
  80ae7b:	6a 00                	push   $0x0
  80ae7d:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80ae80:	52                   	push   %edx
  80ae81:	50                   	push   %eax
  80ae82:	e8 c0 f3 ff ff       	call   80a247 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80ae87:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ae8a:	83 c4 10             	add    $0x10,%esp
  80ae8d:	85 c0                	test   %eax,%eax
  80ae8f:	74 0d                	je     80ae9e <netconn_accept+0x6a>
  80ae91:	83 ec 04             	sub    $0x4,%esp
  80ae94:	6a 00                	push   $0x0
  80ae96:	6a 01                	push   $0x1
  80ae98:	53                   	push   %ebx
  80ae99:	ff d0                	call   *%eax
  80ae9b:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80ae9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80aea1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80aea4:	c9                   	leave  
  80aea5:	c3                   	ret    

0080aea6 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80aea6:	55                   	push   %ebp
  80aea7:	89 e5                	mov    %esp,%ebp
  80aea9:	53                   	push   %ebx
  80aeaa:	83 ec 24             	sub    $0x24,%esp
  80aead:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80aeb0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80aeb7:	85 db                	test   %ebx,%ebx
  80aeb9:	75 17                	jne    80aed2 <netconn_recv+0x2c>
  80aebb:	83 ec 04             	sub    $0x4,%esp
  80aebe:	68 87 2b 81 00       	push   $0x812b87
  80aec3:	68 3a 01 00 00       	push   $0x13a
  80aec8:	68 5a 2a 81 00       	push   $0x812a5a
  80aecd:	e8 7c 35 00 00       	call   80e44e <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80aed2:	8b 43 14             	mov    0x14(%ebx),%eax
  80aed5:	83 f8 ff             	cmp    $0xffffffff,%eax
  80aed8:	75 0e                	jne    80aee8 <netconn_recv+0x42>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80aeda:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80aede:	b8 00 00 00 00       	mov    $0x0,%eax
  80aee3:	e9 5b 01 00 00       	jmp    80b043 <netconn_recv+0x19d>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80aee8:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80aeec:	0f 8c 3a 01 00 00    	jl     80b02c <netconn_recv+0x186>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80aef2:	83 3b 10             	cmpl   $0x10,(%ebx)
  80aef5:	0f 85 f0 00 00 00    	jne    80afeb <netconn_recv+0x145>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80aefb:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80aeff:	75 0e                	jne    80af0f <netconn_recv+0x69>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80af01:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80af05:	b8 00 00 00 00       	mov    $0x0,%eax
  80af0a:	e9 34 01 00 00       	jmp    80b043 <netconn_recv+0x19d>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80af0f:	83 ec 0c             	sub    $0xc,%esp
  80af12:	6a 06                	push   $0x6
  80af14:	e8 43 95 ff ff       	call   80445c <memp_malloc>
  80af19:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80af1c:	83 c4 10             	add    $0x10,%esp
  80af1f:	85 c0                	test   %eax,%eax
  80af21:	75 09                	jne    80af2c <netconn_recv+0x86>
      conn->err = ERR_MEM;
  80af23:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80af27:	e9 17 01 00 00       	jmp    80b043 <netconn_recv+0x19d>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80af2c:	83 ec 04             	sub    $0x4,%esp
  80af2f:	6a 00                	push   $0x0
  80af31:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80af34:	50                   	push   %eax
  80af35:	ff 73 14             	pushl  0x14(%ebx)
  80af38:	e8 0a f3 ff ff       	call   80a247 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80af3d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80af40:	83 c4 10             	add    $0x10,%esp
  80af43:	85 c0                	test   %eax,%eax
  80af45:	0f 84 e8 00 00 00    	je     80b033 <netconn_recv+0x18d>
      len = p->tot_len;
  80af4b:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80af4f:	66 29 53 20          	sub    %dx,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80af53:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80af56:	85 c9                	test   %ecx,%ecx
  80af58:	75 07                	jne    80af61 <netconn_recv+0xbb>
  80af5a:	eb 43                	jmp    80af9f <netconn_recv+0xf9>

    if (p != NULL) {
      len = p->tot_len;
      SYS_ARCH_DEC(conn->recv_avail, len);
    } else {
      len = 0;
  80af5c:	ba 00 00 00 00       	mov    $0x0,%edx
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80af61:	83 ec 04             	sub    $0x4,%esp
  80af64:	0f b7 d2             	movzwl %dx,%edx
  80af67:	52                   	push   %edx
  80af68:	6a 01                	push   $0x1
  80af6a:	53                   	push   %ebx
  80af6b:	ff d1                	call   *%ecx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80af6d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80af70:	83 c4 10             	add    $0x10,%esp
  80af73:	85 c0                	test   %eax,%eax
  80af75:	75 28                	jne    80af9f <netconn_recv+0xf9>
      memp_free(MEMP_NETBUF, buf);
  80af77:	83 ec 08             	sub    $0x8,%esp
  80af7a:	ff 75 e0             	pushl  -0x20(%ebp)
  80af7d:	6a 06                	push   $0x6
  80af7f:	e8 2e 95 ff ff       	call   8044b2 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80af84:	83 c4 10             	add    $0x10,%esp
        conn->err = ERR_CLSD;
      }
      return NULL;
  80af87:	b8 00 00 00 00       	mov    $0x0,%eax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
      memp_free(MEMP_NETBUF, buf);
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80af8c:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80af90:	0f 85 ad 00 00 00    	jne    80b043 <netconn_recv+0x19d>
        conn->err = ERR_CLSD;
  80af96:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80af9a:	e9 a4 00 00 00       	jmp    80b043 <netconn_recv+0x19d>
      }
      return NULL;
    }

    buf->p = p;
  80af9f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80afa2:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80afa4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80afa7:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80afaa:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80afad:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80afb3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80afba:	c7 45 e4 43 c0 80 00 	movl   $0x80c043,-0x1c(%ebp)
    msg.msg.conn = conn;
  80afc1:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80afc4:	85 c0                	test   %eax,%eax
  80afc6:	74 0c                	je     80afd4 <netconn_recv+0x12e>
      msg.msg.msg.r.len = buf->p->tot_len;
  80afc8:	8b 00                	mov    (%eax),%eax
  80afca:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80afce:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80afd2:	eb 06                	jmp    80afda <netconn_recv+0x134>
    } else {
      msg.msg.msg.r.len = 1;
  80afd4:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80afda:	83 ec 0c             	sub    $0xc,%esp
  80afdd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80afe0:	50                   	push   %eax
  80afe1:	e8 1d 74 ff ff       	call   802403 <tcpip_apimsg>
  80afe6:	83 c4 10             	add    $0x10,%esp
  80afe9:	eb 3c                	jmp    80b027 <netconn_recv+0x181>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80afeb:	83 ec 04             	sub    $0x4,%esp
  80afee:	6a 00                	push   $0x0
  80aff0:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80aff3:	52                   	push   %edx
  80aff4:	50                   	push   %eax
  80aff5:	e8 4d f2 ff ff       	call   80a247 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80affa:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80affd:	83 c4 10             	add    $0x10,%esp
  80b000:	85 c0                	test   %eax,%eax
  80b002:	74 23                	je     80b027 <netconn_recv+0x181>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80b004:	8b 10                	mov    (%eax),%edx
  80b006:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80b00a:	66 29 53 20          	sub    %dx,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80b00e:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b011:	85 d2                	test   %edx,%edx
  80b013:	74 12                	je     80b027 <netconn_recv+0x181>
  80b015:	83 ec 04             	sub    $0x4,%esp
  80b018:	8b 00                	mov    (%eax),%eax
  80b01a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b01e:	50                   	push   %eax
  80b01f:	6a 01                	push   $0x1
  80b021:	53                   	push   %ebx
  80b022:	ff d2                	call   *%edx
  80b024:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80b027:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b02a:	eb 17                	jmp    80b043 <netconn_recv+0x19d>
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
    return NULL;
  80b02c:	b8 00 00 00 00       	mov    $0x0,%eax
  80b031:	eb 10                	jmp    80b043 <netconn_recv+0x19d>
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b033:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80b036:	85 c9                	test   %ecx,%ecx
  80b038:	0f 85 1e ff ff ff    	jne    80af5c <netconn_recv+0xb6>
  80b03e:	e9 34 ff ff ff       	jmp    80af77 <netconn_recv+0xd1>
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
}
  80b043:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b046:	c9                   	leave  
  80b047:	c3                   	ret    

0080b048 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b048:	55                   	push   %ebp
  80b049:	89 e5                	mov    %esp,%ebp
  80b04b:	53                   	push   %ebx
  80b04c:	83 ec 24             	sub    $0x24,%esp
  80b04f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b052:	85 db                	test   %ebx,%ebx
  80b054:	75 17                	jne    80b06d <netconn_send+0x25>
  80b056:	83 ec 04             	sub    $0x4,%esp
  80b059:	68 a2 2b 81 00       	push   $0x812ba2
  80b05e:	68 b9 01 00 00       	push   $0x1b9
  80b063:	68 5a 2a 81 00       	push   $0x812a5a
  80b068:	e8 e1 33 00 00       	call   80e44e <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b06d:	c7 45 e4 9d bf 80 00 	movl   $0x80bf9d,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b074:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b077:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b07a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b07d:	83 ec 0c             	sub    $0xc,%esp
  80b080:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b083:	50                   	push   %eax
  80b084:	e8 7a 73 ff ff       	call   802403 <tcpip_apimsg>
  return conn->err;
  80b089:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b08d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b090:	c9                   	leave  
  80b091:	c3                   	ret    

0080b092 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80b092:	55                   	push   %ebp
  80b093:	89 e5                	mov    %esp,%ebp
  80b095:	83 ec 08             	sub    $0x8,%esp
  80b098:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b09b:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80b09e:	85 c0                	test   %eax,%eax
  80b0a0:	74 1b                	je     80b0bd <netconn_sendto+0x2b>
    buf->addr = addr;
  80b0a2:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80b0a5:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80b0a8:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80b0ac:	83 ec 08             	sub    $0x8,%esp
  80b0af:	50                   	push   %eax
  80b0b0:	ff 75 08             	pushl  0x8(%ebp)
  80b0b3:	e8 90 ff ff ff       	call   80b048 <netconn_send>
  80b0b8:	83 c4 10             	add    $0x10,%esp
  80b0bb:	eb 05                	jmp    80b0c2 <netconn_sendto+0x30>
  }
  return ERR_VAL;
  80b0bd:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80b0c2:	c9                   	leave  
  80b0c3:	c3                   	ret    

0080b0c4 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b0c4:	55                   	push   %ebp
  80b0c5:	89 e5                	mov    %esp,%ebp
  80b0c7:	53                   	push   %ebx
  80b0c8:	83 ec 24             	sub    $0x24,%esp
  80b0cb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b0ce:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b0d1:	85 db                	test   %ebx,%ebx
  80b0d3:	75 17                	jne    80b0ec <netconn_write+0x28>
  80b0d5:	83 ec 04             	sub    $0x4,%esp
  80b0d8:	68 bd 2b 81 00       	push   $0x812bbd
  80b0dd:	68 d3 01 00 00       	push   $0x1d3
  80b0e2:	68 5a 2a 81 00       	push   $0x812a5a
  80b0e7:	e8 62 33 00 00       	call   80e44e <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b0ec:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b0ef:	74 17                	je     80b108 <netconn_write+0x44>
  80b0f1:	83 ec 04             	sub    $0x4,%esp
  80b0f4:	68 38 2a 81 00       	push   $0x812a38
  80b0f9:	68 d4 01 00 00       	push   $0x1d4
  80b0fe:	68 5a 2a 81 00       	push   $0x812a5a
  80b103:	e8 46 33 00 00       	call   80e44e <_panic>

  msg.function = do_write;
  80b108:	c7 45 e4 87 c0 80 00 	movl   $0x80c087,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b10f:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b112:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b115:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b118:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b11b:	8b 45 10             	mov    0x10(%ebp),%eax
  80b11e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b121:	83 ec 0c             	sub    $0xc,%esp
  80b124:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b127:	50                   	push   %eax
  80b128:	e8 d6 72 ff ff       	call   802403 <tcpip_apimsg>
  return conn->err;
  80b12d:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b131:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b134:	c9                   	leave  
  80b135:	c3                   	ret    

0080b136 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b136:	55                   	push   %ebp
  80b137:	89 e5                	mov    %esp,%ebp
  80b139:	53                   	push   %ebx
  80b13a:	83 ec 24             	sub    $0x24,%esp
  80b13d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b140:	85 db                	test   %ebx,%ebx
  80b142:	75 17                	jne    80b15b <netconn_close+0x25>
  80b144:	83 ec 04             	sub    $0x4,%esp
  80b147:	68 d9 2b 81 00       	push   $0x812bd9
  80b14c:	68 ed 01 00 00       	push   $0x1ed
  80b151:	68 5a 2a 81 00       	push   $0x812a5a
  80b156:	e8 f3 32 00 00       	call   80e44e <_panic>

  msg.function = do_close;
  80b15b:	c7 45 e4 9b c1 80 00 	movl   $0x80c19b,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b162:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b165:	83 ec 0c             	sub    $0xc,%esp
  80b168:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b16b:	50                   	push   %eax
  80b16c:	e8 92 72 ff ff       	call   802403 <tcpip_apimsg>
  return conn->err;
  80b171:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b175:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b178:	c9                   	leave  
  80b179:	c3                   	ret    

0080b17a <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b17a:	55                   	push   %ebp
  80b17b:	89 e5                	mov    %esp,%ebp
  80b17d:	56                   	push   %esi
  80b17e:	53                   	push   %ebx
  80b17f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b182:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b185:	8b 75 10             	mov    0x10(%ebp),%esi
  80b188:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b18b:	85 c0                	test   %eax,%eax
  80b18d:	75 17                	jne    80b1a6 <recv_tcp+0x2c>
  80b18f:	83 ec 04             	sub    $0x4,%esp
  80b192:	68 f8 2b 81 00       	push   $0x812bf8
  80b197:	68 c1 00 00 00       	push   $0xc1
  80b19c:	68 42 2d 81 00       	push   $0x812d42
  80b1a1:	e8 a8 32 00 00       	call   80e44e <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b1a6:	85 db                	test   %ebx,%ebx
  80b1a8:	75 17                	jne    80b1c1 <recv_tcp+0x47>
  80b1aa:	83 ec 04             	sub    $0x4,%esp
  80b1ad:	68 1c 2c 81 00       	push   $0x812c1c
  80b1b2:	68 c2 00 00 00       	push   $0xc2
  80b1b7:	68 42 2d 81 00       	push   $0x812d42
  80b1bc:	e8 8d 32 00 00       	call   80e44e <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b1c1:	3b 43 08             	cmp    0x8(%ebx),%eax
  80b1c4:	74 17                	je     80b1dd <recv_tcp+0x63>
  80b1c6:	83 ec 04             	sub    $0x4,%esp
  80b1c9:	68 59 2d 81 00       	push   $0x812d59
  80b1ce:	68 c4 00 00 00       	push   $0xc4
  80b1d3:	68 42 2d 81 00       	push   $0x812d42
  80b1d8:	e8 71 32 00 00       	call   80e44e <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b1dd:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b1e1:	74 44                	je     80b227 <recv_tcp+0xad>
    return ERR_VAL;
  }

  conn->err = err;
  80b1e3:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80b1e6:	85 f6                	test   %esi,%esi
  80b1e8:	74 0a                	je     80b1f4 <recv_tcp+0x7a>
    len = p->tot_len;
  80b1ea:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b1ee:	66 01 43 20          	add    %ax,0x20(%ebx)
  80b1f2:	eb 05                	jmp    80b1f9 <recv_tcp+0x7f>
  } else {
    len = 0;
  80b1f4:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b1f9:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b1fc:	85 d2                	test   %edx,%edx
  80b1fe:	74 0f                	je     80b20f <recv_tcp+0x95>
  80b200:	83 ec 04             	sub    $0x4,%esp
  80b203:	0f b7 c0             	movzwl %ax,%eax
  80b206:	50                   	push   %eax
  80b207:	6a 00                	push   $0x0
  80b209:	53                   	push   %ebx
  80b20a:	ff d2                	call   *%edx
  80b20c:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b20f:	83 ec 08             	sub    $0x8,%esp
  80b212:	56                   	push   %esi
  80b213:	ff 73 14             	pushl  0x14(%ebx)
  80b216:	e8 39 ef ff ff       	call   80a154 <sys_mbox_trypost>
  80b21b:	83 c4 10             	add    $0x10,%esp
  80b21e:	84 c0                	test   %al,%al
  80b220:	0f 95 c0             	setne  %al
  80b223:	f7 d8                	neg    %eax
  80b225:	eb 05                	jmp    80b22c <recv_tcp+0xb2>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
    return ERR_VAL;
  80b227:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b22c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b22f:	5b                   	pop    %ebx
  80b230:	5e                   	pop    %esi
  80b231:	5d                   	pop    %ebp
  80b232:	c3                   	ret    

0080b233 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80b233:	55                   	push   %ebp
  80b234:	89 e5                	mov    %esp,%ebp
  80b236:	57                   	push   %edi
  80b237:	56                   	push   %esi
  80b238:	53                   	push   %ebx
  80b239:	83 ec 1c             	sub    $0x1c,%esp
  80b23c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b23f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b242:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b245:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b248:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b24b:	85 c0                	test   %eax,%eax
  80b24d:	75 17                	jne    80b266 <recv_udp+0x33>
  80b24f:	83 ec 04             	sub    $0x4,%esp
  80b252:	68 3c 2c 81 00       	push   $0x812c3c
  80b257:	68 8e 00 00 00       	push   $0x8e
  80b25c:	68 42 2d 81 00       	push   $0x812d42
  80b261:	e8 e8 31 00 00       	call   80e44e <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b266:	85 db                	test   %ebx,%ebx
  80b268:	75 17                	jne    80b281 <recv_udp+0x4e>
  80b26a:	83 ec 04             	sub    $0x4,%esp
  80b26d:	68 60 2c 81 00       	push   $0x812c60
  80b272:	68 8f 00 00 00       	push   $0x8f
  80b277:	68 42 2d 81 00       	push   $0x812d42
  80b27c:	e8 cd 31 00 00       	call   80e44e <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b281:	3b 43 08             	cmp    0x8(%ebx),%eax
  80b284:	74 17                	je     80b29d <recv_udp+0x6a>
  80b286:	83 ec 04             	sub    $0x4,%esp
  80b289:	68 77 2d 81 00       	push   $0x812d77
  80b28e:	68 91 00 00 00       	push   $0x91
  80b293:	68 42 2d 81 00       	push   $0x812d42
  80b298:	e8 b1 31 00 00       	call   80e44e <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b29d:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b2a1:	75 0e                	jne    80b2b1 <recv_udp+0x7e>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80b2a3:	83 ec 0c             	sub    $0xc,%esp
  80b2a6:	57                   	push   %edi
  80b2a7:	e8 79 95 ff ff       	call   804825 <pbuf_free>
    return;
  80b2ac:	83 c4 10             	add    $0x10,%esp
  80b2af:	eb 72                	jmp    80b323 <recv_udp+0xf0>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80b2b1:	83 ec 0c             	sub    $0xc,%esp
  80b2b4:	6a 06                	push   $0x6
  80b2b6:	e8 a1 91 ff ff       	call   80445c <memp_malloc>
  80b2bb:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b2bd:	83 c4 10             	add    $0x10,%esp
  80b2c0:	85 c0                	test   %eax,%eax
  80b2c2:	75 0e                	jne    80b2d2 <recv_udp+0x9f>
    pbuf_free(p);
  80b2c4:	83 ec 0c             	sub    $0xc,%esp
  80b2c7:	57                   	push   %edi
  80b2c8:	e8 58 95 ff ff       	call   804825 <pbuf_free>
    return;
  80b2cd:	83 c4 10             	add    $0x10,%esp
  80b2d0:	eb 51                	jmp    80b323 <recv_udp+0xf0>
  } else {
    buf->p = p;
  80b2d2:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b2d4:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b2d7:	8b 45 14             	mov    0x14(%ebp),%eax
  80b2da:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b2dd:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b2e1:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b2e5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b2e9:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b2ed:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b2f0:	85 c0                	test   %eax,%eax
  80b2f2:	74 10                	je     80b304 <recv_udp+0xd1>
  80b2f4:	83 ec 04             	sub    $0x4,%esp
  80b2f7:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b2fb:	52                   	push   %edx
  80b2fc:	6a 00                	push   $0x0
  80b2fe:	53                   	push   %ebx
  80b2ff:	ff d0                	call   *%eax
  80b301:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b304:	83 ec 08             	sub    $0x8,%esp
  80b307:	56                   	push   %esi
  80b308:	ff 73 14             	pushl  0x14(%ebx)
  80b30b:	e8 44 ee ff ff       	call   80a154 <sys_mbox_trypost>
  80b310:	83 c4 10             	add    $0x10,%esp
  80b313:	84 c0                	test   %al,%al
  80b315:	74 0c                	je     80b323 <recv_udp+0xf0>
    netbuf_delete(buf);
  80b317:	83 ec 0c             	sub    $0xc,%esp
  80b31a:	56                   	push   %esi
  80b31b:	e8 d3 71 ff ff       	call   8024f3 <netbuf_delete>
    return;
  80b320:	83 c4 10             	add    $0x10,%esp
  }
}
  80b323:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b326:	5b                   	pop    %ebx
  80b327:	5e                   	pop    %esi
  80b328:	5f                   	pop    %edi
  80b329:	5d                   	pop    %ebp
  80b32a:	c3                   	ret    

0080b32b <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80b32b:	55                   	push   %ebp
  80b32c:	89 e5                	mov    %esp,%ebp
  80b32e:	57                   	push   %edi
  80b32f:	56                   	push   %esi
  80b330:	53                   	push   %ebx
  80b331:	83 ec 0c             	sub    $0xc,%esp
  80b334:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b337:	85 db                	test   %ebx,%ebx
  80b339:	0f 84 c8 00 00 00    	je     80b407 <recv_raw+0xdc>
  80b33f:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b343:	0f 84 be 00 00 00    	je     80b407 <recv_raw+0xdc>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b349:	83 ec 04             	sub    $0x4,%esp
  80b34c:	6a 00                	push   $0x0
  80b34e:	8b 45 10             	mov    0x10(%ebp),%eax
  80b351:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b355:	50                   	push   %eax
  80b356:	6a 03                	push   $0x3
  80b358:	e8 8e 95 ff ff       	call   8048eb <pbuf_alloc>
  80b35d:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b35f:	83 c4 10             	add    $0x10,%esp
  80b362:	85 c0                	test   %eax,%eax
  80b364:	0f 84 9d 00 00 00    	je     80b407 <recv_raw+0xdc>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b36a:	83 ec 08             	sub    $0x8,%esp
  80b36d:	ff 75 10             	pushl  0x10(%ebp)
  80b370:	50                   	push   %eax
  80b371:	e8 73 9a ff ff       	call   804de9 <pbuf_copy>
  80b376:	83 c4 10             	add    $0x10,%esp
  80b379:	84 c0                	test   %al,%al
  80b37b:	74 75                	je     80b3f2 <recv_raw+0xc7>
        pbuf_free(q);
  80b37d:	83 ec 0c             	sub    $0xc,%esp
  80b380:	56                   	push   %esi
  80b381:	e8 9f 94 ff ff       	call   804825 <pbuf_free>
  80b386:	83 c4 10             	add    $0x10,%esp
  80b389:	eb 7c                	jmp    80b407 <recv_raw+0xdc>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80b38b:	83 ec 0c             	sub    $0xc,%esp
  80b38e:	56                   	push   %esi
  80b38f:	e8 91 94 ff ff       	call   804825 <pbuf_free>
        return 0;
  80b394:	83 c4 10             	add    $0x10,%esp
  80b397:	eb 6e                	jmp    80b407 <recv_raw+0xdc>
      }

      buf->p = q;
  80b399:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b39b:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b39e:	8b 46 04             	mov    0x4(%esi),%eax
  80b3a1:	83 c0 0c             	add    $0xc,%eax
  80b3a4:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b3a7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b3aa:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b3ae:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b3b2:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b3b6:	66 01 43 20          	add    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b3ba:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b3bd:	85 c0                	test   %eax,%eax
  80b3bf:	74 10                	je     80b3d1 <recv_raw+0xa6>
  80b3c1:	83 ec 04             	sub    $0x4,%esp
  80b3c4:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b3c8:	52                   	push   %edx
  80b3c9:	6a 00                	push   $0x0
  80b3cb:	53                   	push   %ebx
  80b3cc:	ff d0                	call   *%eax
  80b3ce:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b3d1:	83 ec 08             	sub    $0x8,%esp
  80b3d4:	57                   	push   %edi
  80b3d5:	ff 73 14             	pushl  0x14(%ebx)
  80b3d8:	e8 77 ed ff ff       	call   80a154 <sys_mbox_trypost>
  80b3dd:	83 c4 10             	add    $0x10,%esp
  80b3e0:	84 c0                	test   %al,%al
  80b3e2:	74 23                	je     80b407 <recv_raw+0xdc>
        netbuf_delete(buf);
  80b3e4:	83 ec 0c             	sub    $0xc,%esp
  80b3e7:	57                   	push   %edi
  80b3e8:	e8 06 71 ff ff       	call   8024f3 <netbuf_delete>
  80b3ed:	83 c4 10             	add    $0x10,%esp
  80b3f0:	eb 15                	jmp    80b407 <recv_raw+0xdc>
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80b3f2:	83 ec 0c             	sub    $0xc,%esp
  80b3f5:	6a 06                	push   $0x6
  80b3f7:	e8 60 90 ff ff       	call   80445c <memp_malloc>
  80b3fc:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b3fe:	83 c4 10             	add    $0x10,%esp
  80b401:	85 c0                	test   %eax,%eax
  80b403:	75 94                	jne    80b399 <recv_raw+0x6e>
  80b405:	eb 84                	jmp    80b38b <recv_raw+0x60>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80b407:	b8 00 00 00 00       	mov    $0x0,%eax
  80b40c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b40f:	5b                   	pop    %ebx
  80b410:	5e                   	pop    %esi
  80b411:	5f                   	pop    %edi
  80b412:	5d                   	pop    %ebp
  80b413:	c3                   	ret    

0080b414 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b414:	55                   	push   %ebp
  80b415:	89 e5                	mov    %esp,%ebp
  80b417:	53                   	push   %ebx
  80b418:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b41b:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b41e:	50                   	push   %eax
  80b41f:	53                   	push   %ebx
  80b420:	e8 00 a4 ff ff       	call   805825 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b425:	83 c4 08             	add    $0x8,%esp
  80b428:	68 7a b1 80 00       	push   $0x80b17a
  80b42d:	53                   	push   %ebx
  80b42e:	e8 00 a4 ff ff       	call   805833 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b433:	83 c4 08             	add    $0x8,%esp
  80b436:	68 b2 b8 80 00       	push   $0x80b8b2
  80b43b:	53                   	push   %ebx
  80b43c:	e8 03 a4 ff ff       	call   805844 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b441:	83 c4 0c             	add    $0xc,%esp
  80b444:	6a 04                	push   $0x4
  80b446:	68 6e b8 80 00       	push   $0x80b86e
  80b44b:	53                   	push   %ebx
  80b44c:	e8 23 a4 ff ff       	call   805874 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b451:	83 c4 08             	add    $0x8,%esp
  80b454:	68 b1 b4 80 00       	push   $0x80b4b1
  80b459:	53                   	push   %ebx
  80b45a:	e8 f6 a3 ff ff       	call   805855 <tcp_err>
}
  80b45f:	83 c4 10             	add    $0x10,%esp
  80b462:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b465:	c9                   	leave  
  80b466:	c3                   	ret    

0080b467 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b467:	55                   	push   %ebp
  80b468:	89 e5                	mov    %esp,%ebp
  80b46a:	53                   	push   %ebx
  80b46b:	83 ec 04             	sub    $0x4,%esp
  80b46e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b471:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b474:	85 db                	test   %ebx,%ebx
  80b476:	74 2f                	je     80b4a7 <do_connected+0x40>
    return ERR_VAL;
  }

  conn->err = err;
  80b478:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b47b:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b47e:	75 0b                	jne    80b48b <do_connected+0x24>
  80b480:	84 c0                	test   %al,%al
  80b482:	75 07                	jne    80b48b <do_connected+0x24>
    setup_tcp(conn);
  80b484:	89 d8                	mov    %ebx,%eax
  80b486:	e8 89 ff ff ff       	call   80b414 <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80b48b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b492:	83 ec 0c             	sub    $0xc,%esp
  80b495:	ff 73 10             	pushl  0x10(%ebx)
  80b498:	e8 3b eb ff ff       	call   809fd8 <sys_sem_signal>
  return ERR_OK;
  80b49d:	83 c4 10             	add    $0x10,%esp
  80b4a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80b4a5:	eb 05                	jmp    80b4ac <do_connected+0x45>
  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
    return ERR_VAL;
  80b4a7:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  sys_sem_signal(conn->op_completed);
  return ERR_OK;
}
  80b4ac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b4af:	c9                   	leave  
  80b4b0:	c3                   	ret    

0080b4b1 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80b4b1:	55                   	push   %ebp
  80b4b2:	89 e5                	mov    %esp,%ebp
  80b4b4:	53                   	push   %ebx
  80b4b5:	83 ec 04             	sub    $0x4,%esp
  80b4b8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b4bb:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b4be:	85 db                	test   %ebx,%ebx
  80b4c0:	75 17                	jne    80b4d9 <err_tcp+0x28>
  80b4c2:	83 ec 04             	sub    $0x4,%esp
  80b4c5:	68 95 2d 81 00       	push   $0x812d95
  80b4ca:	68 22 01 00 00       	push   $0x122
  80b4cf:	68 42 2d 81 00       	push   $0x812d42
  80b4d4:	e8 75 2f 00 00       	call   80e44e <_panic>

  conn->pcb.tcp = NULL;
  80b4d9:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80b4e0:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b4e3:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b4e7:	74 24                	je     80b50d <err_tcp+0x5c>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b4e9:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b4ec:	85 c0                	test   %eax,%eax
  80b4ee:	74 0d                	je     80b4fd <err_tcp+0x4c>
  80b4f0:	83 ec 04             	sub    $0x4,%esp
  80b4f3:	6a 00                	push   $0x0
  80b4f5:	6a 00                	push   $0x0
  80b4f7:	53                   	push   %ebx
  80b4f8:	ff d0                	call   *%eax
  80b4fa:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b4fd:	83 ec 08             	sub    $0x8,%esp
  80b500:	6a 00                	push   $0x0
  80b502:	ff 73 14             	pushl  0x14(%ebx)
  80b505:	e8 0d ed ff ff       	call   80a217 <sys_mbox_post>
  80b50a:	83 c4 10             	add    $0x10,%esp
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b50d:	8b 43 10             	mov    0x10(%ebx),%eax
  80b510:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b513:	74 19                	je     80b52e <err_tcp+0x7d>
  80b515:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b519:	75 13                	jne    80b52e <err_tcp+0x7d>
    conn->state = NETCONN_NONE;
  80b51b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b522:	83 ec 0c             	sub    $0xc,%esp
  80b525:	50                   	push   %eax
  80b526:	e8 ad ea ff ff       	call   809fd8 <sys_sem_signal>
  80b52b:	83 c4 10             	add    $0x10,%esp
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b52e:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b532:	74 24                	je     80b558 <err_tcp+0xa7>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b534:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b537:	85 c0                	test   %eax,%eax
  80b539:	74 0d                	je     80b548 <err_tcp+0x97>
  80b53b:	83 ec 04             	sub    $0x4,%esp
  80b53e:	6a 00                	push   $0x0
  80b540:	6a 00                	push   $0x0
  80b542:	53                   	push   %ebx
  80b543:	ff d0                	call   *%eax
  80b545:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b548:	83 ec 08             	sub    $0x8,%esp
  80b54b:	6a 00                	push   $0x0
  80b54d:	ff 73 18             	pushl  0x18(%ebx)
  80b550:	e8 c2 ec ff ff       	call   80a217 <sys_mbox_post>
  80b555:	83 c4 10             	add    $0x10,%esp
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b558:	8b 43 04             	mov    0x4(%ebx),%eax
  80b55b:	83 f8 01             	cmp    $0x1,%eax
  80b55e:	74 05                	je     80b565 <err_tcp+0xb4>
  80b560:	83 f8 04             	cmp    $0x4,%eax
  80b563:	75 15                	jne    80b57a <err_tcp+0xc9>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80b565:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80b56c:	83 ec 0c             	sub    $0xc,%esp
  80b56f:	ff 73 10             	pushl  0x10(%ebx)
  80b572:	e8 61 ea ff ff       	call   809fd8 <sys_sem_signal>
  80b577:	83 c4 10             	add    $0x10,%esp
  }
}
  80b57a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b57d:	c9                   	leave  
  80b57e:	c3                   	ret    

0080b57f <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b57f:	55                   	push   %ebp
  80b580:	89 e5                	mov    %esp,%ebp
  80b582:	57                   	push   %edi
  80b583:	56                   	push   %esi
  80b584:	53                   	push   %ebx
  80b585:	83 ec 0c             	sub    $0xc,%esp
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b588:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b58c:	74 17                	je     80b5a5 <do_writemore+0x26>
  80b58e:	83 ec 04             	sub    $0x4,%esp
  80b591:	68 a2 2d 81 00       	push   $0x812da2
  80b596:	68 b8 03 00 00       	push   $0x3b8
  80b59b:	68 42 2d 81 00       	push   $0x812d42
  80b5a0:	e8 a9 2e 00 00       	call   80e44e <_panic>
  80b5a5:	89 c6                	mov    %eax,%esi

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b5a7:	8b 50 24             	mov    0x24(%eax),%edx
  80b5aa:	8b 78 28             	mov    0x28(%eax),%edi
  80b5ad:	89 f9                	mov    %edi,%ecx
  80b5af:	03 4a 04             	add    0x4(%edx),%ecx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b5b2:	8b 42 08             	mov    0x8(%edx),%eax
  80b5b5:	89 c3                	mov    %eax,%ebx
  80b5b7:	29 fb                	sub    %edi,%ebx
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b5b9:	29 f8                	sub    %edi,%eax
  80b5bb:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  80b5c1:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80b5c6:	0f 4f c3             	cmovg  %ebx,%eax
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b5c9:	8b 7e 08             	mov    0x8(%esi),%edi
  80b5cc:	0f b7 5f 6e          	movzwl 0x6e(%edi),%ebx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b5d0:	66 39 d8             	cmp    %bx,%ax
  80b5d3:	0f 46 d8             	cmovbe %eax,%ebx
  80b5d6:	0f b7 db             	movzwl %bx,%ebx
  80b5d9:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  80b5dd:	50                   	push   %eax
  80b5de:	53                   	push   %ebx
  80b5df:	51                   	push   %ecx
  80b5e0:	57                   	push   %edi
  80b5e1:	e8 c1 c9 ff ff       	call   807fa7 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b5e6:	89 da                	mov    %ebx,%edx
  80b5e8:	03 56 28             	add    0x28(%esi),%edx
  80b5eb:	8b 4e 24             	mov    0x24(%esi),%ecx
  80b5ee:	83 c4 10             	add    $0x10,%esp
  80b5f1:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b5f4:	7e 17                	jle    80b60d <do_writemore+0x8e>
  80b5f6:	83 ec 04             	sub    $0x4,%esp
  80b5f9:	68 bf 2d 81 00       	push   $0x812dbf
  80b5fe:	68 cd 03 00 00       	push   $0x3cd
  80b603:	68 42 2d 81 00       	push   $0x812d42
  80b608:	e8 41 2e 00 00       	call   80e44e <_panic>
  if (err == ERR_OK) {
  80b60d:	84 c0                	test   %al,%al
  80b60f:	75 6e                	jne    80b67f <do_writemore+0x100>
    conn->write_offset += len;
  80b611:	89 56 28             	mov    %edx,0x28(%esi)
do_writemore(struct netconn *conn)
{
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  80b614:	bf 00 00 00 00       	mov    $0x0,%edi

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80b619:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b61c:	75 13                	jne    80b631 <do_writemore+0xb2>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80b61e:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
      conn->write_offset = 0;
  80b625:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
      /* everything was written */
      write_finished = 1;
  80b62c:	bf 01 00 00 00       	mov    $0x1,%edi
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80b631:	8b 46 08             	mov    0x8(%esi),%eax
  80b634:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80b638:	74 12                	je     80b64c <do_writemore+0xcd>
  80b63a:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80b63e:	75 0c                	jne    80b64c <do_writemore+0xcd>
  80b640:	8b 50 74             	mov    0x74(%eax),%edx
  80b643:	85 d2                	test   %edx,%edx
  80b645:	74 6e                	je     80b6b5 <do_writemore+0x136>
  80b647:	83 3a 00             	cmpl   $0x0,(%edx)
  80b64a:	74 69                	je     80b6b5 <do_writemore+0x136>
  80b64c:	83 ec 0c             	sub    $0xc,%esp
  80b64f:	50                   	push   %eax
  80b650:	e8 a5 c9 ff ff       	call   807ffa <tcp_output>
    conn->err = err;
  80b655:	88 46 0c             	mov    %al,0xc(%esi)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80b658:	83 c4 10             	add    $0x10,%esp
  80b65b:	84 c0                	test   %al,%al
  80b65d:	75 39                	jne    80b698 <do_writemore+0x119>
  80b65f:	8b 46 08             	mov    0x8(%esi),%eax
  80b662:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b668:	77 2e                	ja     80b698 <do_writemore+0x119>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80b66a:	8b 46 2c             	mov    0x2c(%esi),%eax
  80b66d:	85 c0                	test   %eax,%eax
  80b66f:	74 27                	je     80b698 <do_writemore+0x119>
  80b671:	83 ec 04             	sub    $0x4,%esp
  80b674:	53                   	push   %ebx
  80b675:	6a 03                	push   $0x3
  80b677:	56                   	push   %esi
  80b678:	ff d0                	call   *%eax
  80b67a:	83 c4 10             	add    $0x10,%esp
  80b67d:	eb 19                	jmp    80b698 <do_writemore+0x119>
    }
  } else if (err == ERR_MEM) {
  80b67f:	3c ff                	cmp    $0xff,%al
  80b681:	75 10                	jne    80b693 <do_writemore+0x114>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80b683:	83 ec 0c             	sub    $0xc,%esp
  80b686:	ff 76 08             	pushl  0x8(%esi)
  80b689:	e8 6c c9 ff ff       	call   807ffa <tcp_output>
  80b68e:	83 c4 10             	add    $0x10,%esp
  80b691:	eb 28                	jmp    80b6bb <do_writemore+0x13c>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80b693:	88 46 0c             	mov    %al,0xc(%esi)
  80b696:	eb 06                	jmp    80b69e <do_writemore+0x11f>
    write_finished = 1;
  }

  if (write_finished) {
  80b698:	89 f8                	mov    %edi,%eax
  80b69a:	84 c0                	test   %al,%al
  80b69c:	74 1d                	je     80b6bb <do_writemore+0x13c>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80b69e:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80b6a5:	83 ec 0c             	sub    $0xc,%esp
  80b6a8:	ff 76 10             	pushl  0x10(%esi)
  80b6ab:	e8 28 e9 ff ff       	call   809fd8 <sys_sem_signal>
  80b6b0:	83 c4 10             	add    $0x10,%esp
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
  80b6b3:	eb 06                	jmp    80b6bb <do_writemore+0x13c>
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80b6b5:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b6b9:	eb a4                	jmp    80b65f <do_writemore+0xe0>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80b6bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80b6c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b6c3:	5b                   	pop    %ebx
  80b6c4:	5e                   	pop    %esi
  80b6c5:	5f                   	pop    %edi
  80b6c6:	5d                   	pop    %ebp
  80b6c7:	c3                   	ret    

0080b6c8 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80b6c8:	55                   	push   %ebp
  80b6c9:	89 e5                	mov    %esp,%ebp
  80b6cb:	53                   	push   %ebx
  80b6cc:	83 ec 04             	sub    $0x4,%esp
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b6cf:	85 c0                	test   %eax,%eax
  80b6d1:	75 17                	jne    80b6ea <do_close_internal+0x22>
  80b6d3:	83 ec 04             	sub    $0x4,%esp
  80b6d6:	68 b0 2b 81 00       	push   $0x812bb0
  80b6db:	68 53 02 00 00       	push   $0x253
  80b6e0:	68 42 2d 81 00       	push   $0x812d42
  80b6e5:	e8 64 2d 00 00       	call   80e44e <_panic>
  80b6ea:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b6ec:	83 38 10             	cmpl   $0x10,(%eax)
  80b6ef:	74 17                	je     80b708 <do_close_internal+0x40>
  80b6f1:	83 ec 04             	sub    $0x4,%esp
  80b6f4:	68 dd 2d 81 00       	push   $0x812ddd
  80b6f9:	68 54 02 00 00       	push   $0x254
  80b6fe:	68 42 2d 81 00       	push   $0x812d42
  80b703:	e8 46 2d 00 00       	call   80e44e <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b708:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80b70c:	74 17                	je     80b725 <do_close_internal+0x5d>
  80b70e:	83 ec 04             	sub    $0x4,%esp
  80b711:	68 80 2c 81 00       	push   $0x812c80
  80b716:	68 55 02 00 00       	push   $0x255
  80b71b:	68 42 2d 81 00       	push   $0x812d42
  80b720:	e8 29 2d 00 00       	call   80e44e <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b725:	8b 40 08             	mov    0x8(%eax),%eax
  80b728:	85 c0                	test   %eax,%eax
  80b72a:	75 17                	jne    80b743 <do_close_internal+0x7b>
  80b72c:	83 ec 04             	sub    $0x4,%esp
  80b72f:	68 fb 2d 81 00       	push   $0x812dfb
  80b734:	68 56 02 00 00       	push   $0x256
  80b739:	68 42 2d 81 00       	push   $0x812d42
  80b73e:	e8 0b 2d 00 00       	call   80e44e <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80b743:	83 ec 08             	sub    $0x8,%esp
  80b746:	6a 00                	push   $0x0
  80b748:	50                   	push   %eax
  80b749:	e8 d7 a0 ff ff       	call   805825 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80b74e:	8b 43 08             	mov    0x8(%ebx),%eax
  80b751:	83 c4 10             	add    $0x10,%esp
  80b754:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b758:	75 10                	jne    80b76a <do_close_internal+0xa2>
    tcp_accept(conn->pcb.tcp, NULL);
  80b75a:	83 ec 08             	sub    $0x8,%esp
  80b75d:	6a 00                	push   $0x0
  80b75f:	50                   	push   %eax
  80b760:	e8 01 a1 ff ff       	call   805866 <tcp_accept>
  80b765:	83 c4 10             	add    $0x10,%esp
  80b768:	eb 44                	jmp    80b7ae <do_close_internal+0xe6>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80b76a:	83 ec 08             	sub    $0x8,%esp
  80b76d:	6a 00                	push   $0x0
  80b76f:	50                   	push   %eax
  80b770:	e8 be a0 ff ff       	call   805833 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80b775:	83 c4 08             	add    $0x8,%esp
  80b778:	6a 00                	push   $0x0
  80b77a:	ff 73 08             	pushl  0x8(%ebx)
  80b77d:	e8 e4 a0 ff ff       	call   805866 <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80b782:	83 c4 08             	add    $0x8,%esp
  80b785:	6a 00                	push   $0x0
  80b787:	ff 73 08             	pushl  0x8(%ebx)
  80b78a:	e8 b5 a0 ff ff       	call   805844 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80b78f:	83 c4 0c             	add    $0xc,%esp
  80b792:	6a 04                	push   $0x4
  80b794:	6a 00                	push   $0x0
  80b796:	ff 73 08             	pushl  0x8(%ebx)
  80b799:	e8 d6 a0 ff ff       	call   805874 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80b79e:	83 c4 08             	add    $0x8,%esp
  80b7a1:	6a 00                	push   $0x0
  80b7a3:	ff 73 08             	pushl  0x8(%ebx)
  80b7a6:	e8 aa a0 ff ff       	call   805855 <tcp_err>
  80b7ab:	83 c4 10             	add    $0x10,%esp
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80b7ae:	83 ec 0c             	sub    $0xc,%esp
  80b7b1:	ff 73 08             	pushl  0x8(%ebx)
  80b7b4:	e8 79 a2 ff ff       	call   805a32 <tcp_close>
  if (err == ERR_OK) {
  80b7b9:	83 c4 10             	add    $0x10,%esp
  80b7bc:	84 c0                	test   %al,%al
  80b7be:	75 4a                	jne    80b80a <do_close_internal+0x142>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80b7c0:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80b7c7:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80b7ce:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b7d2:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b7d5:	85 c0                	test   %eax,%eax
  80b7d7:	74 21                	je     80b7fa <do_close_internal+0x132>
  80b7d9:	83 ec 04             	sub    $0x4,%esp
  80b7dc:	6a 00                	push   $0x0
  80b7de:	6a 00                	push   $0x0
  80b7e0:	53                   	push   %ebx
  80b7e1:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80b7e3:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b7e6:	83 c4 10             	add    $0x10,%esp
  80b7e9:	85 c0                	test   %eax,%eax
  80b7eb:	74 0d                	je     80b7fa <do_close_internal+0x132>
  80b7ed:	83 ec 04             	sub    $0x4,%esp
  80b7f0:	6a 00                	push   $0x0
  80b7f2:	6a 02                	push   $0x2
  80b7f4:	53                   	push   %ebx
  80b7f5:	ff d0                	call   *%eax
  80b7f7:	83 c4 10             	add    $0x10,%esp
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80b7fa:	83 ec 0c             	sub    $0xc,%esp
  80b7fd:	ff 73 10             	pushl  0x10(%ebx)
  80b800:	e8 d3 e7 ff ff       	call   809fd8 <sys_sem_signal>
  80b805:	83 c4 10             	add    $0x10,%esp
  80b808:	eb 5f                	jmp    80b869 <do_close_internal+0x1a1>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b80a:	8b 43 08             	mov    0x8(%ebx),%eax
  80b80d:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b811:	75 17                	jne    80b82a <do_close_internal+0x162>
  80b813:	83 ec 04             	sub    $0x4,%esp
  80b816:	68 a4 2c 81 00       	push   $0x812ca4
  80b81b:	68 75 02 00 00       	push   $0x275
  80b820:	68 42 2d 81 00       	push   $0x812d42
  80b825:	e8 24 2c 00 00       	call   80e44e <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80b82a:	83 ec 08             	sub    $0x8,%esp
  80b82d:	68 b2 b8 80 00       	push   $0x80b8b2
  80b832:	50                   	push   %eax
  80b833:	e8 0c a0 ff ff       	call   805844 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80b838:	83 c4 0c             	add    $0xc,%esp
  80b83b:	6a 04                	push   $0x4
  80b83d:	68 6e b8 80 00       	push   $0x80b86e
  80b842:	ff 73 08             	pushl  0x8(%ebx)
  80b845:	e8 2a a0 ff ff       	call   805874 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80b84a:	83 c4 08             	add    $0x8,%esp
  80b84d:	68 b1 b4 80 00       	push   $0x80b4b1
  80b852:	ff 73 08             	pushl  0x8(%ebx)
  80b855:	e8 fb 9f ff ff       	call   805855 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80b85a:	83 c4 08             	add    $0x8,%esp
  80b85d:	53                   	push   %ebx
  80b85e:	ff 73 08             	pushl  0x8(%ebx)
  80b861:	e8 bf 9f ff ff       	call   805825 <tcp_arg>
  80b866:	83 c4 10             	add    $0x10,%esp
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80b869:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b86c:	c9                   	leave  
  80b86d:	c3                   	ret    

0080b86e <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80b86e:	55                   	push   %ebp
  80b86f:	89 e5                	mov    %esp,%ebp
  80b871:	83 ec 08             	sub    $0x8,%esp
  80b874:	8b 45 08             	mov    0x8(%ebp),%eax
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b877:	85 c0                	test   %eax,%eax
  80b879:	75 17                	jne    80b892 <poll_tcp+0x24>
  80b87b:	83 ec 04             	sub    $0x4,%esp
  80b87e:	68 95 2d 81 00       	push   $0x812d95
  80b883:	68 eb 00 00 00       	push   $0xeb
  80b888:	68 42 2d 81 00       	push   $0x812d42
  80b88d:	e8 bc 2b 00 00       	call   80e44e <_panic>

  if (conn->state == NETCONN_WRITE) {
  80b892:	8b 50 04             	mov    0x4(%eax),%edx
  80b895:	83 fa 01             	cmp    $0x1,%edx
  80b898:	75 07                	jne    80b8a1 <poll_tcp+0x33>
    do_writemore(conn);
  80b89a:	e8 e0 fc ff ff       	call   80b57f <do_writemore>
  80b89f:	eb 0a                	jmp    80b8ab <poll_tcp+0x3d>
  } else if (conn->state == NETCONN_CLOSE) {
  80b8a1:	83 fa 04             	cmp    $0x4,%edx
  80b8a4:	75 05                	jne    80b8ab <poll_tcp+0x3d>
    do_close_internal(conn);
  80b8a6:	e8 1d fe ff ff       	call   80b6c8 <do_close_internal>
  }

  return ERR_OK;
}
  80b8ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80b8b0:	c9                   	leave  
  80b8b1:	c3                   	ret    

0080b8b2 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80b8b2:	55                   	push   %ebp
  80b8b3:	89 e5                	mov    %esp,%ebp
  80b8b5:	56                   	push   %esi
  80b8b6:	53                   	push   %ebx
  80b8b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b8ba:	8b 75 10             	mov    0x10(%ebp),%esi
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b8bd:	85 db                	test   %ebx,%ebx
  80b8bf:	75 17                	jne    80b8d8 <sent_tcp+0x26>
  80b8c1:	83 ec 04             	sub    $0x4,%esp
  80b8c4:	68 95 2d 81 00       	push   $0x812d95
  80b8c9:	68 03 01 00 00       	push   $0x103
  80b8ce:	68 42 2d 81 00       	push   $0x812d42
  80b8d3:	e8 76 2b 00 00       	call   80e44e <_panic>

  if (conn->state == NETCONN_WRITE) {
  80b8d8:	8b 43 04             	mov    0x4(%ebx),%eax
  80b8db:	83 f8 01             	cmp    $0x1,%eax
  80b8de:	75 26                	jne    80b906 <sent_tcp+0x54>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80b8e0:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80b8e4:	75 17                	jne    80b8fd <sent_tcp+0x4b>
  80b8e6:	83 ec 04             	sub    $0x4,%esp
  80b8e9:	68 0e 2e 81 00       	push   $0x812e0e
  80b8ee:	68 06 01 00 00       	push   $0x106
  80b8f3:	68 42 2d 81 00       	push   $0x812d42
  80b8f8:	e8 51 2b 00 00       	call   80e44e <_panic>
    do_writemore(conn);
  80b8fd:	89 d8                	mov    %ebx,%eax
  80b8ff:	e8 7b fc ff ff       	call   80b57f <do_writemore>
  80b904:	eb 2e                	jmp    80b934 <sent_tcp+0x82>
  } else if (conn->state == NETCONN_CLOSE) {
  80b906:	83 f8 04             	cmp    $0x4,%eax
  80b909:	75 29                	jne    80b934 <sent_tcp+0x82>
    do_close_internal(conn);
  80b90b:	89 d8                	mov    %ebx,%eax
  80b90d:	e8 b6 fd ff ff       	call   80b6c8 <do_close_internal>
  80b912:	eb 20                	jmp    80b934 <sent_tcp+0x82>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80b914:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b91a:	76 1f                	jbe    80b93b <sent_tcp+0x89>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80b91c:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b91f:	85 c0                	test   %eax,%eax
  80b921:	74 18                	je     80b93b <sent_tcp+0x89>
  80b923:	83 ec 04             	sub    $0x4,%esp
  80b926:	0f b7 f6             	movzwl %si,%esi
  80b929:	56                   	push   %esi
  80b92a:	6a 02                	push   $0x2
  80b92c:	53                   	push   %ebx
  80b92d:	ff d0                	call   *%eax
  80b92f:	83 c4 10             	add    $0x10,%esp
  80b932:	eb 07                	jmp    80b93b <sent_tcp+0x89>
  } else if (conn->state == NETCONN_CLOSE) {
    do_close_internal(conn);
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80b934:	8b 43 08             	mov    0x8(%ebx),%eax
  80b937:	85 c0                	test   %eax,%eax
  80b939:	75 d9                	jne    80b914 <sent_tcp+0x62>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
    }
  }
  
  return ERR_OK;
}
  80b93b:	b8 00 00 00 00       	mov    $0x0,%eax
  80b940:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b943:	5b                   	pop    %ebx
  80b944:	5e                   	pop    %esi
  80b945:	5d                   	pop    %ebp
  80b946:	c3                   	ret    

0080b947 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80b947:	55                   	push   %ebp
  80b948:	89 e5                	mov    %esp,%ebp
  80b94a:	56                   	push   %esi
  80b94b:	53                   	push   %ebx
  80b94c:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80b94f:	8b 03                	mov    (%ebx),%eax
  80b951:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80b955:	0f 85 ce 00 00 00    	jne    80ba29 <do_newconn+0xe2>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80b95b:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80b95f:	8b 33                	mov    (%ebx),%esi
  80b961:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80b965:	74 17                	je     80b97e <do_newconn+0x37>
  80b967:	83 ec 04             	sub    $0x4,%esp
  80b96a:	68 c8 2c 81 00       	push   $0x812cc8
  80b96f:	68 8a 01 00 00       	push   $0x18a
  80b974:	68 42 2d 81 00       	push   $0x812d42
  80b979:	e8 d0 2a 00 00       	call   80e44e <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80b97e:	8b 06                	mov    (%esi),%eax
  80b980:	25 f0 00 00 00       	and    $0xf0,%eax
  80b985:	83 f8 20             	cmp    $0x20,%eax
  80b988:	74 46                	je     80b9d0 <do_newconn+0x89>
  80b98a:	83 f8 40             	cmp    $0x40,%eax
  80b98d:	74 0b                	je     80b99a <do_newconn+0x53>
  80b98f:	83 f8 10             	cmp    $0x10,%eax
  80b992:	0f 85 8d 00 00 00    	jne    80ba25 <do_newconn+0xde>
  80b998:	eb 6e                	jmp    80ba08 <do_newconn+0xc1>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80b99a:	83 ec 0c             	sub    $0xc,%esp
  80b99d:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80b9a1:	50                   	push   %eax
  80b9a2:	e8 2c 25 00 00       	call   80ded3 <raw_new>
  80b9a7:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80b9aa:	8b 03                	mov    (%ebx),%eax
  80b9ac:	8b 50 08             	mov    0x8(%eax),%edx
  80b9af:	83 c4 10             	add    $0x10,%esp
  80b9b2:	85 d2                	test   %edx,%edx
  80b9b4:	75 06                	jne    80b9bc <do_newconn+0x75>
       msg->conn->err = ERR_MEM;
  80b9b6:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80b9ba:	eb 6d                	jmp    80ba29 <do_newconn+0xe2>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80b9bc:	83 ec 04             	sub    $0x4,%esp
  80b9bf:	50                   	push   %eax
  80b9c0:	68 2b b3 80 00       	push   $0x80b32b
  80b9c5:	52                   	push   %edx
  80b9c6:	e8 86 23 00 00       	call   80dd51 <raw_recv>
  80b9cb:	83 c4 10             	add    $0x10,%esp
  80b9ce:	eb 59                	jmp    80ba29 <do_newconn+0xe2>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80b9d0:	e8 99 d5 ff ff       	call   808f6e <udp_new>
  80b9d5:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80b9d8:	8b 03                	mov    (%ebx),%eax
  80b9da:	8b 50 08             	mov    0x8(%eax),%edx
  80b9dd:	85 d2                	test   %edx,%edx
  80b9df:	75 06                	jne    80b9e7 <do_newconn+0xa0>
       msg->conn->err = ERR_MEM;
  80b9e1:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80b9e5:	eb 42                	jmp    80ba29 <do_newconn+0xe2>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80b9e7:	83 38 22             	cmpl   $0x22,(%eax)
  80b9ea:	75 04                	jne    80b9f0 <do_newconn+0xa9>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80b9ec:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80b9f0:	8b 03                	mov    (%ebx),%eax
  80b9f2:	83 ec 04             	sub    $0x4,%esp
  80b9f5:	50                   	push   %eax
  80b9f6:	68 33 b2 80 00       	push   $0x80b233
  80b9fb:	ff 70 08             	pushl  0x8(%eax)
  80b9fe:	e8 13 d5 ff ff       	call   808f16 <udp_recv>
  80ba03:	83 c4 10             	add    $0x10,%esp
  80ba06:	eb 21                	jmp    80ba29 <do_newconn+0xe2>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80ba08:	e8 e9 a8 ff ff       	call   8062f6 <tcp_new>
  80ba0d:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80ba10:	8b 03                	mov    (%ebx),%eax
  80ba12:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80ba16:	75 06                	jne    80ba1e <do_newconn+0xd7>
       msg->conn->err = ERR_MEM;
  80ba18:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80ba1c:	eb 0b                	jmp    80ba29 <do_newconn+0xe2>
       break;
     }
     setup_tcp(msg->conn);
  80ba1e:	e8 f1 f9 ff ff       	call   80b414 <setup_tcp>
  80ba23:	eb 04                	jmp    80ba29 <do_newconn+0xe2>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80ba25:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80ba29:	83 ec 0c             	sub    $0xc,%esp
  80ba2c:	8b 03                	mov    (%ebx),%eax
  80ba2e:	ff 70 10             	pushl  0x10(%eax)
  80ba31:	e8 a2 e5 ff ff       	call   809fd8 <sys_sem_signal>
}
  80ba36:	83 c4 10             	add    $0x10,%esp
  80ba39:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ba3c:	5b                   	pop    %ebx
  80ba3d:	5e                   	pop    %esi
  80ba3e:	5d                   	pop    %ebp
  80ba3f:	c3                   	ret    

0080ba40 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80ba40:	55                   	push   %ebp
  80ba41:	89 e5                	mov    %esp,%ebp
  80ba43:	53                   	push   %ebx
  80ba44:	83 ec 10             	sub    $0x10,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80ba47:	6a 07                	push   $0x7
  80ba49:	e8 0e 8a ff ff       	call   80445c <memp_malloc>
  if (conn == NULL) {
  80ba4e:	83 c4 10             	add    $0x10,%esp
  80ba51:	85 c0                	test   %eax,%eax
  80ba53:	0f 84 96 00 00 00    	je     80baef <netconn_alloc+0xaf>
  80ba59:	89 c3                	mov    %eax,%ebx
    return NULL;
  }

  conn->err = ERR_OK;
  80ba5b:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80ba5f:	8b 45 08             	mov    0x8(%ebp),%eax
  80ba62:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80ba64:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80ba6b:	83 ec 0c             	sub    $0xc,%esp
  80ba6e:	6a 00                	push   $0x0
  80ba70:	e8 b7 e2 ff ff       	call   809d2c <sys_sem_new>
  80ba75:	89 43 10             	mov    %eax,0x10(%ebx)
  80ba78:	83 c4 10             	add    $0x10,%esp
  80ba7b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ba7e:	75 15                	jne    80ba95 <netconn_alloc+0x55>
    memp_free(MEMP_NETCONN, conn);
  80ba80:	83 ec 08             	sub    $0x8,%esp
  80ba83:	53                   	push   %ebx
  80ba84:	6a 07                	push   $0x7
  80ba86:	e8 27 8a ff ff       	call   8044b2 <memp_free>
    return NULL;
  80ba8b:	83 c4 10             	add    $0x10,%esp
  80ba8e:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba93:	eb 5f                	jmp    80baf4 <netconn_alloc+0xb4>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80ba95:	83 ec 0c             	sub    $0xc,%esp
  80ba98:	6a 00                	push   $0x0
  80ba9a:	e8 36 e4 ff ff       	call   809ed5 <sys_mbox_new>
  80ba9f:	89 43 14             	mov    %eax,0x14(%ebx)
  80baa2:	83 c4 10             	add    $0x10,%esp
  80baa5:	83 f8 ff             	cmp    $0xffffffff,%eax
  80baa8:	75 20                	jne    80baca <netconn_alloc+0x8a>
    sys_sem_free(conn->op_completed);
  80baaa:	83 ec 0c             	sub    $0xc,%esp
  80baad:	ff 73 10             	pushl  0x10(%ebx)
  80bab0:	e8 f8 e2 ff ff       	call   809dad <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80bab5:	83 c4 08             	add    $0x8,%esp
  80bab8:	53                   	push   %ebx
  80bab9:	6a 07                	push   $0x7
  80babb:	e8 f2 89 ff ff       	call   8044b2 <memp_free>
    return NULL;
  80bac0:	83 c4 10             	add    $0x10,%esp
  80bac3:	b8 00 00 00 00       	mov    $0x0,%eax
  80bac8:	eb 2a                	jmp    80baf4 <netconn_alloc+0xb4>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80baca:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80bad1:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80bad8:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80badf:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bae2:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80bae5:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  80baeb:	89 d8                	mov    %ebx,%eax
  80baed:	eb 05                	jmp    80baf4 <netconn_alloc+0xb4>
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  if (conn == NULL) {
    return NULL;
  80baef:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80baf4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80baf7:	c9                   	leave  
  80baf8:	c3                   	ret    

0080baf9 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80baf9:	55                   	push   %ebp
  80bafa:	89 e5                	mov    %esp,%ebp
  80bafc:	56                   	push   %esi
  80bafd:	53                   	push   %ebx
  80bafe:	83 ec 10             	sub    $0x10,%esp
  80bb01:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bb04:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bb08:	74 17                	je     80bb21 <netconn_free+0x28>
  80bb0a:	83 ec 04             	sub    $0x4,%esp
  80bb0d:	68 e8 2c 81 00       	push   $0x812ce8
  80bb12:	68 26 02 00 00       	push   $0x226
  80bb17:	68 42 2d 81 00       	push   $0x812d42
  80bb1c:	e8 2d 29 00 00       	call   80e44e <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bb21:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bb24:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bb28:	75 2a                	jne    80bb54 <netconn_free+0x5b>
  80bb2a:	eb 51                	jmp    80bb7d <netconn_free+0x84>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80bb2c:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bb2f:	75 15                	jne    80bb46 <netconn_free+0x4d>
        if(mem != NULL) {
  80bb31:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80bb34:	85 c0                	test   %eax,%eax
  80bb36:	74 1c                	je     80bb54 <netconn_free+0x5b>
          pbuf_free((struct pbuf *)mem);
  80bb38:	83 ec 0c             	sub    $0xc,%esp
  80bb3b:	50                   	push   %eax
  80bb3c:	e8 e4 8c ff ff       	call   804825 <pbuf_free>
  80bb41:	83 c4 10             	add    $0x10,%esp
  80bb44:	eb 0e                	jmp    80bb54 <netconn_free+0x5b>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80bb46:	83 ec 0c             	sub    $0xc,%esp
  80bb49:	ff 75 f4             	pushl  -0xc(%ebp)
  80bb4c:	e8 a2 69 ff ff       	call   8024f3 <netbuf_delete>
  80bb51:	83 c4 10             	add    $0x10,%esp
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bb54:	83 ec 08             	sub    $0x8,%esp
  80bb57:	56                   	push   %esi
  80bb58:	ff 73 14             	pushl  0x14(%ebx)
  80bb5b:	e8 d3 e7 ff ff       	call   80a333 <sys_arch_mbox_tryfetch>
  80bb60:	83 c4 10             	add    $0x10,%esp
  80bb63:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bb66:	75 c4                	jne    80bb2c <netconn_free+0x33>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80bb68:	83 ec 0c             	sub    $0xc,%esp
  80bb6b:	ff 73 14             	pushl  0x14(%ebx)
  80bb6e:	e8 c3 e2 ff ff       	call   809e36 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80bb73:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80bb7a:	83 c4 10             	add    $0x10,%esp
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bb7d:	8d 75 f4             	lea    -0xc(%ebp),%esi
    sys_mbox_free(conn->recvmbox);
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80bb80:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bb84:	75 10                	jne    80bb96 <netconn_free+0x9d>
  80bb86:	eb 37                	jmp    80bbbf <netconn_free+0xc6>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80bb88:	83 ec 0c             	sub    $0xc,%esp
  80bb8b:	ff 75 f4             	pushl  -0xc(%ebp)
  80bb8e:	e8 83 f0 ff ff       	call   80ac16 <netconn_delete>
  80bb93:	83 c4 10             	add    $0x10,%esp
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bb96:	83 ec 08             	sub    $0x8,%esp
  80bb99:	56                   	push   %esi
  80bb9a:	ff 73 18             	pushl  0x18(%ebx)
  80bb9d:	e8 91 e7 ff ff       	call   80a333 <sys_arch_mbox_tryfetch>
  80bba2:	83 c4 10             	add    $0x10,%esp
  80bba5:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bba8:	75 de                	jne    80bb88 <netconn_free+0x8f>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80bbaa:	83 ec 0c             	sub    $0xc,%esp
  80bbad:	ff 73 18             	pushl  0x18(%ebx)
  80bbb0:	e8 81 e2 ff ff       	call   809e36 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80bbb5:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80bbbc:	83 c4 10             	add    $0x10,%esp
  }

  sys_sem_free(conn->op_completed);
  80bbbf:	83 ec 0c             	sub    $0xc,%esp
  80bbc2:	ff 73 10             	pushl  0x10(%ebx)
  80bbc5:	e8 e3 e1 ff ff       	call   809dad <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80bbca:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80bbd1:	83 c4 08             	add    $0x8,%esp
  80bbd4:	53                   	push   %ebx
  80bbd5:	6a 07                	push   $0x7
  80bbd7:	e8 d6 88 ff ff       	call   8044b2 <memp_free>
}
  80bbdc:	83 c4 10             	add    $0x10,%esp
  80bbdf:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bbe2:	5b                   	pop    %ebx
  80bbe3:	5e                   	pop    %esi
  80bbe4:	5d                   	pop    %ebp
  80bbe5:	c3                   	ret    

0080bbe6 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80bbe6:	55                   	push   %ebp
  80bbe7:	89 e5                	mov    %esp,%ebp
  80bbe9:	57                   	push   %edi
  80bbea:	56                   	push   %esi
  80bbeb:	53                   	push   %ebx
  80bbec:	83 ec 0c             	sub    $0xc,%esp
  80bbef:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bbf2:	8b 7d 10             	mov    0x10(%ebp),%edi
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bbf5:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bbf9:	75 17                	jne    80bc12 <accept_function+0x2c>
  80bbfb:	83 ec 04             	sub    $0x4,%esp
  80bbfe:	68 18 2d 81 00       	push   $0x812d18
  80bc03:	68 65 01 00 00       	push   $0x165
  80bc08:	68 42 2d 81 00       	push   $0x812d42
  80bc0d:	e8 3c 28 00 00       	call   80e44e <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80bc12:	83 ec 08             	sub    $0x8,%esp
  80bc15:	ff 73 2c             	pushl  0x2c(%ebx)
  80bc18:	ff 33                	pushl  (%ebx)
  80bc1a:	e8 21 fe ff ff       	call   80ba40 <netconn_alloc>
  80bc1f:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80bc21:	83 c4 10             	add    $0x10,%esp
  80bc24:	85 c0                	test   %eax,%eax
  80bc26:	74 53                	je     80bc7b <accept_function+0x95>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80bc28:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bc2b:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80bc2e:	89 f0                	mov    %esi,%eax
  80bc30:	e8 df f7 ff ff       	call   80b414 <setup_tcp>
  newconn->err = err;
  80bc35:	89 f8                	mov    %edi,%eax
  80bc37:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bc3a:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bc3d:	85 c0                	test   %eax,%eax
  80bc3f:	74 0d                	je     80bc4e <accept_function+0x68>
  80bc41:	83 ec 04             	sub    $0x4,%esp
  80bc44:	6a 00                	push   $0x0
  80bc46:	6a 00                	push   $0x0
  80bc48:	53                   	push   %ebx
  80bc49:	ff d0                	call   *%eax
  80bc4b:	83 c4 10             	add    $0x10,%esp

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80bc4e:	83 ec 08             	sub    $0x8,%esp
  80bc51:	56                   	push   %esi
  80bc52:	ff 73 18             	pushl  0x18(%ebx)
  80bc55:	e8 fa e4 ff ff       	call   80a154 <sys_mbox_trypost>
  80bc5a:	83 c4 10             	add    $0x10,%esp
  80bc5d:	84 c0                	test   %al,%al
  80bc5f:	74 1f                	je     80bc80 <accept_function+0x9a>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80bc61:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80bc68:	83 ec 0c             	sub    $0xc,%esp
  80bc6b:	56                   	push   %esi
  80bc6c:	e8 88 fe ff ff       	call   80baf9 <netconn_free>
    return ERR_MEM;
  80bc71:	83 c4 10             	add    $0x10,%esp
  80bc74:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bc79:	eb 05                	jmp    80bc80 <accept_function+0x9a>

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  if (newconn == NULL) {
    return ERR_MEM;
  80bc7b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    newconn->pcb.tcp = NULL;
    netconn_free(newconn);
    return ERR_MEM;
  }
  return ERR_OK;
}
  80bc80:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bc83:	5b                   	pop    %ebx
  80bc84:	5e                   	pop    %esi
  80bc85:	5f                   	pop    %edi
  80bc86:	5d                   	pop    %ebp
  80bc87:	c3                   	ret    

0080bc88 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80bc88:	55                   	push   %ebp
  80bc89:	89 e5                	mov    %esp,%ebp
  80bc8b:	53                   	push   %ebx
  80bc8c:	83 ec 04             	sub    $0x4,%esp
  80bc8f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80bc92:	8b 13                	mov    (%ebx),%edx
  80bc94:	8b 4a 08             	mov    0x8(%edx),%ecx
  80bc97:	85 c9                	test   %ecx,%ecx
  80bc99:	74 4f                	je     80bcea <do_delconn+0x62>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bc9b:	8b 02                	mov    (%edx),%eax
  80bc9d:	25 f0 00 00 00       	and    $0xf0,%eax
  80bca2:	83 f8 20             	cmp    $0x20,%eax
  80bca5:	74 1a                	je     80bcc1 <do_delconn+0x39>
  80bca7:	83 f8 40             	cmp    $0x40,%eax
  80bcaa:	74 07                	je     80bcb3 <do_delconn+0x2b>
  80bcac:	83 f8 10             	cmp    $0x10,%eax
  80bcaf:	75 39                	jne    80bcea <do_delconn+0x62>
  80bcb1:	eb 27                	jmp    80bcda <do_delconn+0x52>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80bcb3:	83 ec 0c             	sub    $0xc,%esp
  80bcb6:	51                   	push   %ecx
  80bcb7:	e8 d3 21 00 00       	call   80de8f <raw_remove>
      break;
  80bcbc:	83 c4 10             	add    $0x10,%esp
  80bcbf:	eb 29                	jmp    80bcea <do_delconn+0x62>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80bcc1:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80bcc8:	83 ec 0c             	sub    $0xc,%esp
  80bccb:	8b 03                	mov    (%ebx),%eax
  80bccd:	ff 70 08             	pushl  0x8(%eax)
  80bcd0:	e8 55 d2 ff ff       	call   808f2a <udp_remove>
      break;
  80bcd5:	83 c4 10             	add    $0x10,%esp
  80bcd8:	eb 10                	jmp    80bcea <do_delconn+0x62>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80bcda:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80bce1:	8b 03                	mov    (%ebx),%eax
  80bce3:	e8 e0 f9 ff ff       	call   80b6c8 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80bce8:	eb 42                	jmp    80bd2c <do_delconn+0xa4>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80bcea:	8b 13                	mov    (%ebx),%edx
  80bcec:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bcef:	85 c0                	test   %eax,%eax
  80bcf1:	74 23                	je     80bd16 <do_delconn+0x8e>
  80bcf3:	83 ec 04             	sub    $0x4,%esp
  80bcf6:	6a 00                	push   $0x0
  80bcf8:	6a 00                	push   $0x0
  80bcfa:	52                   	push   %edx
  80bcfb:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80bcfd:	8b 13                	mov    (%ebx),%edx
  80bcff:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bd02:	83 c4 10             	add    $0x10,%esp
  80bd05:	85 c0                	test   %eax,%eax
  80bd07:	74 0d                	je     80bd16 <do_delconn+0x8e>
  80bd09:	83 ec 04             	sub    $0x4,%esp
  80bd0c:	6a 00                	push   $0x0
  80bd0e:	6a 02                	push   $0x2
  80bd10:	52                   	push   %edx
  80bd11:	ff d0                	call   *%eax
  80bd13:	83 c4 10             	add    $0x10,%esp

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80bd16:	8b 03                	mov    (%ebx),%eax
  80bd18:	8b 40 10             	mov    0x10(%eax),%eax
  80bd1b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bd1e:	74 0c                	je     80bd2c <do_delconn+0xa4>
    sys_sem_signal(msg->conn->op_completed);
  80bd20:	83 ec 0c             	sub    $0xc,%esp
  80bd23:	50                   	push   %eax
  80bd24:	e8 af e2 ff ff       	call   809fd8 <sys_sem_signal>
  80bd29:	83 c4 10             	add    $0x10,%esp
  }
}
  80bd2c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bd2f:	c9                   	leave  
  80bd30:	c3                   	ret    

0080bd31 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80bd31:	55                   	push   %ebp
  80bd32:	89 e5                	mov    %esp,%ebp
  80bd34:	56                   	push   %esi
  80bd35:	53                   	push   %ebx
  80bd36:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bd39:	8b 33                	mov    (%ebx),%esi
  80bd3b:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80bd3f:	7c 69                	jl     80bdaa <do_bind+0x79>
    if (msg->conn->pcb.tcp != NULL) {
  80bd41:	8b 56 08             	mov    0x8(%esi),%edx
  80bd44:	85 d2                	test   %edx,%edx
  80bd46:	74 5e                	je     80bda6 <do_bind+0x75>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bd48:	8b 06                	mov    (%esi),%eax
  80bd4a:	25 f0 00 00 00       	and    $0xf0,%eax
  80bd4f:	83 f8 20             	cmp    $0x20,%eax
  80bd52:	74 20                	je     80bd74 <do_bind+0x43>
  80bd54:	83 f8 40             	cmp    $0x40,%eax
  80bd57:	74 07                	je     80bd60 <do_bind+0x2f>
  80bd59:	83 f8 10             	cmp    $0x10,%eax
  80bd5c:	75 4c                	jne    80bdaa <do_bind+0x79>
  80bd5e:	eb 2d                	jmp    80bd8d <do_bind+0x5c>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bd60:	83 ec 08             	sub    $0x8,%esp
  80bd63:	ff 73 04             	pushl  0x4(%ebx)
  80bd66:	52                   	push   %edx
  80bd67:	e8 a6 1f 00 00       	call   80dd12 <raw_bind>
  80bd6c:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bd6f:	83 c4 10             	add    $0x10,%esp
  80bd72:	eb 36                	jmp    80bdaa <do_bind+0x79>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bd74:	83 ec 04             	sub    $0x4,%esp
  80bd77:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bd7b:	50                   	push   %eax
  80bd7c:	ff 73 04             	pushl  0x4(%ebx)
  80bd7f:	52                   	push   %edx
  80bd80:	e8 63 ce ff ff       	call   808be8 <udp_bind>
  80bd85:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bd88:	83 c4 10             	add    $0x10,%esp
  80bd8b:	eb 1d                	jmp    80bdaa <do_bind+0x79>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bd8d:	83 ec 04             	sub    $0x4,%esp
  80bd90:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bd94:	50                   	push   %eax
  80bd95:	ff 73 04             	pushl  0x4(%ebx)
  80bd98:	52                   	push   %edx
  80bd99:	e8 19 96 ff ff       	call   8053b7 <tcp_bind>
  80bd9e:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bda1:	83 c4 10             	add    $0x10,%esp
  80bda4:	eb 04                	jmp    80bdaa <do_bind+0x79>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80bda6:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80bdaa:	83 ec 0c             	sub    $0xc,%esp
  80bdad:	8b 03                	mov    (%ebx),%eax
  80bdaf:	ff 70 10             	pushl  0x10(%eax)
  80bdb2:	e8 21 e2 ff ff       	call   809fd8 <sys_sem_signal>
}
  80bdb7:	83 c4 10             	add    $0x10,%esp
  80bdba:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bdbd:	5b                   	pop    %ebx
  80bdbe:	5e                   	pop    %esi
  80bdbf:	5d                   	pop    %ebp
  80bdc0:	c3                   	ret    

0080bdc1 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80bdc1:	55                   	push   %ebp
  80bdc2:	89 e5                	mov    %esp,%ebp
  80bdc4:	56                   	push   %esi
  80bdc5:	53                   	push   %ebx
  80bdc6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80bdc9:	8b 33                	mov    (%ebx),%esi
  80bdcb:	8b 56 08             	mov    0x8(%esi),%edx
  80bdce:	85 d2                	test   %edx,%edx
  80bdd0:	75 13                	jne    80bde5 <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80bdd2:	83 ec 0c             	sub    $0xc,%esp
  80bdd5:	ff 76 10             	pushl  0x10(%esi)
  80bdd8:	e8 fb e1 ff ff       	call   809fd8 <sys_sem_signal>
    return;
  80bddd:	83 c4 10             	add    $0x10,%esp
  80bde0:	e9 8a 00 00 00       	jmp    80be6f <do_connect+0xae>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bde5:	8b 06                	mov    (%esi),%eax
  80bde7:	25 f0 00 00 00       	and    $0xf0,%eax
  80bdec:	83 f8 20             	cmp    $0x20,%eax
  80bdef:	74 2d                	je     80be1e <do_connect+0x5d>
  80bdf1:	83 f8 40             	cmp    $0x40,%eax
  80bdf4:	74 07                	je     80bdfd <do_connect+0x3c>
  80bdf6:	83 f8 10             	cmp    $0x10,%eax
  80bdf9:	75 74                	jne    80be6f <do_connect+0xae>
  80bdfb:	eb 47                	jmp    80be44 <do_connect+0x83>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bdfd:	83 ec 08             	sub    $0x8,%esp
  80be00:	ff 73 04             	pushl  0x4(%ebx)
  80be03:	52                   	push   %edx
  80be04:	e8 28 1f 00 00       	call   80dd31 <raw_connect>
  80be09:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80be0c:	83 c4 04             	add    $0x4,%esp
  80be0f:	8b 03                	mov    (%ebx),%eax
  80be11:	ff 70 10             	pushl  0x10(%eax)
  80be14:	e8 bf e1 ff ff       	call   809fd8 <sys_sem_signal>
    break;
  80be19:	83 c4 10             	add    $0x10,%esp
  80be1c:	eb 51                	jmp    80be6f <do_connect+0xae>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80be1e:	83 ec 04             	sub    $0x4,%esp
  80be21:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80be25:	50                   	push   %eax
  80be26:	ff 73 04             	pushl  0x4(%ebx)
  80be29:	52                   	push   %edx
  80be2a:	e8 5b d0 ff ff       	call   808e8a <udp_connect>
  80be2f:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80be32:	83 c4 04             	add    $0x4,%esp
  80be35:	8b 03                	mov    (%ebx),%eax
  80be37:	ff 70 10             	pushl  0x10(%eax)
  80be3a:	e8 99 e1 ff ff       	call   809fd8 <sys_sem_signal>
    break;
  80be3f:	83 c4 10             	add    $0x10,%esp
  80be42:	eb 2b                	jmp    80be6f <do_connect+0xae>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80be44:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80be4b:	8b 03                	mov    (%ebx),%eax
  80be4d:	e8 c2 f5 ff ff       	call   80b414 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80be52:	8b 33                	mov    (%ebx),%esi
  80be54:	68 67 b4 80 00       	push   $0x80b467
  80be59:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80be5d:	50                   	push   %eax
  80be5e:	ff 73 04             	pushl  0x4(%ebx)
  80be61:	ff 76 08             	pushl  0x8(%esi)
  80be64:	e8 d5 a4 ff ff       	call   80633e <tcp_connect>
  80be69:	88 46 0c             	mov    %al,0xc(%esi)
                                 do_connected);
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
  80be6c:	83 c4 10             	add    $0x10,%esp
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80be6f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80be72:	5b                   	pop    %ebx
  80be73:	5e                   	pop    %esi
  80be74:	5d                   	pop    %ebp
  80be75:	c3                   	ret    

0080be76 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80be76:	55                   	push   %ebp
  80be77:	89 e5                	mov    %esp,%ebp
  80be79:	53                   	push   %ebx
  80be7a:	83 ec 04             	sub    $0x4,%esp
  80be7d:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80be80:	8b 13                	mov    (%ebx),%edx
  80be82:	8b 02                	mov    (%edx),%eax
  80be84:	25 f0 00 00 00       	and    $0xf0,%eax
  80be89:	83 f8 20             	cmp    $0x20,%eax
  80be8c:	75 0e                	jne    80be9c <do_disconnect+0x26>
    udp_disconnect(msg->conn->pcb.udp);
  80be8e:	83 ec 0c             	sub    $0xc,%esp
  80be91:	ff 72 08             	pushl  0x8(%edx)
  80be94:	e8 62 d0 ff ff       	call   808efb <udp_disconnect>
  80be99:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80be9c:	83 ec 0c             	sub    $0xc,%esp
  80be9f:	8b 03                	mov    (%ebx),%eax
  80bea1:	ff 70 10             	pushl  0x10(%eax)
  80bea4:	e8 2f e1 ff ff       	call   809fd8 <sys_sem_signal>
}
  80bea9:	83 c4 10             	add    $0x10,%esp
  80beac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80beaf:	c9                   	leave  
  80beb0:	c3                   	ret    

0080beb1 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80beb1:	55                   	push   %ebp
  80beb2:	89 e5                	mov    %esp,%ebp
  80beb4:	57                   	push   %edi
  80beb5:	56                   	push   %esi
  80beb6:	53                   	push   %ebx
  80beb7:	83 ec 0c             	sub    $0xc,%esp
  80beba:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bebd:	8b 03                	mov    (%ebx),%eax
  80bebf:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80bec3:	0f 8c bc 00 00 00    	jl     80bf85 <do_listen+0xd4>
    if (msg->conn->pcb.tcp != NULL) {
  80bec9:	8b 50 08             	mov    0x8(%eax),%edx
  80becc:	85 d2                	test   %edx,%edx
  80bece:	0f 84 b1 00 00 00    	je     80bf85 <do_listen+0xd4>
      if (msg->conn->type == NETCONN_TCP) {
  80bed4:	83 38 10             	cmpl   $0x10,(%eax)
  80bed7:	0f 85 a8 00 00 00    	jne    80bf85 <do_listen+0xd4>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80bedd:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80bee1:	0f 85 9a 00 00 00    	jne    80bf81 <do_listen+0xd0>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80bee7:	83 ec 08             	sub    $0x8,%esp
  80beea:	68 ff 00 00 00       	push   $0xff
  80beef:	52                   	push   %edx
  80bef0:	e8 52 96 ff ff       	call   805547 <tcp_listen_with_backlog>
  80bef5:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80bef7:	83 c4 10             	add    $0x10,%esp
  80befa:	85 c0                	test   %eax,%eax
  80befc:	75 08                	jne    80bf06 <do_listen+0x55>
            msg->conn->err = ERR_MEM;
  80befe:	8b 03                	mov    (%ebx),%eax
  80bf00:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bf04:	eb 7f                	jmp    80bf85 <do_listen+0xd4>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80bf06:	8b 03                	mov    (%ebx),%eax
  80bf08:	8b 40 14             	mov    0x14(%eax),%eax
  80bf0b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bf0e:	74 15                	je     80bf25 <do_listen+0x74>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80bf10:	83 ec 0c             	sub    $0xc,%esp
  80bf13:	50                   	push   %eax
  80bf14:	e8 1d df ff ff       	call   809e36 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80bf19:	8b 03                	mov    (%ebx),%eax
  80bf1b:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80bf22:	83 c4 10             	add    $0x10,%esp
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80bf25:	8b 3b                	mov    (%ebx),%edi
  80bf27:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80bf2b:	75 1b                	jne    80bf48 <do_listen+0x97>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80bf2d:	83 ec 0c             	sub    $0xc,%esp
  80bf30:	6a 00                	push   $0x0
  80bf32:	e8 9e df ff ff       	call   809ed5 <sys_mbox_new>
  80bf37:	89 47 18             	mov    %eax,0x18(%edi)
  80bf3a:	83 c4 10             	add    $0x10,%esp
  80bf3d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bf40:	75 06                	jne    80bf48 <do_listen+0x97>
                msg->conn->err = ERR_MEM;
  80bf42:	8b 03                	mov    (%ebx),%eax
  80bf44:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80bf48:	8b 03                	mov    (%ebx),%eax
  80bf4a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80bf4e:	75 35                	jne    80bf85 <do_listen+0xd4>
              msg->conn->state = NETCONN_LISTEN;
  80bf50:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80bf57:	8b 03                	mov    (%ebx),%eax
  80bf59:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80bf5c:	8b 03                	mov    (%ebx),%eax
  80bf5e:	83 ec 08             	sub    $0x8,%esp
  80bf61:	50                   	push   %eax
  80bf62:	ff 70 08             	pushl  0x8(%eax)
  80bf65:	e8 bb 98 ff ff       	call   805825 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80bf6a:	83 c4 08             	add    $0x8,%esp
  80bf6d:	68 e6 bb 80 00       	push   $0x80bbe6
  80bf72:	8b 03                	mov    (%ebx),%eax
  80bf74:	ff 70 08             	pushl  0x8(%eax)
  80bf77:	e8 ea 98 ff ff       	call   805866 <tcp_accept>
  80bf7c:	83 c4 10             	add    $0x10,%esp
  80bf7f:	eb 04                	jmp    80bf85 <do_listen+0xd4>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80bf81:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80bf85:	83 ec 0c             	sub    $0xc,%esp
  80bf88:	8b 03                	mov    (%ebx),%eax
  80bf8a:	ff 70 10             	pushl  0x10(%eax)
  80bf8d:	e8 46 e0 ff ff       	call   809fd8 <sys_sem_signal>
}
  80bf92:	83 c4 10             	add    $0x10,%esp
  80bf95:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bf98:	5b                   	pop    %ebx
  80bf99:	5e                   	pop    %esi
  80bf9a:	5f                   	pop    %edi
  80bf9b:	5d                   	pop    %ebp
  80bf9c:	c3                   	ret    

0080bf9d <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80bf9d:	55                   	push   %ebp
  80bf9e:	89 e5                	mov    %esp,%ebp
  80bfa0:	57                   	push   %edi
  80bfa1:	56                   	push   %esi
  80bfa2:	53                   	push   %ebx
  80bfa3:	83 ec 0c             	sub    $0xc,%esp
  80bfa6:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bfa9:	8b 1e                	mov    (%esi),%ebx
  80bfab:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80bfaf:	7c 7a                	jl     80c02b <do_send+0x8e>
    if (msg->conn->pcb.tcp != NULL) {
  80bfb1:	8b 53 08             	mov    0x8(%ebx),%edx
  80bfb4:	85 d2                	test   %edx,%edx
  80bfb6:	74 73                	je     80c02b <do_send+0x8e>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bfb8:	8b 03                	mov    (%ebx),%eax
  80bfba:	25 f0 00 00 00       	and    $0xf0,%eax
  80bfbf:	83 f8 20             	cmp    $0x20,%eax
  80bfc2:	74 36                	je     80bffa <do_send+0x5d>
  80bfc4:	83 f8 40             	cmp    $0x40,%eax
  80bfc7:	75 62                	jne    80c02b <do_send+0x8e>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80bfc9:	8b 46 04             	mov    0x4(%esi),%eax
  80bfcc:	8b 48 08             	mov    0x8(%eax),%ecx
  80bfcf:	85 c9                	test   %ecx,%ecx
  80bfd1:	75 13                	jne    80bfe6 <do_send+0x49>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80bfd3:	83 ec 08             	sub    $0x8,%esp
  80bfd6:	ff 30                	pushl  (%eax)
  80bfd8:	52                   	push   %edx
  80bfd9:	e8 99 1e 00 00       	call   80de77 <raw_send>
  80bfde:	88 43 0c             	mov    %al,0xc(%ebx)
  80bfe1:	83 c4 10             	add    $0x10,%esp
  80bfe4:	eb 45                	jmp    80c02b <do_send+0x8e>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80bfe6:	83 ec 04             	sub    $0x4,%esp
  80bfe9:	51                   	push   %ecx
  80bfea:	ff 30                	pushl  (%eax)
  80bfec:	52                   	push   %edx
  80bfed:	e8 73 1d 00 00       	call   80dd65 <raw_sendto>
  80bff2:	88 43 0c             	mov    %al,0xc(%ebx)
  80bff5:	83 c4 10             	add    $0x10,%esp
  80bff8:	eb 31                	jmp    80c02b <do_send+0x8e>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80bffa:	8b 46 04             	mov    0x4(%esi),%eax
  80bffd:	8b 48 08             	mov    0x8(%eax),%ecx
  80c000:	85 c9                	test   %ecx,%ecx
  80c002:	75 13                	jne    80c017 <do_send+0x7a>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80c004:	83 ec 08             	sub    $0x8,%esp
  80c007:	ff 30                	pushl  (%eax)
  80c009:	52                   	push   %edx
  80c00a:	e8 5e ce ff ff       	call   808e6d <udp_send>
  80c00f:	88 43 0c             	mov    %al,0xc(%ebx)
  80c012:	83 c4 10             	add    $0x10,%esp
  80c015:	eb 14                	jmp    80c02b <do_send+0x8e>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80c017:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80c01b:	57                   	push   %edi
  80c01c:	51                   	push   %ecx
  80c01d:	ff 30                	pushl  (%eax)
  80c01f:	52                   	push   %edx
  80c020:	e8 08 ce ff ff       	call   808e2d <udp_sendto>
  80c025:	88 43 0c             	mov    %al,0xc(%ebx)
  80c028:	83 c4 10             	add    $0x10,%esp
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c02b:	83 ec 0c             	sub    $0xc,%esp
  80c02e:	8b 06                	mov    (%esi),%eax
  80c030:	ff 70 10             	pushl  0x10(%eax)
  80c033:	e8 a0 df ff ff       	call   809fd8 <sys_sem_signal>
}
  80c038:	83 c4 10             	add    $0x10,%esp
  80c03b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c03e:	5b                   	pop    %ebx
  80c03f:	5e                   	pop    %esi
  80c040:	5f                   	pop    %edi
  80c041:	5d                   	pop    %ebp
  80c042:	c3                   	ret    

0080c043 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80c043:	55                   	push   %ebp
  80c044:	89 e5                	mov    %esp,%ebp
  80c046:	53                   	push   %ebx
  80c047:	83 ec 04             	sub    $0x4,%esp
  80c04a:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c04d:	8b 03                	mov    (%ebx),%eax
  80c04f:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c053:	7c 1d                	jl     80c072 <do_recv+0x2f>
    if (msg->conn->pcb.tcp != NULL) {
  80c055:	8b 50 08             	mov    0x8(%eax),%edx
  80c058:	85 d2                	test   %edx,%edx
  80c05a:	74 16                	je     80c072 <do_recv+0x2f>
      if (msg->conn->type == NETCONN_TCP) {
  80c05c:	83 38 10             	cmpl   $0x10,(%eax)
  80c05f:	75 11                	jne    80c072 <do_recv+0x2f>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80c061:	83 ec 08             	sub    $0x8,%esp
  80c064:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80c068:	50                   	push   %eax
  80c069:	52                   	push   %edx
  80c06a:	e8 f7 95 ff ff       	call   805666 <tcp_recved>
  80c06f:	83 c4 10             	add    $0x10,%esp
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80c072:	83 ec 0c             	sub    $0xc,%esp
  80c075:	8b 03                	mov    (%ebx),%eax
  80c077:	ff 70 10             	pushl  0x10(%eax)
  80c07a:	e8 59 df ff ff       	call   809fd8 <sys_sem_signal>
}
  80c07f:	83 c4 10             	add    $0x10,%esp
  80c082:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c085:	c9                   	leave  
  80c086:	c3                   	ret    

0080c087 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80c087:	55                   	push   %ebp
  80c088:	89 e5                	mov    %esp,%ebp
  80c08a:	83 ec 08             	sub    $0x8,%esp
  80c08d:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c090:	8b 02                	mov    (%edx),%eax
  80c092:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c096:	7c 2d                	jl     80c0c5 <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c098:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c09c:	74 23                	je     80c0c1 <do_write+0x3a>
  80c09e:	83 38 10             	cmpl   $0x10,(%eax)
  80c0a1:	75 1e                	jne    80c0c1 <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80c0a3:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80c0aa:	8b 02                	mov    (%edx),%eax
  80c0ac:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80c0af:	8b 02                	mov    (%edx),%eax
  80c0b1:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80c0b8:	8b 02                	mov    (%edx),%eax
  80c0ba:	e8 c0 f4 ff ff       	call   80b57f <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80c0bf:	eb 14                	jmp    80c0d5 <do_write+0x4e>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c0c1:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c0c5:	83 ec 0c             	sub    $0xc,%esp
  80c0c8:	8b 02                	mov    (%edx),%eax
  80c0ca:	ff 70 10             	pushl  0x10(%eax)
  80c0cd:	e8 06 df ff ff       	call   809fd8 <sys_sem_signal>
  80c0d2:	83 c4 10             	add    $0x10,%esp
}
  80c0d5:	c9                   	leave  
  80c0d6:	c3                   	ret    

0080c0d7 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80c0d7:	55                   	push   %ebp
  80c0d8:	89 e5                	mov    %esp,%ebp
  80c0da:	83 ec 08             	sub    $0x8,%esp
  80c0dd:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80c0e0:	8b 08                	mov    (%eax),%ecx
  80c0e2:	8b 51 08             	mov    0x8(%ecx),%edx
  80c0e5:	85 d2                	test   %edx,%edx
  80c0e7:	0f 84 98 00 00 00    	je     80c185 <do_getaddr+0xae>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c0ed:	8b 48 04             	mov    0x4(%eax),%ecx
  80c0f0:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c0f4:	74 06                	je     80c0fc <do_getaddr+0x25>
  80c0f6:	8b 12                	mov    (%edx),%edx
  80c0f8:	89 11                	mov    %edx,(%ecx)
  80c0fa:	eb 05                	jmp    80c101 <do_getaddr+0x2a>
  80c0fc:	8b 52 04             	mov    0x4(%edx),%edx
  80c0ff:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c101:	8b 08                	mov    (%eax),%ecx
  80c103:	8b 11                	mov    (%ecx),%edx
  80c105:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c10b:	83 fa 20             	cmp    $0x20,%edx
  80c10e:	74 27                	je     80c137 <do_getaddr+0x60>
  80c110:	83 fa 40             	cmp    $0x40,%edx
  80c113:	74 07                	je     80c11c <do_getaddr+0x45>
  80c115:	83 fa 10             	cmp    $0x10,%edx
  80c118:	75 6f                	jne    80c189 <do_getaddr+0xb2>
  80c11a:	eb 4b                	jmp    80c167 <do_getaddr+0x90>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80c11c:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c120:	74 0f                	je     80c131 <do_getaddr+0x5a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c122:	8b 50 08             	mov    0x8(%eax),%edx
  80c125:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c128:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c12c:	66 89 0a             	mov    %cx,(%edx)
  80c12f:	eb 58                	jmp    80c189 <do_getaddr+0xb2>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80c131:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c135:	eb 52                	jmp    80c189 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80c137:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c13b:	74 0f                	je     80c14c <do_getaddr+0x75>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c13d:	8b 50 08             	mov    0x8(%eax),%edx
  80c140:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c143:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c147:	66 89 0a             	mov    %cx,(%edx)
  80c14a:	eb 3d                	jmp    80c189 <do_getaddr+0xb2>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c14c:	8b 51 08             	mov    0x8(%ecx),%edx
  80c14f:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c153:	75 06                	jne    80c15b <do_getaddr+0x84>
          msg->conn->err = ERR_CONN;
  80c155:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c159:	eb 2e                	jmp    80c189 <do_getaddr+0xb2>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c15b:	8b 48 08             	mov    0x8(%eax),%ecx
  80c15e:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c162:	66 89 11             	mov    %dx,(%ecx)
  80c165:	eb 22                	jmp    80c189 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c167:	8b 50 08             	mov    0x8(%eax),%edx
  80c16a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c16e:	74 09                	je     80c179 <do_getaddr+0xa2>
  80c170:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c173:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  80c177:	eb 07                	jmp    80c180 <do_getaddr+0xa9>
  80c179:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c17c:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  80c180:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c183:	eb 04                	jmp    80c189 <do_getaddr+0xb2>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80c185:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80c189:	83 ec 0c             	sub    $0xc,%esp
  80c18c:	8b 00                	mov    (%eax),%eax
  80c18e:	ff 70 10             	pushl  0x10(%eax)
  80c191:	e8 42 de ff ff       	call   809fd8 <sys_sem_signal>
}
  80c196:	83 c4 10             	add    $0x10,%esp
  80c199:	c9                   	leave  
  80c19a:	c3                   	ret    

0080c19b <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c19b:	55                   	push   %ebp
  80c19c:	89 e5                	mov    %esp,%ebp
  80c19e:	83 ec 08             	sub    $0x8,%esp
  80c1a1:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c1a4:	8b 02                	mov    (%edx),%eax
  80c1a6:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c1aa:	74 15                	je     80c1c1 <do_close+0x26>
  80c1ac:	83 38 10             	cmpl   $0x10,(%eax)
  80c1af:	75 10                	jne    80c1c1 <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80c1b1:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c1b8:	8b 02                	mov    (%edx),%eax
  80c1ba:	e8 09 f5 ff ff       	call   80b6c8 <do_close_internal>
  80c1bf:	eb 14                	jmp    80c1d5 <do_close+0x3a>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c1c1:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c1c5:	83 ec 0c             	sub    $0xc,%esp
  80c1c8:	8b 02                	mov    (%edx),%eax
  80c1ca:	ff 70 10             	pushl  0x10(%eax)
  80c1cd:	e8 06 de ff ff       	call   809fd8 <sys_sem_signal>
  80c1d2:	83 c4 10             	add    $0x10,%esp
  }
}
  80c1d5:	c9                   	leave  
  80c1d6:	c3                   	ret    

0080c1d7 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c1d7:	55                   	push   %ebp
  80c1d8:	89 e5                	mov    %esp,%ebp
  80c1da:	57                   	push   %edi
  80c1db:	56                   	push   %esi
  80c1dc:	53                   	push   %ebx
  80c1dd:	83 ec 18             	sub    $0x18,%esp
  80c1e0:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c1e2:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c1e8:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c1ec:	50                   	push   %eax
  80c1ed:	e8 f1 b4 ff ff       	call   8076e3 <ntohs>
  80c1f2:	83 c4 10             	add    $0x10,%esp
  80c1f5:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c1f9:	0f 86 83 00 00 00    	jbe    80c282 <tcp_parseopt+0xab>
{
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c1ff:	83 c6 14             	add    $0x14,%esi
  80c202:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c207:	eb 4f                	jmp    80c258 <tcp_parseopt+0x81>

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80c209:	0f b6 d3             	movzbl %bl,%edx
  80c20c:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c210:	84 c0                	test   %al,%al
  80c212:	74 6e                	je     80c282 <tcp_parseopt+0xab>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80c214:	3c 01                	cmp    $0x1,%al
  80c216:	75 05                	jne    80c21d <tcp_parseopt+0x46>
        ++c;
  80c218:	83 c3 01             	add    $0x1,%ebx
  80c21b:	eb 3b                	jmp    80c258 <tcp_parseopt+0x81>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80c21d:	3c 02                	cmp    $0x2,%al
  80c21f:	75 2c                	jne    80c24d <tcp_parseopt+0x76>
  80c221:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c226:	75 25                	jne    80c24d <tcp_parseopt+0x76>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c228:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80c22d:	c1 e0 08             	shl    $0x8,%eax
  80c230:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80c235:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c237:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c23a:	66 81 fa b3 05       	cmp    $0x5b3,%dx
  80c23f:	ba b4 05 00 00       	mov    $0x5b4,%edx
  80c244:	0f 47 c2             	cmova  %edx,%eax
  80c247:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80c24b:	eb 35                	jmp    80c282 <tcp_parseopt+0xab>
      } else {
        if (opts[c + 1] == 0) {
  80c24d:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c252:	84 c0                	test   %al,%al
  80c254:	74 2c                	je     80c282 <tcp_parseopt+0xab>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c256:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c258:	83 ec 0c             	sub    $0xc,%esp
  80c25b:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80c260:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c264:	50                   	push   %eax
  80c265:	e8 79 b4 ff ff       	call   8076e3 <ntohs>
  80c26a:	0f b6 d3             	movzbl %bl,%edx
  80c26d:	66 c1 e8 0c          	shr    $0xc,%ax
  80c271:	0f b7 c0             	movzwl %ax,%eax
  80c274:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c27b:	83 c4 10             	add    $0x10,%esp
  80c27e:	39 c2                	cmp    %eax,%edx
  80c280:	7c 87                	jl     80c209 <tcp_parseopt+0x32>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80c282:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c285:	5b                   	pop    %ebx
  80c286:	5e                   	pop    %esi
  80c287:	5f                   	pop    %edi
  80c288:	5d                   	pop    %ebp
  80c289:	c3                   	ret    

0080c28a <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80c28a:	55                   	push   %ebp
  80c28b:	89 e5                	mov    %esp,%ebp
  80c28d:	57                   	push   %edi
  80c28e:	56                   	push   %esi
  80c28f:	53                   	push   %ebx
  80c290:	83 ec 1c             	sub    $0x1c,%esp
  80c293:	89 c7                	mov    %eax,%edi
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80c295:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80c29c:	0f 84 46 04 00 00    	je     80c6e8 <tcp_receive+0x45e>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c2a2:	0f b7 58 5c          	movzwl 0x5c(%eax),%ebx
  80c2a6:	8b 40 60             	mov    0x60(%eax),%eax

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c2a9:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c2af:	39 d0                	cmp    %edx,%eax
  80c2b1:	78 26                	js     80c2d9 <tcp_receive+0x4f>
  80c2b3:	39 d0                	cmp    %edx,%eax
  80c2b5:	75 0b                	jne    80c2c2 <tcp_receive+0x38>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c2b7:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c2bd:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80c2c0:	78 17                	js     80c2d9 <tcp_receive+0x4f>
  80c2c2:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c2c8:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80c2cb:	75 3b                	jne    80c308 <tcp_receive+0x7e>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c2cd:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
  80c2d3:	66 3b 59 0e          	cmp    0xe(%ecx),%bx
  80c2d7:	73 2f                	jae    80c308 <tcp_receive+0x7e>
      pcb->snd_wnd = tcphdr->wnd;
  80c2d9:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
  80c2df:	0f b7 49 0e          	movzwl 0xe(%ecx),%ecx
  80c2e3:	66 89 4f 5c          	mov    %cx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c2e7:	89 57 60             	mov    %edx,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c2ea:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80c2f0:	89 57 64             	mov    %edx,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c2f3:	66 85 c9             	test   %cx,%cx
  80c2f6:	74 10                	je     80c308 <tcp_receive+0x7e>
  80c2f8:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c2ff:	74 07                	je     80c308 <tcp_receive+0x7e>
          pcb->persist_backoff = 0;
  80c301:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80c308:	8b 4f 48             	mov    0x48(%edi),%ecx
  80c30b:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80c311:	39 d1                	cmp    %edx,%ecx
  80c313:	0f 85 ad 00 00 00    	jne    80c3c6 <tcp_receive+0x13c>
      pcb->acked = 0;
  80c319:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c31f:	0f b7 db             	movzwl %bx,%ebx
  80c322:	01 d8                	add    %ebx,%eax
  80c324:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80c328:	03 57 60             	add    0x60(%edi),%edx
  80c32b:	39 d0                	cmp    %edx,%eax
  80c32d:	0f 85 e2 02 00 00    	jne    80c615 <tcp_receive+0x38b>
        ++pcb->dupacks;
  80c333:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c337:	83 c0 01             	add    $0x1,%eax
  80c33a:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c33d:	3c 02                	cmp    $0x2,%al
  80c33f:	0f 86 d0 02 00 00    	jbe    80c615 <tcp_receive+0x38b>
  80c345:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c349:	0f 84 c6 02 00 00    	je     80c615 <tcp_receive+0x38b>
          if (!(pcb->flags & TF_INFR)) {
  80c34f:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c353:	75 55                	jne    80c3aa <tcp_receive+0x120>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80c355:	83 ec 0c             	sub    $0xc,%esp
  80c358:	57                   	push   %edi
  80c359:	e8 91 c2 ff ff       	call   8085ef <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80c35e:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  80c362:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80c366:	83 c4 10             	add    $0x10,%esp
  80c369:	66 39 d0             	cmp    %dx,%ax
  80c36c:	76 09                	jbe    80c377 <tcp_receive+0xed>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c36e:	66 d1 ea             	shr    %dx
  80c371:	66 89 57 50          	mov    %dx,0x50(%edi)
  80c375:	eb 07                	jmp    80c37e <tcp_receive+0xf4>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80c377:	66 d1 e8             	shr    %ax
  80c37a:	66 89 47 50          	mov    %ax,0x50(%edi)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80c37e:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c382:	0f b7 4f 50          	movzwl 0x50(%edi),%ecx
  80c386:	0f b7 d0             	movzwl %ax,%edx
  80c389:	01 d2                	add    %edx,%edx
  80c38b:	39 d1                	cmp    %edx,%ecx
  80c38d:	7d 07                	jge    80c396 <tcp_receive+0x10c>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80c38f:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c392:	66 89 57 50          	mov    %dx,0x50(%edi)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c396:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c399:	66 03 47 50          	add    0x50(%edi),%ax
  80c39d:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c3a1:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c3a5:	e9 6b 02 00 00       	jmp    80c615 <tcp_receive+0x38b>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c3aa:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c3ae:	89 d0                	mov    %edx,%eax
  80c3b0:	66 03 47 34          	add    0x34(%edi),%ax
  80c3b4:	66 39 c2             	cmp    %ax,%dx
  80c3b7:	0f 83 58 02 00 00    	jae    80c615 <tcp_receive+0x38b>
              pcb->cwnd += pcb->mss;
  80c3bd:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c3c1:	e9 4f 02 00 00       	jmp    80c615 <tcp_receive+0x38b>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c3c6:	8d 42 ff             	lea    -0x1(%edx),%eax
  80c3c9:	39 c8                	cmp    %ecx,%eax
  80c3cb:	0f 88 9d 01 00 00    	js     80c56e <tcp_receive+0x2e4>
  80c3d1:	89 d0                	mov    %edx,%eax
  80c3d3:	2b 47 58             	sub    0x58(%edi),%eax
  80c3d6:	85 c0                	test   %eax,%eax
  80c3d8:	0f 8f 90 01 00 00    	jg     80c56e <tcp_receive+0x2e4>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80c3de:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80c3e2:	a8 04                	test   $0x4,%al
  80c3e4:	74 0e                	je     80c3f4 <tcp_receive+0x16a>
        pcb->flags &= ~TF_INFR;
  80c3e6:	83 e0 fb             	and    $0xfffffffb,%eax
  80c3e9:	88 47 20             	mov    %al,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c3ec:	0f b7 47 50          	movzwl 0x50(%edi),%eax
  80c3f0:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  80c3f4:	c6 47 46 00          	movb   $0x0,0x46(%edi)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c3f8:	0f b7 47 40          	movzwl 0x40(%edi),%eax
  80c3fc:	66 c1 f8 03          	sar    $0x3,%ax
  80c400:	66 03 47 42          	add    0x42(%edi),%ax
  80c404:	66 89 47 44          	mov    %ax,0x44(%edi)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c408:	89 d0                	mov    %edx,%eax
  80c40a:	29 c8                	sub    %ecx,%eax
  80c40c:	66 89 47 6c          	mov    %ax,0x6c(%edi)

      pcb->snd_buf += pcb->acked;
  80c410:	66 01 47 6e          	add    %ax,0x6e(%edi)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  80c414:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c418:	89 57 48             	mov    %edx,0x48(%edi)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  80c41b:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c41f:	0f 86 c3 00 00 00    	jbe    80c4e8 <tcp_receive+0x25e>
        if (pcb->cwnd < pcb->ssthresh) {
  80c425:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c429:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c42d:	73 18                	jae    80c447 <tcp_receive+0x1bd>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c42f:	89 c8                	mov    %ecx,%eax
  80c431:	66 03 47 34          	add    0x34(%edi),%ax
  80c435:	66 39 c1             	cmp    %ax,%cx
  80c438:	0f 83 aa 00 00 00    	jae    80c4e8 <tcp_receive+0x25e>
            pcb->cwnd += pcb->mss;
  80c43e:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c442:	e9 a1 00 00 00       	jmp    80c4e8 <tcp_receive+0x25e>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c447:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c44b:	0f af c0             	imul   %eax,%eax
  80c44e:	0f b7 d9             	movzwl %cx,%ebx
  80c451:	99                   	cltd   
  80c452:	f7 fb                	idiv   %ebx
  80c454:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c456:	66 39 c1             	cmp    %ax,%cx
  80c459:	0f 83 89 00 00 00    	jae    80c4e8 <tcp_receive+0x25e>
            pcb->cwnd = new_cwnd;
  80c45f:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c463:	e9 80 00 00 00       	jmp    80c4e8 <tcp_receive+0x25e>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  80c468:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c46b:	8b 03                	mov    (%ebx),%eax
  80c46d:	89 47 78             	mov    %eax,0x78(%edi)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c470:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c474:	83 ec 0c             	sub    $0xc,%esp
  80c477:	ff 73 04             	pushl  0x4(%ebx)
  80c47a:	e8 05 88 ff ff       	call   804c84 <pbuf_clen>
  80c47f:	0f b6 c0             	movzbl %al,%eax
  80c482:	83 c4 10             	add    $0x10,%esp
  80c485:	66 39 c6             	cmp    %ax,%si
  80c488:	73 17                	jae    80c4a1 <tcp_receive+0x217>
  80c48a:	83 ec 04             	sub    $0x4,%esp
  80c48d:	68 24 2e 81 00       	push   $0x812e24
  80c492:	68 55 03 00 00       	push   $0x355
  80c497:	68 90 2f 81 00       	push   $0x812f90
  80c49c:	e8 ad 1f 00 00       	call   80e44e <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c4a1:	83 ec 0c             	sub    $0xc,%esp
  80c4a4:	ff 73 04             	pushl  0x4(%ebx)
  80c4a7:	e8 d8 87 ff ff       	call   804c84 <pbuf_clen>
  80c4ac:	0f b6 c0             	movzbl %al,%eax
  80c4af:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c4b3:	89 1c 24             	mov    %ebx,(%esp)
  80c4b6:	e8 b0 92 ff ff       	call   80576b <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  80c4bb:	83 c4 10             	add    $0x10,%esp
  80c4be:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c4c3:	74 23                	je     80c4e8 <tcp_receive+0x25e>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c4c5:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c4c9:	75 1d                	jne    80c4e8 <tcp_receive+0x25e>
  80c4cb:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c4cf:	75 17                	jne    80c4e8 <tcp_receive+0x25e>
  80c4d1:	83 ec 04             	sub    $0x4,%esp
  80c4d4:	68 4c 2e 81 00       	push   $0x812e4c
  80c4d9:	68 5c 03 00 00       	push   $0x35c
  80c4de:	68 90 2f 81 00       	push   $0x812f90
  80c4e3:	e8 66 1f 00 00       	call   80e44e <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80c4e8:	8b 47 78             	mov    0x78(%edi),%eax
  80c4eb:	85 c0                	test   %eax,%eax
  80c4ed:	74 68                	je     80c557 <tcp_receive+0x2cd>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c4ef:	83 ec 0c             	sub    $0xc,%esp
  80c4f2:	8b 40 10             	mov    0x10(%eax),%eax
  80c4f5:	ff 70 04             	pushl  0x4(%eax)
  80c4f8:	e8 14 b4 ff ff       	call   807911 <ntohl>
  80c4fd:	89 c6                	mov    %eax,%esi
  80c4ff:	8b 47 78             	mov    0x78(%edi),%eax
  80c502:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80c506:	8b 40 10             	mov    0x10(%eax),%eax
  80c509:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c50d:	89 04 24             	mov    %eax,(%esp)
  80c510:	e8 ce b1 ff ff       	call   8076e3 <ntohs>
  80c515:	83 c4 10             	add    $0x10,%esp
  80c518:	ba 01 00 00 00       	mov    $0x1,%edx
  80c51d:	a8 01                	test   $0x1,%al
  80c51f:	75 1e                	jne    80c53f <tcp_receive+0x2b5>
  80c521:	83 ec 0c             	sub    $0xc,%esp
  80c524:	8b 47 78             	mov    0x78(%edi),%eax
  80c527:	8b 40 10             	mov    0x10(%eax),%eax
  80c52a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c52e:	50                   	push   %eax
  80c52f:	e8 af b1 ff ff       	call   8076e3 <ntohs>
  80c534:	66 d1 e8             	shr    %ax
  80c537:	89 c2                	mov    %eax,%edx
  80c539:	83 e2 01             	and    $0x1,%edx
  80c53c:	83 c4 10             	add    $0x10,%esp
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80c53f:	2b 35 a4 b1 b3 00    	sub    0xb3b1a4,%esi
  80c545:	01 d3                	add    %edx,%ebx
  80c547:	01 f3                	add    %esi,%ebx
  80c549:	85 db                	test   %ebx,%ebx
  80c54b:	0f 8e 17 ff ff ff    	jle    80c468 <tcp_receive+0x1de>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80c551:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c555:	75 08                	jne    80c55f <tcp_receive+0x2d5>
        pcb->rtime = -1;
  80c557:	66 c7 47 32 ff ff    	movw   $0xffff,0x32(%edi)
  80c55d:	eb 06                	jmp    80c565 <tcp_receive+0x2db>
      else
        pcb->rtime = 0;
  80c55f:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

      pcb->polltmr = 0;
  80c565:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80c569:	e9 a7 00 00 00       	jmp    80c615 <tcp_receive+0x38b>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  80c56e:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c574:	e9 9c 00 00 00       	jmp    80c615 <tcp_receive+0x38b>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  80c579:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80c57c:	8b 03                	mov    (%ebx),%eax
  80c57e:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c581:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c585:	83 ec 0c             	sub    $0xc,%esp
  80c588:	ff 73 04             	pushl  0x4(%ebx)
  80c58b:	e8 f4 86 ff ff       	call   804c84 <pbuf_clen>
  80c590:	0f b6 c0             	movzbl %al,%eax
  80c593:	83 c4 10             	add    $0x10,%esp
  80c596:	66 39 c6             	cmp    %ax,%si
  80c599:	73 17                	jae    80c5b2 <tcp_receive+0x328>
  80c59b:	83 ec 04             	sub    $0x4,%esp
  80c59e:	68 24 2e 81 00       	push   $0x812e24
  80c5a3:	68 7f 03 00 00       	push   $0x37f
  80c5a8:	68 90 2f 81 00       	push   $0x812f90
  80c5ad:	e8 9c 1e 00 00       	call   80e44e <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80c5b2:	83 ec 0c             	sub    $0xc,%esp
  80c5b5:	ff 73 04             	pushl  0x4(%ebx)
  80c5b8:	e8 c7 86 ff ff       	call   804c84 <pbuf_clen>
  80c5bd:	0f b6 c0             	movzbl %al,%eax
  80c5c0:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80c5c4:	89 1c 24             	mov    %ebx,(%esp)
  80c5c7:	e8 9f 91 ff ff       	call   80576b <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  80c5cc:	83 c4 10             	add    $0x10,%esp
  80c5cf:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c5d4:	74 24                	je     80c5fa <tcp_receive+0x370>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c5d6:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c5da:	75 1e                	jne    80c5fa <tcp_receive+0x370>
  80c5dc:	8b 47 74             	mov    0x74(%edi),%eax
  80c5df:	85 c0                	test   %eax,%eax
  80c5e1:	75 1e                	jne    80c601 <tcp_receive+0x377>
  80c5e3:	83 ec 04             	sub    $0x4,%esp
  80c5e6:	68 4c 2e 81 00       	push   $0x812e4c
  80c5eb:	68 85 03 00 00       	push   $0x385
  80c5f0:	68 90 2f 81 00       	push   $0x812f90
  80c5f5:	e8 54 1e 00 00       	call   80e44e <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  80c5fa:	8b 47 74             	mov    0x74(%edi),%eax
  80c5fd:	85 c0                	test   %eax,%eax
  80c5ff:	74 14                	je     80c615 <tcp_receive+0x38b>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80c601:	83 ec 0c             	sub    $0xc,%esp
  80c604:	8b 40 10             	mov    0x10(%eax),%eax
  80c607:	ff 70 04             	pushl  0x4(%eax)
  80c60a:	e8 e1 b0 ff ff       	call   8076f0 <htonl>
  80c60f:	89 47 54             	mov    %eax,0x54(%edi)
  80c612:	83 c4 10             	add    $0x10,%esp
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80c615:	8b 47 74             	mov    0x74(%edi),%eax
  80c618:	85 c0                	test   %eax,%eax
  80c61a:	74 70                	je     80c68c <tcp_receive+0x402>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c61c:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c622:	83 ec 0c             	sub    $0xc,%esp
  80c625:	8b 40 10             	mov    0x10(%eax),%eax
  80c628:	ff 70 04             	pushl  0x4(%eax)
  80c62b:	e8 e1 b2 ff ff       	call   807911 <ntohl>
  80c630:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c633:	8b 47 74             	mov    0x74(%edi),%eax
  80c636:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80c63a:	8b 40 10             	mov    0x10(%eax),%eax
  80c63d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c641:	89 04 24             	mov    %eax,(%esp)
  80c644:	e8 9a b0 ff ff       	call   8076e3 <ntohs>
  80c649:	83 c4 10             	add    $0x10,%esp
  80c64c:	ba 01 00 00 00       	mov    $0x1,%edx
  80c651:	a8 01                	test   $0x1,%al
  80c653:	75 1e                	jne    80c673 <tcp_receive+0x3e9>
  80c655:	83 ec 0c             	sub    $0xc,%esp
  80c658:	8b 47 74             	mov    0x74(%edi),%eax
  80c65b:	8b 40 10             	mov    0x10(%eax),%eax
  80c65e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c662:	50                   	push   %eax
  80c663:	e8 7b b0 ff ff       	call   8076e3 <ntohs>
  80c668:	66 d1 e8             	shr    %ax
  80c66b:	89 c2                	mov    %eax,%edx
  80c66d:	83 e2 01             	and    $0x1,%edx
  80c670:	83 c4 10             	add    $0x10,%esp
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80c673:	2b 75 e4             	sub    -0x1c(%ebp),%esi
  80c676:	01 d3                	add    %edx,%ebx
  80c678:	39 de                	cmp    %ebx,%esi
  80c67a:	78 10                	js     80c68c <tcp_receive+0x402>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c67c:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c681:	2b 47 58             	sub    0x58(%edi),%eax
  80c684:	85 c0                	test   %eax,%eax
  80c686:	0f 8e ed fe ff ff    	jle    80c579 <tcp_receive+0x2ef>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80c68c:	8b 47 38             	mov    0x38(%edi),%eax
  80c68f:	85 c0                	test   %eax,%eax
  80c691:	74 55                	je     80c6e8 <tcp_receive+0x45e>
  80c693:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c699:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80c69c:	79 4a                	jns    80c6e8 <tcp_receive+0x45e>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80c69e:	0f b7 5f 40          	movzwl 0x40(%edi),%ebx
  80c6a2:	0f b7 15 40 b2 b3 00 	movzwl 0xb3b240,%edx
  80c6a9:	29 c2                	sub    %eax,%edx
  80c6ab:	89 d8                	mov    %ebx,%eax
  80c6ad:	66 c1 f8 03          	sar    $0x3,%ax
  80c6b1:	89 d1                	mov    %edx,%ecx
  80c6b3:	29 c1                	sub    %eax,%ecx
      pcb->sa += m;
  80c6b5:	01 cb                	add    %ecx,%ebx
  80c6b7:	66 89 5f 40          	mov    %bx,0x40(%edi)
      if (m < 0) {
        m = -m;
  80c6bb:	89 ca                	mov    %ecx,%edx
  80c6bd:	f7 da                	neg    %edx
  80c6bf:	66 85 c9             	test   %cx,%cx
  80c6c2:	0f 49 d1             	cmovns %ecx,%edx
      }
      m = m - (pcb->sv >> 2);
  80c6c5:	0f b7 47 42          	movzwl 0x42(%edi),%eax
      pcb->sv += m;
  80c6c9:	89 c1                	mov    %eax,%ecx
  80c6cb:	66 c1 f9 02          	sar    $0x2,%cx
  80c6cf:	29 c8                	sub    %ecx,%eax
  80c6d1:	01 d0                	add    %edx,%eax
  80c6d3:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c6d7:	66 c1 fb 03          	sar    $0x3,%bx
  80c6db:	01 d8                	add    %ebx,%eax
  80c6dd:	66 89 47 44          	mov    %ax,0x44(%edi)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  80c6e1:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  80c6e8:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80c6ef:	66 85 c0             	test   %ax,%ax
  80c6f2:	0f 84 8e 07 00 00    	je     80ce86 <tcp_receive+0xbfc>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80c6f8:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c6fb:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c701:	89 d9                	mov    %ebx,%ecx
  80c703:	29 d1                	sub    %edx,%ecx
  80c705:	89 ce                	mov    %ecx,%esi
  80c707:	83 ee 01             	sub    $0x1,%esi
  80c70a:	0f 88 27 01 00 00    	js     80c837 <tcp_receive+0x5ad>
  80c710:	8d 73 01             	lea    0x1(%ebx),%esi
  80c713:	29 d6                	sub    %edx,%esi
  80c715:	0f b7 c0             	movzwl %ax,%eax
  80c718:	29 c6                	sub    %eax,%esi
  80c71a:	85 f6                	test   %esi,%esi
  80c71c:	0f 8f 15 01 00 00    	jg     80c837 <tcp_receive+0x5ad>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  80c722:	89 c8                	mov    %ecx,%eax
      p = inseg.p;
  80c724:	8b 1d b8 b1 b3 00    	mov    0xb3b1b8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c72a:	85 db                	test   %ebx,%ebx
  80c72c:	75 17                	jne    80c745 <tcp_receive+0x4bb>
  80c72e:	83 ec 04             	sub    $0x4,%esp
  80c731:	68 a7 2f 81 00       	push   $0x812fa7
  80c736:	68 e5 03 00 00       	push   $0x3e5
  80c73b:	68 90 2f 81 00       	push   $0x812f90
  80c740:	e8 09 1d 00 00       	call   80e44e <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c745:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80c74b:	7e 17                	jle    80c764 <tcp_receive+0x4da>
  80c74d:	83 ec 04             	sub    $0x4,%esp
  80c750:	68 b7 2f 81 00       	push   $0x812fb7
  80c755:	68 e6 03 00 00       	push   $0x3e6
  80c75a:	68 90 2f 81 00       	push   $0x812f90
  80c75f:	e8 ea 1c 00 00       	call   80e44e <_panic>
      if (inseg.p->len < off) {
  80c764:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c768:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80c76b:	39 d1                	cmp    %edx,%ecx
  80c76d:	7e 6a                	jle    80c7d9 <tcp_receive+0x54f>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c76f:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80c773:	0f b7 d6             	movzwl %si,%edx
  80c776:	39 d1                	cmp    %edx,%ecx
  80c778:	7e 17                	jle    80c791 <tcp_receive+0x507>
  80c77a:	83 ec 04             	sub    $0x4,%esp
  80c77d:	68 c6 2f 81 00       	push   $0x812fc6
  80c782:	68 e8 03 00 00       	push   $0x3e8
  80c787:	68 90 2f 81 00       	push   $0x812f90
  80c78c:	e8 bd 1c 00 00       	call   80e44e <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80c791:	29 ce                	sub    %ecx,%esi
  80c793:	89 f1                	mov    %esi,%ecx
  80c795:	8b 55 e4             	mov    -0x1c(%ebp),%edx
        while (p->len < off) {
          off -= p->len;
  80c798:	29 d0                	sub    %edx,%eax
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  80c79a:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80c79e:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80c7a4:	8b 1b                	mov    (%ebx),%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  80c7a6:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c7aa:	39 c2                	cmp    %eax,%edx
  80c7ac:	7c ea                	jl     80c798 <tcp_receive+0x50e>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  80c7ae:	83 ec 08             	sub    $0x8,%esp
  80c7b1:	f7 d8                	neg    %eax
  80c7b3:	98                   	cwtl   
  80c7b4:	50                   	push   %eax
  80c7b5:	53                   	push   %ebx
  80c7b6:	e8 98 7f ff ff       	call   804753 <pbuf_header>
  80c7bb:	83 c4 10             	add    $0x10,%esp
  80c7be:	84 c0                	test   %al,%al
  80c7c0:	74 44                	je     80c806 <tcp_receive+0x57c>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80c7c2:	83 ec 04             	sub    $0x4,%esp
  80c7c5:	68 d6 2f 81 00       	push   $0x812fd6
  80c7ca:	68 f5 03 00 00       	push   $0x3f5
  80c7cf:	68 90 2f 81 00       	push   $0x812f90
  80c7d4:	e8 75 1c 00 00       	call   80e44e <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80c7d9:	83 ec 08             	sub    $0x8,%esp
  80c7dc:	f7 d9                	neg    %ecx
  80c7de:	0f bf c1             	movswl %cx,%eax
  80c7e1:	50                   	push   %eax
  80c7e2:	53                   	push   %ebx
  80c7e3:	e8 6b 7f ff ff       	call   804753 <pbuf_header>
  80c7e8:	83 c4 10             	add    $0x10,%esp
  80c7eb:	84 c0                	test   %al,%al
  80c7ed:	74 17                	je     80c806 <tcp_receive+0x57c>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80c7ef:	83 ec 04             	sub    $0x4,%esp
  80c7f2:	68 d6 2f 81 00       	push   $0x812fd6
  80c7f7:	68 fa 03 00 00       	push   $0x3fa
  80c7fc:	68 90 2f 81 00       	push   $0x812f90
  80c801:	e8 48 1c 00 00       	call   80e44e <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  80c806:	8b 43 04             	mov    0x4(%ebx),%eax
  80c809:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80c80e:	8b 57 24             	mov    0x24(%edi),%edx
  80c811:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80c818:	66 03 05 a8 b1 b3 00 	add    0xb3b1a8,%ax
  80c81f:	29 d0                	sub    %edx,%eax
  80c821:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80c827:	89 15 a8 b1 b3 00    	mov    %edx,0xb3b1a8
  80c82d:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c832:	89 50 04             	mov    %edx,0x4(%eax)
  80c835:	eb 14                	jmp    80c84b <tcp_receive+0x5c1>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80c837:	39 da                	cmp    %ebx,%edx
  80c839:	79 21                	jns    80c85c <tcp_receive+0x5d2>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  80c83b:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c83f:	83 ec 0c             	sub    $0xc,%esp
  80c842:	57                   	push   %edi
  80c843:	e8 b2 b7 ff ff       	call   807ffa <tcp_output>
  80c848:	83 c4 10             	add    $0x10,%esp
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c84b:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c851:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c854:	39 da                	cmp    %ebx,%edx
  80c856:	0f 88 13 06 00 00    	js     80ce6f <tcp_receive+0xbe5>
  80c85c:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80c860:	89 d1                	mov    %edx,%ecx
  80c862:	29 c1                	sub    %eax,%ecx
  80c864:	8d 41 01             	lea    0x1(%ecx),%eax
  80c867:	29 d8                	sub    %ebx,%eax
  80c869:	85 c0                	test   %eax,%eax
  80c86b:	0f 8f fe 05 00 00    	jg     80ce6f <tcp_receive+0xbe5>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  80c871:	39 da                	cmp    %ebx,%edx
  80c873:	0f 85 77 03 00 00    	jne    80cbf0 <tcp_receive+0x966>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80c879:	8b 4f 7c             	mov    0x7c(%edi),%ecx
  80c87c:	85 c9                	test   %ecx,%ecx
  80c87e:	0f 84 85 00 00 00    	je     80c909 <tcp_receive+0x67f>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80c884:	8b 41 10             	mov    0x10(%ecx),%eax
  80c887:	8b 58 04             	mov    0x4(%eax),%ebx
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80c88a:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80c891:	89 de                	mov    %ebx,%esi
  80c893:	29 c6                	sub    %eax,%esi
  80c895:	89 f0                	mov    %esi,%eax
  80c897:	29 d0                	sub    %edx,%eax
  80c899:	85 c0                	test   %eax,%eax
  80c89b:	7f 6c                	jg     80c909 <tcp_receive+0x67f>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  80c89d:	66 83 79 0c 00       	cmpw   $0x0,0xc(%ecx)
  80c8a2:	74 20                	je     80c8c4 <tcp_receive+0x63a>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80c8a4:	29 d3                	sub    %edx,%ebx
  80c8a6:	66 89 1d c0 b1 b3 00 	mov    %bx,0xb3b1c0
            pbuf_realloc(inseg.p, inseg.len);
  80c8ad:	83 ec 08             	sub    $0x8,%esp
  80c8b0:	0f b7 db             	movzwl %bx,%ebx
  80c8b3:	53                   	push   %ebx
  80c8b4:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80c8ba:	e8 af 82 ff ff       	call   804b6e <pbuf_realloc>
  80c8bf:	83 c4 10             	add    $0x10,%esp
  80c8c2:	eb 45                	jmp    80c909 <tcp_receive+0x67f>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80c8c4:	83 ec 0c             	sub    $0xc,%esp
  80c8c7:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c8cc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c8d0:	50                   	push   %eax
  80c8d1:	e8 0d ae ff ff       	call   8076e3 <ntohs>
  80c8d6:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80c8d8:	8b 47 7c             	mov    0x7c(%edi),%eax
  80c8db:	8b 40 10             	mov    0x10(%eax),%eax
  80c8de:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c8e2:	89 04 24             	mov    %eax,(%esp)
  80c8e5:	e8 f9 ad ff ff       	call   8076e3 <ntohs>
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80c8ea:	31 d8                	xor    %ebx,%eax
  80c8ec:	83 c4 10             	add    $0x10,%esp
  80c8ef:	a8 03                	test   $0x3,%al
  80c8f1:	75 16                	jne    80c909 <tcp_receive+0x67f>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80c8f3:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80c8f6:	8b 10                	mov    (%eax),%edx
  80c8f8:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80c8fb:	83 ec 08             	sub    $0x8,%esp
  80c8fe:	50                   	push   %eax
  80c8ff:	6a 04                	push   $0x4
  80c901:	e8 ac 7b ff ff       	call   8044b2 <memp_free>
  80c906:	83 c4 10             	add    $0x10,%esp
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  80c909:	0f b7 1d c0 b1 b3 00 	movzwl 0xb3b1c0,%ebx
  80c910:	83 ec 0c             	sub    $0xc,%esp
  80c913:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c918:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c91c:	50                   	push   %eax
  80c91d:	e8 c1 ad ff ff       	call   8076e3 <ntohs>
  80c922:	83 c4 10             	add    $0x10,%esp
  80c925:	ba 01 00 00 00       	mov    $0x1,%edx
  80c92a:	a8 01                	test   $0x1,%al
  80c92c:	75 1d                	jne    80c94b <tcp_receive+0x6c1>
  80c92e:	83 ec 0c             	sub    $0xc,%esp
  80c931:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c936:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c93a:	50                   	push   %eax
  80c93b:	e8 a3 ad ff ff       	call   8076e3 <ntohs>
  80c940:	66 d1 e8             	shr    %ax
  80c943:	89 c2                	mov    %eax,%edx
  80c945:	83 e2 01             	and    $0x1,%edx
  80c948:	83 c4 10             	add    $0x10,%esp
  80c94b:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80c94e:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  80c954:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80c958:	74 06                	je     80c960 <tcp_receive+0x6d6>
          pcb->rcv_nxt += tcplen;
  80c95a:	0f b7 d0             	movzwl %ax,%edx
  80c95d:	01 57 24             	add    %edx,0x24(%edi)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  80c960:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80c964:	66 39 d0             	cmp    %dx,%ax
  80c967:	76 08                	jbe    80c971 <tcp_receive+0x6e7>
          pcb->rcv_wnd = 0;
  80c969:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80c96f:	eb 06                	jmp    80c977 <tcp_receive+0x6ed>
        } else {
          pcb->rcv_wnd -= tcplen;
  80c971:	29 c2                	sub    %eax,%edx
  80c973:	66 89 57 28          	mov    %dx,0x28(%edi)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  80c977:	0f b7 57 2a          	movzwl 0x2a(%edi),%edx
  80c97b:	66 39 d0             	cmp    %dx,%ax
  80c97e:	76 08                	jbe    80c988 <tcp_receive+0x6fe>
          pcb->rcv_ann_wnd = 0;
  80c980:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80c986:	eb 06                	jmp    80c98e <tcp_receive+0x704>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  80c988:	29 c2                	sub    %eax,%edx
  80c98a:	66 89 57 2a          	mov    %dx,0x2a(%edi)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  80c98e:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80c993:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80c998:	74 0f                	je     80c9a9 <tcp_receive+0x71f>
          recv_data = inseg.p;
  80c99a:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  80c99f:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80c9a6:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80c9a9:	83 ec 0c             	sub    $0xc,%esp
  80c9ac:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c9b1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9b5:	50                   	push   %eax
  80c9b6:	e8 28 ad ff ff       	call   8076e3 <ntohs>
  80c9bb:	83 c4 10             	add    $0x10,%esp
  80c9be:	a8 01                	test   $0x1,%al
  80c9c0:	0f 84 dd 01 00 00    	je     80cba3 <tcp_receive+0x919>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  80c9c6:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
  80c9cd:	e9 d1 01 00 00       	jmp    80cba3 <tcp_receive+0x919>
           is now in sequence. */
        while (pcb->ooseq != NULL &&
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  80c9d2:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80c9d7:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80c9db:	83 ec 0c             	sub    $0xc,%esp
  80c9de:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80c9e2:	50                   	push   %eax
  80c9e3:	e8 fb ac ff ff       	call   8076e3 <ntohs>
  80c9e8:	83 c4 10             	add    $0x10,%esp
  80c9eb:	ba 01 00 00 00       	mov    $0x1,%edx
  80c9f0:	a8 01                	test   $0x1,%al
  80c9f2:	75 1b                	jne    80ca0f <tcp_receive+0x785>
  80c9f4:	83 ec 0c             	sub    $0xc,%esp
  80c9f7:	8b 43 10             	mov    0x10(%ebx),%eax
  80c9fa:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9fe:	50                   	push   %eax
  80c9ff:	e8 df ac ff ff       	call   8076e3 <ntohs>
  80ca04:	66 d1 e8             	shr    %ax
  80ca07:	89 c2                	mov    %eax,%edx
  80ca09:	83 e2 01             	and    $0x1,%edx
  80ca0c:	83 c4 10             	add    $0x10,%esp
  80ca0f:	01 d6                	add    %edx,%esi
  80ca11:	01 77 24             	add    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80ca14:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80ca18:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ca1b:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ca1f:	83 ec 0c             	sub    $0xc,%esp
  80ca22:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca25:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca29:	50                   	push   %eax
  80ca2a:	e8 b4 ac ff ff       	call   8076e3 <ntohs>
  80ca2f:	83 c4 10             	add    $0x10,%esp
  80ca32:	ba 01 00 00 00       	mov    $0x1,%edx
  80ca37:	a8 01                	test   $0x1,%al
  80ca39:	75 1b                	jne    80ca56 <tcp_receive+0x7cc>
  80ca3b:	83 ec 0c             	sub    $0xc,%esp
  80ca3e:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca41:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca45:	50                   	push   %eax
  80ca46:	e8 98 ac ff ff       	call   8076e3 <ntohs>
  80ca4b:	66 d1 e8             	shr    %ax
  80ca4e:	89 c2                	mov    %eax,%edx
  80ca50:	83 e2 01             	and    $0x1,%edx
  80ca53:	83 c4 10             	add    $0x10,%esp
  80ca56:	01 d6                	add    %edx,%esi
  80ca58:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80ca5b:	7d 08                	jge    80ca65 <tcp_receive+0x7db>
            pcb->rcv_wnd = 0;
  80ca5d:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80ca63:	eb 41                	jmp    80caa6 <tcp_receive+0x81c>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80ca65:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ca69:	83 ec 0c             	sub    $0xc,%esp
  80ca6c:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca6f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca73:	50                   	push   %eax
  80ca74:	e8 6a ac ff ff       	call   8076e3 <ntohs>
  80ca79:	83 c4 10             	add    $0x10,%esp
  80ca7c:	ba 01 00 00 00       	mov    $0x1,%edx
  80ca81:	a8 01                	test   $0x1,%al
  80ca83:	75 1b                	jne    80caa0 <tcp_receive+0x816>
  80ca85:	83 ec 0c             	sub    $0xc,%esp
  80ca88:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca8b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca8f:	50                   	push   %eax
  80ca90:	e8 4e ac ff ff       	call   8076e3 <ntohs>
  80ca95:	66 d1 e8             	shr    %ax
  80ca98:	89 c2                	mov    %eax,%edx
  80ca9a:	83 e2 01             	and    $0x1,%edx
  80ca9d:	83 c4 10             	add    $0x10,%esp
  80caa0:	01 d6                	add    %edx,%esi
  80caa2:	66 29 77 28          	sub    %si,0x28(%edi)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80caa6:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80caaa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80caad:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cab1:	83 ec 0c             	sub    $0xc,%esp
  80cab4:	8b 43 10             	mov    0x10(%ebx),%eax
  80cab7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cabb:	50                   	push   %eax
  80cabc:	e8 22 ac ff ff       	call   8076e3 <ntohs>
  80cac1:	83 c4 10             	add    $0x10,%esp
  80cac4:	ba 01 00 00 00       	mov    $0x1,%edx
  80cac9:	a8 01                	test   $0x1,%al
  80cacb:	75 1b                	jne    80cae8 <tcp_receive+0x85e>
  80cacd:	83 ec 0c             	sub    $0xc,%esp
  80cad0:	8b 43 10             	mov    0x10(%ebx),%eax
  80cad3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cad7:	50                   	push   %eax
  80cad8:	e8 06 ac ff ff       	call   8076e3 <ntohs>
  80cadd:	66 d1 e8             	shr    %ax
  80cae0:	89 c2                	mov    %eax,%edx
  80cae2:	83 e2 01             	and    $0x1,%edx
  80cae5:	83 c4 10             	add    $0x10,%esp
  80cae8:	01 d6                	add    %edx,%esi
  80caea:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80caed:	7d 08                	jge    80caf7 <tcp_receive+0x86d>
            pcb->rcv_ann_wnd = 0;
  80caef:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80caf5:	eb 41                	jmp    80cb38 <tcp_receive+0x8ae>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80caf7:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cafb:	83 ec 0c             	sub    $0xc,%esp
  80cafe:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb01:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb05:	50                   	push   %eax
  80cb06:	e8 d8 ab ff ff       	call   8076e3 <ntohs>
  80cb0b:	83 c4 10             	add    $0x10,%esp
  80cb0e:	ba 01 00 00 00       	mov    $0x1,%edx
  80cb13:	a8 01                	test   $0x1,%al
  80cb15:	75 1b                	jne    80cb32 <tcp_receive+0x8a8>
  80cb17:	83 ec 0c             	sub    $0xc,%esp
  80cb1a:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb1d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb21:	50                   	push   %eax
  80cb22:	e8 bc ab ff ff       	call   8076e3 <ntohs>
  80cb27:	66 d1 e8             	shr    %ax
  80cb2a:	89 c2                	mov    %eax,%edx
  80cb2c:	83 e2 01             	and    $0x1,%edx
  80cb2f:	83 c4 10             	add    $0x10,%esp
  80cb32:	01 d6                	add    %edx,%esi
  80cb34:	66 29 77 2a          	sub    %si,0x2a(%edi)
          }

          if (cseg->p->tot_len > 0) {
  80cb38:	8b 43 04             	mov    0x4(%ebx),%eax
  80cb3b:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80cb40:	74 25                	je     80cb67 <tcp_receive+0x8dd>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  80cb42:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80cb48:	85 d2                	test   %edx,%edx
  80cb4a:	74 0f                	je     80cb5b <tcp_receive+0x8d1>
              pbuf_cat(recv_data, cseg->p);
  80cb4c:	83 ec 08             	sub    $0x8,%esp
  80cb4f:	50                   	push   %eax
  80cb50:	52                   	push   %edx
  80cb51:	e8 57 81 ff ff       	call   804cad <pbuf_cat>
  80cb56:	83 c4 10             	add    $0x10,%esp
  80cb59:	eb 05                	jmp    80cb60 <tcp_receive+0x8d6>
            } else {
              recv_data = cseg->p;
  80cb5b:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
            }
            cseg->p = NULL;
  80cb60:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80cb67:	83 ec 0c             	sub    $0xc,%esp
  80cb6a:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb6d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb71:	50                   	push   %eax
  80cb72:	e8 6c ab ff ff       	call   8076e3 <ntohs>
  80cb77:	83 c4 10             	add    $0x10,%esp
  80cb7a:	a8 01                	test   $0x1,%al
  80cb7c:	74 14                	je     80cb92 <tcp_receive+0x908>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  80cb7e:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80cb85:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80cb89:	75 07                	jne    80cb92 <tcp_receive+0x908>
              pcb->state = CLOSE_WAIT;
  80cb8b:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
            } 
          }


          pcb->ooseq = cseg->next;
  80cb92:	8b 03                	mov    (%ebx),%eax
  80cb94:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80cb97:	83 ec 0c             	sub    $0xc,%esp
  80cb9a:	53                   	push   %ebx
  80cb9b:	e8 cb 8b ff ff       	call   80576b <tcp_seg_free>
  80cba0:	83 c4 10             	add    $0x10,%esp
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80cba3:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cba6:	85 db                	test   %ebx,%ebx
  80cba8:	74 0f                	je     80cbb9 <tcp_receive+0x92f>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80cbaa:	8b 53 10             	mov    0x10(%ebx),%edx
  80cbad:	8b 42 04             	mov    0x4(%edx),%eax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80cbb0:	3b 47 24             	cmp    0x24(%edi),%eax
  80cbb3:	0f 84 19 fe ff ff    	je     80c9d2 <tcp_receive+0x748>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80cbb9:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80cbbd:	a8 01                	test   $0x1,%al
  80cbbf:	74 1f                	je     80cbe0 <tcp_receive+0x956>
  80cbc1:	83 e0 fe             	and    $0xfffffffe,%eax
  80cbc4:	83 c8 02             	or     $0x2,%eax
  80cbc7:	88 47 20             	mov    %al,0x20(%edi)
  80cbca:	83 ec 0c             	sub    $0xc,%esp
  80cbcd:	57                   	push   %edi
  80cbce:	e8 27 b4 ff ff       	call   807ffa <tcp_output>
  80cbd3:	83 c4 10             	add    $0x10,%esp
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80cbd6:	b8 01 00 00 00       	mov    $0x1,%eax
  80cbdb:	e9 07 03 00 00       	jmp    80cee7 <tcp_receive+0xc5d>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80cbe0:	83 c8 01             	or     $0x1,%eax
  80cbe3:	88 47 20             	mov    %al,0x20(%edi)
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80cbe6:	b8 01 00 00 00       	mov    $0x1,%eax
  80cbeb:	e9 f7 02 00 00       	jmp    80cee7 <tcp_receive+0xc5d>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  80cbf0:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cbf4:	83 ec 0c             	sub    $0xc,%esp
  80cbf7:	57                   	push   %edi
  80cbf8:	e8 fd b3 ff ff       	call   807ffa <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  80cbfd:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cc00:	83 c4 10             	add    $0x10,%esp
  80cc03:	85 db                	test   %ebx,%ebx
  80cc05:	75 1d                	jne    80cc24 <tcp_receive+0x99a>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80cc07:	83 ec 0c             	sub    $0xc,%esp
  80cc0a:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cc0f:	e8 d7 8b ff ff       	call   8057eb <tcp_seg_copy>
  80cc14:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cc17:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cc1a:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc1f:	e9 c3 02 00 00       	jmp    80cee7 <tcp_receive+0xc5d>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80cc24:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80cc2a:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80cc2d:	8d 51 01             	lea    0x1(%ecx),%edx
  80cc30:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80cc33:	be 00 00 00 00       	mov    $0x0,%esi
  80cc38:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80cc3b:	89 c7                	mov    %eax,%edi
  80cc3d:	eb 02                	jmp    80cc41 <tcp_receive+0x9b7>
  80cc3f:	89 d3                	mov    %edx,%ebx
  80cc41:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc44:	8b 40 04             	mov    0x4(%eax),%eax
  80cc47:	39 c8                	cmp    %ecx,%eax
  80cc49:	0f 85 a6 00 00 00    	jne    80ccf5 <tcp_receive+0xa6b>
  80cc4f:	8b 7d e0             	mov    -0x20(%ebp),%edi
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cc52:	b8 00 00 00 00       	mov    $0x0,%eax
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  80cc57:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80cc5b:	66 39 0d c0 b1 b3 00 	cmp    %cx,0xb3b1c0
  80cc62:	0f 86 7f 02 00 00    	jbe    80cee7 <tcp_receive+0xc5d>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  80cc68:	83 ec 0c             	sub    $0xc,%esp
  80cc6b:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cc70:	e8 76 8b ff ff       	call   8057eb <tcp_seg_copy>
  80cc75:	89 c1                	mov    %eax,%ecx
  80cc77:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (cseg != NULL) {
  80cc7a:	83 c4 10             	add    $0x10,%esp
  80cc7d:	85 c0                	test   %eax,%eax
  80cc7f:	0f 84 33 02 00 00    	je     80ceb8 <tcp_receive+0xc2e>
                  cseg->next = next->next;
  80cc85:	8b 03                	mov    (%ebx),%eax
  80cc87:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80cc89:	85 f6                	test   %esi,%esi
  80cc8b:	74 04                	je     80cc91 <tcp_receive+0xa07>
                    prev->next = cseg;
  80cc8d:	89 0e                	mov    %ecx,(%esi)
  80cc8f:	eb 06                	jmp    80cc97 <tcp_receive+0xa0d>
                  } else {
                    pcb->ooseq = cseg;
  80cc91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80cc94:	89 47 7c             	mov    %eax,0x7c(%edi)
                  }
                  tcp_seg_free(next);
  80cc97:	83 ec 0c             	sub    $0xc,%esp
  80cc9a:	53                   	push   %ebx
  80cc9b:	e8 cb 8a ff ff       	call   80576b <tcp_seg_free>
                  if (cseg->next != NULL) {
  80cca0:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80cca3:	8b 06                	mov    (%esi),%eax
  80cca5:	83 c4 10             	add    $0x10,%esp
  80cca8:	85 c0                	test   %eax,%eax
  80ccaa:	0f 84 0f 02 00 00    	je     80cebf <tcp_receive+0xc35>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80ccb0:	8b 1d a8 b1 b3 00    	mov    0xb3b1a8,%ebx
  80ccb6:	8b 40 10             	mov    0x10(%eax),%eax
  80ccb9:	8b 50 04             	mov    0x4(%eax),%edx
  80ccbc:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80ccc0:	29 d1                	sub    %edx,%ecx
  80ccc2:	01 d9                	add    %ebx,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80ccc4:	b8 00 00 00 00       	mov    $0x0,%eax
                    pcb->ooseq = cseg;
                  }
                  tcp_seg_free(next);
                  if (cseg->next != NULL) {
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80ccc9:	85 c9                	test   %ecx,%ecx
  80cccb:	0f 8e 16 02 00 00    	jle    80cee7 <tcp_receive+0xc5d>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80ccd1:	89 d0                	mov    %edx,%eax
  80ccd3:	29 d8                	sub    %ebx,%eax
  80ccd5:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80ccd9:	83 ec 08             	sub    $0x8,%esp
  80ccdc:	0f b7 c0             	movzwl %ax,%eax
  80ccdf:	50                   	push   %eax
  80cce0:	ff 76 04             	pushl  0x4(%esi)
  80cce3:	e8 86 7e ff ff       	call   804b6e <pbuf_realloc>
  80cce8:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cceb:	b8 00 00 00 00       	mov    $0x0,%eax
  80ccf0:	e9 f2 01 00 00       	jmp    80cee7 <tcp_receive+0xc5d>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  80ccf5:	85 f6                	test   %esi,%esi
  80ccf7:	75 5e                	jne    80cd57 <tcp_receive+0xacd>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80ccf9:	39 c1                	cmp    %eax,%ecx
  80ccfb:	0f 89 fc 00 00 00    	jns    80cdfd <tcp_receive+0xb73>
  80cd01:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cd04:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80cd0b:	01 ca                	add    %ecx,%edx
  80cd0d:	29 c2                	sub    %eax,%edx
  80cd0f:	85 d2                	test   %edx,%edx
  80cd11:	7e 1d                	jle    80cd30 <tcp_receive+0xaa6>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cd13:	29 c8                	sub    %ecx,%eax
  80cd15:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                    pbuf_realloc(inseg.p, inseg.len);
  80cd1b:	83 ec 08             	sub    $0x8,%esp
  80cd1e:	0f b7 c0             	movzwl %ax,%eax
  80cd21:	50                   	push   %eax
  80cd22:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cd28:	e8 41 7e ff ff       	call   804b6e <pbuf_realloc>
  80cd2d:	83 c4 10             	add    $0x10,%esp
                  }
                  cseg = tcp_seg_copy(&inseg);
  80cd30:	83 ec 0c             	sub    $0xc,%esp
  80cd33:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cd38:	e8 ae 8a ff ff       	call   8057eb <tcp_seg_copy>
                  if (cseg != NULL) {
  80cd3d:	83 c4 10             	add    $0x10,%esp
  80cd40:	85 c0                	test   %eax,%eax
  80cd42:	0f 84 7e 01 00 00    	je     80cec6 <tcp_receive+0xc3c>
                    cseg->next = next;
  80cd48:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80cd4a:	89 47 7c             	mov    %eax,0x7c(%edi)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cd4d:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd52:	e9 90 01 00 00       	jmp    80cee7 <tcp_receive+0xc5d>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80cd57:	8b 56 10             	mov    0x10(%esi),%edx
  80cd5a:	3b 7a 04             	cmp    0x4(%edx),%edi
  80cd5d:	0f 88 9a 00 00 00    	js     80cdfd <tcp_receive+0xb73>
  80cd63:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80cd66:	29 c2                	sub    %eax,%edx
  80cd68:	85 d2                	test   %edx,%edx
  80cd6a:	0f 8f 8d 00 00 00    	jg     80cdfd <tcp_receive+0xb73>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cd70:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80cd77:	01 ca                	add    %ecx,%edx
  80cd79:	29 c2                	sub    %eax,%edx
  80cd7b:	85 d2                	test   %edx,%edx
  80cd7d:	7e 1d                	jle    80cd9c <tcp_receive+0xb12>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cd7f:	29 c8                	sub    %ecx,%eax
  80cd81:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                  pbuf_realloc(inseg.p, inseg.len);
  80cd87:	83 ec 08             	sub    $0x8,%esp
  80cd8a:	0f b7 c0             	movzwl %ax,%eax
  80cd8d:	50                   	push   %eax
  80cd8e:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cd94:	e8 d5 7d ff ff       	call   804b6e <pbuf_realloc>
  80cd99:	83 c4 10             	add    $0x10,%esp
                }

                cseg = tcp_seg_copy(&inseg);
  80cd9c:	83 ec 0c             	sub    $0xc,%esp
  80cd9f:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cda4:	e8 42 8a ff ff       	call   8057eb <tcp_seg_copy>
                if (cseg != NULL) {
  80cda9:	83 c4 10             	add    $0x10,%esp
  80cdac:	85 c0                	test   %eax,%eax
  80cdae:	0f 84 19 01 00 00    	je     80cecd <tcp_receive+0xc43>
                  cseg->next = next;
  80cdb4:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80cdb6:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80cdb8:	8b 46 10             	mov    0x10(%esi),%eax
  80cdbb:	8b 58 04             	mov    0x4(%eax),%ebx
  80cdbe:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80cdc4:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80cdc8:	29 d1                	sub    %edx,%ecx
  80cdca:	01 d9                	add    %ebx,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cdcc:	b8 00 00 00 00       	mov    $0x0,%eax

                cseg = tcp_seg_copy(&inseg);
                if (cseg != NULL) {
                  cseg->next = next;
                  prev->next = cseg;
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80cdd1:	85 c9                	test   %ecx,%ecx
  80cdd3:	0f 8e 0e 01 00 00    	jle    80cee7 <tcp_receive+0xc5d>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80cdd9:	89 d0                	mov    %edx,%eax
  80cddb:	29 d8                	sub    %ebx,%eax
  80cddd:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80cde1:	83 ec 08             	sub    $0x8,%esp
  80cde4:	0f b7 c0             	movzwl %ax,%eax
  80cde7:	50                   	push   %eax
  80cde8:	ff 76 04             	pushl  0x4(%esi)
  80cdeb:	e8 7e 7d ff ff       	call   804b6e <pbuf_realloc>
  80cdf0:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cdf3:	b8 00 00 00 00       	mov    $0x0,%eax
  80cdf8:	e9 ea 00 00 00       	jmp    80cee7 <tcp_receive+0xc5d>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80cdfd:	8b 13                	mov    (%ebx),%edx
  80cdff:	89 de                	mov    %ebx,%esi
  80ce01:	85 d2                	test   %edx,%edx
  80ce03:	0f 85 36 fe ff ff    	jne    80cc3f <tcp_receive+0x9b5>
  80ce09:	29 c1                	sub    %eax,%ecx
  80ce0b:	85 c9                	test   %ecx,%ecx
  80ce0d:	0f 8e c1 00 00 00    	jle    80ced4 <tcp_receive+0xc4a>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  80ce13:	83 ec 0c             	sub    $0xc,%esp
  80ce16:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80ce1b:	e8 cb 89 ff ff       	call   8057eb <tcp_seg_copy>
  80ce20:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80ce22:	83 c4 10             	add    $0x10,%esp
  80ce25:	85 c0                	test   %eax,%eax
  80ce27:	0f 84 ae 00 00 00    	je     80cedb <tcp_receive+0xc51>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80ce2d:	8b 43 10             	mov    0x10(%ebx),%eax
  80ce30:	8b 70 04             	mov    0x4(%eax),%esi
  80ce33:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80ce39:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80ce3d:	29 d1                	sub    %edx,%ecx
  80ce3f:	01 f1                	add    %esi,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80ce41:	b8 00 00 00 00       	mov    $0x0,%eax
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
                if (next->next != NULL) {
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80ce46:	85 c9                	test   %ecx,%ecx
  80ce48:	0f 8e 99 00 00 00    	jle    80cee7 <tcp_receive+0xc5d>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80ce4e:	89 d0                	mov    %edx,%eax
  80ce50:	29 f0                	sub    %esi,%eax
  80ce52:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80ce56:	83 ec 08             	sub    $0x8,%esp
  80ce59:	0f b7 c0             	movzwl %ax,%eax
  80ce5c:	50                   	push   %eax
  80ce5d:	ff 73 04             	pushl  0x4(%ebx)
  80ce60:	e8 09 7d ff ff       	call   804b6e <pbuf_realloc>
  80ce65:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80ce68:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce6d:	eb 78                	jmp    80cee7 <tcp_receive+0xc5d>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  80ce6f:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80ce73:	83 ec 0c             	sub    $0xc,%esp
  80ce76:	57                   	push   %edi
  80ce77:	e8 7e b1 ff ff       	call   807ffa <tcp_output>
  80ce7c:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80ce7f:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce84:	eb 61                	jmp    80cee7 <tcp_receive+0xc5d>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80ce86:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80ce8b:	8b 57 24             	mov    0x24(%edi),%edx
  80ce8e:	39 d0                	cmp    %edx,%eax
  80ce90:	78 0f                	js     80cea1 <tcp_receive+0xc17>
  80ce92:	83 c0 01             	add    $0x1,%eax
  80ce95:	29 d0                	sub    %edx,%eax
  80ce97:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80ce9b:	29 d0                	sub    %edx,%eax
  80ce9d:	85 c0                	test   %eax,%eax
  80ce9f:	7e 41                	jle    80cee2 <tcp_receive+0xc58>
      tcp_ack_now(pcb);
  80cea1:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cea5:	83 ec 0c             	sub    $0xc,%esp
  80cea8:	57                   	push   %edi
  80cea9:	e8 4c b1 ff ff       	call   807ffa <tcp_output>
  80ceae:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80ceb1:	b8 00 00 00 00       	mov    $0x0,%eax
  80ceb6:	eb 2f                	jmp    80cee7 <tcp_receive+0xc5d>
  80ceb8:	b8 00 00 00 00       	mov    $0x0,%eax
  80cebd:	eb 28                	jmp    80cee7 <tcp_receive+0xc5d>
  80cebf:	b8 00 00 00 00       	mov    $0x0,%eax
  80cec4:	eb 21                	jmp    80cee7 <tcp_receive+0xc5d>
  80cec6:	b8 00 00 00 00       	mov    $0x0,%eax
  80cecb:	eb 1a                	jmp    80cee7 <tcp_receive+0xc5d>
  80cecd:	b8 00 00 00 00       	mov    $0x0,%eax
  80ced2:	eb 13                	jmp    80cee7 <tcp_receive+0xc5d>
  80ced4:	b8 00 00 00 00       	mov    $0x0,%eax
  80ced9:	eb 0c                	jmp    80cee7 <tcp_receive+0xc5d>
  80cedb:	b8 00 00 00 00       	mov    $0x0,%eax
  80cee0:	eb 05                	jmp    80cee7 <tcp_receive+0xc5d>
  80cee2:	b8 00 00 00 00       	mov    $0x0,%eax
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
  return accepted_inseq;
}
  80cee7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ceea:	5b                   	pop    %ebx
  80ceeb:	5e                   	pop    %esi
  80ceec:	5f                   	pop    %edi
  80ceed:	5d                   	pop    %ebp
  80ceee:	c3                   	ret    

0080ceef <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  80ceef:	55                   	push   %ebp
  80cef0:	89 e5                	mov    %esp,%ebp
  80cef2:	57                   	push   %edi
  80cef3:	56                   	push   %esi
  80cef4:	53                   	push   %ebx
  80cef5:	83 ec 38             	sub    $0x38,%esp
  80cef8:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  80cefb:	8b 5e 04             	mov    0x4(%esi),%ebx
  80cefe:	89 1d ac b1 b3 00    	mov    %ebx,0xb3b1ac
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80cf04:	0f b7 03             	movzwl (%ebx),%eax
  80cf07:	50                   	push   %eax
  80cf08:	e8 d6 a7 ff ff       	call   8076e3 <ntohs>
  80cf0d:	66 c1 e8 08          	shr    $0x8,%ax
  80cf11:	83 e0 0f             	and    $0xf,%eax
  80cf14:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80cf17:	a3 b0 b1 b3 00       	mov    %eax,0xb3b1b0
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80cf1c:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80cf21:	0f b7 00             	movzwl (%eax),%eax
  80cf24:	89 04 24             	mov    %eax,(%esp)
  80cf27:	e8 b7 a7 ff ff       	call   8076e3 <ntohs>
  80cf2c:	83 c4 08             	add    $0x8,%esp
  80cf2f:	66 c1 e8 06          	shr    $0x6,%ax
  80cf33:	83 e0 3c             	and    $0x3c,%eax
  80cf36:	f7 d8                	neg    %eax
  80cf38:	98                   	cwtl   
  80cf39:	50                   	push   %eax
  80cf3a:	56                   	push   %esi
  80cf3b:	e8 13 78 ff ff       	call   804753 <pbuf_header>
  80cf40:	83 c4 10             	add    $0x10,%esp
  80cf43:	84 c0                	test   %al,%al
  80cf45:	75 07                	jne    80cf4e <tcp_input+0x5f>
  80cf47:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80cf4c:	77 11                	ja     80cf5f <tcp_input+0x70>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cf4e:	83 ec 0c             	sub    $0xc,%esp
  80cf51:	56                   	push   %esi
  80cf52:	e8 ce 78 ff ff       	call   804825 <pbuf_free>
    return;
  80cf57:	83 c4 10             	add    $0x10,%esp
  80cf5a:	e9 fb 0c 00 00       	jmp    80dc5a <tcp_input+0xd6b>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80cf5f:	83 ec 08             	sub    $0x8,%esp
  80cf62:	ff 75 0c             	pushl  0xc(%ebp)
  80cf65:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80cf6a:	83 c0 10             	add    $0x10,%eax
  80cf6d:	50                   	push   %eax
  80cf6e:	e8 5b 95 ff ff       	call   8064ce <ip_addr_isbroadcast>
  80cf73:	83 c4 10             	add    $0x10,%esp
  80cf76:	84 c0                	test   %al,%al
  80cf78:	75 2a                	jne    80cfa4 <tcp_input+0xb5>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80cf7a:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80cf7f:	8b 58 10             	mov    0x10(%eax),%ebx
  80cf82:	83 ec 0c             	sub    $0xc,%esp
  80cf85:	68 00 00 00 f0       	push   $0xf0000000
  80cf8a:	e8 82 a9 ff ff       	call   807911 <ntohl>
  80cf8f:	21 c3                	and    %eax,%ebx
  80cf91:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80cf98:	e8 74 a9 ff ff       	call   807911 <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80cf9d:	83 c4 10             	add    $0x10,%esp
  80cfa0:	39 c3                	cmp    %eax,%ebx
  80cfa2:	75 11                	jne    80cfb5 <tcp_input+0xc6>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cfa4:	83 ec 0c             	sub    $0xc,%esp
  80cfa7:	56                   	push   %esi
  80cfa8:	e8 78 78 ff ff       	call   804825 <pbuf_free>
    return;
  80cfad:	83 c4 10             	add    $0x10,%esp
  80cfb0:	e9 a5 0c 00 00       	jmp    80dc5a <tcp_input+0xd6b>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  80cfb5:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80cfba:	83 ec 0c             	sub    $0xc,%esp
  80cfbd:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80cfc1:	52                   	push   %edx
  80cfc2:	6a 06                	push   $0x6
  80cfc4:	8d 50 10             	lea    0x10(%eax),%edx
  80cfc7:	52                   	push   %edx
  80cfc8:	83 c0 0c             	add    $0xc,%eax
  80cfcb:	50                   	push   %eax
  80cfcc:	56                   	push   %esi
  80cfcd:	e8 eb a3 ff ff       	call   8073bd <inet_chksum_pseudo>
  80cfd2:	83 c4 20             	add    $0x20,%esp
  80cfd5:	66 85 c0             	test   %ax,%ax
  80cfd8:	74 11                	je     80cfeb <tcp_input+0xfc>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cfda:	83 ec 0c             	sub    $0xc,%esp
  80cfdd:	56                   	push   %esi
  80cfde:	e8 42 78 ff ff       	call   804825 <pbuf_free>
    return;
  80cfe3:	83 c4 10             	add    $0x10,%esp
  80cfe6:	e9 6f 0c 00 00       	jmp    80dc5a <tcp_input+0xd6b>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  80cfeb:	83 ec 0c             	sub    $0xc,%esp
  80cfee:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80cff3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cff7:	50                   	push   %eax
  80cff8:	e8 e6 a6 ff ff       	call   8076e3 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80cffd:	83 c4 08             	add    $0x8,%esp
  80d000:	66 c1 e8 0c          	shr    $0xc,%ax
  80d004:	f7 d8                	neg    %eax
  80d006:	c1 e0 02             	shl    $0x2,%eax
  80d009:	98                   	cwtl   
  80d00a:	50                   	push   %eax
  80d00b:	56                   	push   %esi
  80d00c:	e8 42 77 ff ff       	call   804753 <pbuf_header>
  80d011:	83 c4 10             	add    $0x10,%esp
  80d014:	84 c0                	test   %al,%al
  80d016:	74 11                	je     80d029 <tcp_input+0x13a>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80d018:	83 ec 0c             	sub    $0xc,%esp
  80d01b:	56                   	push   %esi
  80d01c:	e8 04 78 ff ff       	call   804825 <pbuf_free>
    return;
  80d021:	83 c4 10             	add    $0x10,%esp
  80d024:	e9 31 0c 00 00       	jmp    80dc5a <tcp_input+0xd6b>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  80d029:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d02f:	83 ec 0c             	sub    $0xc,%esp
  80d032:	0f b7 03             	movzwl (%ebx),%eax
  80d035:	50                   	push   %eax
  80d036:	e8 a8 a6 ff ff       	call   8076e3 <ntohs>
  80d03b:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80d03e:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d044:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80d048:	89 04 24             	mov    %eax,(%esp)
  80d04b:	e8 93 a6 ff ff       	call   8076e3 <ntohs>
  80d050:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80d054:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d05a:	83 c4 04             	add    $0x4,%esp
  80d05d:	ff 73 04             	pushl  0x4(%ebx)
  80d060:	e8 ac a8 ff ff       	call   807911 <ntohl>
  80d065:	89 43 04             	mov    %eax,0x4(%ebx)
  80d068:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80d06d:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d073:	83 c4 04             	add    $0x4,%esp
  80d076:	ff 73 08             	pushl  0x8(%ebx)
  80d079:	e8 93 a8 ff ff       	call   807911 <ntohl>
  80d07e:	89 43 08             	mov    %eax,0x8(%ebx)
  80d081:	a3 a4 b1 b3 00       	mov    %eax,0xb3b1a4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80d086:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d08c:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80d090:	89 04 24             	mov    %eax,(%esp)
  80d093:	e8 4b a6 ff ff       	call   8076e3 <ntohs>
  80d098:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80d09c:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d0a1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d0a5:	89 04 24             	mov    %eax,(%esp)
  80d0a8:	e8 36 a6 ff ff       	call   8076e3 <ntohs>
  80d0ad:	89 c1                	mov    %eax,%ecx
  80d0af:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80d0b3:	83 e0 3f             	and    $0x3f,%eax
  80d0b6:	a2 a0 b1 b3 00       	mov    %al,0xb3b1a0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80d0bb:	83 c4 10             	add    $0x10,%esp
  80d0be:	89 c8                	mov    %ecx,%eax
  80d0c0:	a8 03                	test   $0x3,%al
  80d0c2:	0f 95 c0             	setne  %al
  80d0c5:	0f b6 c0             	movzbl %al,%eax
  80d0c8:	66 03 46 08          	add    0x8(%esi),%ax
  80d0cc:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80d0d0:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d0d6:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d0db:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  80d0de:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d0e4:	8b 0d ac b1 b3 00    	mov    0xb3b1ac,%ecx
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d0ea:	89 c3                	mov    %eax,%ebx
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  80d0ec:	bf 00 00 00 00       	mov    $0x0,%edi

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d0f1:	e9 d1 00 00 00       	jmp    80d1c7 <tcp_input+0x2d8>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d0f6:	8b 43 10             	mov    0x10(%ebx),%eax
  80d0f9:	85 c0                	test   %eax,%eax
  80d0fb:	75 17                	jne    80d114 <tcp_input+0x225>
  80d0fd:	83 ec 04             	sub    $0x4,%esp
  80d100:	68 6c 2e 81 00       	push   $0x812e6c
  80d105:	68 b5 00 00 00       	push   $0xb5
  80d10a:	68 90 2f 81 00       	push   $0x812f90
  80d10f:	e8 3a 13 00 00       	call   80e44e <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d114:	83 f8 0a             	cmp    $0xa,%eax
  80d117:	75 17                	jne    80d130 <tcp_input+0x241>
  80d119:	83 ec 04             	sub    $0x4,%esp
  80d11c:	68 94 2e 81 00       	push   $0x812e94
  80d121:	68 b6 00 00 00       	push   $0xb6
  80d126:	68 90 2f 81 00       	push   $0x812f90
  80d12b:	e8 1e 13 00 00       	call   80e44e <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d130:	83 f8 01             	cmp    $0x1,%eax
  80d133:	75 17                	jne    80d14c <tcp_input+0x25d>
  80d135:	83 ec 04             	sub    $0x4,%esp
  80d138:	68 c0 2e 81 00       	push   $0x812ec0
  80d13d:	68 b7 00 00 00       	push   $0xb7
  80d142:	68 90 2f 81 00       	push   $0x812f90
  80d147:	e8 02 13 00 00       	call   80e44e <_panic>
    if (pcb->remote_port == tcphdr->src &&
  80d14c:	0f b7 02             	movzwl (%edx),%eax
  80d14f:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d153:	75 6d                	jne    80d1c2 <tcp_input+0x2d3>
  80d155:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d159:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d15d:	75 63                	jne    80d1c2 <tcp_input+0x2d3>
       pcb->local_port == tcphdr->dest &&
  80d15f:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d162:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d165:	75 5b                	jne    80d1c2 <tcp_input+0x2d3>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d167:	8b 41 10             	mov    0x10(%ecx),%eax
  80d16a:	39 03                	cmp    %eax,(%ebx)
  80d16c:	75 54                	jne    80d1c2 <tcp_input+0x2d3>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d16e:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d171:	39 c3                	cmp    %eax,%ebx
  80d173:	75 17                	jne    80d18c <tcp_input+0x29d>
  80d175:	83 ec 04             	sub    $0x4,%esp
  80d178:	68 e8 2e 81 00       	push   $0x812ee8
  80d17d:	68 c0 00 00 00       	push   $0xc0
  80d182:	68 90 2f 81 00       	push   $0x812f90
  80d187:	e8 c2 12 00 00       	call   80e44e <_panic>
      if (prev != NULL) {
  80d18c:	85 ff                	test   %edi,%edi
  80d18e:	0f 84 80 02 00 00    	je     80d414 <tcp_input+0x525>
        prev->next = pcb->next;
  80d194:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d197:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d19a:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80d19d:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d1a3:	39 c3                	cmp    %eax,%ebx
  80d1a5:	0f 85 69 02 00 00    	jne    80d414 <tcp_input+0x525>
  80d1ab:	83 ec 04             	sub    $0x4,%esp
  80d1ae:	68 14 2f 81 00       	push   $0x812f14
  80d1b3:	68 c6 00 00 00       	push   $0xc6
  80d1b8:	68 90 2f 81 00       	push   $0x812f90
  80d1bd:	e8 8c 12 00 00       	call   80e44e <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d1c2:	89 df                	mov    %ebx,%edi
  80d1c4:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d1c7:	85 db                	test   %ebx,%ebx
  80d1c9:	0f 85 27 ff ff ff    	jne    80d0f6 <tcp_input+0x207>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d1cf:	8b 1d 50 b2 b3 00    	mov    0xb3b250,%ebx
  80d1d5:	e9 88 00 00 00       	jmp    80d262 <tcp_input+0x373>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d1da:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80d1de:	74 17                	je     80d1f7 <tcp_input+0x308>
  80d1e0:	83 ec 04             	sub    $0x4,%esp
  80d1e3:	68 40 2f 81 00       	push   $0x812f40
  80d1e8:	68 d0 00 00 00       	push   $0xd0
  80d1ed:	68 90 2f 81 00       	push   $0x812f90
  80d1f2:	e8 57 12 00 00       	call   80e44e <_panic>
      if (pcb->remote_port == tcphdr->src &&
  80d1f7:	0f b7 02             	movzwl (%edx),%eax
  80d1fa:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d1fe:	75 5f                	jne    80d25f <tcp_input+0x370>
  80d200:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d204:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d208:	75 55                	jne    80d25f <tcp_input+0x370>
         pcb->local_port == tcphdr->dest &&
  80d20a:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d20d:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d210:	75 4d                	jne    80d25f <tcp_input+0x370>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d212:	8b 41 10             	mov    0x10(%ecx),%eax
  80d215:	39 03                	cmp    %eax,(%ebx)
  80d217:	75 46                	jne    80d25f <tcp_input+0x370>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d219:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80d21d:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d223:	89 c2                	mov    %eax,%edx
  80d225:	2b 53 24             	sub    0x24(%ebx),%edx
  80d228:	85 d2                	test   %edx,%edx
  80d22a:	7e 03                	jle    80d22f <tcp_input+0x340>
    pcb->rcv_nxt = seqno + tcplen;
  80d22c:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  80d22f:	66 83 7d d6 00       	cmpw   $0x0,-0x2a(%ebp)
  80d234:	74 10                	je     80d246 <tcp_input+0x357>
    tcp_ack_now(pcb);
  80d236:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d23a:	83 ec 0c             	sub    $0xc,%esp
  80d23d:	53                   	push   %ebx
  80d23e:	e8 b7 ad ff ff       	call   807ffa <tcp_output>
  80d243:	83 c4 10             	add    $0x10,%esp
  }
  return tcp_output(pcb);
  80d246:	83 ec 0c             	sub    $0xc,%esp
  80d249:	53                   	push   %ebx
  80d24a:	e8 ab ad ff ff       	call   807ffa <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  80d24f:	89 34 24             	mov    %esi,(%esp)
  80d252:	e8 ce 75 ff ff       	call   804825 <pbuf_free>
        return;
  80d257:	83 c4 10             	add    $0x10,%esp
  80d25a:	e9 fb 09 00 00       	jmp    80dc5a <tcp_input+0xd6b>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d25f:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d262:	85 db                	test   %ebx,%ebx
  80d264:	0f 85 70 ff ff ff    	jne    80d1da <tcp_input+0x2eb>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d26a:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80d26f:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d272:	89 c3                	mov    %eax,%ebx
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  80d274:	bf 00 00 00 00       	mov    $0x0,%edi
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d279:	e9 89 01 00 00       	jmp    80d407 <tcp_input+0x518>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d27e:	85 db                	test   %ebx,%ebx
  80d280:	74 0f                	je     80d291 <tcp_input+0x3a2>
  80d282:	8b 03                	mov    (%ebx),%eax
  80d284:	85 c0                	test   %eax,%eax
  80d286:	74 09                	je     80d291 <tcp_input+0x3a2>
  80d288:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d28b:	0f 85 71 01 00 00    	jne    80d402 <tcp_input+0x513>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d291:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d295:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d299:	0f 85 63 01 00 00    	jne    80d402 <tcp_input+0x513>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  80d29f:	85 ff                	test   %edi,%edi
  80d2a1:	74 12                	je     80d2b5 <tcp_input+0x3c6>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d2a3:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d2a6:	89 47 0c             	mov    %eax,0xc(%edi)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d2a9:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d2ac:	89 43 0c             	mov    %eax,0xc(%ebx)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d2af:	89 1d 44 b2 b3 00    	mov    %ebx,0xb3b244
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  80d2b5:	f6 45 d4 10          	testb  $0x10,-0x2c(%ebp)
  80d2b9:	74 35                	je     80d2f0 <tcp_input+0x401>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  80d2bb:	83 ec 08             	sub    $0x8,%esp
  80d2be:	0f b7 02             	movzwl (%edx),%eax
  80d2c1:	50                   	push   %eax
  80d2c2:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d2c6:	50                   	push   %eax
  80d2c7:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d2ca:	50                   	push   %eax
  80d2cb:	83 c1 10             	add    $0x10,%ecx
  80d2ce:	51                   	push   %ecx
  80d2cf:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80d2d3:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d2d9:	50                   	push   %eax
  80d2da:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d2df:	83 c0 01             	add    $0x1,%eax
  80d2e2:	50                   	push   %eax
  80d2e3:	e8 89 b1 ff ff       	call   808471 <tcp_rst>
  80d2e8:	83 c4 20             	add    $0x20,%esp
  80d2eb:	e9 01 01 00 00       	jmp    80d3f1 <tcp_input+0x502>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  80d2f0:	f6 45 d4 02          	testb  $0x2,-0x2c(%ebp)
  80d2f4:	0f 84 f7 00 00 00    	je     80d3f1 <tcp_input+0x502>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  80d2fa:	83 ec 0c             	sub    $0xc,%esp
  80d2fd:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  80d301:	50                   	push   %eax
  80d302:	e8 71 8e ff ff       	call   806178 <tcp_alloc>
  80d307:	89 c7                	mov    %eax,%edi
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  80d309:	83 c4 10             	add    $0x10,%esp
  80d30c:	85 c0                	test   %eax,%eax
  80d30e:	0f 84 dd 00 00 00    	je     80d3f1 <tcp_input+0x502>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d314:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d319:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80d31c:	74 05                	je     80d323 <tcp_input+0x434>
  80d31e:	8b 50 10             	mov    0x10(%eax),%edx
  80d321:	eb 05                	jmp    80d328 <tcp_input+0x439>
  80d323:	ba 00 00 00 00       	mov    $0x0,%edx
  80d328:	89 17                	mov    %edx,(%edi)
    npcb->local_port = pcb->local_port;
  80d32a:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  80d32e:	66 89 57 1c          	mov    %dx,0x1c(%edi)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d332:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80d335:	74 05                	je     80d33c <tcp_input+0x44d>
  80d337:	8b 40 0c             	mov    0xc(%eax),%eax
  80d33a:	eb 05                	jmp    80d341 <tcp_input+0x452>
  80d33c:	b8 00 00 00 00       	mov    $0x0,%eax
  80d341:	89 47 04             	mov    %eax,0x4(%edi)
    npcb->remote_port = tcphdr->src;
  80d344:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d34a:	0f b7 02             	movzwl (%edx),%eax
  80d34d:	66 89 47 1e          	mov    %ax,0x1e(%edi)
    npcb->state = SYN_RCVD;
  80d351:	c7 47 10 03 00 00 00 	movl   $0x3,0x10(%edi)
    npcb->rcv_nxt = seqno + 1;
  80d358:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d35d:	8d 48 01             	lea    0x1(%eax),%ecx
  80d360:	89 4f 24             	mov    %ecx,0x24(%edi)
    npcb->snd_wnd = tcphdr->wnd;
  80d363:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d367:	66 89 57 5c          	mov    %dx,0x5c(%edi)
    npcb->ssthresh = npcb->snd_wnd;
  80d36b:	66 89 57 50          	mov    %dx,0x50(%edi)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d36f:	83 e8 01             	sub    $0x1,%eax
  80d372:	89 47 60             	mov    %eax,0x60(%edi)
    npcb->callback_arg = pcb->callback_arg;
  80d375:	8b 43 18             	mov    0x18(%ebx),%eax
  80d378:	89 47 18             	mov    %eax,0x18(%edi)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  80d37b:	8b 43 20             	mov    0x20(%ebx),%eax
  80d37e:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d384:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80d388:	66 25 99 01          	and    $0x199,%ax
  80d38c:	66 89 47 08          	mov    %ax,0x8(%edi)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  80d390:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d395:	89 47 0c             	mov    %eax,0xc(%edi)
  80d398:	89 3d 3c b2 b3 00    	mov    %edi,0xb3b23c
  80d39e:	e8 c1 4e ff ff       	call   802264 <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  80d3a3:	89 f8                	mov    %edi,%eax
  80d3a5:	e8 2d ee ff ff       	call   80c1d7 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d3aa:	83 ec 08             	sub    $0x8,%esp
  80d3ad:	8d 47 04             	lea    0x4(%edi),%eax
  80d3b0:	50                   	push   %eax
  80d3b1:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80d3b5:	50                   	push   %eax
  80d3b6:	e8 4a 8f ff ff       	call   806305 <tcp_eff_send_mss>
  80d3bb:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  80d3bf:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80d3c6:	e8 25 a3 ff ff       	call   8076f0 <htonl>
  80d3cb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80d3ce:	83 c4 0c             	add    $0xc,%esp
  80d3d1:	6a 04                	push   $0x4
  80d3d3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d3d6:	50                   	push   %eax
  80d3d7:	6a 00                	push   $0x0
  80d3d9:	6a 12                	push   $0x12
  80d3db:	6a 00                	push   $0x0
  80d3dd:	6a 00                	push   $0x0
  80d3df:	57                   	push   %edi
  80d3e0:	e8 3c a5 ff ff       	call   807921 <tcp_enqueue>
    return tcp_output(npcb);
  80d3e5:	83 c4 14             	add    $0x14,%esp
  80d3e8:	57                   	push   %edi
  80d3e9:	e8 0c ac ff ff       	call   807ffa <tcp_output>
  80d3ee:	83 c4 10             	add    $0x10,%esp
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  80d3f1:	83 ec 0c             	sub    $0xc,%esp
  80d3f4:	56                   	push   %esi
  80d3f5:	e8 2b 74 ff ff       	call   804825 <pbuf_free>
        return;
  80d3fa:	83 c4 10             	add    $0x10,%esp
  80d3fd:	e9 58 08 00 00       	jmp    80dc5a <tcp_input+0xd6b>
  80d402:	89 df                	mov    %ebx,%edi
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d404:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d407:	85 db                	test   %ebx,%ebx
  80d409:	0f 85 6f fe ff ff    	jne    80d27e <tcp_input+0x38f>
  80d40f:	e9 b5 07 00 00       	jmp    80dbc9 <tcp_input+0xcda>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  80d414:	c7 05 b4 b1 b3 00 00 	movl   $0x0,0xb3b1b4
  80d41b:	00 00 00 
    inseg.len = p->tot_len;
  80d41e:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d422:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
    inseg.dataptr = p->payload;
  80d428:	8b 46 04             	mov    0x4(%esi),%eax
  80d42b:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
    inseg.p = p;
  80d430:	89 35 b8 b1 b3 00    	mov    %esi,0xb3b1b8
    inseg.tcphdr = tcphdr;
  80d436:	89 15 c4 b1 b3 00    	mov    %edx,0xb3b1c4

    recv_data = NULL;
  80d43c:	c7 05 98 b1 b3 00 00 	movl   $0x0,0xb3b198
  80d443:	00 00 00 
    recv_flags = 0;
  80d446:	c6 05 9c b1 b3 00 00 	movb   $0x0,0xb3b19c

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80d44d:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80d453:	85 c0                	test   %eax,%eax
  80d455:	74 45                	je     80d49c <tcp_input+0x5ad>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d457:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80d45d:	85 d2                	test   %edx,%edx
  80d45f:	74 12                	je     80d473 <tcp_input+0x584>
  80d461:	6a 00                	push   $0x0
  80d463:	50                   	push   %eax
  80d464:	53                   	push   %ebx
  80d465:	ff 73 18             	pushl  0x18(%ebx)
  80d468:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d46a:	83 c4 10             	add    $0x10,%esp
  80d46d:	84 c0                	test   %al,%al
  80d46f:	74 0e                	je     80d47f <tcp_input+0x590>
  80d471:	eb 18                	jmp    80d48b <tcp_input+0x59c>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d473:	83 ec 0c             	sub    $0xc,%esp
  80d476:	50                   	push   %eax
  80d477:	e8 a9 73 ff ff       	call   804825 <pbuf_free>
  80d47c:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80d47f:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80d486:	00 00 00 
  80d489:	eb 11                	jmp    80d49c <tcp_input+0x5ad>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  80d48b:	83 ec 0c             	sub    $0xc,%esp
  80d48e:	56                   	push   %esi
  80d48f:	e8 91 73 ff ff       	call   804825 <pbuf_free>
        return;
  80d494:	83 c4 10             	add    $0x10,%esp
  80d497:	e9 be 07 00 00       	jmp    80dc5a <tcp_input+0xd6b>
      }
    }

    tcp_input_pcb = pcb;
  80d49c:	89 1d 58 b2 b3 00    	mov    %ebx,0xb3b258
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  80d4a2:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d4a9:	a8 04                	test   $0x4,%al
  80d4ab:	74 5e                	je     80d50b <tcp_input+0x61c>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  80d4ad:	8b 53 10             	mov    0x10(%ebx),%edx
  80d4b0:	83 fa 02             	cmp    $0x2,%edx
  80d4b3:	75 0f                	jne    80d4c4 <tcp_input+0x5d5>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80d4b5:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d4ba:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d4bd:	74 3c                	je     80d4fb <tcp_input+0x60c>
  80d4bf:	e9 b1 05 00 00       	jmp    80da75 <tcp_input+0xb86>
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d4c4:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d4c9:	2b 43 24             	sub    0x24(%ebx),%eax
  80d4cc:	0f 88 a3 05 00 00    	js     80da75 <tcp_input+0xb86>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80d4d2:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d4d6:	29 c8                	sub    %ecx,%eax
  80d4d8:	85 c0                	test   %eax,%eax
  80d4da:	0f 8f 46 07 00 00    	jg     80dc26 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d4e0:	85 d2                	test   %edx,%edx
  80d4e2:	75 17                	jne    80d4fb <tcp_input+0x60c>
  80d4e4:	83 ec 04             	sub    $0x4,%esp
  80d4e7:	68 70 2f 81 00       	push   $0x812f70
  80d4ec:	68 09 02 00 00       	push   $0x209
  80d4f1:	68 90 2f 81 00       	push   $0x812f90
  80d4f6:	e8 53 0f 00 00       	call   80e44e <_panic>
      recv_flags = TF_RESET;
  80d4fb:	c6 05 9c b1 b3 00 08 	movb   $0x8,0xb3b19c
      pcb->flags &= ~TF_ACK_DELAY;
  80d502:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  80d506:	e9 1b 07 00 00       	jmp    80dc26 <tcp_input+0xd37>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  80d50b:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  80d511:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80d514:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  80d51b:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80d51f:	0f 87 50 05 00 00    	ja     80da75 <tcp_input+0xb86>
  80d525:	8b 53 10             	mov    0x10(%ebx),%edx
  80d528:	ff 24 95 14 30 81 00 	jmp    *0x813014(,%edx,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80d52f:	83 e0 12             	and    $0x12,%eax
  80d532:	3c 12                	cmp    $0x12,%al
  80d534:	0f 85 04 01 00 00    	jne    80d63e <tcp_input+0x74f>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80d53a:	83 ec 0c             	sub    $0xc,%esp
  80d53d:	8b 43 78             	mov    0x78(%ebx),%eax
  80d540:	8b 40 10             	mov    0x10(%eax),%eax
  80d543:	ff 70 04             	pushl  0x4(%eax)
  80d546:	e8 c6 a3 ff ff       	call   807911 <ntohl>
  80d54b:	8d 50 01             	lea    0x1(%eax),%edx
  80d54e:	83 c4 10             	add    $0x10,%esp
  80d551:	3b 15 a4 b1 b3 00    	cmp    0xb3b1a4,%edx
  80d557:	0f 85 e1 00 00 00    	jne    80d63e <tcp_input+0x74f>
      pcb->snd_buf++;
  80d55d:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80d562:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d567:	8d 48 01             	lea    0x1(%eax),%ecx
  80d56a:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80d56d:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80d570:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d576:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d57a:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80d57e:	83 e8 01             	sub    $0x1,%eax
  80d581:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80d584:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  80d58b:	89 d8                	mov    %ebx,%eax
  80d58d:	e8 45 ec ff ff       	call   80c1d7 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80d592:	83 ec 08             	sub    $0x8,%esp
  80d595:	8d 43 04             	lea    0x4(%ebx),%eax
  80d598:	50                   	push   %eax
  80d599:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d59d:	50                   	push   %eax
  80d59e:	e8 62 8d ff ff       	call   806305 <tcp_eff_send_mss>
  80d5a3:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  80d5a7:	6b d0 0a             	imul   $0xa,%eax,%edx
  80d5aa:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d5ae:	83 c4 10             	add    $0x10,%esp
  80d5b1:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80d5b4:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80d5b9:	0f 44 c2             	cmove  %edx,%eax
  80d5bc:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d5c0:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80d5c4:	66 85 c0             	test   %ax,%ax
  80d5c7:	75 17                	jne    80d5e0 <tcp_input+0x6f1>
  80d5c9:	83 ec 04             	sub    $0x4,%esp
  80d5cc:	68 e9 2f 81 00       	push   $0x812fe9
  80d5d1:	68 35 02 00 00       	push   $0x235
  80d5d6:	68 90 2f 81 00       	push   $0x812f90
  80d5db:	e8 6e 0e 00 00       	call   80e44e <_panic>
      --pcb->snd_queuelen;
  80d5e0:	83 e8 01             	sub    $0x1,%eax
  80d5e3:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  80d5e7:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80d5ea:	8b 10                	mov    (%eax),%edx
  80d5ec:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80d5ef:	85 d2                	test   %edx,%edx
  80d5f1:	75 08                	jne    80d5fb <tcp_input+0x70c>
        pcb->rtime = -1;
  80d5f3:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80d5f9:	eb 0a                	jmp    80d605 <tcp_input+0x716>
      else {
        pcb->rtime = 0;
  80d5fb:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80d601:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  80d605:	83 ec 0c             	sub    $0xc,%esp
  80d608:	50                   	push   %eax
  80d609:	e8 5d 81 ff ff       	call   80576b <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80d60e:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80d614:	83 c4 10             	add    $0x10,%esp
  80d617:	85 c0                	test   %eax,%eax
  80d619:	74 0e                	je     80d629 <tcp_input+0x73a>
  80d61b:	83 ec 04             	sub    $0x4,%esp
  80d61e:	6a 00                	push   $0x0
  80d620:	53                   	push   %ebx
  80d621:	ff 73 18             	pushl  0x18(%ebx)
  80d624:	ff d0                	call   *%eax
  80d626:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80d629:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d62d:	83 ec 0c             	sub    $0xc,%esp
  80d630:	53                   	push   %ebx
  80d631:	e8 c4 a9 ff ff       	call   807ffa <tcp_output>
  80d636:	83 c4 10             	add    $0x10,%esp
  80d639:	e9 e8 05 00 00       	jmp    80dc26 <tcp_input+0xd37>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  80d63e:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d645:	0f 84 db 05 00 00    	je     80dc26 <tcp_input+0xd37>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80d64b:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d651:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d656:	83 ec 08             	sub    $0x8,%esp
  80d659:	0f b7 0a             	movzwl (%edx),%ecx
  80d65c:	51                   	push   %ecx
  80d65d:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80d661:	52                   	push   %edx
  80d662:	8d 50 0c             	lea    0xc(%eax),%edx
  80d665:	52                   	push   %edx
  80d666:	83 c0 10             	add    $0x10,%eax
  80d669:	50                   	push   %eax
  80d66a:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d671:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d677:	50                   	push   %eax
  80d678:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80d67e:	e8 ee ad ff ff       	call   808471 <tcp_rst>
  80d683:	83 c4 20             	add    $0x20,%esp
  80d686:	e9 9b 05 00 00       	jmp    80dc26 <tcp_input+0xd37>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  80d68b:	83 e0 14             	and    $0x14,%eax
  80d68e:	3c 10                	cmp    $0x10,%al
  80d690:	0f 85 90 05 00 00    	jne    80dc26 <tcp_input+0xd37>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80d696:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80d69c:	8d 42 ff             	lea    -0x1(%edx),%eax
  80d69f:	3b 43 48             	cmp    0x48(%ebx),%eax
  80d6a2:	0f 88 b5 00 00 00    	js     80d75d <tcp_input+0x86e>
  80d6a8:	89 d0                	mov    %edx,%eax
  80d6aa:	2b 43 54             	sub    0x54(%ebx),%eax
  80d6ad:	85 c0                	test   %eax,%eax
  80d6af:	0f 8f a8 00 00 00    	jg     80d75d <tcp_input+0x86e>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  80d6b5:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d6bc:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80d6c2:	85 c0                	test   %eax,%eax
  80d6c4:	75 17                	jne    80d6dd <tcp_input+0x7ee>
  80d6c6:	83 ec 04             	sub    $0x4,%esp
  80d6c9:	68 ff 2f 81 00       	push   $0x812fff
  80d6ce:	68 5b 02 00 00       	push   $0x25b
  80d6d3:	68 90 2f 81 00       	push   $0x812f90
  80d6d8:	e8 71 0d 00 00       	call   80e44e <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80d6dd:	83 ec 04             	sub    $0x4,%esp
  80d6e0:	6a 00                	push   $0x0
  80d6e2:	53                   	push   %ebx
  80d6e3:	ff 73 18             	pushl  0x18(%ebx)
  80d6e6:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80d6e8:	83 c4 10             	add    $0x10,%esp
  80d6eb:	84 c0                	test   %al,%al
  80d6ed:	74 1b                	je     80d70a <tcp_input+0x81b>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  80d6ef:	83 ec 0c             	sub    $0xc,%esp
  80d6f2:	53                   	push   %ebx
  80d6f3:	e8 ec 84 ff ff       	call   805be4 <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80d6f8:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d6ff:	00 00 00 
  80d702:	83 c4 10             	add    $0x10,%esp
  80d705:	e9 97 04 00 00       	jmp    80dba1 <tcp_input+0xcb2>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  80d70a:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  80d70e:	89 d8                	mov    %ebx,%eax
  80d710:	e8 75 eb ff ff       	call   80c28a <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d715:	66 83 fe 01          	cmp    $0x1,%si
  80d719:	75 09                	jne    80d724 <tcp_input+0x835>
  80d71b:	0f b7 4b 34          	movzwl 0x34(%ebx),%ecx
  80d71f:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  80d722:	eb 04                	jmp    80d728 <tcp_input+0x839>
  80d724:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80d728:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  80d72c:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d733:	0f 84 ed 04 00 00    	je     80dc26 <tcp_input+0xd37>
  80d739:	84 c0                	test   %al,%al
  80d73b:	0f 84 e5 04 00 00    	je     80dc26 <tcp_input+0xd37>
          tcp_ack_now(pcb);
  80d741:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d745:	83 ec 0c             	sub    $0xc,%esp
  80d748:	53                   	push   %ebx
  80d749:	e8 ac a8 ff ff       	call   807ffa <tcp_output>
          pcb->state = CLOSE_WAIT;
  80d74e:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d755:	83 c4 10             	add    $0x10,%esp
  80d758:	e9 c9 04 00 00       	jmp    80dc26 <tcp_input+0xd37>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  80d75d:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d763:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d768:	83 ec 08             	sub    $0x8,%esp
  80d76b:	0f b7 31             	movzwl (%ecx),%esi
  80d76e:	56                   	push   %esi
  80d76f:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80d773:	51                   	push   %ecx
  80d774:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d777:	51                   	push   %ecx
  80d778:	83 c0 10             	add    $0x10,%eax
  80d77b:	50                   	push   %eax
  80d77c:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d783:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d789:	50                   	push   %eax
  80d78a:	52                   	push   %edx
  80d78b:	e8 e1 ac ff ff       	call   808471 <tcp_rst>
  80d790:	83 c4 20             	add    $0x20,%esp
  80d793:	e9 8e 04 00 00       	jmp    80dc26 <tcp_input+0xd37>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  80d798:	89 d8                	mov    %ebx,%eax
  80d79a:	e8 eb ea ff ff       	call   80c28a <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80d79f:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d7a6:	0f 84 7a 04 00 00    	je     80dc26 <tcp_input+0xd37>
  80d7ac:	84 c0                	test   %al,%al
  80d7ae:	0f 84 72 04 00 00    	je     80dc26 <tcp_input+0xd37>
      tcp_ack_now(pcb);
  80d7b4:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d7b8:	83 ec 0c             	sub    $0xc,%esp
  80d7bb:	53                   	push   %ebx
  80d7bc:	e8 39 a8 ff ff       	call   807ffa <tcp_output>
      pcb->state = CLOSE_WAIT;
  80d7c1:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d7c8:	83 c4 10             	add    $0x10,%esp
  80d7cb:	e9 56 04 00 00       	jmp    80dc26 <tcp_input+0xd37>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  80d7d0:	89 d8                	mov    %ebx,%eax
  80d7d2:	e8 b3 ea ff ff       	call   80c28a <tcp_receive>
    if (flags & TCP_FIN) {
  80d7d7:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d7de:	a8 01                	test   $0x1,%al
  80d7e0:	0f 84 cf 00 00 00    	je     80d8b5 <tcp_input+0x9c6>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d7e6:	a8 10                	test   $0x10,%al
  80d7e8:	0f 84 ab 00 00 00    	je     80d899 <tcp_input+0x9aa>
  80d7ee:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d7f3:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d7f6:	0f 85 9d 00 00 00    	jne    80d899 <tcp_input+0x9aa>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  80d7fc:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d800:	83 ec 0c             	sub    $0xc,%esp
  80d803:	53                   	push   %ebx
  80d804:	e8 f1 a7 ff ff       	call   807ffa <tcp_output>
        tcp_pcb_purge(pcb);
  80d809:	89 1c 24             	mov    %ebx,(%esp)
  80d80c:	e8 7a 80 ff ff       	call   80588b <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80d811:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d816:	83 c4 10             	add    $0x10,%esp
  80d819:	39 c3                	cmp    %eax,%ebx
  80d81b:	75 0a                	jne    80d827 <tcp_input+0x938>
  80d81d:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d820:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80d825:	eb 53                	jmp    80d87a <tcp_input+0x98b>
  80d827:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d82c:	ba 00 00 00 00       	mov    $0x0,%edx
  80d831:	89 de                	mov    %ebx,%esi
  80d833:	89 d7                	mov    %edx,%edi
  80d835:	eb 2d                	jmp    80d864 <tcp_input+0x975>
  80d837:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d83a:	39 ce                	cmp    %ecx,%esi
  80d83c:	0f 94 c3             	sete   %bl
  80d83f:	85 c9                	test   %ecx,%ecx
  80d841:	0f 95 c2             	setne  %dl
  80d844:	84 d3                	test   %dl,%bl
  80d846:	74 15                	je     80d85d <tcp_input+0x96e>
  80d848:	89 f3                	mov    %esi,%ebx
  80d84a:	89 fa                	mov    %edi,%edx
  80d84c:	84 d2                	test   %dl,%dl
  80d84e:	74 05                	je     80d855 <tcp_input+0x966>
  80d850:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d855:	8b 53 0c             	mov    0xc(%ebx),%edx
  80d858:	89 50 0c             	mov    %edx,0xc(%eax)
  80d85b:	eb 1d                	jmp    80d87a <tcp_input+0x98b>
  80d85d:	bf 01 00 00 00       	mov    $0x1,%edi
  80d862:	89 c8                	mov    %ecx,%eax
  80d864:	85 c0                	test   %eax,%eax
  80d866:	75 cf                	jne    80d837 <tcp_input+0x948>
  80d868:	89 f3                	mov    %esi,%ebx
  80d86a:	89 fa                	mov    %edi,%edx
  80d86c:	84 d2                	test   %dl,%dl
  80d86e:	74 0a                	je     80d87a <tcp_input+0x98b>
  80d870:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80d877:	00 00 00 
        pcb->state = TIME_WAIT;
  80d87a:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80d881:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80d886:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d889:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80d88f:	e8 d0 49 ff ff       	call   802264 <tcp_timer_needed>
  80d894:	e9 8d 03 00 00       	jmp    80dc26 <tcp_input+0xd37>
      } else {
        tcp_ack_now(pcb);
  80d899:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d89d:	83 ec 0c             	sub    $0xc,%esp
  80d8a0:	53                   	push   %ebx
  80d8a1:	e8 54 a7 ff ff       	call   807ffa <tcp_output>
        pcb->state = CLOSING;
  80d8a6:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80d8ad:	83 c4 10             	add    $0x10,%esp
  80d8b0:	e9 71 03 00 00       	jmp    80dc26 <tcp_input+0xd37>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d8b5:	a8 10                	test   $0x10,%al
  80d8b7:	0f 84 69 03 00 00    	je     80dc26 <tcp_input+0xd37>
  80d8bd:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d8c2:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d8c5:	0f 85 5b 03 00 00    	jne    80dc26 <tcp_input+0xd37>
      pcb->state = FIN_WAIT_2;
  80d8cb:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80d8d2:	e9 4f 03 00 00       	jmp    80dc26 <tcp_input+0xd37>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  80d8d7:	89 d8                	mov    %ebx,%eax
  80d8d9:	e8 ac e9 ff ff       	call   80c28a <tcp_receive>
    if (flags & TCP_FIN) {
  80d8de:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d8e5:	0f 84 3b 03 00 00    	je     80dc26 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80d8eb:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d8ef:	83 ec 0c             	sub    $0xc,%esp
  80d8f2:	53                   	push   %ebx
  80d8f3:	e8 02 a7 ff ff       	call   807ffa <tcp_output>
      tcp_pcb_purge(pcb);
  80d8f8:	89 1c 24             	mov    %ebx,(%esp)
  80d8fb:	e8 8b 7f ff ff       	call   80588b <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80d900:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d905:	83 c4 10             	add    $0x10,%esp
  80d908:	39 c3                	cmp    %eax,%ebx
  80d90a:	75 0a                	jne    80d916 <tcp_input+0xa27>
  80d90c:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d90f:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80d914:	eb 53                	jmp    80d969 <tcp_input+0xa7a>
  80d916:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d91b:	b9 00 00 00 00       	mov    $0x0,%ecx
  80d920:	89 de                	mov    %ebx,%esi
  80d922:	89 cf                	mov    %ecx,%edi
  80d924:	eb 2d                	jmp    80d953 <tcp_input+0xa64>
  80d926:	8b 50 0c             	mov    0xc(%eax),%edx
  80d929:	85 d2                	test   %edx,%edx
  80d92b:	0f 95 c3             	setne  %bl
  80d92e:	39 d6                	cmp    %edx,%esi
  80d930:	0f 94 c1             	sete   %cl
  80d933:	84 cb                	test   %cl,%bl
  80d935:	74 15                	je     80d94c <tcp_input+0xa5d>
  80d937:	89 f3                	mov    %esi,%ebx
  80d939:	89 f9                	mov    %edi,%ecx
  80d93b:	84 c9                	test   %cl,%cl
  80d93d:	74 05                	je     80d944 <tcp_input+0xa55>
  80d93f:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d944:	8b 53 0c             	mov    0xc(%ebx),%edx
  80d947:	89 50 0c             	mov    %edx,0xc(%eax)
  80d94a:	eb 1d                	jmp    80d969 <tcp_input+0xa7a>
  80d94c:	bf 01 00 00 00       	mov    $0x1,%edi
  80d951:	89 d0                	mov    %edx,%eax
  80d953:	85 c0                	test   %eax,%eax
  80d955:	75 cf                	jne    80d926 <tcp_input+0xa37>
  80d957:	89 f3                	mov    %esi,%ebx
  80d959:	89 f9                	mov    %edi,%ecx
  80d95b:	84 c9                	test   %cl,%cl
  80d95d:	74 0a                	je     80d969 <tcp_input+0xa7a>
  80d95f:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80d966:	00 00 00 
      pcb->state = TIME_WAIT;
  80d969:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80d970:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80d975:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d978:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80d97e:	e8 e1 48 ff ff       	call   802264 <tcp_timer_needed>
  80d983:	e9 9e 02 00 00       	jmp    80dc26 <tcp_input+0xd37>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  80d988:	89 d8                	mov    %ebx,%eax
  80d98a:	e8 fb e8 ff ff       	call   80c28a <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d98f:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d996:	0f 84 8a 02 00 00    	je     80dc26 <tcp_input+0xd37>
  80d99c:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d9a1:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d9a4:	0f 85 7c 02 00 00    	jne    80dc26 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80d9aa:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d9ae:	83 ec 0c             	sub    $0xc,%esp
  80d9b1:	53                   	push   %ebx
  80d9b2:	e8 43 a6 ff ff       	call   807ffa <tcp_output>
      tcp_pcb_purge(pcb);
  80d9b7:	89 1c 24             	mov    %ebx,(%esp)
  80d9ba:	e8 cc 7e ff ff       	call   80588b <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80d9bf:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d9c4:	83 c4 10             	add    $0x10,%esp
  80d9c7:	39 c3                	cmp    %eax,%ebx
  80d9c9:	75 0a                	jne    80d9d5 <tcp_input+0xae6>
  80d9cb:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d9ce:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80d9d3:	eb 53                	jmp    80da28 <tcp_input+0xb39>
  80d9d5:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d9da:	ba 00 00 00 00       	mov    $0x0,%edx
  80d9df:	89 de                	mov    %ebx,%esi
  80d9e1:	89 d7                	mov    %edx,%edi
  80d9e3:	eb 2d                	jmp    80da12 <tcp_input+0xb23>
  80d9e5:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d9e8:	39 ce                	cmp    %ecx,%esi
  80d9ea:	0f 94 c3             	sete   %bl
  80d9ed:	85 c9                	test   %ecx,%ecx
  80d9ef:	0f 95 c2             	setne  %dl
  80d9f2:	84 d3                	test   %dl,%bl
  80d9f4:	74 15                	je     80da0b <tcp_input+0xb1c>
  80d9f6:	89 f3                	mov    %esi,%ebx
  80d9f8:	89 fa                	mov    %edi,%edx
  80d9fa:	84 d2                	test   %dl,%dl
  80d9fc:	74 05                	je     80da03 <tcp_input+0xb14>
  80d9fe:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80da03:	8b 53 0c             	mov    0xc(%ebx),%edx
  80da06:	89 50 0c             	mov    %edx,0xc(%eax)
  80da09:	eb 1d                	jmp    80da28 <tcp_input+0xb39>
  80da0b:	bf 01 00 00 00       	mov    $0x1,%edi
  80da10:	89 c8                	mov    %ecx,%eax
  80da12:	85 c0                	test   %eax,%eax
  80da14:	75 cf                	jne    80d9e5 <tcp_input+0xaf6>
  80da16:	89 f3                	mov    %esi,%ebx
  80da18:	89 fa                	mov    %edi,%edx
  80da1a:	84 d2                	test   %dl,%dl
  80da1c:	74 0a                	je     80da28 <tcp_input+0xb39>
  80da1e:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80da25:	00 00 00 
      pcb->state = TIME_WAIT;
  80da28:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80da2f:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80da34:	89 43 0c             	mov    %eax,0xc(%ebx)
  80da37:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80da3d:	e8 22 48 ff ff       	call   802264 <tcp_timer_needed>
  80da42:	e9 df 01 00 00       	jmp    80dc26 <tcp_input+0xd37>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  80da47:	89 d8                	mov    %ebx,%eax
  80da49:	e8 3c e8 ff ff       	call   80c28a <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80da4e:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80da55:	0f 84 cb 01 00 00    	je     80dc26 <tcp_input+0xd37>
  80da5b:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80da60:	39 43 54             	cmp    %eax,0x54(%ebx)
  80da63:	0f 85 bd 01 00 00    	jne    80dc26 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  80da69:	c6 05 9c b1 b3 00 10 	movb   $0x10,0xb3b19c
  80da70:	e9 b1 01 00 00       	jmp    80dc26 <tcp_input+0xd37>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80da75:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80da7c:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  80da7f:	0f b6 05 9c b1 b3 00 	movzbl 0xb3b19c,%eax
  80da86:	a8 08                	test   $0x8,%al
  80da88:	74 38                	je     80dac2 <tcp_input+0xbd3>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80da8a:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80da90:	85 c0                	test   %eax,%eax
  80da92:	74 0d                	je     80daa1 <tcp_input+0xbb2>
  80da94:	83 ec 08             	sub    $0x8,%esp
  80da97:	6a fa                	push   $0xfffffffa
  80da99:	ff 73 18             	pushl  0x18(%ebx)
  80da9c:	ff d0                	call   *%eax
  80da9e:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80daa1:	83 ec 08             	sub    $0x8,%esp
  80daa4:	53                   	push   %ebx
  80daa5:	68 3c b2 b3 00       	push   $0xb3b23c
  80daaa:	e8 57 7e ff ff       	call   805906 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80daaf:	83 c4 08             	add    $0x8,%esp
  80dab2:	53                   	push   %ebx
  80dab3:	6a 02                	push   $0x2
  80dab5:	e8 f8 69 ff ff       	call   8044b2 <memp_free>
  80daba:	83 c4 10             	add    $0x10,%esp
  80dabd:	e9 df 00 00 00       	jmp    80dba1 <tcp_input+0xcb2>
      } else if (recv_flags & TF_CLOSED) {
  80dac2:	a8 10                	test   $0x10,%al
  80dac4:	74 21                	je     80dae7 <tcp_input+0xbf8>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80dac6:	83 ec 08             	sub    $0x8,%esp
  80dac9:	53                   	push   %ebx
  80daca:	68 3c b2 b3 00       	push   $0xb3b23c
  80dacf:	e8 32 7e ff ff       	call   805906 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80dad4:	83 c4 08             	add    $0x8,%esp
  80dad7:	53                   	push   %ebx
  80dad8:	6a 02                	push   $0x2
  80dada:	e8 d3 69 ff ff       	call   8044b2 <memp_free>
  80dadf:	83 c4 10             	add    $0x10,%esp
  80dae2:	e9 ba 00 00 00       	jmp    80dba1 <tcp_input+0xcb2>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80dae7:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else {
        err = ERR_OK;
  80daeb:	b8 00 00 00 00       	mov    $0x0,%eax
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80daf0:	66 85 d2             	test   %dx,%dx
  80daf3:	74 1a                	je     80db0f <tcp_input+0xc20>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80daf5:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80dafb:	85 c9                	test   %ecx,%ecx
  80dafd:	74 10                	je     80db0f <tcp_input+0xc20>
  80daff:	83 ec 04             	sub    $0x4,%esp
  80db02:	0f b7 d2             	movzwl %dx,%edx
  80db05:	52                   	push   %edx
  80db06:	53                   	push   %ebx
  80db07:	ff 73 18             	pushl  0x18(%ebx)
  80db0a:	ff d1                	call   *%ecx
  80db0c:	83 c4 10             	add    $0x10,%esp
        }
      
        if (recv_data != NULL) {
  80db0f:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80db15:	85 d2                	test   %edx,%edx
  80db17:	74 58                	je     80db71 <tcp_input+0xc82>
          if(flags & TCP_PSH) {
  80db19:	f6 05 a0 b1 b3 00 08 	testb  $0x8,0xb3b1a0
  80db20:	0f 84 0f 01 00 00    	je     80dc35 <tcp_input+0xd46>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80db26:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
  80db2a:	e9 06 01 00 00       	jmp    80dc35 <tcp_input+0xd46>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80db2f:	6a 00                	push   $0x0
  80db31:	52                   	push   %edx
  80db32:	53                   	push   %ebx
  80db33:	ff 73 18             	pushl  0x18(%ebx)
  80db36:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  80db38:	83 c4 10             	add    $0x10,%esp
  80db3b:	84 c0                	test   %al,%al
  80db3d:	75 1c                	jne    80db5b <tcp_input+0xc6c>
  80db3f:	e9 04 01 00 00       	jmp    80dc48 <tcp_input+0xd59>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80db44:	83 ec 0c             	sub    $0xc,%esp
  80db47:	52                   	push   %edx
  80db48:	e8 d8 6c ff ff       	call   804825 <pbuf_free>
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80db4d:	83 c4 10             	add    $0x10,%esp
  80db50:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80db57:	75 21                	jne    80db7a <tcp_input+0xc8b>
  80db59:	eb 3a                	jmp    80db95 <tcp_input+0xca6>
          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  80db5b:	a1 98 b1 b3 00       	mov    0xb3b198,%eax
  80db60:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80db66:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80db6d:	74 32                	je     80dba1 <tcp_input+0xcb2>
  80db6f:	eb 09                	jmp    80db7a <tcp_input+0xc8b>
  80db71:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80db78:	74 17                	je     80db91 <tcp_input+0xca2>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80db7a:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80db80:	85 c0                	test   %eax,%eax
  80db82:	74 11                	je     80db95 <tcp_input+0xca6>
  80db84:	6a 00                	push   $0x0
  80db86:	6a 00                	push   $0x0
  80db88:	53                   	push   %ebx
  80db89:	ff 73 18             	pushl  0x18(%ebx)
  80db8c:	ff d0                	call   *%eax
  80db8e:	83 c4 10             	add    $0x10,%esp
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  80db91:	84 c0                	test   %al,%al
  80db93:	75 0c                	jne    80dba1 <tcp_input+0xcb2>
          tcp_output(pcb);
  80db95:	83 ec 0c             	sub    $0xc,%esp
  80db98:	53                   	push   %ebx
  80db99:	e8 5c a4 ff ff       	call   807ffa <tcp_output>
  80db9e:	83 c4 10             	add    $0x10,%esp
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  80dba1:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80dba6:	85 c0                	test   %eax,%eax
  80dba8:	0f 84 ac 00 00 00    	je     80dc5a <tcp_input+0xd6b>
    {
      pbuf_free(inseg.p);
  80dbae:	83 ec 0c             	sub    $0xc,%esp
  80dbb1:	50                   	push   %eax
  80dbb2:	e8 6e 6c ff ff       	call   804825 <pbuf_free>
      inseg.p = NULL;
  80dbb7:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80dbbe:	00 00 00 
  80dbc1:	83 c4 10             	add    $0x10,%esp
  80dbc4:	e9 91 00 00 00       	jmp    80dc5a <tcp_input+0xd6b>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80dbc9:	83 ec 0c             	sub    $0xc,%esp
  80dbcc:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80dbd0:	50                   	push   %eax
  80dbd1:	e8 0d 9b ff ff       	call   8076e3 <ntohs>
  80dbd6:	83 c4 10             	add    $0x10,%esp
  80dbd9:	a8 04                	test   $0x4,%al
  80dbdb:	75 3b                	jne    80dc18 <tcp_input+0xd29>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80dbdd:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  80dbe3:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  80dbe8:	83 ec 08             	sub    $0x8,%esp
  80dbeb:	0f b7 0a             	movzwl (%edx),%ecx
  80dbee:	51                   	push   %ecx
  80dbef:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80dbf3:	52                   	push   %edx
  80dbf4:	8d 50 0c             	lea    0xc(%eax),%edx
  80dbf7:	52                   	push   %edx
  80dbf8:	83 c0 10             	add    $0x10,%eax
  80dbfb:	50                   	push   %eax
  80dbfc:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80dc03:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80dc09:	50                   	push   %eax
  80dc0a:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80dc10:	e8 5c a8 ff ff       	call   808471 <tcp_rst>
  80dc15:	83 c4 20             	add    $0x20,%esp
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  80dc18:	83 ec 0c             	sub    $0xc,%esp
  80dc1b:	56                   	push   %esi
  80dc1c:	e8 04 6c ff ff       	call   804825 <pbuf_free>
  80dc21:	83 c4 10             	add    $0x10,%esp
  80dc24:	eb 34                	jmp    80dc5a <tcp_input+0xd6b>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80dc26:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80dc2d:	00 00 00 
  80dc30:	e9 4a fe ff ff       	jmp    80da7f <tcp_input+0xb90>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80dc35:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80dc3b:	85 c0                	test   %eax,%eax
  80dc3d:	0f 85 ec fe ff ff    	jne    80db2f <tcp_input+0xc40>
  80dc43:	e9 fc fe ff ff       	jmp    80db44 <tcp_input+0xc55>
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80dc48:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dc4f:	0f 85 25 ff ff ff    	jne    80db7a <tcp_input+0xc8b>
  80dc55:	e9 3b ff ff ff       	jmp    80db95 <tcp_input+0xca6>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  80dc5a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80dc5d:	5b                   	pop    %ebx
  80dc5e:	5e                   	pop    %esi
  80dc5f:	5f                   	pop    %edi
  80dc60:	5d                   	pop    %ebp
  80dc61:	c3                   	ret    

0080dc62 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80dc62:	55                   	push   %ebp
  80dc63:	89 e5                	mov    %esp,%ebp
  80dc65:	57                   	push   %edi
  80dc66:	56                   	push   %esi
  80dc67:	53                   	push   %ebx
  80dc68:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80dc6b:	8b 45 08             	mov    0x8(%ebp),%eax
  80dc6e:	8b 40 04             	mov    0x4(%eax),%eax
  proto = IPH_PROTO(iphdr);
  80dc71:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80dc74:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80dc78:	50                   	push   %eax
  80dc79:	e8 65 9a ff ff       	call   8076e3 <ntohs>

  prev = NULL;
  pcb = raw_pcbs;
  80dc7e:	8b 1d c8 b1 b3 00    	mov    0xb3b1c8,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dc84:	83 c4 10             	add    $0x10,%esp
raw_input(struct pbuf *p, struct netif *inp)
{
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  80dc87:	be 00 00 00 00       	mov    $0x0,%esi
  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  80dc8c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  80dc93:	0f b6 f8             	movzbl %al,%edi
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80dc96:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80dc99:	83 c0 0c             	add    $0xc,%eax
  80dc9c:	89 45 e0             	mov    %eax,-0x20(%ebp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dc9f:	eb 5d                	jmp    80dcfe <raw_input+0x9c>
    if (pcb->protocol == proto) {
  80dca1:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80dca5:	39 f8                	cmp    %edi,%eax
  80dca7:	75 4f                	jne    80dcf8 <raw_input+0x96>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  80dca9:	8b 43 14             	mov    0x14(%ebx),%eax
  80dcac:	85 c0                	test   %eax,%eax
  80dcae:	74 48                	je     80dcf8 <raw_input+0x96>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80dcb0:	ff 75 e0             	pushl  -0x20(%ebp)
  80dcb3:	ff 75 08             	pushl  0x8(%ebp)
  80dcb6:	53                   	push   %ebx
  80dcb7:	ff 73 18             	pushl  0x18(%ebx)
  80dcba:	ff d0                	call   *%eax
  80dcbc:	83 c4 10             	add    $0x10,%esp
  80dcbf:	84 c0                	test   %al,%al
  80dcc1:	74 35                	je     80dcf8 <raw_input+0x96>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  80dcc3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80dcc6:	85 d2                	test   %edx,%edx
  80dcc8:	74 22                	je     80dcec <raw_input+0x8a>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  80dcca:	8b 43 0c             	mov    0xc(%ebx),%eax
  80dccd:	89 42 0c             	mov    %eax,0xc(%edx)
            pcb->next = raw_pcbs;
  80dcd0:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80dcd5:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80dcd8:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
  80dcde:	be 01 00 00 00       	mov    $0x1,%esi
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80dce3:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80dcea:	eb 0c                	jmp    80dcf8 <raw_input+0x96>
          eaten = 1;
  80dcec:	be 01 00 00 00       	mov    $0x1,%esi
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80dcf1:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80dcf8:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    pcb = pcb->next;
  80dcfb:	8b 5b 0c             	mov    0xc(%ebx),%ebx

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dcfe:	89 f0                	mov    %esi,%eax
  80dd00:	84 c0                	test   %al,%al
  80dd02:	75 04                	jne    80dd08 <raw_input+0xa6>
  80dd04:	85 db                	test   %ebx,%ebx
  80dd06:	75 99                	jne    80dca1 <raw_input+0x3f>
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  80dd08:	89 f0                	mov    %esi,%eax
  80dd0a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80dd0d:	5b                   	pop    %ebx
  80dd0e:	5e                   	pop    %esi
  80dd0f:	5f                   	pop    %edi
  80dd10:	5d                   	pop    %ebp
  80dd11:	c3                   	ret    

0080dd12 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80dd12:	55                   	push   %ebp
  80dd13:	89 e5                	mov    %esp,%ebp
  80dd15:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->local_ip, ipaddr);
  80dd18:	85 c0                	test   %eax,%eax
  80dd1a:	74 04                	je     80dd20 <raw_bind+0xe>
  80dd1c:	8b 10                	mov    (%eax),%edx
  80dd1e:	eb 05                	jmp    80dd25 <raw_bind+0x13>
  80dd20:	ba 00 00 00 00       	mov    $0x0,%edx
  80dd25:	8b 45 08             	mov    0x8(%ebp),%eax
  80dd28:	89 10                	mov    %edx,(%eax)
  return ERR_OK;
}
  80dd2a:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd2f:	5d                   	pop    %ebp
  80dd30:	c3                   	ret    

0080dd31 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80dd31:	55                   	push   %ebp
  80dd32:	89 e5                	mov    %esp,%ebp
  80dd34:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80dd37:	85 c0                	test   %eax,%eax
  80dd39:	74 04                	je     80dd3f <raw_connect+0xe>
  80dd3b:	8b 10                	mov    (%eax),%edx
  80dd3d:	eb 05                	jmp    80dd44 <raw_connect+0x13>
  80dd3f:	ba 00 00 00 00       	mov    $0x0,%edx
  80dd44:	8b 45 08             	mov    0x8(%ebp),%eax
  80dd47:	89 50 04             	mov    %edx,0x4(%eax)
  return ERR_OK;
}
  80dd4a:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd4f:	5d                   	pop    %ebp
  80dd50:	c3                   	ret    

0080dd51 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80dd51:	55                   	push   %ebp
  80dd52:	89 e5                	mov    %esp,%ebp
  80dd54:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80dd57:	8b 55 0c             	mov    0xc(%ebp),%edx
  80dd5a:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80dd5d:	8b 55 10             	mov    0x10(%ebp),%edx
  80dd60:	89 50 18             	mov    %edx,0x18(%eax)
}
  80dd63:	5d                   	pop    %ebp
  80dd64:	c3                   	ret    

0080dd65 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80dd65:	55                   	push   %ebp
  80dd66:	89 e5                	mov    %esp,%ebp
  80dd68:	57                   	push   %edi
  80dd69:	56                   	push   %esi
  80dd6a:	53                   	push   %ebx
  80dd6b:	83 ec 14             	sub    $0x14,%esp
  80dd6e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dd71:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80dd74:	6a 14                	push   $0x14
  80dd76:	57                   	push   %edi
  80dd77:	e8 d7 69 ff ff       	call   804753 <pbuf_header>
  80dd7c:	83 c4 10             	add    $0x10,%esp
  80dd7f:	84 c0                	test   %al,%al
  80dd81:	74 39                	je     80ddbc <raw_sendto+0x57>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80dd83:	83 ec 04             	sub    $0x4,%esp
  80dd86:	6a 00                	push   $0x0
  80dd88:	6a 00                	push   $0x0
  80dd8a:	6a 01                	push   $0x1
  80dd8c:	e8 5a 6b ff ff       	call   8048eb <pbuf_alloc>
  80dd91:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80dd93:	83 c4 10             	add    $0x10,%esp
  80dd96:	85 c0                	test   %eax,%eax
  80dd98:	0f 84 a6 00 00 00    	je     80de44 <raw_sendto+0xdf>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80dd9e:	83 ec 08             	sub    $0x8,%esp
  80dda1:	57                   	push   %edi
  80dda2:	50                   	push   %eax
  80dda3:	e8 71 6f ff ff       	call   804d19 <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80dda8:	83 c4 04             	add    $0x4,%esp
  80ddab:	ff 75 10             	pushl  0x10(%ebp)
  80ddae:	e8 67 87 ff ff       	call   80651a <ip_route>
  80ddb3:	83 c4 10             	add    $0x10,%esp
  80ddb6:	85 c0                	test   %eax,%eax
  80ddb8:	75 46                	jne    80de00 <raw_sendto+0x9b>
  80ddba:	eb 2d                	jmp    80dde9 <raw_sendto+0x84>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  80ddbc:	83 ec 08             	sub    $0x8,%esp
  80ddbf:	6a ec                	push   $0xffffffec
  80ddc1:	57                   	push   %edi
  80ddc2:	e8 8c 69 ff ff       	call   804753 <pbuf_header>
  80ddc7:	83 c4 10             	add    $0x10,%esp
  80ddca:	84 c0                	test   %al,%al
  80ddcc:	0f 84 87 00 00 00    	je     80de59 <raw_sendto+0xf4>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80ddd2:	83 ec 04             	sub    $0x4,%esp
  80ddd5:	68 3c 30 81 00       	push   $0x81303c
  80ddda:	68 e3 00 00 00       	push   $0xe3
  80dddf:	68 62 30 81 00       	push   $0x813062
  80dde4:	e8 65 06 00 00       	call   80e44e <_panic>
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80dde9:	39 f7                	cmp    %esi,%edi
  80ddeb:	74 5e                	je     80de4b <raw_sendto+0xe6>
      pbuf_free(q);
  80dded:	83 ec 0c             	sub    $0xc,%esp
  80ddf0:	56                   	push   %esi
  80ddf1:	e8 2f 6a ff ff       	call   804825 <pbuf_free>
  80ddf6:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80ddf9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80ddfe:	eb 6f                	jmp    80de6f <raw_sendto+0x10a>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80de00:	89 da                	mov    %ebx,%edx
  80de02:	85 db                	test   %ebx,%ebx
  80de04:	74 05                	je     80de0b <raw_sendto+0xa6>
  80de06:	83 3b 00             	cmpl   $0x0,(%ebx)
  80de09:	75 03                	jne    80de0e <raw_sendto+0xa9>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80de0b:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80de0e:	83 ec 04             	sub    $0x4,%esp
  80de11:	50                   	push   %eax
  80de12:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80de16:	50                   	push   %eax
  80de17:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80de1b:	50                   	push   %eax
  80de1c:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80de20:	50                   	push   %eax
  80de21:	ff 75 10             	pushl  0x10(%ebp)
  80de24:	52                   	push   %edx
  80de25:	56                   	push   %esi
  80de26:	e8 51 8a ff ff       	call   80687c <ip_output_if>
  80de2b:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80de2d:	83 c4 20             	add    $0x20,%esp
  80de30:	39 f7                	cmp    %esi,%edi
  80de32:	74 3b                	je     80de6f <raw_sendto+0x10a>
    /* free the header */
    pbuf_free(q);
  80de34:	83 ec 0c             	sub    $0xc,%esp
  80de37:	56                   	push   %esi
  80de38:	e8 e8 69 ff ff       	call   804825 <pbuf_free>
  80de3d:	83 c4 10             	add    $0x10,%esp
  }
  return err;
  80de40:	89 d8                	mov    %ebx,%eax
  80de42:	eb 2b                	jmp    80de6f <raw_sendto+0x10a>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  80de44:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80de49:	eb 24                	jmp    80de6f <raw_sendto+0x10a>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  80de4b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80de50:	eb 1d                	jmp    80de6f <raw_sendto+0x10a>
  80de52:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80de57:	eb 16                	jmp    80de6f <raw_sendto+0x10a>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80de59:	83 ec 0c             	sub    $0xc,%esp
  80de5c:	ff 75 10             	pushl  0x10(%ebp)
  80de5f:	e8 b6 86 ff ff       	call   80651a <ip_route>
  80de64:	83 c4 10             	add    $0x10,%esp
  80de67:	85 c0                	test   %eax,%eax
  80de69:	74 e7                	je     80de52 <raw_sendto+0xed>
    pbuf_chain(q, p);
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  80de6b:	89 fe                	mov    %edi,%esi
  80de6d:	eb 91                	jmp    80de00 <raw_sendto+0x9b>
  if (q != p) {
    /* free the header */
    pbuf_free(q);
  }
  return err;
}
  80de6f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80de72:	5b                   	pop    %ebx
  80de73:	5e                   	pop    %esi
  80de74:	5f                   	pop    %edi
  80de75:	5d                   	pop    %ebp
  80de76:	c3                   	ret    

0080de77 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80de77:	55                   	push   %ebp
  80de78:	89 e5                	mov    %esp,%ebp
  80de7a:	83 ec 0c             	sub    $0xc,%esp
  80de7d:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80de80:	8d 50 04             	lea    0x4(%eax),%edx
  80de83:	52                   	push   %edx
  80de84:	ff 75 0c             	pushl  0xc(%ebp)
  80de87:	50                   	push   %eax
  80de88:	e8 d8 fe ff ff       	call   80dd65 <raw_sendto>
}
  80de8d:	c9                   	leave  
  80de8e:	c3                   	ret    

0080de8f <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80de8f:	55                   	push   %ebp
  80de90:	89 e5                	mov    %esp,%ebp
  80de92:	83 ec 08             	sub    $0x8,%esp
  80de95:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80de98:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80de9d:	39 c8                	cmp    %ecx,%eax
  80de9f:	75 1e                	jne    80debf <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80dea1:	8b 40 0c             	mov    0xc(%eax),%eax
  80dea4:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
  80dea9:	eb 18                	jmp    80dec3 <raw_remove+0x34>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80deab:	8b 50 0c             	mov    0xc(%eax),%edx
  80deae:	39 d1                	cmp    %edx,%ecx
  80deb0:	75 0a                	jne    80debc <raw_remove+0x2d>
  80deb2:	85 d2                	test   %edx,%edx
  80deb4:	74 06                	je     80debc <raw_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80deb6:	8b 51 0c             	mov    0xc(%ecx),%edx
  80deb9:	89 50 0c             	mov    %edx,0xc(%eax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80debc:	8b 40 0c             	mov    0xc(%eax),%eax
  80debf:	85 c0                	test   %eax,%eax
  80dec1:	75 e8                	jne    80deab <raw_remove+0x1c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80dec3:	83 ec 08             	sub    $0x8,%esp
  80dec6:	51                   	push   %ecx
  80dec7:	6a 00                	push   $0x0
  80dec9:	e8 e4 65 ff ff       	call   8044b2 <memp_free>
}
  80dece:	83 c4 10             	add    $0x10,%esp
  80ded1:	c9                   	leave  
  80ded2:	c3                   	ret    

0080ded3 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80ded3:	55                   	push   %ebp
  80ded4:	89 e5                	mov    %esp,%ebp
  80ded6:	56                   	push   %esi
  80ded7:	53                   	push   %ebx
  80ded8:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80dedb:	83 ec 0c             	sub    $0xc,%esp
  80dede:	6a 00                	push   $0x0
  80dee0:	e8 77 65 ff ff       	call   80445c <memp_malloc>
  80dee5:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80dee7:	83 c4 10             	add    $0x10,%esp
  80deea:	85 c0                	test   %eax,%eax
  80deec:	74 27                	je     80df15 <raw_new+0x42>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80deee:	83 ec 04             	sub    $0x4,%esp
  80def1:	6a 1c                	push   $0x1c
  80def3:	6a 00                	push   $0x0
  80def5:	50                   	push   %eax
  80def6:	e8 f6 0c 00 00       	call   80ebf1 <memset>
    pcb->protocol = proto;
  80defb:	89 f0                	mov    %esi,%eax
  80defd:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80df00:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80df04:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80df09:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80df0c:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
  80df12:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80df15:	89 d8                	mov    %ebx,%eax
  80df17:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80df1a:	5b                   	pop    %ebx
  80df1b:	5e                   	pop    %esi
  80df1c:	5d                   	pop    %ebp
  80df1d:	c3                   	ret    

0080df1e <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80df1e:	55                   	push   %ebp
  80df1f:	89 e5                	mov    %esp,%ebp
  80df21:	57                   	push   %edi
  80df22:	56                   	push   %esi
  80df23:	53                   	push   %ebx
  80df24:	83 ec 28             	sub    $0x28,%esp
  80df27:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80df2a:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80df2d:	0f b7 07             	movzwl (%edi),%eax
  80df30:	50                   	push   %eax
  80df31:	e8 ad 97 ff ff       	call   8076e3 <ntohs>
  80df36:	66 c1 e8 06          	shr    $0x6,%ax
  80df3a:	83 e0 3c             	and    $0x3c,%eax
  80df3d:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80df41:	89 c6                	mov    %eax,%esi
  80df43:	f7 de                	neg    %esi
  80df45:	0f bf f6             	movswl %si,%esi
  80df48:	83 c4 08             	add    $0x8,%esp
  80df4b:	56                   	push   %esi
  80df4c:	53                   	push   %ebx
  80df4d:	e8 01 68 ff ff       	call   804753 <pbuf_header>
  80df52:	83 c4 10             	add    $0x10,%esp
  80df55:	84 c0                	test   %al,%al
  80df57:	0f 85 b1 02 00 00    	jne    80e20e <icmp_input+0x2f0>
  80df5d:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80df62:	0f 86 a6 02 00 00    	jbe    80e20e <icmp_input+0x2f0>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80df68:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80df6b:	80 38 08             	cmpb   $0x8,(%eax)
  80df6e:	0f 85 8c 02 00 00    	jne    80e200 <icmp_input+0x2e2>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80df74:	83 ec 08             	sub    $0x8,%esp
  80df77:	ff 75 0c             	pushl  0xc(%ebp)
  80df7a:	8d 47 10             	lea    0x10(%edi),%eax
  80df7d:	50                   	push   %eax
  80df7e:	e8 4b 85 ff ff       	call   8064ce <ip_addr_isbroadcast>
  80df83:	83 c4 10             	add    $0x10,%esp
  80df86:	84 c0                	test   %al,%al
  80df88:	75 2d                	jne    80dfb7 <icmp_input+0x99>
  80df8a:	8b 47 10             	mov    0x10(%edi),%eax
  80df8d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80df90:	83 ec 0c             	sub    $0xc,%esp
  80df93:	68 00 00 00 f0       	push   $0xf0000000
  80df98:	e8 74 99 ff ff       	call   807911 <ntohl>
  80df9d:	23 45 e0             	and    -0x20(%ebp),%eax
  80dfa0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80dfa3:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80dfaa:	e8 62 99 ff ff       	call   807911 <ntohl>
  80dfaf:	83 c4 10             	add    $0x10,%esp
  80dfb2:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80dfb5:	75 11                	jne    80dfc8 <icmp_input+0xaa>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  80dfb7:	83 ec 0c             	sub    $0xc,%esp
  80dfba:	53                   	push   %ebx
  80dfbb:	e8 65 68 ff ff       	call   804825 <pbuf_free>
      return;
  80dfc0:	83 c4 10             	add    $0x10,%esp
  80dfc3:	e9 60 02 00 00       	jmp    80e228 <icmp_input+0x30a>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80dfc8:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80dfcd:	0f 86 3b 02 00 00    	jbe    80e20e <icmp_input+0x2f0>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  80dfd3:	83 ec 0c             	sub    $0xc,%esp
  80dfd6:	53                   	push   %ebx
  80dfd7:	e8 eb 95 ff ff       	call   8075c7 <inet_chksum_pbuf>
  80dfdc:	83 c4 10             	add    $0x10,%esp
  80dfdf:	66 85 c0             	test   %ax,%ax
  80dfe2:	74 11                	je     80dff5 <icmp_input+0xd7>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  80dfe4:	83 ec 0c             	sub    $0xc,%esp
  80dfe7:	53                   	push   %ebx
  80dfe8:	e8 38 68 ff ff       	call   804825 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  80dfed:	83 c4 10             	add    $0x10,%esp
  80dff0:	e9 33 02 00 00       	jmp    80e228 <icmp_input+0x30a>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80dff5:	83 ec 08             	sub    $0x8,%esp
  80dff8:	6a 22                	push   $0x22
  80dffa:	53                   	push   %ebx
  80dffb:	e8 53 67 ff ff       	call   804753 <pbuf_header>
  80e000:	83 c4 10             	add    $0x10,%esp
  80e003:	84 c0                	test   %al,%al
  80e005:	0f 84 d7 00 00 00    	je     80e0e2 <icmp_input+0x1c4>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  80e00b:	83 ec 08             	sub    $0x8,%esp
  80e00e:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e012:	50                   	push   %eax
  80e013:	53                   	push   %ebx
  80e014:	e8 3a 67 ff ff       	call   804753 <pbuf_header>
  80e019:	83 c4 10             	add    $0x10,%esp
  80e01c:	84 c0                	test   %al,%al
  80e01e:	74 14                	je     80e034 <icmp_input+0x116>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80e020:	83 ec 04             	sub    $0x4,%esp
  80e023:	68 78 30 81 00       	push   $0x813078
  80e028:	6a 7b                	push   $0x7b
  80e02a:	68 6c 31 81 00       	push   $0x81316c
  80e02f:	e8 1a 04 00 00       	call   80e44e <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80e034:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80e038:	83 ec 04             	sub    $0x4,%esp
  80e03b:	6a 00                	push   $0x0
  80e03d:	50                   	push   %eax
  80e03e:	6a 02                	push   $0x2
  80e040:	e8 a6 68 ff ff       	call   8048eb <pbuf_alloc>
  80e045:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80e048:	83 c4 10             	add    $0x10,%esp
  80e04b:	85 c0                	test   %eax,%eax
  80e04d:	0f 84 c9 01 00 00    	je     80e21c <icmp_input+0x2fe>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e053:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80e057:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e05b:	83 c0 08             	add    $0x8,%eax
  80e05e:	39 c2                	cmp    %eax,%edx
  80e060:	73 17                	jae    80e079 <icmp_input+0x15b>
  80e062:	83 ec 04             	sub    $0x4,%esp
  80e065:	68 ac 30 81 00       	push   $0x8130ac
  80e06a:	68 85 00 00 00       	push   $0x85
  80e06f:	68 6c 31 81 00       	push   $0x81316c
  80e074:	e8 d5 03 00 00       	call   80e44e <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  80e079:	83 ec 08             	sub    $0x8,%esp
  80e07c:	53                   	push   %ebx
  80e07d:	ff 75 e0             	pushl  -0x20(%ebp)
  80e080:	e8 64 6d ff ff       	call   804de9 <pbuf_copy>
  80e085:	83 c4 10             	add    $0x10,%esp
  80e088:	84 c0                	test   %al,%al
  80e08a:	74 17                	je     80e0a3 <icmp_input+0x185>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80e08c:	83 ec 04             	sub    $0x4,%esp
  80e08f:	68 e4 30 81 00       	push   $0x8130e4
  80e094:	68 88 00 00 00       	push   $0x88
  80e099:	68 6c 31 81 00       	push   $0x81316c
  80e09e:	e8 ab 03 00 00       	call   80e44e <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  80e0a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e0a6:	8b 78 04             	mov    0x4(%eax),%edi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  80e0a9:	83 ec 08             	sub    $0x8,%esp
  80e0ac:	56                   	push   %esi
  80e0ad:	50                   	push   %eax
  80e0ae:	e8 a0 66 ff ff       	call   804753 <pbuf_header>
  80e0b3:	83 c4 10             	add    $0x10,%esp
  80e0b6:	84 c0                	test   %al,%al
  80e0b8:	74 17                	je     80e0d1 <icmp_input+0x1b3>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e0ba:	83 ec 04             	sub    $0x4,%esp
  80e0bd:	68 0c 31 81 00       	push   $0x81310c
  80e0c2:	68 8e 00 00 00       	push   $0x8e
  80e0c7:	68 6c 31 81 00       	push   $0x81316c
  80e0cc:	e8 7d 03 00 00       	call   80e44e <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  80e0d1:	83 ec 0c             	sub    $0xc,%esp
  80e0d4:	53                   	push   %ebx
  80e0d5:	e8 4b 67 ff ff       	call   804825 <pbuf_free>
  80e0da:	83 c4 10             	add    $0x10,%esp
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  80e0dd:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e0e0:	eb 29                	jmp    80e10b <icmp_input+0x1ed>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e0e2:	83 ec 08             	sub    $0x8,%esp
  80e0e5:	6a de                	push   $0xffffffde
  80e0e7:	53                   	push   %ebx
  80e0e8:	e8 66 66 ff ff       	call   804753 <pbuf_header>
  80e0ed:	83 c4 10             	add    $0x10,%esp
  80e0f0:	84 c0                	test   %al,%al
  80e0f2:	74 17                	je     80e10b <icmp_input+0x1ed>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e0f4:	83 ec 04             	sub    $0x4,%esp
  80e0f7:	68 0c 31 81 00       	push   $0x81310c
  80e0fc:	68 98 00 00 00       	push   $0x98
  80e101:	68 6c 31 81 00       	push   $0x81316c
  80e106:	e8 43 03 00 00       	call   80e44e <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  80e10b:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e10e:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e111:	8b 57 10             	mov    0x10(%edi),%edx
  80e114:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e117:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e11a:	83 ec 0c             	sub    $0xc,%esp
  80e11d:	0f b7 06             	movzwl (%esi),%eax
  80e120:	50                   	push   %eax
  80e121:	e8 bd 95 ff ff       	call   8076e3 <ntohs>
  80e126:	0f b6 c0             	movzbl %al,%eax
  80e129:	89 04 24             	mov    %eax,(%esp)
  80e12c:	e8 a5 95 ff ff       	call   8076d6 <htons>
  80e131:	66 89 06             	mov    %ax,(%esi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e134:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e138:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e13c:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e143:	e8 8e 95 ff ff       	call   8076d6 <htons>
  80e148:	83 c4 10             	add    $0x10,%esp
  80e14b:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e14f:	72 1c                	jb     80e16d <icmp_input+0x24f>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e151:	83 ec 0c             	sub    $0xc,%esp
  80e154:	68 00 08 00 00       	push   $0x800
  80e159:	e8 78 95 ff ff       	call   8076d6 <htons>
  80e15e:	0f b7 c0             	movzwl %ax,%eax
  80e161:	83 c0 01             	add    $0x1,%eax
  80e164:	66 01 46 02          	add    %ax,0x2(%esi)
  80e168:	83 c4 10             	add    $0x10,%esp
  80e16b:	eb 14                	jmp    80e181 <icmp_input+0x263>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e16d:	83 ec 0c             	sub    $0xc,%esp
  80e170:	68 00 08 00 00       	push   $0x800
  80e175:	e8 5c 95 ff ff       	call   8076d6 <htons>
  80e17a:	66 01 46 02          	add    %ax,0x2(%esi)
  80e17e:	83 c4 10             	add    $0x10,%esp
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e181:	83 ec 0c             	sub    $0xc,%esp
  80e184:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e188:	50                   	push   %eax
  80e189:	e8 55 95 ff ff       	call   8076e3 <ntohs>
  80e18e:	66 0d 00 ff          	or     $0xff00,%ax
  80e192:	0f b7 c0             	movzwl %ax,%eax
  80e195:	89 04 24             	mov    %eax,(%esp)
  80e198:	e8 39 95 ff ff       	call   8076d6 <htons>
  80e19d:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e1a1:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e1a7:	83 c4 08             	add    $0x8,%esp
  80e1aa:	6a 14                	push   $0x14
  80e1ac:	57                   	push   %edi
  80e1ad:	e8 ff 93 ff ff       	call   8075b1 <inet_chksum>
  80e1b2:	66 89 47 0a          	mov    %ax,0xa(%edi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  80e1b6:	83 c4 08             	add    $0x8,%esp
  80e1b9:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e1bd:	50                   	push   %eax
  80e1be:	53                   	push   %ebx
  80e1bf:	e8 8f 65 ff ff       	call   804753 <pbuf_header>
  80e1c4:	83 c4 10             	add    $0x10,%esp
  80e1c7:	84 c0                	test   %al,%al
  80e1c9:	74 17                	je     80e1e2 <icmp_input+0x2c4>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e1cb:	83 ec 04             	sub    $0x4,%esp
  80e1ce:	68 d4 21 81 00       	push   $0x8121d4
  80e1d3:	68 b9 00 00 00       	push   $0xb9
  80e1d8:	68 6c 31 81 00       	push   $0x81316c
  80e1dd:	e8 6c 02 00 00       	call   80e44e <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e1e2:	83 ec 04             	sub    $0x4,%esp
  80e1e5:	ff 75 0c             	pushl  0xc(%ebp)
  80e1e8:	6a 01                	push   $0x1
  80e1ea:	6a 00                	push   $0x0
  80e1ec:	68 ff 00 00 00       	push   $0xff
  80e1f1:	6a 00                	push   $0x0
  80e1f3:	83 c7 0c             	add    $0xc,%edi
  80e1f6:	57                   	push   %edi
  80e1f7:	53                   	push   %ebx
  80e1f8:	e8 7f 86 ff ff       	call   80687c <ip_output_if>
  80e1fd:	83 c4 20             	add    $0x20,%esp
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80e200:	83 ec 0c             	sub    $0xc,%esp
  80e203:	53                   	push   %ebx
  80e204:	e8 1c 66 ff ff       	call   804825 <pbuf_free>
  return;
  80e209:	83 c4 10             	add    $0x10,%esp
  80e20c:	eb 1a                	jmp    80e228 <icmp_input+0x30a>
lenerr:
  pbuf_free(p);
  80e20e:	83 ec 0c             	sub    $0xc,%esp
  80e211:	53                   	push   %ebx
  80e212:	e8 0e 66 ff ff       	call   804825 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e217:	83 c4 10             	add    $0x10,%esp
  80e21a:	eb 0c                	jmp    80e228 <icmp_input+0x30a>
memerr:
  pbuf_free(p);
  80e21c:	83 ec 0c             	sub    $0xc,%esp
  80e21f:	53                   	push   %ebx
  80e220:	e8 00 66 ff ff       	call   804825 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
  80e225:	83 c4 10             	add    $0x10,%esp
}
  80e228:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e22b:	5b                   	pop    %ebx
  80e22c:	5e                   	pop    %esi
  80e22d:	5f                   	pop    %edi
  80e22e:	5d                   	pop    %ebp
  80e22f:	c3                   	ret    

0080e230 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e230:	55                   	push   %ebp
  80e231:	89 e5                	mov    %esp,%ebp
  80e233:	57                   	push   %edi
  80e234:	56                   	push   %esi
  80e235:	53                   	push   %ebx
  80e236:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e239:	6a 00                	push   $0x0
  80e23b:	6a 24                	push   $0x24
  80e23d:	6a 01                	push   $0x1
  80e23f:	e8 a7 66 ff ff       	call   8048eb <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e244:	83 c4 10             	add    $0x10,%esp
  80e247:	85 c0                	test   %eax,%eax
  80e249:	0f 84 b8 00 00 00    	je     80e307 <icmp_dest_unreach+0xd7>
  80e24f:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e251:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e256:	77 17                	ja     80e26f <icmp_dest_unreach+0x3f>
  80e258:	83 ec 04             	sub    $0x4,%esp
  80e25b:	68 40 31 81 00       	push   $0x813140
  80e260:	68 ef 00 00 00       	push   $0xef
  80e265:	68 6c 31 81 00       	push   $0x81316c
  80e26a:	e8 df 01 00 00       	call   80e44e <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e26f:	8b 45 08             	mov    0x8(%ebp),%eax
  80e272:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e275:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e278:	83 ec 0c             	sub    $0xc,%esp
  80e27b:	0f b7 06             	movzwl (%esi),%eax
  80e27e:	50                   	push   %eax
  80e27f:	e8 5f 94 ff ff       	call   8076e3 <ntohs>
  80e284:	0f b6 c0             	movzbl %al,%eax
  80e287:	80 cc 03             	or     $0x3,%ah
  80e28a:	89 04 24             	mov    %eax,(%esp)
  80e28d:	e8 44 94 ff ff       	call   8076d6 <htons>
  80e292:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e295:	0f b7 c0             	movzwl %ax,%eax
  80e298:	89 04 24             	mov    %eax,(%esp)
  80e29b:	e8 43 94 ff ff       	call   8076e3 <ntohs>
  80e2a0:	b0 00                	mov    $0x0,%al
  80e2a2:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e2a6:	0f b7 c0             	movzwl %ax,%eax
  80e2a9:	89 04 24             	mov    %eax,(%esp)
  80e2ac:	e8 25 94 ff ff       	call   8076d6 <htons>
  80e2b1:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e2b4:	83 c4 0c             	add    $0xc,%esp
  80e2b7:	6a 1c                	push   $0x1c
  80e2b9:	8b 45 08             	mov    0x8(%ebp),%eax
  80e2bc:	ff 70 04             	pushl  0x4(%eax)
  80e2bf:	8b 43 04             	mov    0x4(%ebx),%eax
  80e2c2:	83 c0 08             	add    $0x8,%eax
  80e2c5:	50                   	push   %eax
  80e2c6:	e8 db 09 00 00       	call   80eca6 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e2cb:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e2d1:	83 c4 08             	add    $0x8,%esp
  80e2d4:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e2d8:	50                   	push   %eax
  80e2d9:	56                   	push   %esi
  80e2da:	e8 d2 92 ff ff       	call   8075b1 <inet_chksum>
  80e2df:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e2e3:	83 c4 08             	add    $0x8,%esp
  80e2e6:	6a 01                	push   $0x1
  80e2e8:	6a 00                	push   $0x0
  80e2ea:	68 ff 00 00 00       	push   $0xff
  80e2ef:	83 c7 0c             	add    $0xc,%edi
  80e2f2:	57                   	push   %edi
  80e2f3:	6a 00                	push   $0x0
  80e2f5:	53                   	push   %ebx
  80e2f6:	e8 09 87 ff ff       	call   806a04 <ip_output>
  pbuf_free(q);
  80e2fb:	83 c4 14             	add    $0x14,%esp
  80e2fe:	53                   	push   %ebx
  80e2ff:	e8 21 65 ff ff       	call   804825 <pbuf_free>
  80e304:	83 c4 10             	add    $0x10,%esp
}
  80e307:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e30a:	5b                   	pop    %ebx
  80e30b:	5e                   	pop    %esi
  80e30c:	5f                   	pop    %edi
  80e30d:	5d                   	pop    %ebp
  80e30e:	c3                   	ret    

0080e30f <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e30f:	55                   	push   %ebp
  80e310:	89 e5                	mov    %esp,%ebp
  80e312:	57                   	push   %edi
  80e313:	56                   	push   %esi
  80e314:	53                   	push   %ebx
  80e315:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e318:	6a 00                	push   $0x0
  80e31a:	6a 24                	push   $0x24
  80e31c:	6a 01                	push   $0x1
  80e31e:	e8 c8 65 ff ff       	call   8048eb <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e323:	83 c4 10             	add    $0x10,%esp
  80e326:	85 c0                	test   %eax,%eax
  80e328:	0f 84 b8 00 00 00    	je     80e3e6 <icmp_time_exceeded+0xd7>
  80e32e:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e330:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e335:	77 17                	ja     80e34e <icmp_time_exceeded+0x3f>
  80e337:	83 ec 04             	sub    $0x4,%esp
  80e33a:	68 40 31 81 00       	push   $0x813140
  80e33f:	68 1e 01 00 00       	push   $0x11e
  80e344:	68 6c 31 81 00       	push   $0x81316c
  80e349:	e8 00 01 00 00       	call   80e44e <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e34e:	8b 45 08             	mov    0x8(%ebp),%eax
  80e351:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e354:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e357:	83 ec 0c             	sub    $0xc,%esp
  80e35a:	0f b7 06             	movzwl (%esi),%eax
  80e35d:	50                   	push   %eax
  80e35e:	e8 80 93 ff ff       	call   8076e3 <ntohs>
  80e363:	0f b6 c0             	movzbl %al,%eax
  80e366:	80 cc 0b             	or     $0xb,%ah
  80e369:	89 04 24             	mov    %eax,(%esp)
  80e36c:	e8 65 93 ff ff       	call   8076d6 <htons>
  80e371:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e374:	0f b7 c0             	movzwl %ax,%eax
  80e377:	89 04 24             	mov    %eax,(%esp)
  80e37a:	e8 64 93 ff ff       	call   8076e3 <ntohs>
  80e37f:	b0 00                	mov    $0x0,%al
  80e381:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e385:	0f b7 c0             	movzwl %ax,%eax
  80e388:	89 04 24             	mov    %eax,(%esp)
  80e38b:	e8 46 93 ff ff       	call   8076d6 <htons>
  80e390:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e393:	83 c4 0c             	add    $0xc,%esp
  80e396:	6a 1c                	push   $0x1c
  80e398:	8b 45 08             	mov    0x8(%ebp),%eax
  80e39b:	ff 70 04             	pushl  0x4(%eax)
  80e39e:	8b 43 04             	mov    0x4(%ebx),%eax
  80e3a1:	83 c0 08             	add    $0x8,%eax
  80e3a4:	50                   	push   %eax
  80e3a5:	e8 fc 08 00 00       	call   80eca6 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e3aa:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e3b0:	83 c4 08             	add    $0x8,%esp
  80e3b3:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e3b7:	50                   	push   %eax
  80e3b8:	56                   	push   %esi
  80e3b9:	e8 f3 91 ff ff       	call   8075b1 <inet_chksum>
  80e3be:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e3c2:	83 c4 08             	add    $0x8,%esp
  80e3c5:	6a 01                	push   $0x1
  80e3c7:	6a 00                	push   $0x0
  80e3c9:	68 ff 00 00 00       	push   $0xff
  80e3ce:	83 c7 0c             	add    $0xc,%edi
  80e3d1:	57                   	push   %edi
  80e3d2:	6a 00                	push   $0x0
  80e3d4:	53                   	push   %ebx
  80e3d5:	e8 2a 86 ff ff       	call   806a04 <ip_output>
  pbuf_free(q);
  80e3da:	83 c4 14             	add    $0x14,%esp
  80e3dd:	53                   	push   %ebx
  80e3de:	e8 42 64 ff ff       	call   804825 <pbuf_free>
  80e3e3:	83 c4 10             	add    $0x10,%esp
}
  80e3e6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e3e9:	5b                   	pop    %ebx
  80e3ea:	5e                   	pop    %esi
  80e3eb:	5f                   	pop    %edi
  80e3ec:	5d                   	pop    %ebp
  80e3ed:	c3                   	ret    

0080e3ee <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80e3ee:	55                   	push   %ebp
  80e3ef:	89 e5                	mov    %esp,%ebp
  80e3f1:	56                   	push   %esi
  80e3f2:	53                   	push   %ebx
  80e3f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e3f6:	8b 75 0c             	mov    0xc(%ebp),%esi
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = &envs[ENVX(sys_getenvid())];
  80e3f9:	e8 73 0a 00 00       	call   80ee71 <sys_getenvid>
  80e3fe:	25 ff 03 00 00       	and    $0x3ff,%eax
  80e403:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80e406:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80e40b:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e410:	85 db                	test   %ebx,%ebx
  80e412:	7e 07                	jle    80e41b <libmain+0x2d>
		binaryname = argv[0];
  80e414:	8b 06                	mov    (%esi),%eax
  80e416:	a3 e8 42 81 00       	mov    %eax,0x8142e8

	// call user main routine
	umain(argc, argv);
  80e41b:	83 ec 08             	sub    $0x8,%esp
  80e41e:	56                   	push   %esi
  80e41f:	53                   	push   %ebx
  80e420:	e8 34 21 ff ff       	call   800559 <umain>

	// exit gracefully
	exit();
  80e425:	e8 0a 00 00 00       	call   80e434 <exit>
}
  80e42a:	83 c4 10             	add    $0x10,%esp
  80e42d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e430:	5b                   	pop    %ebx
  80e431:	5e                   	pop    %esi
  80e432:	5d                   	pop    %ebp
  80e433:	c3                   	ret    

0080e434 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e434:	55                   	push   %ebp
  80e435:	89 e5                	mov    %esp,%ebp
  80e437:	83 ec 08             	sub    $0x8,%esp
	close_all();
  80e43a:	e8 53 12 00 00       	call   80f692 <close_all>
	sys_env_destroy(0);
  80e43f:	83 ec 0c             	sub    $0xc,%esp
  80e442:	6a 00                	push   $0x0
  80e444:	e8 e7 09 00 00       	call   80ee30 <sys_env_destroy>
}
  80e449:	83 c4 10             	add    $0x10,%esp
  80e44c:	c9                   	leave  
  80e44d:	c3                   	ret    

0080e44e <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e44e:	55                   	push   %ebp
  80e44f:	89 e5                	mov    %esp,%ebp
  80e451:	56                   	push   %esi
  80e452:	53                   	push   %ebx
	va_list ap;

	va_start(ap, fmt);
  80e453:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e456:	8b 35 e8 42 81 00    	mov    0x8142e8,%esi
  80e45c:	e8 10 0a 00 00       	call   80ee71 <sys_getenvid>
  80e461:	83 ec 0c             	sub    $0xc,%esp
  80e464:	ff 75 0c             	pushl  0xc(%ebp)
  80e467:	ff 75 08             	pushl  0x8(%ebp)
  80e46a:	56                   	push   %esi
  80e46b:	50                   	push   %eax
  80e46c:	68 90 31 81 00       	push   $0x813190
  80e471:	e8 b1 00 00 00       	call   80e527 <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e476:	83 c4 18             	add    $0x18,%esp
  80e479:	53                   	push   %ebx
  80e47a:	ff 75 10             	pushl  0x10(%ebp)
  80e47d:	e8 54 00 00 00       	call   80e4d6 <vcprintf>
	cprintf("\n");
  80e482:	c7 04 24 68 0d 81 00 	movl   $0x810d68,(%esp)
  80e489:	e8 99 00 00 00       	call   80e527 <cprintf>
  80e48e:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e491:	cc                   	int3   
  80e492:	eb fd                	jmp    80e491 <_panic+0x43>

0080e494 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e494:	55                   	push   %ebp
  80e495:	89 e5                	mov    %esp,%ebp
  80e497:	53                   	push   %ebx
  80e498:	83 ec 04             	sub    $0x4,%esp
  80e49b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e49e:	8b 13                	mov    (%ebx),%edx
  80e4a0:	8d 42 01             	lea    0x1(%edx),%eax
  80e4a3:	89 03                	mov    %eax,(%ebx)
  80e4a5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e4a8:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e4ac:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e4b1:	75 1a                	jne    80e4cd <putch+0x39>
		sys_cputs(b->buf, b->idx);
  80e4b3:	83 ec 08             	sub    $0x8,%esp
  80e4b6:	68 ff 00 00 00       	push   $0xff
  80e4bb:	8d 43 08             	lea    0x8(%ebx),%eax
  80e4be:	50                   	push   %eax
  80e4bf:	e8 2f 09 00 00       	call   80edf3 <sys_cputs>
		b->idx = 0;
  80e4c4:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e4ca:	83 c4 10             	add    $0x10,%esp
	}
	b->cnt++;
  80e4cd:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e4d1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e4d4:	c9                   	leave  
  80e4d5:	c3                   	ret    

0080e4d6 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e4d6:	55                   	push   %ebp
  80e4d7:	89 e5                	mov    %esp,%ebp
  80e4d9:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e4df:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e4e6:	00 00 00 
	b.cnt = 0;
  80e4e9:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e4f0:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e4f3:	ff 75 0c             	pushl  0xc(%ebp)
  80e4f6:	ff 75 08             	pushl  0x8(%ebp)
  80e4f9:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80e4ff:	50                   	push   %eax
  80e500:	68 94 e4 80 00       	push   $0x80e494
  80e505:	e8 54 01 00 00       	call   80e65e <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80e50a:	83 c4 08             	add    $0x8,%esp
  80e50d:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
  80e513:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80e519:	50                   	push   %eax
  80e51a:	e8 d4 08 00 00       	call   80edf3 <sys_cputs>

	return b.cnt;
}
  80e51f:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80e525:	c9                   	leave  
  80e526:	c3                   	ret    

0080e527 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80e527:	55                   	push   %ebp
  80e528:	89 e5                	mov    %esp,%ebp
  80e52a:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80e52d:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80e530:	50                   	push   %eax
  80e531:	ff 75 08             	pushl  0x8(%ebp)
  80e534:	e8 9d ff ff ff       	call   80e4d6 <vcprintf>
	va_end(ap);

	return cnt;
}
  80e539:	c9                   	leave  
  80e53a:	c3                   	ret    

0080e53b <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80e53b:	55                   	push   %ebp
  80e53c:	89 e5                	mov    %esp,%ebp
  80e53e:	57                   	push   %edi
  80e53f:	56                   	push   %esi
  80e540:	53                   	push   %ebx
  80e541:	83 ec 1c             	sub    $0x1c,%esp
  80e544:	89 c7                	mov    %eax,%edi
  80e546:	89 d6                	mov    %edx,%esi
  80e548:	8b 45 08             	mov    0x8(%ebp),%eax
  80e54b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e54e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e551:	89 55 dc             	mov    %edx,-0x24(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80e554:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80e557:	bb 00 00 00 00       	mov    $0x0,%ebx
  80e55c:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80e55f:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80e562:	39 d3                	cmp    %edx,%ebx
  80e564:	72 05                	jb     80e56b <printnum+0x30>
  80e566:	39 45 10             	cmp    %eax,0x10(%ebp)
  80e569:	77 45                	ja     80e5b0 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80e56b:	83 ec 0c             	sub    $0xc,%esp
  80e56e:	ff 75 18             	pushl  0x18(%ebp)
  80e571:	8b 45 14             	mov    0x14(%ebp),%eax
  80e574:	8d 58 ff             	lea    -0x1(%eax),%ebx
  80e577:	53                   	push   %ebx
  80e578:	ff 75 10             	pushl  0x10(%ebp)
  80e57b:	83 ec 08             	sub    $0x8,%esp
  80e57e:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e581:	ff 75 e0             	pushl  -0x20(%ebp)
  80e584:	ff 75 dc             	pushl  -0x24(%ebp)
  80e587:	ff 75 d8             	pushl  -0x28(%ebp)
  80e58a:	e8 b1 23 00 00       	call   810940 <__udivdi3>
  80e58f:	83 c4 18             	add    $0x18,%esp
  80e592:	52                   	push   %edx
  80e593:	50                   	push   %eax
  80e594:	89 f2                	mov    %esi,%edx
  80e596:	89 f8                	mov    %edi,%eax
  80e598:	e8 9e ff ff ff       	call   80e53b <printnum>
  80e59d:	83 c4 20             	add    $0x20,%esp
  80e5a0:	eb 18                	jmp    80e5ba <printnum+0x7f>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80e5a2:	83 ec 08             	sub    $0x8,%esp
  80e5a5:	56                   	push   %esi
  80e5a6:	ff 75 18             	pushl  0x18(%ebp)
  80e5a9:	ff d7                	call   *%edi
  80e5ab:	83 c4 10             	add    $0x10,%esp
  80e5ae:	eb 03                	jmp    80e5b3 <printnum+0x78>
  80e5b0:	8b 5d 14             	mov    0x14(%ebp),%ebx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80e5b3:	83 eb 01             	sub    $0x1,%ebx
  80e5b6:	85 db                	test   %ebx,%ebx
  80e5b8:	7f e8                	jg     80e5a2 <printnum+0x67>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80e5ba:	83 ec 08             	sub    $0x8,%esp
  80e5bd:	56                   	push   %esi
  80e5be:	83 ec 04             	sub    $0x4,%esp
  80e5c1:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e5c4:	ff 75 e0             	pushl  -0x20(%ebp)
  80e5c7:	ff 75 dc             	pushl  -0x24(%ebp)
  80e5ca:	ff 75 d8             	pushl  -0x28(%ebp)
  80e5cd:	e8 9e 24 00 00       	call   810a70 <__umoddi3>
  80e5d2:	83 c4 14             	add    $0x14,%esp
  80e5d5:	0f be 80 b3 31 81 00 	movsbl 0x8131b3(%eax),%eax
  80e5dc:	50                   	push   %eax
  80e5dd:	ff d7                	call   *%edi
}
  80e5df:	83 c4 10             	add    $0x10,%esp
  80e5e2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e5e5:	5b                   	pop    %ebx
  80e5e6:	5e                   	pop    %esi
  80e5e7:	5f                   	pop    %edi
  80e5e8:	5d                   	pop    %ebp
  80e5e9:	c3                   	ret    

0080e5ea <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  80e5ea:	55                   	push   %ebp
  80e5eb:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  80e5ed:	83 fa 01             	cmp    $0x1,%edx
  80e5f0:	7e 0e                	jle    80e600 <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  80e5f2:	8b 10                	mov    (%eax),%edx
  80e5f4:	8d 4a 08             	lea    0x8(%edx),%ecx
  80e5f7:	89 08                	mov    %ecx,(%eax)
  80e5f9:	8b 02                	mov    (%edx),%eax
  80e5fb:	8b 52 04             	mov    0x4(%edx),%edx
  80e5fe:	eb 22                	jmp    80e622 <getuint+0x38>
	else if (lflag)
  80e600:	85 d2                	test   %edx,%edx
  80e602:	74 10                	je     80e614 <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  80e604:	8b 10                	mov    (%eax),%edx
  80e606:	8d 4a 04             	lea    0x4(%edx),%ecx
  80e609:	89 08                	mov    %ecx,(%eax)
  80e60b:	8b 02                	mov    (%edx),%eax
  80e60d:	ba 00 00 00 00       	mov    $0x0,%edx
  80e612:	eb 0e                	jmp    80e622 <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  80e614:	8b 10                	mov    (%eax),%edx
  80e616:	8d 4a 04             	lea    0x4(%edx),%ecx
  80e619:	89 08                	mov    %ecx,(%eax)
  80e61b:	8b 02                	mov    (%edx),%eax
  80e61d:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80e622:	5d                   	pop    %ebp
  80e623:	c3                   	ret    

0080e624 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80e624:	55                   	push   %ebp
  80e625:	89 e5                	mov    %esp,%ebp
  80e627:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80e62a:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80e62e:	8b 10                	mov    (%eax),%edx
  80e630:	3b 50 04             	cmp    0x4(%eax),%edx
  80e633:	73 0a                	jae    80e63f <sprintputch+0x1b>
		*b->buf++ = ch;
  80e635:	8d 4a 01             	lea    0x1(%edx),%ecx
  80e638:	89 08                	mov    %ecx,(%eax)
  80e63a:	8b 45 08             	mov    0x8(%ebp),%eax
  80e63d:	88 02                	mov    %al,(%edx)
}
  80e63f:	5d                   	pop    %ebp
  80e640:	c3                   	ret    

0080e641 <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  80e641:	55                   	push   %ebp
  80e642:	89 e5                	mov    %esp,%ebp
  80e644:	83 ec 08             	sub    $0x8,%esp
	va_list ap;

	va_start(ap, fmt);
  80e647:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80e64a:	50                   	push   %eax
  80e64b:	ff 75 10             	pushl  0x10(%ebp)
  80e64e:	ff 75 0c             	pushl  0xc(%ebp)
  80e651:	ff 75 08             	pushl  0x8(%ebp)
  80e654:	e8 05 00 00 00       	call   80e65e <vprintfmt>
	va_end(ap);
}
  80e659:	83 c4 10             	add    $0x10,%esp
  80e65c:	c9                   	leave  
  80e65d:	c3                   	ret    

0080e65e <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80e65e:	55                   	push   %ebp
  80e65f:	89 e5                	mov    %esp,%ebp
  80e661:	57                   	push   %edi
  80e662:	56                   	push   %esi
  80e663:	53                   	push   %ebx
  80e664:	83 ec 2c             	sub    $0x2c,%esp
  80e667:	8b 75 08             	mov    0x8(%ebp),%esi
  80e66a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e66d:	8b 7d 10             	mov    0x10(%ebp),%edi
  80e670:	eb 12                	jmp    80e684 <vprintfmt+0x26>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  80e672:	85 c0                	test   %eax,%eax
  80e674:	0f 84 89 03 00 00    	je     80ea03 <vprintfmt+0x3a5>
				return;
			putch(ch, putdat);
  80e67a:	83 ec 08             	sub    $0x8,%esp
  80e67d:	53                   	push   %ebx
  80e67e:	50                   	push   %eax
  80e67f:	ff d6                	call   *%esi
  80e681:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80e684:	83 c7 01             	add    $0x1,%edi
  80e687:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e68b:	83 f8 25             	cmp    $0x25,%eax
  80e68e:	75 e2                	jne    80e672 <vprintfmt+0x14>
  80e690:	c6 45 d4 20          	movb   $0x20,-0x2c(%ebp)
  80e694:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80e69b:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  80e6a2:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
  80e6a9:	ba 00 00 00 00       	mov    $0x0,%edx
  80e6ae:	eb 07                	jmp    80e6b7 <vprintfmt+0x59>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e6b0:	8b 7d e4             	mov    -0x1c(%ebp),%edi

		// flag to pad on the right
		case '-':
			padc = '-';
  80e6b3:	c6 45 d4 2d          	movb   $0x2d,-0x2c(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e6b7:	8d 47 01             	lea    0x1(%edi),%eax
  80e6ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80e6bd:	0f b6 07             	movzbl (%edi),%eax
  80e6c0:	0f b6 c8             	movzbl %al,%ecx
  80e6c3:	83 e8 23             	sub    $0x23,%eax
  80e6c6:	3c 55                	cmp    $0x55,%al
  80e6c8:	0f 87 1a 03 00 00    	ja     80e9e8 <vprintfmt+0x38a>
  80e6ce:	0f b6 c0             	movzbl %al,%eax
  80e6d1:	ff 24 85 00 33 81 00 	jmp    *0x813300(,%eax,4)
  80e6d8:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
			goto reswitch;

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  80e6db:	c6 45 d4 30          	movb   $0x30,-0x2c(%ebp)
  80e6df:	eb d6                	jmp    80e6b7 <vprintfmt+0x59>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e6e1:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e6e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80e6e9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  80e6ec:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80e6ef:	8d 44 41 d0          	lea    -0x30(%ecx,%eax,2),%eax
				ch = *fmt;
  80e6f3:	0f be 0f             	movsbl (%edi),%ecx
				if (ch < '0' || ch > '9')
  80e6f6:	8d 51 d0             	lea    -0x30(%ecx),%edx
  80e6f9:	83 fa 09             	cmp    $0x9,%edx
  80e6fc:	77 39                	ja     80e737 <vprintfmt+0xd9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80e6fe:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80e701:	eb e9                	jmp    80e6ec <vprintfmt+0x8e>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  80e703:	8b 45 14             	mov    0x14(%ebp),%eax
  80e706:	8d 48 04             	lea    0x4(%eax),%ecx
  80e709:	89 4d 14             	mov    %ecx,0x14(%ebp)
  80e70c:	8b 00                	mov    (%eax),%eax
  80e70e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e711:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
			goto process_precision;
  80e714:	eb 27                	jmp    80e73d <vprintfmt+0xdf>
  80e716:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e719:	85 c0                	test   %eax,%eax
  80e71b:	b9 00 00 00 00       	mov    $0x0,%ecx
  80e720:	0f 49 c8             	cmovns %eax,%ecx
  80e723:	89 4d e0             	mov    %ecx,-0x20(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e726:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e729:	eb 8c                	jmp    80e6b7 <vprintfmt+0x59>
  80e72b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
  80e72e:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
			goto reswitch;
  80e735:	eb 80                	jmp    80e6b7 <vprintfmt+0x59>
  80e737:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80e73a:	89 45 d0             	mov    %eax,-0x30(%ebp)

		process_precision:
			if (width < 0)
  80e73d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e741:	0f 89 70 ff ff ff    	jns    80e6b7 <vprintfmt+0x59>
				width = precision, precision = -1;
  80e747:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80e74a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e74d:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  80e754:	e9 5e ff ff ff       	jmp    80e6b7 <vprintfmt+0x59>
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  80e759:	83 c2 01             	add    $0x1,%edx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e75c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
			goto reswitch;
  80e75f:	e9 53 ff ff ff       	jmp    80e6b7 <vprintfmt+0x59>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  80e764:	8b 45 14             	mov    0x14(%ebp),%eax
  80e767:	8d 50 04             	lea    0x4(%eax),%edx
  80e76a:	89 55 14             	mov    %edx,0x14(%ebp)
  80e76d:	83 ec 08             	sub    $0x8,%esp
  80e770:	53                   	push   %ebx
  80e771:	ff 30                	pushl  (%eax)
  80e773:	ff d6                	call   *%esi
			break;
  80e775:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e778:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
			break;
  80e77b:	e9 04 ff ff ff       	jmp    80e684 <vprintfmt+0x26>

		// error message
		case 'e':
			err = va_arg(ap, int);
  80e780:	8b 45 14             	mov    0x14(%ebp),%eax
  80e783:	8d 50 04             	lea    0x4(%eax),%edx
  80e786:	89 55 14             	mov    %edx,0x14(%ebp)
  80e789:	8b 00                	mov    (%eax),%eax
  80e78b:	99                   	cltd   
  80e78c:	31 d0                	xor    %edx,%eax
  80e78e:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80e790:	83 f8 0f             	cmp    $0xf,%eax
  80e793:	7f 0b                	jg     80e7a0 <vprintfmt+0x142>
  80e795:	8b 14 85 60 34 81 00 	mov    0x813460(,%eax,4),%edx
  80e79c:	85 d2                	test   %edx,%edx
  80e79e:	75 18                	jne    80e7b8 <vprintfmt+0x15a>
				printfmt(putch, putdat, "error %d", err);
  80e7a0:	50                   	push   %eax
  80e7a1:	68 cb 31 81 00       	push   $0x8131cb
  80e7a6:	53                   	push   %ebx
  80e7a7:	56                   	push   %esi
  80e7a8:	e8 94 fe ff ff       	call   80e641 <printfmt>
  80e7ad:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e7b0:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		case 'e':
			err = va_arg(ap, int);
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
  80e7b3:	e9 cc fe ff ff       	jmp    80e684 <vprintfmt+0x26>
			else
				printfmt(putch, putdat, "%s", p);
  80e7b8:	52                   	push   %edx
  80e7b9:	68 99 23 81 00       	push   $0x812399
  80e7be:	53                   	push   %ebx
  80e7bf:	56                   	push   %esi
  80e7c0:	e8 7c fe ff ff       	call   80e641 <printfmt>
  80e7c5:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e7c8:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e7cb:	e9 b4 fe ff ff       	jmp    80e684 <vprintfmt+0x26>
				printfmt(putch, putdat, "%s", p);
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  80e7d0:	8b 45 14             	mov    0x14(%ebp),%eax
  80e7d3:	8d 50 04             	lea    0x4(%eax),%edx
  80e7d6:	89 55 14             	mov    %edx,0x14(%ebp)
  80e7d9:	8b 38                	mov    (%eax),%edi
				p = "(null)";
  80e7db:	85 ff                	test   %edi,%edi
  80e7dd:	b8 c4 31 81 00       	mov    $0x8131c4,%eax
  80e7e2:	0f 44 f8             	cmove  %eax,%edi
			if (width > 0 && padc != '-')
  80e7e5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e7e9:	0f 8e 94 00 00 00    	jle    80e883 <vprintfmt+0x225>
  80e7ef:	80 7d d4 2d          	cmpb   $0x2d,-0x2c(%ebp)
  80e7f3:	0f 84 98 00 00 00    	je     80e891 <vprintfmt+0x233>
				for (width -= strnlen(p, precision); width > 0; width--)
  80e7f9:	83 ec 08             	sub    $0x8,%esp
  80e7fc:	ff 75 d0             	pushl  -0x30(%ebp)
  80e7ff:	57                   	push   %edi
  80e800:	e8 86 02 00 00       	call   80ea8b <strnlen>
  80e805:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80e808:	29 c1                	sub    %eax,%ecx
  80e80a:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  80e80d:	83 c4 10             	add    $0x10,%esp
					putch(padc, putdat);
  80e810:	0f be 45 d4          	movsbl -0x2c(%ebp),%eax
  80e814:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e817:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  80e81a:	89 cf                	mov    %ecx,%edi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80e81c:	eb 0f                	jmp    80e82d <vprintfmt+0x1cf>
					putch(padc, putdat);
  80e81e:	83 ec 08             	sub    $0x8,%esp
  80e821:	53                   	push   %ebx
  80e822:	ff 75 e0             	pushl  -0x20(%ebp)
  80e825:	ff d6                	call   *%esi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80e827:	83 ef 01             	sub    $0x1,%edi
  80e82a:	83 c4 10             	add    $0x10,%esp
  80e82d:	85 ff                	test   %edi,%edi
  80e82f:	7f ed                	jg     80e81e <vprintfmt+0x1c0>
  80e831:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  80e834:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  80e837:	85 c9                	test   %ecx,%ecx
  80e839:	b8 00 00 00 00       	mov    $0x0,%eax
  80e83e:	0f 49 c1             	cmovns %ecx,%eax
  80e841:	29 c1                	sub    %eax,%ecx
  80e843:	89 75 08             	mov    %esi,0x8(%ebp)
  80e846:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e849:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e84c:	89 cb                	mov    %ecx,%ebx
  80e84e:	eb 4d                	jmp    80e89d <vprintfmt+0x23f>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  80e850:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80e854:	74 1b                	je     80e871 <vprintfmt+0x213>
  80e856:	0f be c0             	movsbl %al,%eax
  80e859:	83 e8 20             	sub    $0x20,%eax
  80e85c:	83 f8 5e             	cmp    $0x5e,%eax
  80e85f:	76 10                	jbe    80e871 <vprintfmt+0x213>
					putch('?', putdat);
  80e861:	83 ec 08             	sub    $0x8,%esp
  80e864:	ff 75 0c             	pushl  0xc(%ebp)
  80e867:	6a 3f                	push   $0x3f
  80e869:	ff 55 08             	call   *0x8(%ebp)
  80e86c:	83 c4 10             	add    $0x10,%esp
  80e86f:	eb 0d                	jmp    80e87e <vprintfmt+0x220>
				else
					putch(ch, putdat);
  80e871:	83 ec 08             	sub    $0x8,%esp
  80e874:	ff 75 0c             	pushl  0xc(%ebp)
  80e877:	52                   	push   %edx
  80e878:	ff 55 08             	call   *0x8(%ebp)
  80e87b:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80e87e:	83 eb 01             	sub    $0x1,%ebx
  80e881:	eb 1a                	jmp    80e89d <vprintfmt+0x23f>
  80e883:	89 75 08             	mov    %esi,0x8(%ebp)
  80e886:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e889:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e88c:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e88f:	eb 0c                	jmp    80e89d <vprintfmt+0x23f>
  80e891:	89 75 08             	mov    %esi,0x8(%ebp)
  80e894:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e897:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e89a:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e89d:	83 c7 01             	add    $0x1,%edi
  80e8a0:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e8a4:	0f be d0             	movsbl %al,%edx
  80e8a7:	85 d2                	test   %edx,%edx
  80e8a9:	74 23                	je     80e8ce <vprintfmt+0x270>
  80e8ab:	85 f6                	test   %esi,%esi
  80e8ad:	78 a1                	js     80e850 <vprintfmt+0x1f2>
  80e8af:	83 ee 01             	sub    $0x1,%esi
  80e8b2:	79 9c                	jns    80e850 <vprintfmt+0x1f2>
  80e8b4:	89 df                	mov    %ebx,%edi
  80e8b6:	8b 75 08             	mov    0x8(%ebp),%esi
  80e8b9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e8bc:	eb 18                	jmp    80e8d6 <vprintfmt+0x278>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  80e8be:	83 ec 08             	sub    $0x8,%esp
  80e8c1:	53                   	push   %ebx
  80e8c2:	6a 20                	push   $0x20
  80e8c4:	ff d6                	call   *%esi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  80e8c6:	83 ef 01             	sub    $0x1,%edi
  80e8c9:	83 c4 10             	add    $0x10,%esp
  80e8cc:	eb 08                	jmp    80e8d6 <vprintfmt+0x278>
  80e8ce:	89 df                	mov    %ebx,%edi
  80e8d0:	8b 75 08             	mov    0x8(%ebp),%esi
  80e8d3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e8d6:	85 ff                	test   %edi,%edi
  80e8d8:	7f e4                	jg     80e8be <vprintfmt+0x260>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e8da:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e8dd:	e9 a2 fd ff ff       	jmp    80e684 <vprintfmt+0x26>
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  80e8e2:	83 fa 01             	cmp    $0x1,%edx
  80e8e5:	7e 16                	jle    80e8fd <vprintfmt+0x29f>
		return va_arg(*ap, long long);
  80e8e7:	8b 45 14             	mov    0x14(%ebp),%eax
  80e8ea:	8d 50 08             	lea    0x8(%eax),%edx
  80e8ed:	89 55 14             	mov    %edx,0x14(%ebp)
  80e8f0:	8b 50 04             	mov    0x4(%eax),%edx
  80e8f3:	8b 00                	mov    (%eax),%eax
  80e8f5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e8f8:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80e8fb:	eb 32                	jmp    80e92f <vprintfmt+0x2d1>
	else if (lflag)
  80e8fd:	85 d2                	test   %edx,%edx
  80e8ff:	74 18                	je     80e919 <vprintfmt+0x2bb>
		return va_arg(*ap, long);
  80e901:	8b 45 14             	mov    0x14(%ebp),%eax
  80e904:	8d 50 04             	lea    0x4(%eax),%edx
  80e907:	89 55 14             	mov    %edx,0x14(%ebp)
  80e90a:	8b 00                	mov    (%eax),%eax
  80e90c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e90f:	89 c1                	mov    %eax,%ecx
  80e911:	c1 f9 1f             	sar    $0x1f,%ecx
  80e914:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80e917:	eb 16                	jmp    80e92f <vprintfmt+0x2d1>
	else
		return va_arg(*ap, int);
  80e919:	8b 45 14             	mov    0x14(%ebp),%eax
  80e91c:	8d 50 04             	lea    0x4(%eax),%edx
  80e91f:	89 55 14             	mov    %edx,0x14(%ebp)
  80e922:	8b 00                	mov    (%eax),%eax
  80e924:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e927:	89 c1                	mov    %eax,%ecx
  80e929:	c1 f9 1f             	sar    $0x1f,%ecx
  80e92c:	89 4d dc             	mov    %ecx,-0x24(%ebp)
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  80e92f:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80e932:	8b 55 dc             	mov    -0x24(%ebp),%edx
			if ((long long) num < 0) {
				putch('-', putdat);
				num = -(long long) num;
			}
			base = 10;
  80e935:	b9 0a 00 00 00       	mov    $0xa,%ecx
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
			if ((long long) num < 0) {
  80e93a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80e93e:	79 74                	jns    80e9b4 <vprintfmt+0x356>
				putch('-', putdat);
  80e940:	83 ec 08             	sub    $0x8,%esp
  80e943:	53                   	push   %ebx
  80e944:	6a 2d                	push   $0x2d
  80e946:	ff d6                	call   *%esi
				num = -(long long) num;
  80e948:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80e94b:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e94e:	f7 d8                	neg    %eax
  80e950:	83 d2 00             	adc    $0x0,%edx
  80e953:	f7 da                	neg    %edx
  80e955:	83 c4 10             	add    $0x10,%esp
			}
			base = 10;
  80e958:	b9 0a 00 00 00       	mov    $0xa,%ecx
  80e95d:	eb 55                	jmp    80e9b4 <vprintfmt+0x356>
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  80e95f:	8d 45 14             	lea    0x14(%ebp),%eax
  80e962:	e8 83 fc ff ff       	call   80e5ea <getuint>
			base = 10;
  80e967:	b9 0a 00 00 00       	mov    $0xa,%ecx
			goto number;
  80e96c:	eb 46                	jmp    80e9b4 <vprintfmt+0x356>
		case 'o':
			// Replace this with your code.
			// putch('X', putdat);
			// putch('X', putdat);
			// putch('X', putdat);
			num = getuint(&ap, lflag);
  80e96e:	8d 45 14             	lea    0x14(%ebp),%eax
  80e971:	e8 74 fc ff ff       	call   80e5ea <getuint>
			base = 8;
  80e976:	b9 08 00 00 00       	mov    $0x8,%ecx
			goto number;
  80e97b:	eb 37                	jmp    80e9b4 <vprintfmt+0x356>

		// pointer
		case 'p':
			putch('0', putdat);
  80e97d:	83 ec 08             	sub    $0x8,%esp
  80e980:	53                   	push   %ebx
  80e981:	6a 30                	push   $0x30
  80e983:	ff d6                	call   *%esi
			putch('x', putdat);
  80e985:	83 c4 08             	add    $0x8,%esp
  80e988:	53                   	push   %ebx
  80e989:	6a 78                	push   $0x78
  80e98b:	ff d6                	call   *%esi
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
  80e98d:	8b 45 14             	mov    0x14(%ebp),%eax
  80e990:	8d 50 04             	lea    0x4(%eax),%edx
  80e993:	89 55 14             	mov    %edx,0x14(%ebp)

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  80e996:	8b 00                	mov    (%eax),%eax
  80e998:	ba 00 00 00 00       	mov    $0x0,%edx
				(uintptr_t) va_arg(ap, void *);
			base = 16;
			goto number;
  80e99d:	83 c4 10             	add    $0x10,%esp
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
			base = 16;
  80e9a0:	b9 10 00 00 00       	mov    $0x10,%ecx
			goto number;
  80e9a5:	eb 0d                	jmp    80e9b4 <vprintfmt+0x356>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  80e9a7:	8d 45 14             	lea    0x14(%ebp),%eax
  80e9aa:	e8 3b fc ff ff       	call   80e5ea <getuint>
			base = 16;
  80e9af:	b9 10 00 00 00       	mov    $0x10,%ecx
		number:
			printnum(putch, putdat, num, base, width, padc);
  80e9b4:	83 ec 0c             	sub    $0xc,%esp
  80e9b7:	0f be 7d d4          	movsbl -0x2c(%ebp),%edi
  80e9bb:	57                   	push   %edi
  80e9bc:	ff 75 e0             	pushl  -0x20(%ebp)
  80e9bf:	51                   	push   %ecx
  80e9c0:	52                   	push   %edx
  80e9c1:	50                   	push   %eax
  80e9c2:	89 da                	mov    %ebx,%edx
  80e9c4:	89 f0                	mov    %esi,%eax
  80e9c6:	e8 70 fb ff ff       	call   80e53b <printnum>
			break;
  80e9cb:	83 c4 20             	add    $0x20,%esp
  80e9ce:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e9d1:	e9 ae fc ff ff       	jmp    80e684 <vprintfmt+0x26>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  80e9d6:	83 ec 08             	sub    $0x8,%esp
  80e9d9:	53                   	push   %ebx
  80e9da:	51                   	push   %ecx
  80e9db:	ff d6                	call   *%esi
			break;
  80e9dd:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e9e0:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			break;

		// escaped '%' character
		case '%':
			putch(ch, putdat);
			break;
  80e9e3:	e9 9c fc ff ff       	jmp    80e684 <vprintfmt+0x26>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  80e9e8:	83 ec 08             	sub    $0x8,%esp
  80e9eb:	53                   	push   %ebx
  80e9ec:	6a 25                	push   $0x25
  80e9ee:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80e9f0:	83 c4 10             	add    $0x10,%esp
  80e9f3:	eb 03                	jmp    80e9f8 <vprintfmt+0x39a>
  80e9f5:	83 ef 01             	sub    $0x1,%edi
  80e9f8:	80 7f ff 25          	cmpb   $0x25,-0x1(%edi)
  80e9fc:	75 f7                	jne    80e9f5 <vprintfmt+0x397>
  80e9fe:	e9 81 fc ff ff       	jmp    80e684 <vprintfmt+0x26>
				/* do nothing */;
			break;
		}
	}
}
  80ea03:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ea06:	5b                   	pop    %ebx
  80ea07:	5e                   	pop    %esi
  80ea08:	5f                   	pop    %edi
  80ea09:	5d                   	pop    %ebp
  80ea0a:	c3                   	ret    

0080ea0b <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80ea0b:	55                   	push   %ebp
  80ea0c:	89 e5                	mov    %esp,%ebp
  80ea0e:	83 ec 18             	sub    $0x18,%esp
  80ea11:	8b 45 08             	mov    0x8(%ebp),%eax
  80ea14:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80ea17:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80ea1a:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80ea1e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80ea21:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80ea28:	85 c0                	test   %eax,%eax
  80ea2a:	74 26                	je     80ea52 <vsnprintf+0x47>
  80ea2c:	85 d2                	test   %edx,%edx
  80ea2e:	7e 22                	jle    80ea52 <vsnprintf+0x47>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80ea30:	ff 75 14             	pushl  0x14(%ebp)
  80ea33:	ff 75 10             	pushl  0x10(%ebp)
  80ea36:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80ea39:	50                   	push   %eax
  80ea3a:	68 24 e6 80 00       	push   $0x80e624
  80ea3f:	e8 1a fc ff ff       	call   80e65e <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80ea44:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80ea47:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80ea4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ea4d:	83 c4 10             	add    $0x10,%esp
  80ea50:	eb 05                	jmp    80ea57 <vsnprintf+0x4c>
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
		return -E_INVAL;
  80ea52:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

	// null terminate the buffer
	*b.buf = '\0';

	return b.cnt;
}
  80ea57:	c9                   	leave  
  80ea58:	c3                   	ret    

0080ea59 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80ea59:	55                   	push   %ebp
  80ea5a:	89 e5                	mov    %esp,%ebp
  80ea5c:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80ea5f:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80ea62:	50                   	push   %eax
  80ea63:	ff 75 10             	pushl  0x10(%ebp)
  80ea66:	ff 75 0c             	pushl  0xc(%ebp)
  80ea69:	ff 75 08             	pushl  0x8(%ebp)
  80ea6c:	e8 9a ff ff ff       	call   80ea0b <vsnprintf>
	va_end(ap);

	return rc;
}
  80ea71:	c9                   	leave  
  80ea72:	c3                   	ret    

0080ea73 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80ea73:	55                   	push   %ebp
  80ea74:	89 e5                	mov    %esp,%ebp
  80ea76:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80ea79:	b8 00 00 00 00       	mov    $0x0,%eax
  80ea7e:	eb 03                	jmp    80ea83 <strlen+0x10>
		n++;
  80ea80:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  80ea83:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80ea87:	75 f7                	jne    80ea80 <strlen+0xd>
		n++;
	return n;
}
  80ea89:	5d                   	pop    %ebp
  80ea8a:	c3                   	ret    

0080ea8b <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80ea8b:	55                   	push   %ebp
  80ea8c:	89 e5                	mov    %esp,%ebp
  80ea8e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ea91:	8b 45 0c             	mov    0xc(%ebp),%eax
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80ea94:	ba 00 00 00 00       	mov    $0x0,%edx
  80ea99:	eb 03                	jmp    80ea9e <strnlen+0x13>
		n++;
  80ea9b:	83 c2 01             	add    $0x1,%edx
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80ea9e:	39 c2                	cmp    %eax,%edx
  80eaa0:	74 08                	je     80eaaa <strnlen+0x1f>
  80eaa2:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
  80eaa6:	75 f3                	jne    80ea9b <strnlen+0x10>
  80eaa8:	89 d0                	mov    %edx,%eax
		n++;
	return n;
}
  80eaaa:	5d                   	pop    %ebp
  80eaab:	c3                   	ret    

0080eaac <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80eaac:	55                   	push   %ebp
  80eaad:	89 e5                	mov    %esp,%ebp
  80eaaf:	53                   	push   %ebx
  80eab0:	8b 45 08             	mov    0x8(%ebp),%eax
  80eab3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80eab6:	89 c2                	mov    %eax,%edx
  80eab8:	83 c2 01             	add    $0x1,%edx
  80eabb:	83 c1 01             	add    $0x1,%ecx
  80eabe:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
  80eac2:	88 5a ff             	mov    %bl,-0x1(%edx)
  80eac5:	84 db                	test   %bl,%bl
  80eac7:	75 ef                	jne    80eab8 <strcpy+0xc>
		/* do nothing */;
	return ret;
}
  80eac9:	5b                   	pop    %ebx
  80eaca:	5d                   	pop    %ebp
  80eacb:	c3                   	ret    

0080eacc <strcat>:

char *
strcat(char *dst, const char *src)
{
  80eacc:	55                   	push   %ebp
  80eacd:	89 e5                	mov    %esp,%ebp
  80eacf:	53                   	push   %ebx
  80ead0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80ead3:	53                   	push   %ebx
  80ead4:	e8 9a ff ff ff       	call   80ea73 <strlen>
  80ead9:	83 c4 04             	add    $0x4,%esp
	strcpy(dst + len, src);
  80eadc:	ff 75 0c             	pushl  0xc(%ebp)
  80eadf:	01 d8                	add    %ebx,%eax
  80eae1:	50                   	push   %eax
  80eae2:	e8 c5 ff ff ff       	call   80eaac <strcpy>
	return dst;
}
  80eae7:	89 d8                	mov    %ebx,%eax
  80eae9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80eaec:	c9                   	leave  
  80eaed:	c3                   	ret    

0080eaee <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80eaee:	55                   	push   %ebp
  80eaef:	89 e5                	mov    %esp,%ebp
  80eaf1:	56                   	push   %esi
  80eaf2:	53                   	push   %ebx
  80eaf3:	8b 75 08             	mov    0x8(%ebp),%esi
  80eaf6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80eaf9:	89 f3                	mov    %esi,%ebx
  80eafb:	03 5d 10             	add    0x10(%ebp),%ebx
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80eafe:	89 f2                	mov    %esi,%edx
  80eb00:	eb 0f                	jmp    80eb11 <strncpy+0x23>
		*dst++ = *src;
  80eb02:	83 c2 01             	add    $0x1,%edx
  80eb05:	0f b6 01             	movzbl (%ecx),%eax
  80eb08:	88 42 ff             	mov    %al,-0x1(%edx)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80eb0b:	80 39 01             	cmpb   $0x1,(%ecx)
  80eb0e:	83 d9 ff             	sbb    $0xffffffff,%ecx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80eb11:	39 da                	cmp    %ebx,%edx
  80eb13:	75 ed                	jne    80eb02 <strncpy+0x14>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  80eb15:	89 f0                	mov    %esi,%eax
  80eb17:	5b                   	pop    %ebx
  80eb18:	5e                   	pop    %esi
  80eb19:	5d                   	pop    %ebp
  80eb1a:	c3                   	ret    

0080eb1b <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80eb1b:	55                   	push   %ebp
  80eb1c:	89 e5                	mov    %esp,%ebp
  80eb1e:	56                   	push   %esi
  80eb1f:	53                   	push   %ebx
  80eb20:	8b 75 08             	mov    0x8(%ebp),%esi
  80eb23:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80eb26:	8b 55 10             	mov    0x10(%ebp),%edx
  80eb29:	89 f0                	mov    %esi,%eax
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80eb2b:	85 d2                	test   %edx,%edx
  80eb2d:	74 21                	je     80eb50 <strlcpy+0x35>
  80eb2f:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
  80eb33:	89 f2                	mov    %esi,%edx
  80eb35:	eb 09                	jmp    80eb40 <strlcpy+0x25>
		while (--size > 0 && *src != '\0')
			*dst++ = *src++;
  80eb37:	83 c2 01             	add    $0x1,%edx
  80eb3a:	83 c1 01             	add    $0x1,%ecx
  80eb3d:	88 5a ff             	mov    %bl,-0x1(%edx)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  80eb40:	39 c2                	cmp    %eax,%edx
  80eb42:	74 09                	je     80eb4d <strlcpy+0x32>
  80eb44:	0f b6 19             	movzbl (%ecx),%ebx
  80eb47:	84 db                	test   %bl,%bl
  80eb49:	75 ec                	jne    80eb37 <strlcpy+0x1c>
  80eb4b:	89 d0                	mov    %edx,%eax
			*dst++ = *src++;
		*dst = '\0';
  80eb4d:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80eb50:	29 f0                	sub    %esi,%eax
}
  80eb52:	5b                   	pop    %ebx
  80eb53:	5e                   	pop    %esi
  80eb54:	5d                   	pop    %ebp
  80eb55:	c3                   	ret    

0080eb56 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80eb56:	55                   	push   %ebp
  80eb57:	89 e5                	mov    %esp,%ebp
  80eb59:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80eb5c:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80eb5f:	eb 06                	jmp    80eb67 <strcmp+0x11>
		p++, q++;
  80eb61:	83 c1 01             	add    $0x1,%ecx
  80eb64:	83 c2 01             	add    $0x1,%edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  80eb67:	0f b6 01             	movzbl (%ecx),%eax
  80eb6a:	84 c0                	test   %al,%al
  80eb6c:	74 04                	je     80eb72 <strcmp+0x1c>
  80eb6e:	3a 02                	cmp    (%edx),%al
  80eb70:	74 ef                	je     80eb61 <strcmp+0xb>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80eb72:	0f b6 c0             	movzbl %al,%eax
  80eb75:	0f b6 12             	movzbl (%edx),%edx
  80eb78:	29 d0                	sub    %edx,%eax
}
  80eb7a:	5d                   	pop    %ebp
  80eb7b:	c3                   	ret    

0080eb7c <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80eb7c:	55                   	push   %ebp
  80eb7d:	89 e5                	mov    %esp,%ebp
  80eb7f:	53                   	push   %ebx
  80eb80:	8b 45 08             	mov    0x8(%ebp),%eax
  80eb83:	8b 55 0c             	mov    0xc(%ebp),%edx
  80eb86:	89 c3                	mov    %eax,%ebx
  80eb88:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80eb8b:	eb 06                	jmp    80eb93 <strncmp+0x17>
		n--, p++, q++;
  80eb8d:	83 c0 01             	add    $0x1,%eax
  80eb90:	83 c2 01             	add    $0x1,%edx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80eb93:	39 d8                	cmp    %ebx,%eax
  80eb95:	74 15                	je     80ebac <strncmp+0x30>
  80eb97:	0f b6 08             	movzbl (%eax),%ecx
  80eb9a:	84 c9                	test   %cl,%cl
  80eb9c:	74 04                	je     80eba2 <strncmp+0x26>
  80eb9e:	3a 0a                	cmp    (%edx),%cl
  80eba0:	74 eb                	je     80eb8d <strncmp+0x11>
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80eba2:	0f b6 00             	movzbl (%eax),%eax
  80eba5:	0f b6 12             	movzbl (%edx),%edx
  80eba8:	29 d0                	sub    %edx,%eax
  80ebaa:	eb 05                	jmp    80ebb1 <strncmp+0x35>
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
  80ebac:	b8 00 00 00 00       	mov    $0x0,%eax
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  80ebb1:	5b                   	pop    %ebx
  80ebb2:	5d                   	pop    %ebp
  80ebb3:	c3                   	ret    

0080ebb4 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80ebb4:	55                   	push   %ebp
  80ebb5:	89 e5                	mov    %esp,%ebp
  80ebb7:	8b 45 08             	mov    0x8(%ebp),%eax
  80ebba:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80ebbe:	eb 07                	jmp    80ebc7 <strchr+0x13>
		if (*s == c)
  80ebc0:	38 ca                	cmp    %cl,%dl
  80ebc2:	74 0f                	je     80ebd3 <strchr+0x1f>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80ebc4:	83 c0 01             	add    $0x1,%eax
  80ebc7:	0f b6 10             	movzbl (%eax),%edx
  80ebca:	84 d2                	test   %dl,%dl
  80ebcc:	75 f2                	jne    80ebc0 <strchr+0xc>
		if (*s == c)
			return (char *) s;
	return 0;
  80ebce:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ebd3:	5d                   	pop    %ebp
  80ebd4:	c3                   	ret    

0080ebd5 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80ebd5:	55                   	push   %ebp
  80ebd6:	89 e5                	mov    %esp,%ebp
  80ebd8:	8b 45 08             	mov    0x8(%ebp),%eax
  80ebdb:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80ebdf:	eb 03                	jmp    80ebe4 <strfind+0xf>
  80ebe1:	83 c0 01             	add    $0x1,%eax
  80ebe4:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80ebe7:	38 ca                	cmp    %cl,%dl
  80ebe9:	74 04                	je     80ebef <strfind+0x1a>
  80ebeb:	84 d2                	test   %dl,%dl
  80ebed:	75 f2                	jne    80ebe1 <strfind+0xc>
			break;
	return (char *) s;
}
  80ebef:	5d                   	pop    %ebp
  80ebf0:	c3                   	ret    

0080ebf1 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80ebf1:	55                   	push   %ebp
  80ebf2:	89 e5                	mov    %esp,%ebp
  80ebf4:	57                   	push   %edi
  80ebf5:	56                   	push   %esi
  80ebf6:	53                   	push   %ebx
  80ebf7:	8b 7d 08             	mov    0x8(%ebp),%edi
  80ebfa:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80ebfd:	85 c9                	test   %ecx,%ecx
  80ebff:	74 36                	je     80ec37 <memset+0x46>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80ec01:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80ec07:	75 28                	jne    80ec31 <memset+0x40>
  80ec09:	f6 c1 03             	test   $0x3,%cl
  80ec0c:	75 23                	jne    80ec31 <memset+0x40>
		c &= 0xFF;
  80ec0e:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80ec12:	89 d3                	mov    %edx,%ebx
  80ec14:	c1 e3 08             	shl    $0x8,%ebx
  80ec17:	89 d6                	mov    %edx,%esi
  80ec19:	c1 e6 18             	shl    $0x18,%esi
  80ec1c:	89 d0                	mov    %edx,%eax
  80ec1e:	c1 e0 10             	shl    $0x10,%eax
  80ec21:	09 f0                	or     %esi,%eax
  80ec23:	09 c2                	or     %eax,%edx
		asm volatile("cld; rep stosl\n"
  80ec25:	89 d8                	mov    %ebx,%eax
  80ec27:	09 d0                	or     %edx,%eax
  80ec29:	c1 e9 02             	shr    $0x2,%ecx
  80ec2c:	fc                   	cld    
  80ec2d:	f3 ab                	rep stos %eax,%es:(%edi)
  80ec2f:	eb 06                	jmp    80ec37 <memset+0x46>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80ec31:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ec34:	fc                   	cld    
  80ec35:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80ec37:	89 f8                	mov    %edi,%eax
  80ec39:	5b                   	pop    %ebx
  80ec3a:	5e                   	pop    %esi
  80ec3b:	5f                   	pop    %edi
  80ec3c:	5d                   	pop    %ebp
  80ec3d:	c3                   	ret    

0080ec3e <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80ec3e:	55                   	push   %ebp
  80ec3f:	89 e5                	mov    %esp,%ebp
  80ec41:	57                   	push   %edi
  80ec42:	56                   	push   %esi
  80ec43:	8b 45 08             	mov    0x8(%ebp),%eax
  80ec46:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ec49:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80ec4c:	39 c6                	cmp    %eax,%esi
  80ec4e:	73 35                	jae    80ec85 <memmove+0x47>
  80ec50:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80ec53:	39 d0                	cmp    %edx,%eax
  80ec55:	73 2e                	jae    80ec85 <memmove+0x47>
		s += n;
		d += n;
  80ec57:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80ec5a:	89 d6                	mov    %edx,%esi
  80ec5c:	09 fe                	or     %edi,%esi
  80ec5e:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80ec64:	75 13                	jne    80ec79 <memmove+0x3b>
  80ec66:	f6 c1 03             	test   $0x3,%cl
  80ec69:	75 0e                	jne    80ec79 <memmove+0x3b>
			asm volatile("std; rep movsl\n"
  80ec6b:	83 ef 04             	sub    $0x4,%edi
  80ec6e:	8d 72 fc             	lea    -0x4(%edx),%esi
  80ec71:	c1 e9 02             	shr    $0x2,%ecx
  80ec74:	fd                   	std    
  80ec75:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80ec77:	eb 09                	jmp    80ec82 <memmove+0x44>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80ec79:	83 ef 01             	sub    $0x1,%edi
  80ec7c:	8d 72 ff             	lea    -0x1(%edx),%esi
  80ec7f:	fd                   	std    
  80ec80:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80ec82:	fc                   	cld    
  80ec83:	eb 1d                	jmp    80eca2 <memmove+0x64>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80ec85:	89 f2                	mov    %esi,%edx
  80ec87:	09 c2                	or     %eax,%edx
  80ec89:	f6 c2 03             	test   $0x3,%dl
  80ec8c:	75 0f                	jne    80ec9d <memmove+0x5f>
  80ec8e:	f6 c1 03             	test   $0x3,%cl
  80ec91:	75 0a                	jne    80ec9d <memmove+0x5f>
			asm volatile("cld; rep movsl\n"
  80ec93:	c1 e9 02             	shr    $0x2,%ecx
  80ec96:	89 c7                	mov    %eax,%edi
  80ec98:	fc                   	cld    
  80ec99:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80ec9b:	eb 05                	jmp    80eca2 <memmove+0x64>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80ec9d:	89 c7                	mov    %eax,%edi
  80ec9f:	fc                   	cld    
  80eca0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80eca2:	5e                   	pop    %esi
  80eca3:	5f                   	pop    %edi
  80eca4:	5d                   	pop    %ebp
  80eca5:	c3                   	ret    

0080eca6 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80eca6:	55                   	push   %ebp
  80eca7:	89 e5                	mov    %esp,%ebp
	return memmove(dst, src, n);
  80eca9:	ff 75 10             	pushl  0x10(%ebp)
  80ecac:	ff 75 0c             	pushl  0xc(%ebp)
  80ecaf:	ff 75 08             	pushl  0x8(%ebp)
  80ecb2:	e8 87 ff ff ff       	call   80ec3e <memmove>
}
  80ecb7:	c9                   	leave  
  80ecb8:	c3                   	ret    

0080ecb9 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80ecb9:	55                   	push   %ebp
  80ecba:	89 e5                	mov    %esp,%ebp
  80ecbc:	56                   	push   %esi
  80ecbd:	53                   	push   %ebx
  80ecbe:	8b 45 08             	mov    0x8(%ebp),%eax
  80ecc1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ecc4:	89 c6                	mov    %eax,%esi
  80ecc6:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80ecc9:	eb 1a                	jmp    80ece5 <memcmp+0x2c>
		if (*s1 != *s2)
  80eccb:	0f b6 08             	movzbl (%eax),%ecx
  80ecce:	0f b6 1a             	movzbl (%edx),%ebx
  80ecd1:	38 d9                	cmp    %bl,%cl
  80ecd3:	74 0a                	je     80ecdf <memcmp+0x26>
			return (int) *s1 - (int) *s2;
  80ecd5:	0f b6 c1             	movzbl %cl,%eax
  80ecd8:	0f b6 db             	movzbl %bl,%ebx
  80ecdb:	29 d8                	sub    %ebx,%eax
  80ecdd:	eb 0f                	jmp    80ecee <memcmp+0x35>
		s1++, s2++;
  80ecdf:	83 c0 01             	add    $0x1,%eax
  80ece2:	83 c2 01             	add    $0x1,%edx
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80ece5:	39 f0                	cmp    %esi,%eax
  80ece7:	75 e2                	jne    80eccb <memcmp+0x12>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80ece9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ecee:	5b                   	pop    %ebx
  80ecef:	5e                   	pop    %esi
  80ecf0:	5d                   	pop    %ebp
  80ecf1:	c3                   	ret    

0080ecf2 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80ecf2:	55                   	push   %ebp
  80ecf3:	89 e5                	mov    %esp,%ebp
  80ecf5:	53                   	push   %ebx
  80ecf6:	8b 45 08             	mov    0x8(%ebp),%eax
	const void *ends = (const char *) s + n;
  80ecf9:	89 c1                	mov    %eax,%ecx
  80ecfb:	03 4d 10             	add    0x10(%ebp),%ecx
	for (; s < ends; s++)
		if (*(const unsigned char *) s == (unsigned char) c)
  80ecfe:	0f b6 5d 0c          	movzbl 0xc(%ebp),%ebx

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80ed02:	eb 0a                	jmp    80ed0e <memfind+0x1c>
		if (*(const unsigned char *) s == (unsigned char) c)
  80ed04:	0f b6 10             	movzbl (%eax),%edx
  80ed07:	39 da                	cmp    %ebx,%edx
  80ed09:	74 07                	je     80ed12 <memfind+0x20>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80ed0b:	83 c0 01             	add    $0x1,%eax
  80ed0e:	39 c8                	cmp    %ecx,%eax
  80ed10:	72 f2                	jb     80ed04 <memfind+0x12>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  80ed12:	5b                   	pop    %ebx
  80ed13:	5d                   	pop    %ebp
  80ed14:	c3                   	ret    

0080ed15 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80ed15:	55                   	push   %ebp
  80ed16:	89 e5                	mov    %esp,%ebp
  80ed18:	57                   	push   %edi
  80ed19:	56                   	push   %esi
  80ed1a:	53                   	push   %ebx
  80ed1b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ed1e:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80ed21:	eb 03                	jmp    80ed26 <strtol+0x11>
		s++;
  80ed23:	83 c1 01             	add    $0x1,%ecx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80ed26:	0f b6 01             	movzbl (%ecx),%eax
  80ed29:	3c 20                	cmp    $0x20,%al
  80ed2b:	74 f6                	je     80ed23 <strtol+0xe>
  80ed2d:	3c 09                	cmp    $0x9,%al
  80ed2f:	74 f2                	je     80ed23 <strtol+0xe>
		s++;

	// plus/minus sign
	if (*s == '+')
  80ed31:	3c 2b                	cmp    $0x2b,%al
  80ed33:	75 0a                	jne    80ed3f <strtol+0x2a>
		s++;
  80ed35:	83 c1 01             	add    $0x1,%ecx
}

long
strtol(const char *s, char **endptr, int base)
{
	int neg = 0;
  80ed38:	bf 00 00 00 00       	mov    $0x0,%edi
  80ed3d:	eb 11                	jmp    80ed50 <strtol+0x3b>
  80ed3f:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;

	// plus/minus sign
	if (*s == '+')
		s++;
	else if (*s == '-')
  80ed44:	3c 2d                	cmp    $0x2d,%al
  80ed46:	75 08                	jne    80ed50 <strtol+0x3b>
		s++, neg = 1;
  80ed48:	83 c1 01             	add    $0x1,%ecx
  80ed4b:	bf 01 00 00 00       	mov    $0x1,%edi

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80ed50:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80ed56:	75 15                	jne    80ed6d <strtol+0x58>
  80ed58:	80 39 30             	cmpb   $0x30,(%ecx)
  80ed5b:	75 10                	jne    80ed6d <strtol+0x58>
  80ed5d:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  80ed61:	75 7c                	jne    80eddf <strtol+0xca>
		s += 2, base = 16;
  80ed63:	83 c1 02             	add    $0x2,%ecx
  80ed66:	bb 10 00 00 00       	mov    $0x10,%ebx
  80ed6b:	eb 16                	jmp    80ed83 <strtol+0x6e>
	else if (base == 0 && s[0] == '0')
  80ed6d:	85 db                	test   %ebx,%ebx
  80ed6f:	75 12                	jne    80ed83 <strtol+0x6e>
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80ed71:	bb 0a 00 00 00       	mov    $0xa,%ebx
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80ed76:	80 39 30             	cmpb   $0x30,(%ecx)
  80ed79:	75 08                	jne    80ed83 <strtol+0x6e>
		s++, base = 8;
  80ed7b:	83 c1 01             	add    $0x1,%ecx
  80ed7e:	bb 08 00 00 00       	mov    $0x8,%ebx
	else if (base == 0)
		base = 10;
  80ed83:	b8 00 00 00 00       	mov    $0x0,%eax
  80ed88:	89 5d 10             	mov    %ebx,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  80ed8b:	0f b6 11             	movzbl (%ecx),%edx
  80ed8e:	8d 72 d0             	lea    -0x30(%edx),%esi
  80ed91:	89 f3                	mov    %esi,%ebx
  80ed93:	80 fb 09             	cmp    $0x9,%bl
  80ed96:	77 08                	ja     80eda0 <strtol+0x8b>
			dig = *s - '0';
  80ed98:	0f be d2             	movsbl %dl,%edx
  80ed9b:	83 ea 30             	sub    $0x30,%edx
  80ed9e:	eb 22                	jmp    80edc2 <strtol+0xad>
		else if (*s >= 'a' && *s <= 'z')
  80eda0:	8d 72 9f             	lea    -0x61(%edx),%esi
  80eda3:	89 f3                	mov    %esi,%ebx
  80eda5:	80 fb 19             	cmp    $0x19,%bl
  80eda8:	77 08                	ja     80edb2 <strtol+0x9d>
			dig = *s - 'a' + 10;
  80edaa:	0f be d2             	movsbl %dl,%edx
  80edad:	83 ea 57             	sub    $0x57,%edx
  80edb0:	eb 10                	jmp    80edc2 <strtol+0xad>
		else if (*s >= 'A' && *s <= 'Z')
  80edb2:	8d 72 bf             	lea    -0x41(%edx),%esi
  80edb5:	89 f3                	mov    %esi,%ebx
  80edb7:	80 fb 19             	cmp    $0x19,%bl
  80edba:	77 16                	ja     80edd2 <strtol+0xbd>
			dig = *s - 'A' + 10;
  80edbc:	0f be d2             	movsbl %dl,%edx
  80edbf:	83 ea 37             	sub    $0x37,%edx
		else
			break;
		if (dig >= base)
  80edc2:	3b 55 10             	cmp    0x10(%ebp),%edx
  80edc5:	7d 0b                	jge    80edd2 <strtol+0xbd>
			break;
		s++, val = (val * base) + dig;
  80edc7:	83 c1 01             	add    $0x1,%ecx
  80edca:	0f af 45 10          	imul   0x10(%ebp),%eax
  80edce:	01 d0                	add    %edx,%eax
		// we don't properly detect overflow!
	}
  80edd0:	eb b9                	jmp    80ed8b <strtol+0x76>

	if (endptr)
  80edd2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80edd6:	74 0d                	je     80ede5 <strtol+0xd0>
		*endptr = (char *) s;
  80edd8:	8b 75 0c             	mov    0xc(%ebp),%esi
  80eddb:	89 0e                	mov    %ecx,(%esi)
  80eddd:	eb 06                	jmp    80ede5 <strtol+0xd0>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80eddf:	85 db                	test   %ebx,%ebx
  80ede1:	74 98                	je     80ed7b <strtol+0x66>
  80ede3:	eb 9e                	jmp    80ed83 <strtol+0x6e>
		// we don't properly detect overflow!
	}

	if (endptr)
		*endptr = (char *) s;
	return (neg ? -val : val);
  80ede5:	89 c2                	mov    %eax,%edx
  80ede7:	f7 da                	neg    %edx
  80ede9:	85 ff                	test   %edi,%edi
  80edeb:	0f 45 c2             	cmovne %edx,%eax
}
  80edee:	5b                   	pop    %ebx
  80edef:	5e                   	pop    %esi
  80edf0:	5f                   	pop    %edi
  80edf1:	5d                   	pop    %ebp
  80edf2:	c3                   	ret    

0080edf3 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80edf3:	55                   	push   %ebp
  80edf4:	89 e5                	mov    %esp,%ebp
  80edf6:	57                   	push   %edi
  80edf7:	56                   	push   %esi
  80edf8:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80edf9:	b8 00 00 00 00       	mov    $0x0,%eax
  80edfe:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ee01:	8b 55 08             	mov    0x8(%ebp),%edx
  80ee04:	89 c3                	mov    %eax,%ebx
  80ee06:	89 c7                	mov    %eax,%edi
  80ee08:	89 c6                	mov    %eax,%esi
  80ee0a:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80ee0c:	5b                   	pop    %ebx
  80ee0d:	5e                   	pop    %esi
  80ee0e:	5f                   	pop    %edi
  80ee0f:	5d                   	pop    %ebp
  80ee10:	c3                   	ret    

0080ee11 <sys_cgetc>:

int
sys_cgetc(void)
{
  80ee11:	55                   	push   %ebp
  80ee12:	89 e5                	mov    %esp,%ebp
  80ee14:	57                   	push   %edi
  80ee15:	56                   	push   %esi
  80ee16:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ee17:	ba 00 00 00 00       	mov    $0x0,%edx
  80ee1c:	b8 01 00 00 00       	mov    $0x1,%eax
  80ee21:	89 d1                	mov    %edx,%ecx
  80ee23:	89 d3                	mov    %edx,%ebx
  80ee25:	89 d7                	mov    %edx,%edi
  80ee27:	89 d6                	mov    %edx,%esi
  80ee29:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80ee2b:	5b                   	pop    %ebx
  80ee2c:	5e                   	pop    %esi
  80ee2d:	5f                   	pop    %edi
  80ee2e:	5d                   	pop    %ebp
  80ee2f:	c3                   	ret    

0080ee30 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80ee30:	55                   	push   %ebp
  80ee31:	89 e5                	mov    %esp,%ebp
  80ee33:	57                   	push   %edi
  80ee34:	56                   	push   %esi
  80ee35:	53                   	push   %ebx
  80ee36:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ee39:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ee3e:	b8 03 00 00 00       	mov    $0x3,%eax
  80ee43:	8b 55 08             	mov    0x8(%ebp),%edx
  80ee46:	89 cb                	mov    %ecx,%ebx
  80ee48:	89 cf                	mov    %ecx,%edi
  80ee4a:	89 ce                	mov    %ecx,%esi
  80ee4c:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80ee4e:	85 c0                	test   %eax,%eax
  80ee50:	7e 17                	jle    80ee69 <sys_env_destroy+0x39>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ee52:	83 ec 0c             	sub    $0xc,%esp
  80ee55:	50                   	push   %eax
  80ee56:	6a 03                	push   $0x3
  80ee58:	68 bf 34 81 00       	push   $0x8134bf
  80ee5d:	6a 23                	push   $0x23
  80ee5f:	68 dc 34 81 00       	push   $0x8134dc
  80ee64:	e8 e5 f5 ff ff       	call   80e44e <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80ee69:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ee6c:	5b                   	pop    %ebx
  80ee6d:	5e                   	pop    %esi
  80ee6e:	5f                   	pop    %edi
  80ee6f:	5d                   	pop    %ebp
  80ee70:	c3                   	ret    

0080ee71 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80ee71:	55                   	push   %ebp
  80ee72:	89 e5                	mov    %esp,%ebp
  80ee74:	57                   	push   %edi
  80ee75:	56                   	push   %esi
  80ee76:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ee77:	ba 00 00 00 00       	mov    $0x0,%edx
  80ee7c:	b8 02 00 00 00       	mov    $0x2,%eax
  80ee81:	89 d1                	mov    %edx,%ecx
  80ee83:	89 d3                	mov    %edx,%ebx
  80ee85:	89 d7                	mov    %edx,%edi
  80ee87:	89 d6                	mov    %edx,%esi
  80ee89:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80ee8b:	5b                   	pop    %ebx
  80ee8c:	5e                   	pop    %esi
  80ee8d:	5f                   	pop    %edi
  80ee8e:	5d                   	pop    %ebp
  80ee8f:	c3                   	ret    

0080ee90 <sys_yield>:

void
sys_yield(void)
{
  80ee90:	55                   	push   %ebp
  80ee91:	89 e5                	mov    %esp,%ebp
  80ee93:	57                   	push   %edi
  80ee94:	56                   	push   %esi
  80ee95:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ee96:	ba 00 00 00 00       	mov    $0x0,%edx
  80ee9b:	b8 0b 00 00 00       	mov    $0xb,%eax
  80eea0:	89 d1                	mov    %edx,%ecx
  80eea2:	89 d3                	mov    %edx,%ebx
  80eea4:	89 d7                	mov    %edx,%edi
  80eea6:	89 d6                	mov    %edx,%esi
  80eea8:	cd 30                	int    $0x30

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80eeaa:	5b                   	pop    %ebx
  80eeab:	5e                   	pop    %esi
  80eeac:	5f                   	pop    %edi
  80eead:	5d                   	pop    %ebp
  80eeae:	c3                   	ret    

0080eeaf <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80eeaf:	55                   	push   %ebp
  80eeb0:	89 e5                	mov    %esp,%ebp
  80eeb2:	57                   	push   %edi
  80eeb3:	56                   	push   %esi
  80eeb4:	53                   	push   %ebx
  80eeb5:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80eeb8:	be 00 00 00 00       	mov    $0x0,%esi
  80eebd:	b8 04 00 00 00       	mov    $0x4,%eax
  80eec2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80eec5:	8b 55 08             	mov    0x8(%ebp),%edx
  80eec8:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80eecb:	89 f7                	mov    %esi,%edi
  80eecd:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80eecf:	85 c0                	test   %eax,%eax
  80eed1:	7e 17                	jle    80eeea <sys_page_alloc+0x3b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80eed3:	83 ec 0c             	sub    $0xc,%esp
  80eed6:	50                   	push   %eax
  80eed7:	6a 04                	push   $0x4
  80eed9:	68 bf 34 81 00       	push   $0x8134bf
  80eede:	6a 23                	push   $0x23
  80eee0:	68 dc 34 81 00       	push   $0x8134dc
  80eee5:	e8 64 f5 ff ff       	call   80e44e <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80eeea:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80eeed:	5b                   	pop    %ebx
  80eeee:	5e                   	pop    %esi
  80eeef:	5f                   	pop    %edi
  80eef0:	5d                   	pop    %ebp
  80eef1:	c3                   	ret    

0080eef2 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80eef2:	55                   	push   %ebp
  80eef3:	89 e5                	mov    %esp,%ebp
  80eef5:	57                   	push   %edi
  80eef6:	56                   	push   %esi
  80eef7:	53                   	push   %ebx
  80eef8:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80eefb:	b8 05 00 00 00       	mov    $0x5,%eax
  80ef00:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef03:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef06:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80ef09:	8b 7d 14             	mov    0x14(%ebp),%edi
  80ef0c:	8b 75 18             	mov    0x18(%ebp),%esi
  80ef0f:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80ef11:	85 c0                	test   %eax,%eax
  80ef13:	7e 17                	jle    80ef2c <sys_page_map+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ef15:	83 ec 0c             	sub    $0xc,%esp
  80ef18:	50                   	push   %eax
  80ef19:	6a 05                	push   $0x5
  80ef1b:	68 bf 34 81 00       	push   $0x8134bf
  80ef20:	6a 23                	push   $0x23
  80ef22:	68 dc 34 81 00       	push   $0x8134dc
  80ef27:	e8 22 f5 ff ff       	call   80e44e <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80ef2c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ef2f:	5b                   	pop    %ebx
  80ef30:	5e                   	pop    %esi
  80ef31:	5f                   	pop    %edi
  80ef32:	5d                   	pop    %ebp
  80ef33:	c3                   	ret    

0080ef34 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80ef34:	55                   	push   %ebp
  80ef35:	89 e5                	mov    %esp,%ebp
  80ef37:	57                   	push   %edi
  80ef38:	56                   	push   %esi
  80ef39:	53                   	push   %ebx
  80ef3a:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ef3d:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ef42:	b8 06 00 00 00       	mov    $0x6,%eax
  80ef47:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef4a:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef4d:	89 df                	mov    %ebx,%edi
  80ef4f:	89 de                	mov    %ebx,%esi
  80ef51:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80ef53:	85 c0                	test   %eax,%eax
  80ef55:	7e 17                	jle    80ef6e <sys_page_unmap+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ef57:	83 ec 0c             	sub    $0xc,%esp
  80ef5a:	50                   	push   %eax
  80ef5b:	6a 06                	push   $0x6
  80ef5d:	68 bf 34 81 00       	push   $0x8134bf
  80ef62:	6a 23                	push   $0x23
  80ef64:	68 dc 34 81 00       	push   $0x8134dc
  80ef69:	e8 e0 f4 ff ff       	call   80e44e <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80ef6e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ef71:	5b                   	pop    %ebx
  80ef72:	5e                   	pop    %esi
  80ef73:	5f                   	pop    %edi
  80ef74:	5d                   	pop    %ebp
  80ef75:	c3                   	ret    

0080ef76 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80ef76:	55                   	push   %ebp
  80ef77:	89 e5                	mov    %esp,%ebp
  80ef79:	57                   	push   %edi
  80ef7a:	56                   	push   %esi
  80ef7b:	53                   	push   %ebx
  80ef7c:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ef7f:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ef84:	b8 08 00 00 00       	mov    $0x8,%eax
  80ef89:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef8c:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef8f:	89 df                	mov    %ebx,%edi
  80ef91:	89 de                	mov    %ebx,%esi
  80ef93:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80ef95:	85 c0                	test   %eax,%eax
  80ef97:	7e 17                	jle    80efb0 <sys_env_set_status+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ef99:	83 ec 0c             	sub    $0xc,%esp
  80ef9c:	50                   	push   %eax
  80ef9d:	6a 08                	push   $0x8
  80ef9f:	68 bf 34 81 00       	push   $0x8134bf
  80efa4:	6a 23                	push   $0x23
  80efa6:	68 dc 34 81 00       	push   $0x8134dc
  80efab:	e8 9e f4 ff ff       	call   80e44e <_panic>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80efb0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80efb3:	5b                   	pop    %ebx
  80efb4:	5e                   	pop    %esi
  80efb5:	5f                   	pop    %edi
  80efb6:	5d                   	pop    %ebp
  80efb7:	c3                   	ret    

0080efb8 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80efb8:	55                   	push   %ebp
  80efb9:	89 e5                	mov    %esp,%ebp
  80efbb:	57                   	push   %edi
  80efbc:	56                   	push   %esi
  80efbd:	53                   	push   %ebx
  80efbe:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80efc1:	bb 00 00 00 00       	mov    $0x0,%ebx
  80efc6:	b8 09 00 00 00       	mov    $0x9,%eax
  80efcb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80efce:	8b 55 08             	mov    0x8(%ebp),%edx
  80efd1:	89 df                	mov    %ebx,%edi
  80efd3:	89 de                	mov    %ebx,%esi
  80efd5:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80efd7:	85 c0                	test   %eax,%eax
  80efd9:	7e 17                	jle    80eff2 <sys_env_set_trapframe+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80efdb:	83 ec 0c             	sub    $0xc,%esp
  80efde:	50                   	push   %eax
  80efdf:	6a 09                	push   $0x9
  80efe1:	68 bf 34 81 00       	push   $0x8134bf
  80efe6:	6a 23                	push   $0x23
  80efe8:	68 dc 34 81 00       	push   $0x8134dc
  80efed:	e8 5c f4 ff ff       	call   80e44e <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80eff2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80eff5:	5b                   	pop    %ebx
  80eff6:	5e                   	pop    %esi
  80eff7:	5f                   	pop    %edi
  80eff8:	5d                   	pop    %ebp
  80eff9:	c3                   	ret    

0080effa <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80effa:	55                   	push   %ebp
  80effb:	89 e5                	mov    %esp,%ebp
  80effd:	57                   	push   %edi
  80effe:	56                   	push   %esi
  80efff:	53                   	push   %ebx
  80f000:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f003:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f008:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f00d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f010:	8b 55 08             	mov    0x8(%ebp),%edx
  80f013:	89 df                	mov    %ebx,%edi
  80f015:	89 de                	mov    %ebx,%esi
  80f017:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80f019:	85 c0                	test   %eax,%eax
  80f01b:	7e 17                	jle    80f034 <sys_env_set_pgfault_upcall+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f01d:	83 ec 0c             	sub    $0xc,%esp
  80f020:	50                   	push   %eax
  80f021:	6a 0a                	push   $0xa
  80f023:	68 bf 34 81 00       	push   $0x8134bf
  80f028:	6a 23                	push   $0x23
  80f02a:	68 dc 34 81 00       	push   $0x8134dc
  80f02f:	e8 1a f4 ff ff       	call   80e44e <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80f034:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f037:	5b                   	pop    %ebx
  80f038:	5e                   	pop    %esi
  80f039:	5f                   	pop    %edi
  80f03a:	5d                   	pop    %ebp
  80f03b:	c3                   	ret    

0080f03c <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80f03c:	55                   	push   %ebp
  80f03d:	89 e5                	mov    %esp,%ebp
  80f03f:	57                   	push   %edi
  80f040:	56                   	push   %esi
  80f041:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f042:	be 00 00 00 00       	mov    $0x0,%esi
  80f047:	b8 0c 00 00 00       	mov    $0xc,%eax
  80f04c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f04f:	8b 55 08             	mov    0x8(%ebp),%edx
  80f052:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f055:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f058:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80f05a:	5b                   	pop    %ebx
  80f05b:	5e                   	pop    %esi
  80f05c:	5f                   	pop    %edi
  80f05d:	5d                   	pop    %ebp
  80f05e:	c3                   	ret    

0080f05f <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80f05f:	55                   	push   %ebp
  80f060:	89 e5                	mov    %esp,%ebp
  80f062:	57                   	push   %edi
  80f063:	56                   	push   %esi
  80f064:	53                   	push   %ebx
  80f065:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f068:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f06d:	b8 0d 00 00 00       	mov    $0xd,%eax
  80f072:	8b 55 08             	mov    0x8(%ebp),%edx
  80f075:	89 cb                	mov    %ecx,%ebx
  80f077:	89 cf                	mov    %ecx,%edi
  80f079:	89 ce                	mov    %ecx,%esi
  80f07b:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80f07d:	85 c0                	test   %eax,%eax
  80f07f:	7e 17                	jle    80f098 <sys_ipc_recv+0x39>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f081:	83 ec 0c             	sub    $0xc,%esp
  80f084:	50                   	push   %eax
  80f085:	6a 0d                	push   $0xd
  80f087:	68 bf 34 81 00       	push   $0x8134bf
  80f08c:	6a 23                	push   $0x23
  80f08e:	68 dc 34 81 00       	push   $0x8134dc
  80f093:	e8 b6 f3 ff ff       	call   80e44e <_panic>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80f098:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f09b:	5b                   	pop    %ebx
  80f09c:	5e                   	pop    %esi
  80f09d:	5f                   	pop    %edi
  80f09e:	5d                   	pop    %ebp
  80f09f:	c3                   	ret    

0080f0a0 <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80f0a0:	55                   	push   %ebp
  80f0a1:	89 e5                	mov    %esp,%ebp
  80f0a3:	57                   	push   %edi
  80f0a4:	56                   	push   %esi
  80f0a5:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f0a6:	ba 00 00 00 00       	mov    $0x0,%edx
  80f0ab:	b8 0e 00 00 00       	mov    $0xe,%eax
  80f0b0:	89 d1                	mov    %edx,%ecx
  80f0b2:	89 d3                	mov    %edx,%ebx
  80f0b4:	89 d7                	mov    %edx,%edi
  80f0b6:	89 d6                	mov    %edx,%esi
  80f0b8:	cd 30                	int    $0x30

unsigned int
sys_time_msec(void)
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80f0ba:	5b                   	pop    %ebx
  80f0bb:	5e                   	pop    %esi
  80f0bc:	5f                   	pop    %edi
  80f0bd:	5d                   	pop    %ebp
  80f0be:	c3                   	ret    

0080f0bf <sys_e1000_try_send>:

int
sys_e1000_try_send(void *data, uint32_t len)
{
  80f0bf:	55                   	push   %ebp
  80f0c0:	89 e5                	mov    %esp,%ebp
  80f0c2:	57                   	push   %edi
  80f0c3:	56                   	push   %esi
  80f0c4:	53                   	push   %ebx
  80f0c5:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f0c8:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f0cd:	b8 0f 00 00 00       	mov    $0xf,%eax
  80f0d2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f0d5:	8b 55 08             	mov    0x8(%ebp),%edx
  80f0d8:	89 df                	mov    %ebx,%edi
  80f0da:	89 de                	mov    %ebx,%esi
  80f0dc:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80f0de:	85 c0                	test   %eax,%eax
  80f0e0:	7e 17                	jle    80f0f9 <sys_e1000_try_send+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f0e2:	83 ec 0c             	sub    $0xc,%esp
  80f0e5:	50                   	push   %eax
  80f0e6:	6a 0f                	push   $0xf
  80f0e8:	68 bf 34 81 00       	push   $0x8134bf
  80f0ed:	6a 23                	push   $0x23
  80f0ef:	68 dc 34 81 00       	push   $0x8134dc
  80f0f4:	e8 55 f3 ff ff       	call   80e44e <_panic>

int
sys_e1000_try_send(void *data, uint32_t len)
{
	return syscall(SYS_e1000_try_send, 1, (uint32_t)data, len, 0, 0, 0);
}
  80f0f9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f0fc:	5b                   	pop    %ebx
  80f0fd:	5e                   	pop    %esi
  80f0fe:	5f                   	pop    %edi
  80f0ff:	5d                   	pop    %ebp
  80f100:	c3                   	ret    

0080f101 <sys_e1000_try_recv>:

int
sys_e1000_try_recv(void *buf, uint32_t* len)
{
  80f101:	55                   	push   %ebp
  80f102:	89 e5                	mov    %esp,%ebp
  80f104:	57                   	push   %edi
  80f105:	56                   	push   %esi
  80f106:	53                   	push   %ebx
  80f107:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f10a:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f10f:	b8 10 00 00 00       	mov    $0x10,%eax
  80f114:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f117:	8b 55 08             	mov    0x8(%ebp),%edx
  80f11a:	89 df                	mov    %ebx,%edi
  80f11c:	89 de                	mov    %ebx,%esi
  80f11e:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80f120:	85 c0                	test   %eax,%eax
  80f122:	7e 17                	jle    80f13b <sys_e1000_try_recv+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f124:	83 ec 0c             	sub    $0xc,%esp
  80f127:	50                   	push   %eax
  80f128:	6a 10                	push   $0x10
  80f12a:	68 bf 34 81 00       	push   $0x8134bf
  80f12f:	6a 23                	push   $0x23
  80f131:	68 dc 34 81 00       	push   $0x8134dc
  80f136:	e8 13 f3 ff ff       	call   80e44e <_panic>

int
sys_e1000_try_recv(void *buf, uint32_t* len)
{
	return syscall(SYS_e1000_try_recv, 1, (uint32_t)buf, (uint32_t)len, 0, 0, 0);
}
  80f13b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f13e:	5b                   	pop    %ebx
  80f13f:	5e                   	pop    %esi
  80f140:	5f                   	pop    %edi
  80f141:	5d                   	pop    %ebp
  80f142:	c3                   	ret    

0080f143 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80f143:	55                   	push   %ebp
  80f144:	89 e5                	mov    %esp,%ebp
  80f146:	56                   	push   %esi
  80f147:	53                   	push   %ebx
  80f148:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  80f14b:	8b 18                	mov    (%eax),%ebx
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.

	if ((err & FEC_WR) != FEC_WR && ((uvpt[PGNUM(addr)] & PTE_COW) != PTE_COW)) {
  80f14d:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  80f151:	75 25                	jne    80f178 <pgfault+0x35>
  80f153:	89 d8                	mov    %ebx,%eax
  80f155:	c1 e8 0c             	shr    $0xc,%eax
  80f158:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f15f:	f6 c4 08             	test   $0x8,%ah
  80f162:	75 14                	jne    80f178 <pgfault+0x35>
		panic("pgfault: not due to a write or a COW page");
  80f164:	83 ec 04             	sub    $0x4,%esp
  80f167:	68 ec 34 81 00       	push   $0x8134ec
  80f16c:	6a 1e                	push   $0x1e
  80f16e:	68 80 35 81 00       	push   $0x813580
  80f173:	e8 d6 f2 ff ff       	call   80e44e <_panic>

	// LAB 4: Your code here.

	// panic("pgfault not implemented");

	addr = ROUNDDOWN(addr, PGSIZE);
  80f178:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	envid_t envid = sys_getenvid();
  80f17e:	e8 ee fc ff ff       	call   80ee71 <sys_getenvid>
  80f183:	89 c6                	mov    %eax,%esi

	// envid = 0;

	// Allocate a new page, map it at a temporary location (PFTEMP)
	r = sys_page_alloc(envid, (void *)PFTEMP, PTE_U | PTE_P | PTE_W);
  80f185:	83 ec 04             	sub    $0x4,%esp
  80f188:	6a 07                	push   $0x7
  80f18a:	68 00 f0 7f 00       	push   $0x7ff000
  80f18f:	50                   	push   %eax
  80f190:	e8 1a fd ff ff       	call   80eeaf <sys_page_alloc>
	if (r < 0)
  80f195:	83 c4 10             	add    $0x10,%esp
  80f198:	85 c0                	test   %eax,%eax
  80f19a:	79 12                	jns    80f1ae <pgfault+0x6b>
		panic("pgfault: sys_page_alloc failed: %e\n", r);
  80f19c:	50                   	push   %eax
  80f19d:	68 18 35 81 00       	push   $0x813518
  80f1a2:	6a 33                	push   $0x33
  80f1a4:	68 80 35 81 00       	push   $0x813580
  80f1a9:	e8 a0 f2 ff ff       	call   80e44e <_panic>
	
	// copy the data from the old page to the new page
	memcpy((void *) PFTEMP, (const void *) addr, PGSIZE);
  80f1ae:	83 ec 04             	sub    $0x4,%esp
  80f1b1:	68 00 10 00 00       	push   $0x1000
  80f1b6:	53                   	push   %ebx
  80f1b7:	68 00 f0 7f 00       	push   $0x7ff000
  80f1bc:	e8 e5 fa ff ff       	call   80eca6 <memcpy>

	// move the new page to the old page's address
	r = sys_page_map(envid, (void *) PFTEMP, envid, addr, PTE_U | PTE_P | PTE_W);
  80f1c1:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f1c8:	53                   	push   %ebx
  80f1c9:	56                   	push   %esi
  80f1ca:	68 00 f0 7f 00       	push   $0x7ff000
  80f1cf:	56                   	push   %esi
  80f1d0:	e8 1d fd ff ff       	call   80eef2 <sys_page_map>
	if (r < 0)
  80f1d5:	83 c4 20             	add    $0x20,%esp
  80f1d8:	85 c0                	test   %eax,%eax
  80f1da:	79 12                	jns    80f1ee <pgfault+0xab>
		panic("pgfault: sys_page_map failed: %e\n", r);
  80f1dc:	50                   	push   %eax
  80f1dd:	68 3c 35 81 00       	push   $0x81353c
  80f1e2:	6a 3b                	push   $0x3b
  80f1e4:	68 80 35 81 00       	push   $0x813580
  80f1e9:	e8 60 f2 ff ff       	call   80e44e <_panic>

	// unmap temporary region
	r = sys_page_unmap(envid, (void *) PFTEMP);
  80f1ee:	83 ec 08             	sub    $0x8,%esp
  80f1f1:	68 00 f0 7f 00       	push   $0x7ff000
  80f1f6:	56                   	push   %esi
  80f1f7:	e8 38 fd ff ff       	call   80ef34 <sys_page_unmap>
	if (r < 0)
  80f1fc:	83 c4 10             	add    $0x10,%esp
  80f1ff:	85 c0                	test   %eax,%eax
  80f201:	79 12                	jns    80f215 <pgfault+0xd2>
        panic("pgfault: page unmap failed: %e\n", r);
  80f203:	50                   	push   %eax
  80f204:	68 60 35 81 00       	push   $0x813560
  80f209:	6a 40                	push   $0x40
  80f20b:	68 80 35 81 00       	push   $0x813580
  80f210:	e8 39 f2 ff ff       	call   80e44e <_panic>
}
  80f215:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f218:	5b                   	pop    %ebx
  80f219:	5e                   	pop    %esi
  80f21a:	5d                   	pop    %ebp
  80f21b:	c3                   	ret    

0080f21c <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f21c:	55                   	push   %ebp
  80f21d:	89 e5                	mov    %esp,%ebp
  80f21f:	57                   	push   %edi
  80f220:	56                   	push   %esi
  80f221:	53                   	push   %ebx
  80f222:	83 ec 28             	sub    $0x28,%esp
	// LAB 4: Your code here.
	// cprintf("[fork]\n");
	int r;

	set_pgfault_handler(pgfault);
  80f225:	68 43 f1 80 00       	push   $0x80f143
  80f22a:	e8 6a 16 00 00       	call   810899 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  80f22f:	b8 07 00 00 00       	mov    $0x7,%eax
  80f234:	cd 30                	int    $0x30

	envid_t envid = sys_exofork();
	if (envid < 0)
  80f236:	83 c4 10             	add    $0x10,%esp
  80f239:	85 c0                	test   %eax,%eax
  80f23b:	0f 88 64 01 00 00    	js     80f3a5 <fork+0x189>
  80f241:	bb 00 00 80 00       	mov    $0x800000,%ebx
  80f246:	be 00 08 00 00       	mov    $0x800,%esi
		return envid;

	// fix "thisenv" in the child process
	if (envid == 0) {
  80f24b:	85 c0                	test   %eax,%eax
  80f24d:	75 21                	jne    80f270 <fork+0x54>
		thisenv = &envs[ENVX(sys_getenvid())];
  80f24f:	e8 1d fc ff ff       	call   80ee71 <sys_getenvid>
  80f254:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f259:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f25c:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f261:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
        return 0;
  80f266:	ba 00 00 00 00       	mov    $0x0,%edx
  80f26b:	e9 3f 01 00 00       	jmp    80f3af <fork+0x193>
  80f270:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80f273:	89 c7                	mov    %eax,%edi
	for (uint32_t pn = PGNUM(UTEXT); pn < PGNUM(USTACKTOP); pn++) {

		addr = pn * PGSIZE;

		// if level-2 page exists
		if ((uvpd[PDX(addr)] & PTE_P) == PTE_P) {
  80f275:	89 d8                	mov    %ebx,%eax
  80f277:	c1 e8 16             	shr    $0x16,%eax
  80f27a:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f281:	a8 01                	test   $0x1,%al
  80f283:	0f 84 bd 00 00 00    	je     80f346 <fork+0x12a>
			
			// if real PTE exists
			if ((uvpt[PGNUM(addr)] & PTE_P) == PTE_P) {
  80f289:	89 d8                	mov    %ebx,%eax
  80f28b:	c1 e8 0c             	shr    $0xc,%eax
  80f28e:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f295:	f6 c2 01             	test   $0x1,%dl
  80f298:	0f 84 a8 00 00 00    	je     80f346 <fork+0x12a>

				// For each writable or copy-on-write page
				// if ((uvpt[PGNUM(addr)] & (PTE_W | PTE_COW)) != 0) {
				if ((uvpt[PGNUM(addr)] & PTE_U) != 0) {
  80f29e:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f2a5:	a8 04                	test   $0x4,%al
  80f2a7:	0f 84 99 00 00 00    	je     80f346 <fork+0x12a>
	// r = envid2env(envid, &env, 1);
	// if (r < 0)
	// 	return r;	// E_BAD_ENV
	// envid_t parent_envid = env->env_parent_id;

	if (uvpt[pn] & PTE_SHARE) {
  80f2ad:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f2b4:	f6 c4 04             	test   $0x4,%ah
  80f2b7:	74 17                	je     80f2d0 <fork+0xb4>
		sys_page_map(0, (void *)va, envid, (void *)va, PTE_SYSCALL);
  80f2b9:	83 ec 0c             	sub    $0xc,%esp
  80f2bc:	68 07 0e 00 00       	push   $0xe07
  80f2c1:	53                   	push   %ebx
  80f2c2:	57                   	push   %edi
  80f2c3:	53                   	push   %ebx
  80f2c4:	6a 00                	push   $0x0
  80f2c6:	e8 27 fc ff ff       	call   80eef2 <sys_page_map>
  80f2cb:	83 c4 20             	add    $0x20,%esp
  80f2ce:	eb 76                	jmp    80f346 <fork+0x12a>
	}
	else if ((uvpt[pn] & PTE_W) == PTE_W || (uvpt[pn] & PTE_COW) == PTE_COW) {
  80f2d0:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f2d7:	a8 02                	test   $0x2,%al
  80f2d9:	75 0c                	jne    80f2e7 <fork+0xcb>
  80f2db:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f2e2:	f6 c4 08             	test   $0x8,%ah
  80f2e5:	74 3f                	je     80f326 <fork+0x10a>

		// map the page copy-on-write into the address space of the child
        r = sys_page_map(0, (void *)va, envid, (void *)va, PTE_P|PTE_U|PTE_COW);
  80f2e7:	83 ec 0c             	sub    $0xc,%esp
  80f2ea:	68 05 08 00 00       	push   $0x805
  80f2ef:	53                   	push   %ebx
  80f2f0:	57                   	push   %edi
  80f2f1:	53                   	push   %ebx
  80f2f2:	6a 00                	push   $0x0
  80f2f4:	e8 f9 fb ff ff       	call   80eef2 <sys_page_map>
		if (r < 0)
  80f2f9:	83 c4 20             	add    $0x20,%esp
  80f2fc:	85 c0                	test   %eax,%eax
  80f2fe:	0f 88 a5 00 00 00    	js     80f3a9 <fork+0x18d>
            return r;

		// remap the page copy-on-write in its own(parent) address space
        r = sys_page_map(0, (void *)va, 0, (void *)va, PTE_P|PTE_U|PTE_COW);
  80f304:	83 ec 0c             	sub    $0xc,%esp
  80f307:	68 05 08 00 00       	push   $0x805
  80f30c:	53                   	push   %ebx
  80f30d:	6a 00                	push   $0x0
  80f30f:	53                   	push   %ebx
  80f310:	6a 00                	push   $0x0
  80f312:	e8 db fb ff ff       	call   80eef2 <sys_page_map>
  80f317:	83 c4 20             	add    $0x20,%esp
  80f31a:	85 c0                	test   %eax,%eax
  80f31c:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f321:	0f 4f c1             	cmovg  %ecx,%eax
  80f324:	eb 1c                	jmp    80f342 <fork+0x126>
		if (r < 0)
            return r;
    }
    else {
        r = sys_page_map(0, (void *)va, envid, (void *)va, PTE_P|PTE_U);
  80f326:	83 ec 0c             	sub    $0xc,%esp
  80f329:	6a 05                	push   $0x5
  80f32b:	53                   	push   %ebx
  80f32c:	57                   	push   %edi
  80f32d:	53                   	push   %ebx
  80f32e:	6a 00                	push   $0x0
  80f330:	e8 bd fb ff ff       	call   80eef2 <sys_page_map>
  80f335:	83 c4 20             	add    $0x20,%esp
  80f338:	85 c0                	test   %eax,%eax
  80f33a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f33f:	0f 4f c1             	cmovg  %ecx,%eax

				// For each writable or copy-on-write page
				// if ((uvpt[PGNUM(addr)] & (PTE_W | PTE_COW)) != 0) {
				if ((uvpt[PGNUM(addr)] & PTE_U) != 0) {
					r = duppage(envid, pn);
					if (r < 0)
  80f342:	85 c0                	test   %eax,%eax
  80f344:	78 67                	js     80f3ad <fork+0x191>
        return 0;
	}

	// For each writable or copy-on-write page in its address space below UTOP, the parent calls duppage
	uint32_t addr;
	for (uint32_t pn = PGNUM(UTEXT); pn < PGNUM(USTACKTOP); pn++) {
  80f346:	83 c6 01             	add    $0x1,%esi
  80f349:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f34f:	81 fe fe eb 0e 00    	cmp    $0xeebfe,%esi
  80f355:	0f 85 1a ff ff ff    	jne    80f275 <fork+0x59>
  80f35b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			}
		}
	}

	// allocate a fresh page in the child for the exception stack
	r = sys_page_alloc(envid, (void *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_P | PTE_W);
  80f35e:	83 ec 04             	sub    $0x4,%esp
  80f361:	6a 07                	push   $0x7
  80f363:	68 00 f0 bf ee       	push   $0xeebff000
  80f368:	57                   	push   %edi
  80f369:	e8 41 fb ff ff       	call   80eeaf <sys_page_alloc>
	if (r < 0)
  80f36e:	83 c4 10             	add    $0x10,%esp
		return r;
  80f371:	89 c2                	mov    %eax,%edx
		}
	}

	// allocate a fresh page in the child for the exception stack
	r = sys_page_alloc(envid, (void *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_P | PTE_W);
	if (r < 0)
  80f373:	85 c0                	test   %eax,%eax
  80f375:	78 38                	js     80f3af <fork+0x193>
		return r;

	// The parent sets the user page fault entrypoint for the child to look like its own
	extern void _pgfault_upcall(void);
	r = sys_env_set_pgfault_upcall(envid, _pgfault_upcall);
  80f377:	83 ec 08             	sub    $0x8,%esp
  80f37a:	68 e0 08 81 00       	push   $0x8108e0
  80f37f:	57                   	push   %edi
  80f380:	e8 75 fc ff ff       	call   80effa <sys_env_set_pgfault_upcall>
	if (r < 0)
  80f385:	83 c4 10             	add    $0x10,%esp
		return r;
  80f388:	89 c2                	mov    %eax,%edx
		return r;

	// The parent sets the user page fault entrypoint for the child to look like its own
	extern void _pgfault_upcall(void);
	r = sys_env_set_pgfault_upcall(envid, _pgfault_upcall);
	if (r < 0)
  80f38a:	85 c0                	test   %eax,%eax
  80f38c:	78 21                	js     80f3af <fork+0x193>
		return r;

	// The child is now ready to run, so the parent marks it runnable
	r = sys_env_set_status(envid, ENV_RUNNABLE);
  80f38e:	83 ec 08             	sub    $0x8,%esp
  80f391:	6a 02                	push   $0x2
  80f393:	57                   	push   %edi
  80f394:	e8 dd fb ff ff       	call   80ef76 <sys_env_set_status>
	if (r < 0)
  80f399:	83 c4 10             	add    $0x10,%esp
		return r;

	return envid;
  80f39c:	85 c0                	test   %eax,%eax
  80f39e:	0f 48 f8             	cmovs  %eax,%edi
  80f3a1:	89 fa                	mov    %edi,%edx
  80f3a3:	eb 0a                	jmp    80f3af <fork+0x193>

	set_pgfault_handler(pgfault);

	envid_t envid = sys_exofork();
	if (envid < 0)
		return envid;
  80f3a5:	89 c2                	mov    %eax,%edx
  80f3a7:	eb 06                	jmp    80f3af <fork+0x193>
		sys_page_map(0, (void *)va, envid, (void *)va, PTE_SYSCALL);
	}
	else if ((uvpt[pn] & PTE_W) == PTE_W || (uvpt[pn] & PTE_COW) == PTE_COW) {

		// map the page copy-on-write into the address space of the child
        r = sys_page_map(0, (void *)va, envid, (void *)va, PTE_P|PTE_U|PTE_COW);
  80f3a9:	89 c2                	mov    %eax,%edx
  80f3ab:	eb 02                	jmp    80f3af <fork+0x193>
  80f3ad:	89 c2                	mov    %eax,%edx
	if (r < 0)
		return r;

	return envid;
	// panic("fork not implemented");
}
  80f3af:	89 d0                	mov    %edx,%eax
  80f3b1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f3b4:	5b                   	pop    %ebx
  80f3b5:	5e                   	pop    %esi
  80f3b6:	5f                   	pop    %edi
  80f3b7:	5d                   	pop    %ebp
  80f3b8:	c3                   	ret    

0080f3b9 <sfork>:

// Challenge!
int
sfork(void)
{
  80f3b9:	55                   	push   %ebp
  80f3ba:	89 e5                	mov    %esp,%ebp
  80f3bc:	83 ec 0c             	sub    $0xc,%esp
	panic("sfork not implemented");
  80f3bf:	68 8b 35 81 00       	push   $0x81358b
  80f3c4:	68 c9 00 00 00       	push   $0xc9
  80f3c9:	68 80 35 81 00       	push   $0x813580
  80f3ce:	e8 7b f0 ff ff       	call   80e44e <_panic>

0080f3d3 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80f3d3:	55                   	push   %ebp
  80f3d4:	89 e5                	mov    %esp,%ebp
  80f3d6:	56                   	push   %esi
  80f3d7:	53                   	push   %ebx
  80f3d8:	8b 75 08             	mov    0x8(%ebp),%esi
  80f3db:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f3de:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	// panic("ipc_recv not implemented");

	// don't want to recv page
	if (pg == NULL)
  80f3e1:	85 c0                	test   %eax,%eax
		pg = (void *)UTOP;
  80f3e3:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
  80f3e8:	0f 44 c2             	cmove  %edx,%eax

	int err = sys_ipc_recv(pg);
  80f3eb:	83 ec 0c             	sub    $0xc,%esp
  80f3ee:	50                   	push   %eax
  80f3ef:	e8 6b fc ff ff       	call   80f05f <sys_ipc_recv>

	if (from_env_store != NULL)
  80f3f4:	83 c4 10             	add    $0x10,%esp
  80f3f7:	85 f6                	test   %esi,%esi
  80f3f9:	74 14                	je     80f40f <ipc_recv+0x3c>
		*from_env_store = err < 0? 0 : thisenv->env_ipc_from;
  80f3fb:	ba 00 00 00 00       	mov    $0x0,%edx
  80f400:	85 c0                	test   %eax,%eax
  80f402:	78 09                	js     80f40d <ipc_recv+0x3a>
  80f404:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  80f40a:	8b 52 74             	mov    0x74(%edx),%edx
  80f40d:	89 16                	mov    %edx,(%esi)
	
	if (perm_store != NULL)
  80f40f:	85 db                	test   %ebx,%ebx
  80f411:	74 14                	je     80f427 <ipc_recv+0x54>
		*perm_store = err < 0? 0 : thisenv->env_ipc_perm;
  80f413:	ba 00 00 00 00       	mov    $0x0,%edx
  80f418:	85 c0                	test   %eax,%eax
  80f41a:	78 09                	js     80f425 <ipc_recv+0x52>
  80f41c:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  80f422:	8b 52 78             	mov    0x78(%edx),%edx
  80f425:	89 13                	mov    %edx,(%ebx)

	if (err < 0)
  80f427:	85 c0                	test   %eax,%eax
  80f429:	78 08                	js     80f433 <ipc_recv+0x60>
		return err;
	return thisenv->env_ipc_value;
  80f42b:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f430:	8b 40 70             	mov    0x70(%eax),%eax
}
  80f433:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f436:	5b                   	pop    %ebx
  80f437:	5e                   	pop    %esi
  80f438:	5d                   	pop    %ebp
  80f439:	c3                   	ret    

0080f43a <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  80f43a:	55                   	push   %ebp
  80f43b:	89 e5                	mov    %esp,%ebp
  80f43d:	57                   	push   %edi
  80f43e:	56                   	push   %esi
  80f43f:	53                   	push   %ebx
  80f440:	83 ec 0c             	sub    $0xc,%esp
  80f443:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f446:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f449:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	// panic("ipc_send not implemented");

	// don't want to send page
	if (pg == NULL)
  80f44c:	85 db                	test   %ebx,%ebx
		pg = (void *)UTOP;
  80f44e:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  80f453:	0f 44 d8             	cmove  %eax,%ebx
	
	int err = 0;
	
	do {

		err = sys_ipc_try_send(to_env, val, pg, perm);
  80f456:	ff 75 14             	pushl  0x14(%ebp)
  80f459:	53                   	push   %ebx
  80f45a:	56                   	push   %esi
  80f45b:	57                   	push   %edi
  80f45c:	e8 db fb ff ff       	call   80f03c <sys_ipc_try_send>

		if (err < 0) {
  80f461:	83 c4 10             	add    $0x10,%esp
  80f464:	85 c0                	test   %eax,%eax
  80f466:	79 1e                	jns    80f486 <ipc_send+0x4c>
			if (err == -E_IPC_NOT_RECV)
  80f468:	83 f8 f9             	cmp    $0xfffffff9,%eax
  80f46b:	75 07                	jne    80f474 <ipc_send+0x3a>
				sys_yield();
  80f46d:	e8 1e fa ff ff       	call   80ee90 <sys_yield>
  80f472:	eb e2                	jmp    80f456 <ipc_send+0x1c>
			else 
				panic("ipc_send: %e", err);
  80f474:	50                   	push   %eax
  80f475:	68 a1 35 81 00       	push   $0x8135a1
  80f47a:	6a 49                	push   $0x49
  80f47c:	68 ae 35 81 00       	push   $0x8135ae
  80f481:	e8 c8 ef ff ff       	call   80e44e <_panic>
		}

	} while (err < 0);

}
  80f486:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f489:	5b                   	pop    %ebx
  80f48a:	5e                   	pop    %esi
  80f48b:	5f                   	pop    %edi
  80f48c:	5d                   	pop    %ebp
  80f48d:	c3                   	ret    

0080f48e <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80f48e:	55                   	push   %ebp
  80f48f:	89 e5                	mov    %esp,%ebp
  80f491:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80f494:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80f499:	6b d0 7c             	imul   $0x7c,%eax,%edx
  80f49c:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80f4a2:	8b 52 50             	mov    0x50(%edx),%edx
  80f4a5:	39 ca                	cmp    %ecx,%edx
  80f4a7:	75 0d                	jne    80f4b6 <ipc_find_env+0x28>
			return envs[i].env_id;
  80f4a9:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f4ac:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f4b1:	8b 40 48             	mov    0x48(%eax),%eax
  80f4b4:	eb 0f                	jmp    80f4c5 <ipc_find_env+0x37>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  80f4b6:	83 c0 01             	add    $0x1,%eax
  80f4b9:	3d 00 04 00 00       	cmp    $0x400,%eax
  80f4be:	75 d9                	jne    80f499 <ipc_find_env+0xb>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
  80f4c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f4c5:	5d                   	pop    %ebp
  80f4c6:	c3                   	ret    

0080f4c7 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80f4c7:	55                   	push   %ebp
  80f4c8:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f4ca:	8b 45 08             	mov    0x8(%ebp),%eax
  80f4cd:	05 00 00 00 30       	add    $0x30000000,%eax
  80f4d2:	c1 e8 0c             	shr    $0xc,%eax
}
  80f4d5:	5d                   	pop    %ebp
  80f4d6:	c3                   	ret    

0080f4d7 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80f4d7:	55                   	push   %ebp
  80f4d8:	89 e5                	mov    %esp,%ebp
	return INDEX2DATA(fd2num(fd));
  80f4da:	8b 45 08             	mov    0x8(%ebp),%eax
  80f4dd:	05 00 00 00 30       	add    $0x30000000,%eax
  80f4e2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f4e7:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80f4ec:	5d                   	pop    %ebp
  80f4ed:	c3                   	ret    

0080f4ee <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80f4ee:	55                   	push   %ebp
  80f4ef:	89 e5                	mov    %esp,%ebp
  80f4f1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f4f4:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80f4f9:	89 c2                	mov    %eax,%edx
  80f4fb:	c1 ea 16             	shr    $0x16,%edx
  80f4fe:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f505:	f6 c2 01             	test   $0x1,%dl
  80f508:	74 11                	je     80f51b <fd_alloc+0x2d>
  80f50a:	89 c2                	mov    %eax,%edx
  80f50c:	c1 ea 0c             	shr    $0xc,%edx
  80f50f:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f516:	f6 c2 01             	test   $0x1,%dl
  80f519:	75 09                	jne    80f524 <fd_alloc+0x36>
			*fd_store = fd;
  80f51b:	89 01                	mov    %eax,(%ecx)
			return 0;
  80f51d:	b8 00 00 00 00       	mov    $0x0,%eax
  80f522:	eb 17                	jmp    80f53b <fd_alloc+0x4d>
  80f524:	05 00 10 00 00       	add    $0x1000,%eax
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  80f529:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80f52e:	75 c9                	jne    80f4f9 <fd_alloc+0xb>
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80f530:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	return -E_MAX_OPEN;
  80f536:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
  80f53b:	5d                   	pop    %ebp
  80f53c:	c3                   	ret    

0080f53d <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80f53d:	55                   	push   %ebp
  80f53e:	89 e5                	mov    %esp,%ebp
  80f540:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80f543:	83 f8 1f             	cmp    $0x1f,%eax
  80f546:	77 36                	ja     80f57e <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80f548:	c1 e0 0c             	shl    $0xc,%eax
  80f54b:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80f550:	89 c2                	mov    %eax,%edx
  80f552:	c1 ea 16             	shr    $0x16,%edx
  80f555:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f55c:	f6 c2 01             	test   $0x1,%dl
  80f55f:	74 24                	je     80f585 <fd_lookup+0x48>
  80f561:	89 c2                	mov    %eax,%edx
  80f563:	c1 ea 0c             	shr    $0xc,%edx
  80f566:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f56d:	f6 c2 01             	test   $0x1,%dl
  80f570:	74 1a                	je     80f58c <fd_lookup+0x4f>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80f572:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f575:	89 02                	mov    %eax,(%edx)
	return 0;
  80f577:	b8 00 00 00 00       	mov    $0x0,%eax
  80f57c:	eb 13                	jmp    80f591 <fd_lookup+0x54>
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  80f57e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f583:	eb 0c                	jmp    80f591 <fd_lookup+0x54>
	}
	fd = INDEX2FD(fdnum);
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  80f585:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f58a:	eb 05                	jmp    80f591 <fd_lookup+0x54>
  80f58c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	}
	*fd_store = fd;
	return 0;
}
  80f591:	5d                   	pop    %ebp
  80f592:	c3                   	ret    

0080f593 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80f593:	55                   	push   %ebp
  80f594:	89 e5                	mov    %esp,%ebp
  80f596:	83 ec 08             	sub    $0x8,%esp
  80f599:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f59c:	ba 34 36 81 00       	mov    $0x813634,%edx
	int i;
	for (i = 0; devtab[i]; i++)
  80f5a1:	eb 13                	jmp    80f5b6 <dev_lookup+0x23>
  80f5a3:	83 c2 04             	add    $0x4,%edx
		if (devtab[i]->dev_id == dev_id) {
  80f5a6:	39 08                	cmp    %ecx,(%eax)
  80f5a8:	75 0c                	jne    80f5b6 <dev_lookup+0x23>
			*dev = devtab[i];
  80f5aa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f5ad:	89 01                	mov    %eax,(%ecx)
			return 0;
  80f5af:	b8 00 00 00 00       	mov    $0x0,%eax
  80f5b4:	eb 2e                	jmp    80f5e4 <dev_lookup+0x51>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  80f5b6:	8b 02                	mov    (%edx),%eax
  80f5b8:	85 c0                	test   %eax,%eax
  80f5ba:	75 e7                	jne    80f5a3 <dev_lookup+0x10>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80f5bc:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f5c1:	8b 40 48             	mov    0x48(%eax),%eax
  80f5c4:	83 ec 04             	sub    $0x4,%esp
  80f5c7:	51                   	push   %ecx
  80f5c8:	50                   	push   %eax
  80f5c9:	68 b8 35 81 00       	push   $0x8135b8
  80f5ce:	e8 54 ef ff ff       	call   80e527 <cprintf>
	*dev = 0;
  80f5d3:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f5d6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  80f5dc:	83 c4 10             	add    $0x10,%esp
  80f5df:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80f5e4:	c9                   	leave  
  80f5e5:	c3                   	ret    

0080f5e6 <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  80f5e6:	55                   	push   %ebp
  80f5e7:	89 e5                	mov    %esp,%ebp
  80f5e9:	56                   	push   %esi
  80f5ea:	53                   	push   %ebx
  80f5eb:	83 ec 10             	sub    $0x10,%esp
  80f5ee:	8b 75 08             	mov    0x8(%ebp),%esi
  80f5f1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80f5f4:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f5f7:	50                   	push   %eax
  80f5f8:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80f5fe:	c1 e8 0c             	shr    $0xc,%eax
  80f601:	50                   	push   %eax
  80f602:	e8 36 ff ff ff       	call   80f53d <fd_lookup>
  80f607:	83 c4 08             	add    $0x8,%esp
  80f60a:	85 c0                	test   %eax,%eax
  80f60c:	78 05                	js     80f613 <fd_close+0x2d>
	    || fd != fd2)
  80f60e:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  80f611:	74 0c                	je     80f61f <fd_close+0x39>
		return (must_exist ? r : 0);
  80f613:	84 db                	test   %bl,%bl
  80f615:	ba 00 00 00 00       	mov    $0x0,%edx
  80f61a:	0f 44 c2             	cmove  %edx,%eax
  80f61d:	eb 41                	jmp    80f660 <fd_close+0x7a>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80f61f:	83 ec 08             	sub    $0x8,%esp
  80f622:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f625:	50                   	push   %eax
  80f626:	ff 36                	pushl  (%esi)
  80f628:	e8 66 ff ff ff       	call   80f593 <dev_lookup>
  80f62d:	89 c3                	mov    %eax,%ebx
  80f62f:	83 c4 10             	add    $0x10,%esp
  80f632:	85 c0                	test   %eax,%eax
  80f634:	78 1a                	js     80f650 <fd_close+0x6a>
		if (dev->dev_close)
  80f636:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f639:	8b 40 10             	mov    0x10(%eax),%eax
			r = (*dev->dev_close)(fd);
		else
			r = 0;
  80f63c:	bb 00 00 00 00       	mov    $0x0,%ebx
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
	    || fd != fd2)
		return (must_exist ? r : 0);
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
		if (dev->dev_close)
  80f641:	85 c0                	test   %eax,%eax
  80f643:	74 0b                	je     80f650 <fd_close+0x6a>
			r = (*dev->dev_close)(fd);
  80f645:	83 ec 0c             	sub    $0xc,%esp
  80f648:	56                   	push   %esi
  80f649:	ff d0                	call   *%eax
  80f64b:	89 c3                	mov    %eax,%ebx
  80f64d:	83 c4 10             	add    $0x10,%esp
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  80f650:	83 ec 08             	sub    $0x8,%esp
  80f653:	56                   	push   %esi
  80f654:	6a 00                	push   $0x0
  80f656:	e8 d9 f8 ff ff       	call   80ef34 <sys_page_unmap>
	return r;
  80f65b:	83 c4 10             	add    $0x10,%esp
  80f65e:	89 d8                	mov    %ebx,%eax
}
  80f660:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f663:	5b                   	pop    %ebx
  80f664:	5e                   	pop    %esi
  80f665:	5d                   	pop    %ebp
  80f666:	c3                   	ret    

0080f667 <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  80f667:	55                   	push   %ebp
  80f668:	89 e5                	mov    %esp,%ebp
  80f66a:	83 ec 18             	sub    $0x18,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80f66d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f670:	50                   	push   %eax
  80f671:	ff 75 08             	pushl  0x8(%ebp)
  80f674:	e8 c4 fe ff ff       	call   80f53d <fd_lookup>
  80f679:	83 c4 08             	add    $0x8,%esp
  80f67c:	85 c0                	test   %eax,%eax
  80f67e:	78 10                	js     80f690 <close+0x29>
		return r;
	else
		return fd_close(fd, 1);
  80f680:	83 ec 08             	sub    $0x8,%esp
  80f683:	6a 01                	push   $0x1
  80f685:	ff 75 f4             	pushl  -0xc(%ebp)
  80f688:	e8 59 ff ff ff       	call   80f5e6 <fd_close>
  80f68d:	83 c4 10             	add    $0x10,%esp
}
  80f690:	c9                   	leave  
  80f691:	c3                   	ret    

0080f692 <close_all>:

void
close_all(void)
{
  80f692:	55                   	push   %ebp
  80f693:	89 e5                	mov    %esp,%ebp
  80f695:	53                   	push   %ebx
  80f696:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80f699:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80f69e:	83 ec 0c             	sub    $0xc,%esp
  80f6a1:	53                   	push   %ebx
  80f6a2:	e8 c0 ff ff ff       	call   80f667 <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  80f6a7:	83 c3 01             	add    $0x1,%ebx
  80f6aa:	83 c4 10             	add    $0x10,%esp
  80f6ad:	83 fb 20             	cmp    $0x20,%ebx
  80f6b0:	75 ec                	jne    80f69e <close_all+0xc>
		close(i);
}
  80f6b2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f6b5:	c9                   	leave  
  80f6b6:	c3                   	ret    

0080f6b7 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80f6b7:	55                   	push   %ebp
  80f6b8:	89 e5                	mov    %esp,%ebp
  80f6ba:	57                   	push   %edi
  80f6bb:	56                   	push   %esi
  80f6bc:	53                   	push   %ebx
  80f6bd:	83 ec 2c             	sub    $0x2c,%esp
  80f6c0:	8b 75 0c             	mov    0xc(%ebp),%esi
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80f6c3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80f6c6:	50                   	push   %eax
  80f6c7:	ff 75 08             	pushl  0x8(%ebp)
  80f6ca:	e8 6e fe ff ff       	call   80f53d <fd_lookup>
  80f6cf:	83 c4 08             	add    $0x8,%esp
  80f6d2:	85 c0                	test   %eax,%eax
  80f6d4:	0f 88 c1 00 00 00    	js     80f79b <dup+0xe4>
		return r;
	close(newfdnum);
  80f6da:	83 ec 0c             	sub    $0xc,%esp
  80f6dd:	56                   	push   %esi
  80f6de:	e8 84 ff ff ff       	call   80f667 <close>

	newfd = INDEX2FD(newfdnum);
  80f6e3:	89 f3                	mov    %esi,%ebx
  80f6e5:	c1 e3 0c             	shl    $0xc,%ebx
  80f6e8:	81 eb 00 00 00 30    	sub    $0x30000000,%ebx
	ova = fd2data(oldfd);
  80f6ee:	83 c4 04             	add    $0x4,%esp
  80f6f1:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f6f4:	e8 de fd ff ff       	call   80f4d7 <fd2data>
  80f6f9:	89 c7                	mov    %eax,%edi
	nva = fd2data(newfd);
  80f6fb:	89 1c 24             	mov    %ebx,(%esp)
  80f6fe:	e8 d4 fd ff ff       	call   80f4d7 <fd2data>
  80f703:	83 c4 10             	add    $0x10,%esp
  80f706:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80f709:	89 f8                	mov    %edi,%eax
  80f70b:	c1 e8 16             	shr    $0x16,%eax
  80f70e:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f715:	a8 01                	test   $0x1,%al
  80f717:	74 37                	je     80f750 <dup+0x99>
  80f719:	89 f8                	mov    %edi,%eax
  80f71b:	c1 e8 0c             	shr    $0xc,%eax
  80f71e:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f725:	f6 c2 01             	test   $0x1,%dl
  80f728:	74 26                	je     80f750 <dup+0x99>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80f72a:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f731:	83 ec 0c             	sub    $0xc,%esp
  80f734:	25 07 0e 00 00       	and    $0xe07,%eax
  80f739:	50                   	push   %eax
  80f73a:	ff 75 d4             	pushl  -0x2c(%ebp)
  80f73d:	6a 00                	push   $0x0
  80f73f:	57                   	push   %edi
  80f740:	6a 00                	push   $0x0
  80f742:	e8 ab f7 ff ff       	call   80eef2 <sys_page_map>
  80f747:	89 c7                	mov    %eax,%edi
  80f749:	83 c4 20             	add    $0x20,%esp
  80f74c:	85 c0                	test   %eax,%eax
  80f74e:	78 2e                	js     80f77e <dup+0xc7>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80f750:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80f753:	89 d0                	mov    %edx,%eax
  80f755:	c1 e8 0c             	shr    $0xc,%eax
  80f758:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f75f:	83 ec 0c             	sub    $0xc,%esp
  80f762:	25 07 0e 00 00       	and    $0xe07,%eax
  80f767:	50                   	push   %eax
  80f768:	53                   	push   %ebx
  80f769:	6a 00                	push   $0x0
  80f76b:	52                   	push   %edx
  80f76c:	6a 00                	push   $0x0
  80f76e:	e8 7f f7 ff ff       	call   80eef2 <sys_page_map>
  80f773:	89 c7                	mov    %eax,%edi
  80f775:	83 c4 20             	add    $0x20,%esp
		goto err;

	return newfdnum;
  80f778:	89 f0                	mov    %esi,%eax
	nva = fd2data(newfd);

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80f77a:	85 ff                	test   %edi,%edi
  80f77c:	79 1d                	jns    80f79b <dup+0xe4>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  80f77e:	83 ec 08             	sub    $0x8,%esp
  80f781:	53                   	push   %ebx
  80f782:	6a 00                	push   $0x0
  80f784:	e8 ab f7 ff ff       	call   80ef34 <sys_page_unmap>
	sys_page_unmap(0, nva);
  80f789:	83 c4 08             	add    $0x8,%esp
  80f78c:	ff 75 d4             	pushl  -0x2c(%ebp)
  80f78f:	6a 00                	push   $0x0
  80f791:	e8 9e f7 ff ff       	call   80ef34 <sys_page_unmap>
	return r;
  80f796:	83 c4 10             	add    $0x10,%esp
  80f799:	89 f8                	mov    %edi,%eax
}
  80f79b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f79e:	5b                   	pop    %ebx
  80f79f:	5e                   	pop    %esi
  80f7a0:	5f                   	pop    %edi
  80f7a1:	5d                   	pop    %ebp
  80f7a2:	c3                   	ret    

0080f7a3 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80f7a3:	55                   	push   %ebp
  80f7a4:	89 e5                	mov    %esp,%ebp
  80f7a6:	53                   	push   %ebx
  80f7a7:	83 ec 14             	sub    $0x14,%esp
  80f7aa:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f7ad:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f7b0:	50                   	push   %eax
  80f7b1:	53                   	push   %ebx
  80f7b2:	e8 86 fd ff ff       	call   80f53d <fd_lookup>
  80f7b7:	83 c4 08             	add    $0x8,%esp
  80f7ba:	89 c2                	mov    %eax,%edx
  80f7bc:	85 c0                	test   %eax,%eax
  80f7be:	78 6d                	js     80f82d <read+0x8a>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f7c0:	83 ec 08             	sub    $0x8,%esp
  80f7c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f7c6:	50                   	push   %eax
  80f7c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f7ca:	ff 30                	pushl  (%eax)
  80f7cc:	e8 c2 fd ff ff       	call   80f593 <dev_lookup>
  80f7d1:	83 c4 10             	add    $0x10,%esp
  80f7d4:	85 c0                	test   %eax,%eax
  80f7d6:	78 4c                	js     80f824 <read+0x81>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80f7d8:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80f7db:	8b 42 08             	mov    0x8(%edx),%eax
  80f7de:	83 e0 03             	and    $0x3,%eax
  80f7e1:	83 f8 01             	cmp    $0x1,%eax
  80f7e4:	75 21                	jne    80f807 <read+0x64>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80f7e6:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f7eb:	8b 40 48             	mov    0x48(%eax),%eax
  80f7ee:	83 ec 04             	sub    $0x4,%esp
  80f7f1:	53                   	push   %ebx
  80f7f2:	50                   	push   %eax
  80f7f3:	68 f9 35 81 00       	push   $0x8135f9
  80f7f8:	e8 2a ed ff ff       	call   80e527 <cprintf>
		return -E_INVAL;
  80f7fd:	83 c4 10             	add    $0x10,%esp
  80f800:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f805:	eb 26                	jmp    80f82d <read+0x8a>
	}
	if (!dev->dev_read)
  80f807:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f80a:	8b 40 08             	mov    0x8(%eax),%eax
  80f80d:	85 c0                	test   %eax,%eax
  80f80f:	74 17                	je     80f828 <read+0x85>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80f811:	83 ec 04             	sub    $0x4,%esp
  80f814:	ff 75 10             	pushl  0x10(%ebp)
  80f817:	ff 75 0c             	pushl  0xc(%ebp)
  80f81a:	52                   	push   %edx
  80f81b:	ff d0                	call   *%eax
  80f81d:	89 c2                	mov    %eax,%edx
  80f81f:	83 c4 10             	add    $0x10,%esp
  80f822:	eb 09                	jmp    80f82d <read+0x8a>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f824:	89 c2                	mov    %eax,%edx
  80f826:	eb 05                	jmp    80f82d <read+0x8a>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
		return -E_NOT_SUPP;
  80f828:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_read)(fd, buf, n);
}
  80f82d:	89 d0                	mov    %edx,%eax
  80f82f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f832:	c9                   	leave  
  80f833:	c3                   	ret    

0080f834 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80f834:	55                   	push   %ebp
  80f835:	89 e5                	mov    %esp,%ebp
  80f837:	57                   	push   %edi
  80f838:	56                   	push   %esi
  80f839:	53                   	push   %ebx
  80f83a:	83 ec 0c             	sub    $0xc,%esp
  80f83d:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f840:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80f843:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f848:	eb 21                	jmp    80f86b <readn+0x37>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80f84a:	83 ec 04             	sub    $0x4,%esp
  80f84d:	89 f0                	mov    %esi,%eax
  80f84f:	29 d8                	sub    %ebx,%eax
  80f851:	50                   	push   %eax
  80f852:	89 d8                	mov    %ebx,%eax
  80f854:	03 45 0c             	add    0xc(%ebp),%eax
  80f857:	50                   	push   %eax
  80f858:	57                   	push   %edi
  80f859:	e8 45 ff ff ff       	call   80f7a3 <read>
		if (m < 0)
  80f85e:	83 c4 10             	add    $0x10,%esp
  80f861:	85 c0                	test   %eax,%eax
  80f863:	78 10                	js     80f875 <readn+0x41>
			return m;
		if (m == 0)
  80f865:	85 c0                	test   %eax,%eax
  80f867:	74 0a                	je     80f873 <readn+0x3f>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80f869:	01 c3                	add    %eax,%ebx
  80f86b:	39 f3                	cmp    %esi,%ebx
  80f86d:	72 db                	jb     80f84a <readn+0x16>
  80f86f:	89 d8                	mov    %ebx,%eax
  80f871:	eb 02                	jmp    80f875 <readn+0x41>
  80f873:	89 d8                	mov    %ebx,%eax
			return m;
		if (m == 0)
			break;
	}
	return tot;
}
  80f875:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f878:	5b                   	pop    %ebx
  80f879:	5e                   	pop    %esi
  80f87a:	5f                   	pop    %edi
  80f87b:	5d                   	pop    %ebp
  80f87c:	c3                   	ret    

0080f87d <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80f87d:	55                   	push   %ebp
  80f87e:	89 e5                	mov    %esp,%ebp
  80f880:	53                   	push   %ebx
  80f881:	83 ec 14             	sub    $0x14,%esp
  80f884:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f887:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f88a:	50                   	push   %eax
  80f88b:	53                   	push   %ebx
  80f88c:	e8 ac fc ff ff       	call   80f53d <fd_lookup>
  80f891:	83 c4 08             	add    $0x8,%esp
  80f894:	89 c2                	mov    %eax,%edx
  80f896:	85 c0                	test   %eax,%eax
  80f898:	78 68                	js     80f902 <write+0x85>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f89a:	83 ec 08             	sub    $0x8,%esp
  80f89d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f8a0:	50                   	push   %eax
  80f8a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f8a4:	ff 30                	pushl  (%eax)
  80f8a6:	e8 e8 fc ff ff       	call   80f593 <dev_lookup>
  80f8ab:	83 c4 10             	add    $0x10,%esp
  80f8ae:	85 c0                	test   %eax,%eax
  80f8b0:	78 47                	js     80f8f9 <write+0x7c>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80f8b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f8b5:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80f8b9:	75 21                	jne    80f8dc <write+0x5f>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  80f8bb:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f8c0:	8b 40 48             	mov    0x48(%eax),%eax
  80f8c3:	83 ec 04             	sub    $0x4,%esp
  80f8c6:	53                   	push   %ebx
  80f8c7:	50                   	push   %eax
  80f8c8:	68 15 36 81 00       	push   $0x813615
  80f8cd:	e8 55 ec ff ff       	call   80e527 <cprintf>
		return -E_INVAL;
  80f8d2:	83 c4 10             	add    $0x10,%esp
  80f8d5:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f8da:	eb 26                	jmp    80f902 <write+0x85>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80f8dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80f8df:	8b 52 0c             	mov    0xc(%edx),%edx
  80f8e2:	85 d2                	test   %edx,%edx
  80f8e4:	74 17                	je     80f8fd <write+0x80>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80f8e6:	83 ec 04             	sub    $0x4,%esp
  80f8e9:	ff 75 10             	pushl  0x10(%ebp)
  80f8ec:	ff 75 0c             	pushl  0xc(%ebp)
  80f8ef:	50                   	push   %eax
  80f8f0:	ff d2                	call   *%edx
  80f8f2:	89 c2                	mov    %eax,%edx
  80f8f4:	83 c4 10             	add    $0x10,%esp
  80f8f7:	eb 09                	jmp    80f902 <write+0x85>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f8f9:	89 c2                	mov    %eax,%edx
  80f8fb:	eb 05                	jmp    80f902 <write+0x85>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
		return -E_NOT_SUPP;
  80f8fd:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_write)(fd, buf, n);
}
  80f902:	89 d0                	mov    %edx,%eax
  80f904:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f907:	c9                   	leave  
  80f908:	c3                   	ret    

0080f909 <seek>:

int
seek(int fdnum, off_t offset)
{
  80f909:	55                   	push   %ebp
  80f90a:	89 e5                	mov    %esp,%ebp
  80f90c:	83 ec 10             	sub    $0x10,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80f90f:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80f912:	50                   	push   %eax
  80f913:	ff 75 08             	pushl  0x8(%ebp)
  80f916:	e8 22 fc ff ff       	call   80f53d <fd_lookup>
  80f91b:	83 c4 08             	add    $0x8,%esp
  80f91e:	85 c0                	test   %eax,%eax
  80f920:	78 0e                	js     80f930 <seek+0x27>
		return r;
	fd->fd_offset = offset;
  80f922:	8b 45 fc             	mov    -0x4(%ebp),%eax
  80f925:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f928:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  80f92b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f930:	c9                   	leave  
  80f931:	c3                   	ret    

0080f932 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  80f932:	55                   	push   %ebp
  80f933:	89 e5                	mov    %esp,%ebp
  80f935:	53                   	push   %ebx
  80f936:	83 ec 14             	sub    $0x14,%esp
  80f939:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f93c:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f93f:	50                   	push   %eax
  80f940:	53                   	push   %ebx
  80f941:	e8 f7 fb ff ff       	call   80f53d <fd_lookup>
  80f946:	83 c4 08             	add    $0x8,%esp
  80f949:	89 c2                	mov    %eax,%edx
  80f94b:	85 c0                	test   %eax,%eax
  80f94d:	78 65                	js     80f9b4 <ftruncate+0x82>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f94f:	83 ec 08             	sub    $0x8,%esp
  80f952:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f955:	50                   	push   %eax
  80f956:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f959:	ff 30                	pushl  (%eax)
  80f95b:	e8 33 fc ff ff       	call   80f593 <dev_lookup>
  80f960:	83 c4 10             	add    $0x10,%esp
  80f963:	85 c0                	test   %eax,%eax
  80f965:	78 44                	js     80f9ab <ftruncate+0x79>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80f967:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f96a:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80f96e:	75 21                	jne    80f991 <ftruncate+0x5f>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  80f970:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  80f975:	8b 40 48             	mov    0x48(%eax),%eax
  80f978:	83 ec 04             	sub    $0x4,%esp
  80f97b:	53                   	push   %ebx
  80f97c:	50                   	push   %eax
  80f97d:	68 d8 35 81 00       	push   $0x8135d8
  80f982:	e8 a0 eb ff ff       	call   80e527 <cprintf>
			thisenv->env_id, fdnum);
		return -E_INVAL;
  80f987:	83 c4 10             	add    $0x10,%esp
  80f98a:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f98f:	eb 23                	jmp    80f9b4 <ftruncate+0x82>
	}
	if (!dev->dev_trunc)
  80f991:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80f994:	8b 52 18             	mov    0x18(%edx),%edx
  80f997:	85 d2                	test   %edx,%edx
  80f999:	74 14                	je     80f9af <ftruncate+0x7d>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  80f99b:	83 ec 08             	sub    $0x8,%esp
  80f99e:	ff 75 0c             	pushl  0xc(%ebp)
  80f9a1:	50                   	push   %eax
  80f9a2:	ff d2                	call   *%edx
  80f9a4:	89 c2                	mov    %eax,%edx
  80f9a6:	83 c4 10             	add    $0x10,%esp
  80f9a9:	eb 09                	jmp    80f9b4 <ftruncate+0x82>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f9ab:	89 c2                	mov    %eax,%edx
  80f9ad:	eb 05                	jmp    80f9b4 <ftruncate+0x82>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
		return -E_NOT_SUPP;
  80f9af:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_trunc)(fd, newsize);
}
  80f9b4:	89 d0                	mov    %edx,%eax
  80f9b6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f9b9:	c9                   	leave  
  80f9ba:	c3                   	ret    

0080f9bb <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  80f9bb:	55                   	push   %ebp
  80f9bc:	89 e5                	mov    %esp,%ebp
  80f9be:	53                   	push   %ebx
  80f9bf:	83 ec 14             	sub    $0x14,%esp
  80f9c2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f9c5:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f9c8:	50                   	push   %eax
  80f9c9:	ff 75 08             	pushl  0x8(%ebp)
  80f9cc:	e8 6c fb ff ff       	call   80f53d <fd_lookup>
  80f9d1:	83 c4 08             	add    $0x8,%esp
  80f9d4:	89 c2                	mov    %eax,%edx
  80f9d6:	85 c0                	test   %eax,%eax
  80f9d8:	78 58                	js     80fa32 <fstat+0x77>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f9da:	83 ec 08             	sub    $0x8,%esp
  80f9dd:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f9e0:	50                   	push   %eax
  80f9e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f9e4:	ff 30                	pushl  (%eax)
  80f9e6:	e8 a8 fb ff ff       	call   80f593 <dev_lookup>
  80f9eb:	83 c4 10             	add    $0x10,%esp
  80f9ee:	85 c0                	test   %eax,%eax
  80f9f0:	78 37                	js     80fa29 <fstat+0x6e>
		return r;
	if (!dev->dev_stat)
  80f9f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f9f5:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  80f9f9:	74 32                	je     80fa2d <fstat+0x72>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  80f9fb:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  80f9fe:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80fa05:	00 00 00 
	stat->st_isdir = 0;
  80fa08:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  80fa0f:	00 00 00 
	stat->st_dev = dev;
  80fa12:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  80fa18:	83 ec 08             	sub    $0x8,%esp
  80fa1b:	53                   	push   %ebx
  80fa1c:	ff 75 f0             	pushl  -0x10(%ebp)
  80fa1f:	ff 50 14             	call   *0x14(%eax)
  80fa22:	89 c2                	mov    %eax,%edx
  80fa24:	83 c4 10             	add    $0x10,%esp
  80fa27:	eb 09                	jmp    80fa32 <fstat+0x77>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fa29:	89 c2                	mov    %eax,%edx
  80fa2b:	eb 05                	jmp    80fa32 <fstat+0x77>
		return r;
	if (!dev->dev_stat)
		return -E_NOT_SUPP;
  80fa2d:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	stat->st_name[0] = 0;
	stat->st_size = 0;
	stat->st_isdir = 0;
	stat->st_dev = dev;
	return (*dev->dev_stat)(fd, stat);
}
  80fa32:	89 d0                	mov    %edx,%eax
  80fa34:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fa37:	c9                   	leave  
  80fa38:	c3                   	ret    

0080fa39 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  80fa39:	55                   	push   %ebp
  80fa3a:	89 e5                	mov    %esp,%ebp
  80fa3c:	56                   	push   %esi
  80fa3d:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  80fa3e:	83 ec 08             	sub    $0x8,%esp
  80fa41:	6a 00                	push   $0x0
  80fa43:	ff 75 08             	pushl  0x8(%ebp)
  80fa46:	e8 d6 01 00 00       	call   80fc21 <open>
  80fa4b:	89 c3                	mov    %eax,%ebx
  80fa4d:	83 c4 10             	add    $0x10,%esp
  80fa50:	85 c0                	test   %eax,%eax
  80fa52:	78 1b                	js     80fa6f <stat+0x36>
		return fd;
	r = fstat(fd, stat);
  80fa54:	83 ec 08             	sub    $0x8,%esp
  80fa57:	ff 75 0c             	pushl  0xc(%ebp)
  80fa5a:	50                   	push   %eax
  80fa5b:	e8 5b ff ff ff       	call   80f9bb <fstat>
  80fa60:	89 c6                	mov    %eax,%esi
	close(fd);
  80fa62:	89 1c 24             	mov    %ebx,(%esp)
  80fa65:	e8 fd fb ff ff       	call   80f667 <close>
	return r;
  80fa6a:	83 c4 10             	add    $0x10,%esp
  80fa6d:	89 f0                	mov    %esi,%eax
}
  80fa6f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fa72:	5b                   	pop    %ebx
  80fa73:	5e                   	pop    %esi
  80fa74:	5d                   	pop    %ebp
  80fa75:	c3                   	ret    

0080fa76 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  80fa76:	55                   	push   %ebp
  80fa77:	89 e5                	mov    %esp,%ebp
  80fa79:	56                   	push   %esi
  80fa7a:	53                   	push   %ebx
  80fa7b:	89 c6                	mov    %eax,%esi
  80fa7d:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  80fa7f:	83 3d cc b1 b3 00 00 	cmpl   $0x0,0xb3b1cc
  80fa86:	75 12                	jne    80fa9a <fsipc+0x24>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  80fa88:	83 ec 0c             	sub    $0xc,%esp
  80fa8b:	6a 01                	push   $0x1
  80fa8d:	e8 fc f9 ff ff       	call   80f48e <ipc_find_env>
  80fa92:	a3 cc b1 b3 00       	mov    %eax,0xb3b1cc
  80fa97:	83 c4 10             	add    $0x10,%esp
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  80fa9a:	6a 07                	push   $0x7
  80fa9c:	68 00 c0 b3 00       	push   $0xb3c000
  80faa1:	56                   	push   %esi
  80faa2:	ff 35 cc b1 b3 00    	pushl  0xb3b1cc
  80faa8:	e8 8d f9 ff ff       	call   80f43a <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  80faad:	83 c4 0c             	add    $0xc,%esp
  80fab0:	6a 00                	push   $0x0
  80fab2:	53                   	push   %ebx
  80fab3:	6a 00                	push   $0x0
  80fab5:	e8 19 f9 ff ff       	call   80f3d3 <ipc_recv>
}
  80faba:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fabd:	5b                   	pop    %ebx
  80fabe:	5e                   	pop    %esi
  80fabf:	5d                   	pop    %ebp
  80fac0:	c3                   	ret    

0080fac1 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  80fac1:	55                   	push   %ebp
  80fac2:	89 e5                	mov    %esp,%ebp
  80fac4:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  80fac7:	8b 45 08             	mov    0x8(%ebp),%eax
  80faca:	8b 40 0c             	mov    0xc(%eax),%eax
  80facd:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.set_size.req_size = newsize;
  80fad2:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fad5:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return fsipc(FSREQ_SET_SIZE, NULL);
  80fada:	ba 00 00 00 00       	mov    $0x0,%edx
  80fadf:	b8 02 00 00 00       	mov    $0x2,%eax
  80fae4:	e8 8d ff ff ff       	call   80fa76 <fsipc>
}
  80fae9:	c9                   	leave  
  80faea:	c3                   	ret    

0080faeb <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  80faeb:	55                   	push   %ebp
  80faec:	89 e5                	mov    %esp,%ebp
  80faee:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  80faf1:	8b 45 08             	mov    0x8(%ebp),%eax
  80faf4:	8b 40 0c             	mov    0xc(%eax),%eax
  80faf7:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	return fsipc(FSREQ_FLUSH, NULL);
  80fafc:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb01:	b8 06 00 00 00       	mov    $0x6,%eax
  80fb06:	e8 6b ff ff ff       	call   80fa76 <fsipc>
}
  80fb0b:	c9                   	leave  
  80fb0c:	c3                   	ret    

0080fb0d <devfile_stat>:

}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  80fb0d:	55                   	push   %ebp
  80fb0e:	89 e5                	mov    %esp,%ebp
  80fb10:	53                   	push   %ebx
  80fb11:	83 ec 04             	sub    $0x4,%esp
  80fb14:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  80fb17:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb1a:	8b 40 0c             	mov    0xc(%eax),%eax
  80fb1d:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  80fb22:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb27:	b8 05 00 00 00       	mov    $0x5,%eax
  80fb2c:	e8 45 ff ff ff       	call   80fa76 <fsipc>
  80fb31:	85 c0                	test   %eax,%eax
  80fb33:	78 2c                	js     80fb61 <devfile_stat+0x54>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  80fb35:	83 ec 08             	sub    $0x8,%esp
  80fb38:	68 00 c0 b3 00       	push   $0xb3c000
  80fb3d:	53                   	push   %ebx
  80fb3e:	e8 69 ef ff ff       	call   80eaac <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  80fb43:	a1 80 c0 b3 00       	mov    0xb3c080,%eax
  80fb48:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  80fb4e:	a1 84 c0 b3 00       	mov    0xb3c084,%eax
  80fb53:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  80fb59:	83 c4 10             	add    $0x10,%esp
  80fb5c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fb61:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fb64:	c9                   	leave  
  80fb65:	c3                   	ret    

0080fb66 <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  80fb66:	55                   	push   %ebp
  80fb67:	89 e5                	mov    %esp,%ebp
  80fb69:	83 ec 0c             	sub    $0xc,%esp
  80fb6c:	8b 45 10             	mov    0x10(%ebp),%eax
	// remember that write is always allowed to write *fewer*
	// bytes than requested.
	// LAB 5: Your code here
	// panic("devfile_write not implemented");

	fsipcbuf.write.req_fileid = fd->fd_file.id;
  80fb6f:	8b 55 08             	mov    0x8(%ebp),%edx
  80fb72:	8b 52 0c             	mov    0xc(%edx),%edx
  80fb75:	89 15 00 c0 b3 00    	mov    %edx,0xb3c000
	fsipcbuf.write.req_n = n;
  80fb7b:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	memmove(fsipcbuf.write.req_buf, buf, n);
  80fb80:	50                   	push   %eax
  80fb81:	ff 75 0c             	pushl  0xc(%ebp)
  80fb84:	68 08 c0 b3 00       	push   $0xb3c008
  80fb89:	e8 b0 f0 ff ff       	call   80ec3e <memmove>
	return fsipc(FSREQ_WRITE, NULL);
  80fb8e:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb93:	b8 04 00 00 00       	mov    $0x4,%eax
  80fb98:	e8 d9 fe ff ff       	call   80fa76 <fsipc>

}
  80fb9d:	c9                   	leave  
  80fb9e:	c3                   	ret    

0080fb9f <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  80fb9f:	55                   	push   %ebp
  80fba0:	89 e5                	mov    %esp,%ebp
  80fba2:	56                   	push   %esi
  80fba3:	53                   	push   %ebx
  80fba4:	8b 75 10             	mov    0x10(%ebp),%esi
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	int r;

	fsipcbuf.read.req_fileid = fd->fd_file.id;
  80fba7:	8b 45 08             	mov    0x8(%ebp),%eax
  80fbaa:	8b 40 0c             	mov    0xc(%eax),%eax
  80fbad:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.read.req_n = n;
  80fbb2:	89 35 04 c0 b3 00    	mov    %esi,0xb3c004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  80fbb8:	ba 00 00 00 00       	mov    $0x0,%edx
  80fbbd:	b8 03 00 00 00       	mov    $0x3,%eax
  80fbc2:	e8 af fe ff ff       	call   80fa76 <fsipc>
  80fbc7:	89 c3                	mov    %eax,%ebx
  80fbc9:	85 c0                	test   %eax,%eax
  80fbcb:	78 4b                	js     80fc18 <devfile_read+0x79>
		return r;
	assert(r <= n);
  80fbcd:	39 c6                	cmp    %eax,%esi
  80fbcf:	73 16                	jae    80fbe7 <devfile_read+0x48>
  80fbd1:	68 48 36 81 00       	push   $0x813648
  80fbd6:	68 87 23 81 00       	push   $0x812387
  80fbdb:	6a 7c                	push   $0x7c
  80fbdd:	68 4f 36 81 00       	push   $0x81364f
  80fbe2:	e8 67 e8 ff ff       	call   80e44e <_panic>
	assert(r <= PGSIZE);
  80fbe7:	3d 00 10 00 00       	cmp    $0x1000,%eax
  80fbec:	7e 16                	jle    80fc04 <devfile_read+0x65>
  80fbee:	68 5a 36 81 00       	push   $0x81365a
  80fbf3:	68 87 23 81 00       	push   $0x812387
  80fbf8:	6a 7d                	push   $0x7d
  80fbfa:	68 4f 36 81 00       	push   $0x81364f
  80fbff:	e8 4a e8 ff ff       	call   80e44e <_panic>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  80fc04:	83 ec 04             	sub    $0x4,%esp
  80fc07:	50                   	push   %eax
  80fc08:	68 00 c0 b3 00       	push   $0xb3c000
  80fc0d:	ff 75 0c             	pushl  0xc(%ebp)
  80fc10:	e8 29 f0 ff ff       	call   80ec3e <memmove>
	return r;
  80fc15:	83 c4 10             	add    $0x10,%esp
}
  80fc18:	89 d8                	mov    %ebx,%eax
  80fc1a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fc1d:	5b                   	pop    %ebx
  80fc1e:	5e                   	pop    %esi
  80fc1f:	5d                   	pop    %ebp
  80fc20:	c3                   	ret    

0080fc21 <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  80fc21:	55                   	push   %ebp
  80fc22:	89 e5                	mov    %esp,%ebp
  80fc24:	53                   	push   %ebx
  80fc25:	83 ec 20             	sub    $0x20,%esp
  80fc28:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// file descriptor.

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
  80fc2b:	53                   	push   %ebx
  80fc2c:	e8 42 ee ff ff       	call   80ea73 <strlen>
  80fc31:	83 c4 10             	add    $0x10,%esp
  80fc34:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  80fc39:	7f 67                	jg     80fca2 <open+0x81>
		return -E_BAD_PATH;

	if ((r = fd_alloc(&fd)) < 0)
  80fc3b:	83 ec 0c             	sub    $0xc,%esp
  80fc3e:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fc41:	50                   	push   %eax
  80fc42:	e8 a7 f8 ff ff       	call   80f4ee <fd_alloc>
  80fc47:	83 c4 10             	add    $0x10,%esp
		return r;
  80fc4a:	89 c2                	mov    %eax,%edx
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
		return -E_BAD_PATH;

	if ((r = fd_alloc(&fd)) < 0)
  80fc4c:	85 c0                	test   %eax,%eax
  80fc4e:	78 57                	js     80fca7 <open+0x86>
		return r;

	strcpy(fsipcbuf.open.req_path, path);
  80fc50:	83 ec 08             	sub    $0x8,%esp
  80fc53:	53                   	push   %ebx
  80fc54:	68 00 c0 b3 00       	push   $0xb3c000
  80fc59:	e8 4e ee ff ff       	call   80eaac <strcpy>
	fsipcbuf.open.req_omode = mode;
  80fc5e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fc61:	a3 00 c4 b3 00       	mov    %eax,0xb3c400

	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  80fc66:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fc69:	b8 01 00 00 00       	mov    $0x1,%eax
  80fc6e:	e8 03 fe ff ff       	call   80fa76 <fsipc>
  80fc73:	89 c3                	mov    %eax,%ebx
  80fc75:	83 c4 10             	add    $0x10,%esp
  80fc78:	85 c0                	test   %eax,%eax
  80fc7a:	79 14                	jns    80fc90 <open+0x6f>
		fd_close(fd, 0);
  80fc7c:	83 ec 08             	sub    $0x8,%esp
  80fc7f:	6a 00                	push   $0x0
  80fc81:	ff 75 f4             	pushl  -0xc(%ebp)
  80fc84:	e8 5d f9 ff ff       	call   80f5e6 <fd_close>
		return r;
  80fc89:	83 c4 10             	add    $0x10,%esp
  80fc8c:	89 da                	mov    %ebx,%edx
  80fc8e:	eb 17                	jmp    80fca7 <open+0x86>
	}

	return fd2num(fd);
  80fc90:	83 ec 0c             	sub    $0xc,%esp
  80fc93:	ff 75 f4             	pushl  -0xc(%ebp)
  80fc96:	e8 2c f8 ff ff       	call   80f4c7 <fd2num>
  80fc9b:	89 c2                	mov    %eax,%edx
  80fc9d:	83 c4 10             	add    $0x10,%esp
  80fca0:	eb 05                	jmp    80fca7 <open+0x86>

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
		return -E_BAD_PATH;
  80fca2:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
		fd_close(fd, 0);
		return r;
	}

	return fd2num(fd);
}
  80fca7:	89 d0                	mov    %edx,%eax
  80fca9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fcac:	c9                   	leave  
  80fcad:	c3                   	ret    

0080fcae <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  80fcae:	55                   	push   %ebp
  80fcaf:	89 e5                	mov    %esp,%ebp
  80fcb1:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  80fcb4:	ba 00 00 00 00       	mov    $0x0,%edx
  80fcb9:	b8 08 00 00 00       	mov    $0x8,%eax
  80fcbe:	e8 b3 fd ff ff       	call   80fa76 <fsipc>
}
  80fcc3:	c9                   	leave  
  80fcc4:	c3                   	ret    

0080fcc5 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  80fcc5:	55                   	push   %ebp
  80fcc6:	89 e5                	mov    %esp,%ebp
  80fcc8:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  80fccb:	68 66 36 81 00       	push   $0x813666
  80fcd0:	ff 75 0c             	pushl  0xc(%ebp)
  80fcd3:	e8 d4 ed ff ff       	call   80eaac <strcpy>
	return 0;
}
  80fcd8:	b8 00 00 00 00       	mov    $0x0,%eax
  80fcdd:	c9                   	leave  
  80fcde:	c3                   	ret    

0080fcdf <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  80fcdf:	55                   	push   %ebp
  80fce0:	89 e5                	mov    %esp,%ebp
  80fce2:	53                   	push   %ebx
  80fce3:	83 ec 10             	sub    $0x10,%esp
  80fce6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  80fce9:	53                   	push   %ebx
  80fcea:	e8 15 0c 00 00       	call   810904 <pageref>
  80fcef:	83 c4 10             	add    $0x10,%esp
		return nsipc_close(fd->fd_sock.sockid);
	else
		return 0;
  80fcf2:	ba 00 00 00 00       	mov    $0x0,%edx
}

static int
devsock_close(struct Fd *fd)
{
	if (pageref(fd) == 1)
  80fcf7:	83 f8 01             	cmp    $0x1,%eax
  80fcfa:	75 10                	jne    80fd0c <devsock_close+0x2d>
		return nsipc_close(fd->fd_sock.sockid);
  80fcfc:	83 ec 0c             	sub    $0xc,%esp
  80fcff:	ff 73 0c             	pushl  0xc(%ebx)
  80fd02:	e8 c0 02 00 00       	call   80ffc7 <nsipc_close>
  80fd07:	89 c2                	mov    %eax,%edx
  80fd09:	83 c4 10             	add    $0x10,%esp
	else
		return 0;
}
  80fd0c:	89 d0                	mov    %edx,%eax
  80fd0e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fd11:	c9                   	leave  
  80fd12:	c3                   	ret    

0080fd13 <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  80fd13:	55                   	push   %ebp
  80fd14:	89 e5                	mov    %esp,%ebp
  80fd16:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  80fd19:	6a 00                	push   $0x0
  80fd1b:	ff 75 10             	pushl  0x10(%ebp)
  80fd1e:	ff 75 0c             	pushl  0xc(%ebp)
  80fd21:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd24:	ff 70 0c             	pushl  0xc(%eax)
  80fd27:	e8 78 03 00 00       	call   8100a4 <nsipc_send>
}
  80fd2c:	c9                   	leave  
  80fd2d:	c3                   	ret    

0080fd2e <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  80fd2e:	55                   	push   %ebp
  80fd2f:	89 e5                	mov    %esp,%ebp
  80fd31:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  80fd34:	6a 00                	push   $0x0
  80fd36:	ff 75 10             	pushl  0x10(%ebp)
  80fd39:	ff 75 0c             	pushl  0xc(%ebp)
  80fd3c:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd3f:	ff 70 0c             	pushl  0xc(%eax)
  80fd42:	e8 f1 02 00 00       	call   810038 <nsipc_recv>
}
  80fd47:	c9                   	leave  
  80fd48:	c3                   	ret    

0080fd49 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  80fd49:	55                   	push   %ebp
  80fd4a:	89 e5                	mov    %esp,%ebp
  80fd4c:	83 ec 20             	sub    $0x20,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  80fd4f:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80fd52:	52                   	push   %edx
  80fd53:	50                   	push   %eax
  80fd54:	e8 e4 f7 ff ff       	call   80f53d <fd_lookup>
  80fd59:	83 c4 10             	add    $0x10,%esp
  80fd5c:	85 c0                	test   %eax,%eax
  80fd5e:	78 17                	js     80fd77 <fd2sockid+0x2e>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  80fd60:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fd63:	8b 0d 08 43 81 00    	mov    0x814308,%ecx
  80fd69:	39 08                	cmp    %ecx,(%eax)
  80fd6b:	75 05                	jne    80fd72 <fd2sockid+0x29>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  80fd6d:	8b 40 0c             	mov    0xc(%eax),%eax
  80fd70:	eb 05                	jmp    80fd77 <fd2sockid+0x2e>
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
		return -E_NOT_SUPP;
  80fd72:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return sfd->fd_sock.sockid;
}
  80fd77:	c9                   	leave  
  80fd78:	c3                   	ret    

0080fd79 <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  80fd79:	55                   	push   %ebp
  80fd7a:	89 e5                	mov    %esp,%ebp
  80fd7c:	56                   	push   %esi
  80fd7d:	53                   	push   %ebx
  80fd7e:	83 ec 1c             	sub    $0x1c,%esp
  80fd81:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  80fd83:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fd86:	50                   	push   %eax
  80fd87:	e8 62 f7 ff ff       	call   80f4ee <fd_alloc>
  80fd8c:	89 c3                	mov    %eax,%ebx
  80fd8e:	83 c4 10             	add    $0x10,%esp
  80fd91:	85 c0                	test   %eax,%eax
  80fd93:	78 1b                	js     80fdb0 <alloc_sockfd+0x37>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  80fd95:	83 ec 04             	sub    $0x4,%esp
  80fd98:	68 07 04 00 00       	push   $0x407
  80fd9d:	ff 75 f4             	pushl  -0xc(%ebp)
  80fda0:	6a 00                	push   $0x0
  80fda2:	e8 08 f1 ff ff       	call   80eeaf <sys_page_alloc>
  80fda7:	89 c3                	mov    %eax,%ebx
  80fda9:	83 c4 10             	add    $0x10,%esp
  80fdac:	85 c0                	test   %eax,%eax
  80fdae:	79 10                	jns    80fdc0 <alloc_sockfd+0x47>
		nsipc_close(sockid);
  80fdb0:	83 ec 0c             	sub    $0xc,%esp
  80fdb3:	56                   	push   %esi
  80fdb4:	e8 0e 02 00 00       	call   80ffc7 <nsipc_close>
		return r;
  80fdb9:	83 c4 10             	add    $0x10,%esp
  80fdbc:	89 d8                	mov    %ebx,%eax
  80fdbe:	eb 24                	jmp    80fde4 <alloc_sockfd+0x6b>
	}

	sfd->fd_dev_id = devsock.dev_id;
  80fdc0:	8b 15 08 43 81 00    	mov    0x814308,%edx
  80fdc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fdc9:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  80fdcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fdce:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  80fdd5:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  80fdd8:	83 ec 0c             	sub    $0xc,%esp
  80fddb:	50                   	push   %eax
  80fddc:	e8 e6 f6 ff ff       	call   80f4c7 <fd2num>
  80fde1:	83 c4 10             	add    $0x10,%esp
}
  80fde4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fde7:	5b                   	pop    %ebx
  80fde8:	5e                   	pop    %esi
  80fde9:	5d                   	pop    %ebp
  80fdea:	c3                   	ret    

0080fdeb <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80fdeb:	55                   	push   %ebp
  80fdec:	89 e5                	mov    %esp,%ebp
  80fdee:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fdf1:	8b 45 08             	mov    0x8(%ebp),%eax
  80fdf4:	e8 50 ff ff ff       	call   80fd49 <fd2sockid>
		return r;
  80fdf9:	89 c1                	mov    %eax,%ecx

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fdfb:	85 c0                	test   %eax,%eax
  80fdfd:	78 1f                	js     80fe1e <accept+0x33>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80fdff:	83 ec 04             	sub    $0x4,%esp
  80fe02:	ff 75 10             	pushl  0x10(%ebp)
  80fe05:	ff 75 0c             	pushl  0xc(%ebp)
  80fe08:	50                   	push   %eax
  80fe09:	e8 12 01 00 00       	call   80ff20 <nsipc_accept>
  80fe0e:	83 c4 10             	add    $0x10,%esp
		return r;
  80fe11:	89 c1                	mov    %eax,%ecx
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80fe13:	85 c0                	test   %eax,%eax
  80fe15:	78 07                	js     80fe1e <accept+0x33>
		return r;
	return alloc_sockfd(r);
  80fe17:	e8 5d ff ff ff       	call   80fd79 <alloc_sockfd>
  80fe1c:	89 c1                	mov    %eax,%ecx
}
  80fe1e:	89 c8                	mov    %ecx,%eax
  80fe20:	c9                   	leave  
  80fe21:	c3                   	ret    

0080fe22 <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80fe22:	55                   	push   %ebp
  80fe23:	89 e5                	mov    %esp,%ebp
  80fe25:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fe28:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe2b:	e8 19 ff ff ff       	call   80fd49 <fd2sockid>
  80fe30:	85 c0                	test   %eax,%eax
  80fe32:	78 12                	js     80fe46 <bind+0x24>
		return r;
	return nsipc_bind(r, name, namelen);
  80fe34:	83 ec 04             	sub    $0x4,%esp
  80fe37:	ff 75 10             	pushl  0x10(%ebp)
  80fe3a:	ff 75 0c             	pushl  0xc(%ebp)
  80fe3d:	50                   	push   %eax
  80fe3e:	e8 2d 01 00 00       	call   80ff70 <nsipc_bind>
  80fe43:	83 c4 10             	add    $0x10,%esp
}
  80fe46:	c9                   	leave  
  80fe47:	c3                   	ret    

0080fe48 <shutdown>:

int
shutdown(int s, int how)
{
  80fe48:	55                   	push   %ebp
  80fe49:	89 e5                	mov    %esp,%ebp
  80fe4b:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fe4e:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe51:	e8 f3 fe ff ff       	call   80fd49 <fd2sockid>
  80fe56:	85 c0                	test   %eax,%eax
  80fe58:	78 0f                	js     80fe69 <shutdown+0x21>
		return r;
	return nsipc_shutdown(r, how);
  80fe5a:	83 ec 08             	sub    $0x8,%esp
  80fe5d:	ff 75 0c             	pushl  0xc(%ebp)
  80fe60:	50                   	push   %eax
  80fe61:	e8 3f 01 00 00       	call   80ffa5 <nsipc_shutdown>
  80fe66:	83 c4 10             	add    $0x10,%esp
}
  80fe69:	c9                   	leave  
  80fe6a:	c3                   	ret    

0080fe6b <connect>:
		return 0;
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80fe6b:	55                   	push   %ebp
  80fe6c:	89 e5                	mov    %esp,%ebp
  80fe6e:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fe71:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe74:	e8 d0 fe ff ff       	call   80fd49 <fd2sockid>
  80fe79:	85 c0                	test   %eax,%eax
  80fe7b:	78 12                	js     80fe8f <connect+0x24>
		return r;
	return nsipc_connect(r, name, namelen);
  80fe7d:	83 ec 04             	sub    $0x4,%esp
  80fe80:	ff 75 10             	pushl  0x10(%ebp)
  80fe83:	ff 75 0c             	pushl  0xc(%ebp)
  80fe86:	50                   	push   %eax
  80fe87:	e8 55 01 00 00       	call   80ffe1 <nsipc_connect>
  80fe8c:	83 c4 10             	add    $0x10,%esp
}
  80fe8f:	c9                   	leave  
  80fe90:	c3                   	ret    

0080fe91 <listen>:

int
listen(int s, int backlog)
{
  80fe91:	55                   	push   %ebp
  80fe92:	89 e5                	mov    %esp,%ebp
  80fe94:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fe97:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe9a:	e8 aa fe ff ff       	call   80fd49 <fd2sockid>
  80fe9f:	85 c0                	test   %eax,%eax
  80fea1:	78 0f                	js     80feb2 <listen+0x21>
		return r;
	return nsipc_listen(r, backlog);
  80fea3:	83 ec 08             	sub    $0x8,%esp
  80fea6:	ff 75 0c             	pushl  0xc(%ebp)
  80fea9:	50                   	push   %eax
  80feaa:	e8 67 01 00 00       	call   810016 <nsipc_listen>
  80feaf:	83 c4 10             	add    $0x10,%esp
}
  80feb2:	c9                   	leave  
  80feb3:	c3                   	ret    

0080feb4 <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  80feb4:	55                   	push   %ebp
  80feb5:	89 e5                	mov    %esp,%ebp
  80feb7:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  80feba:	ff 75 10             	pushl  0x10(%ebp)
  80febd:	ff 75 0c             	pushl  0xc(%ebp)
  80fec0:	ff 75 08             	pushl  0x8(%ebp)
  80fec3:	e8 3a 02 00 00       	call   810102 <nsipc_socket>
  80fec8:	83 c4 10             	add    $0x10,%esp
  80fecb:	85 c0                	test   %eax,%eax
  80fecd:	78 05                	js     80fed4 <socket+0x20>
		return r;
	return alloc_sockfd(r);
  80fecf:	e8 a5 fe ff ff       	call   80fd79 <alloc_sockfd>
}
  80fed4:	c9                   	leave  
  80fed5:	c3                   	ret    

0080fed6 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  80fed6:	55                   	push   %ebp
  80fed7:	89 e5                	mov    %esp,%ebp
  80fed9:	53                   	push   %ebx
  80feda:	83 ec 04             	sub    $0x4,%esp
  80fedd:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  80fedf:	83 3d d0 b1 b3 00 00 	cmpl   $0x0,0xb3b1d0
  80fee6:	75 12                	jne    80fefa <nsipc+0x24>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  80fee8:	83 ec 0c             	sub    $0xc,%esp
  80feeb:	6a 02                	push   $0x2
  80feed:	e8 9c f5 ff ff       	call   80f48e <ipc_find_env>
  80fef2:	a3 d0 b1 b3 00       	mov    %eax,0xb3b1d0
  80fef7:	83 c4 10             	add    $0x10,%esp
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  80fefa:	6a 07                	push   $0x7
  80fefc:	68 00 d0 b3 00       	push   $0xb3d000
  80ff01:	53                   	push   %ebx
  80ff02:	ff 35 d0 b1 b3 00    	pushl  0xb3b1d0
  80ff08:	e8 2d f5 ff ff       	call   80f43a <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  80ff0d:	83 c4 0c             	add    $0xc,%esp
  80ff10:	6a 00                	push   $0x0
  80ff12:	6a 00                	push   $0x0
  80ff14:	6a 00                	push   $0x0
  80ff16:	e8 b8 f4 ff ff       	call   80f3d3 <ipc_recv>
}
  80ff1b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ff1e:	c9                   	leave  
  80ff1f:	c3                   	ret    

0080ff20 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80ff20:	55                   	push   %ebp
  80ff21:	89 e5                	mov    %esp,%ebp
  80ff23:	56                   	push   %esi
  80ff24:	53                   	push   %ebx
  80ff25:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  80ff28:	8b 45 08             	mov    0x8(%ebp),%eax
  80ff2b:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.accept.req_addrlen = *addrlen;
  80ff30:	8b 06                	mov    (%esi),%eax
  80ff32:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  80ff37:	b8 01 00 00 00       	mov    $0x1,%eax
  80ff3c:	e8 95 ff ff ff       	call   80fed6 <nsipc>
  80ff41:	89 c3                	mov    %eax,%ebx
  80ff43:	85 c0                	test   %eax,%eax
  80ff45:	78 20                	js     80ff67 <nsipc_accept+0x47>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  80ff47:	83 ec 04             	sub    $0x4,%esp
  80ff4a:	ff 35 10 d0 b3 00    	pushl  0xb3d010
  80ff50:	68 00 d0 b3 00       	push   $0xb3d000
  80ff55:	ff 75 0c             	pushl  0xc(%ebp)
  80ff58:	e8 e1 ec ff ff       	call   80ec3e <memmove>
		*addrlen = ret->ret_addrlen;
  80ff5d:	a1 10 d0 b3 00       	mov    0xb3d010,%eax
  80ff62:	89 06                	mov    %eax,(%esi)
  80ff64:	83 c4 10             	add    $0x10,%esp
	}
	return r;
}
  80ff67:	89 d8                	mov    %ebx,%eax
  80ff69:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ff6c:	5b                   	pop    %ebx
  80ff6d:	5e                   	pop    %esi
  80ff6e:	5d                   	pop    %ebp
  80ff6f:	c3                   	ret    

0080ff70 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80ff70:	55                   	push   %ebp
  80ff71:	89 e5                	mov    %esp,%ebp
  80ff73:	53                   	push   %ebx
  80ff74:	83 ec 08             	sub    $0x8,%esp
  80ff77:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  80ff7a:	8b 45 08             	mov    0x8(%ebp),%eax
  80ff7d:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  80ff82:	53                   	push   %ebx
  80ff83:	ff 75 0c             	pushl  0xc(%ebp)
  80ff86:	68 04 d0 b3 00       	push   $0xb3d004
  80ff8b:	e8 ae ec ff ff       	call   80ec3e <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  80ff90:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_BIND);
  80ff96:	b8 02 00 00 00       	mov    $0x2,%eax
  80ff9b:	e8 36 ff ff ff       	call   80fed6 <nsipc>
}
  80ffa0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ffa3:	c9                   	leave  
  80ffa4:	c3                   	ret    

0080ffa5 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  80ffa5:	55                   	push   %ebp
  80ffa6:	89 e5                	mov    %esp,%ebp
  80ffa8:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  80ffab:	8b 45 08             	mov    0x8(%ebp),%eax
  80ffae:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.shutdown.req_how = how;
  80ffb3:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ffb6:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_SHUTDOWN);
  80ffbb:	b8 03 00 00 00       	mov    $0x3,%eax
  80ffc0:	e8 11 ff ff ff       	call   80fed6 <nsipc>
}
  80ffc5:	c9                   	leave  
  80ffc6:	c3                   	ret    

0080ffc7 <nsipc_close>:

int
nsipc_close(int s)
{
  80ffc7:	55                   	push   %ebp
  80ffc8:	89 e5                	mov    %esp,%ebp
  80ffca:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  80ffcd:	8b 45 08             	mov    0x8(%ebp),%eax
  80ffd0:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return nsipc(NSREQ_CLOSE);
  80ffd5:	b8 04 00 00 00       	mov    $0x4,%eax
  80ffda:	e8 f7 fe ff ff       	call   80fed6 <nsipc>
}
  80ffdf:	c9                   	leave  
  80ffe0:	c3                   	ret    

0080ffe1 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80ffe1:	55                   	push   %ebp
  80ffe2:	89 e5                	mov    %esp,%ebp
  80ffe4:	53                   	push   %ebx
  80ffe5:	83 ec 08             	sub    $0x8,%esp
  80ffe8:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  80ffeb:	8b 45 08             	mov    0x8(%ebp),%eax
  80ffee:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  80fff3:	53                   	push   %ebx
  80fff4:	ff 75 0c             	pushl  0xc(%ebp)
  80fff7:	68 04 d0 b3 00       	push   $0xb3d004
  80fffc:	e8 3d ec ff ff       	call   80ec3e <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  810001:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_CONNECT);
  810007:	b8 05 00 00 00       	mov    $0x5,%eax
  81000c:	e8 c5 fe ff ff       	call   80fed6 <nsipc>
}
  810011:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810014:	c9                   	leave  
  810015:	c3                   	ret    

00810016 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  810016:	55                   	push   %ebp
  810017:	89 e5                	mov    %esp,%ebp
  810019:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  81001c:	8b 45 08             	mov    0x8(%ebp),%eax
  81001f:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.listen.req_backlog = backlog;
  810024:	8b 45 0c             	mov    0xc(%ebp),%eax
  810027:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_LISTEN);
  81002c:	b8 06 00 00 00       	mov    $0x6,%eax
  810031:	e8 a0 fe ff ff       	call   80fed6 <nsipc>
}
  810036:	c9                   	leave  
  810037:	c3                   	ret    

00810038 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  810038:	55                   	push   %ebp
  810039:	89 e5                	mov    %esp,%ebp
  81003b:	56                   	push   %esi
  81003c:	53                   	push   %ebx
  81003d:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  810040:	8b 45 08             	mov    0x8(%ebp),%eax
  810043:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.recv.req_len = len;
  810048:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	nsipcbuf.recv.req_flags = flags;
  81004e:	8b 45 14             	mov    0x14(%ebp),%eax
  810051:	a3 08 d0 b3 00       	mov    %eax,0xb3d008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  810056:	b8 07 00 00 00       	mov    $0x7,%eax
  81005b:	e8 76 fe ff ff       	call   80fed6 <nsipc>
  810060:	89 c3                	mov    %eax,%ebx
  810062:	85 c0                	test   %eax,%eax
  810064:	78 35                	js     81009b <nsipc_recv+0x63>
		assert(r < 1600 && r <= len);
  810066:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  81006b:	7f 04                	jg     810071 <nsipc_recv+0x39>
  81006d:	39 c6                	cmp    %eax,%esi
  81006f:	7d 16                	jge    810087 <nsipc_recv+0x4f>
  810071:	68 72 36 81 00       	push   $0x813672
  810076:	68 87 23 81 00       	push   $0x812387
  81007b:	6a 62                	push   $0x62
  81007d:	68 87 36 81 00       	push   $0x813687
  810082:	e8 c7 e3 ff ff       	call   80e44e <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  810087:	83 ec 04             	sub    $0x4,%esp
  81008a:	50                   	push   %eax
  81008b:	68 00 d0 b3 00       	push   $0xb3d000
  810090:	ff 75 0c             	pushl  0xc(%ebp)
  810093:	e8 a6 eb ff ff       	call   80ec3e <memmove>
  810098:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  81009b:	89 d8                	mov    %ebx,%eax
  81009d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8100a0:	5b                   	pop    %ebx
  8100a1:	5e                   	pop    %esi
  8100a2:	5d                   	pop    %ebp
  8100a3:	c3                   	ret    

008100a4 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  8100a4:	55                   	push   %ebp
  8100a5:	89 e5                	mov    %esp,%ebp
  8100a7:	53                   	push   %ebx
  8100a8:	83 ec 04             	sub    $0x4,%esp
  8100ab:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  8100ae:	8b 45 08             	mov    0x8(%ebp),%eax
  8100b1:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	assert(size < 1600);
  8100b6:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  8100bc:	7e 16                	jle    8100d4 <nsipc_send+0x30>
  8100be:	68 93 36 81 00       	push   $0x813693
  8100c3:	68 87 23 81 00       	push   $0x812387
  8100c8:	6a 6d                	push   $0x6d
  8100ca:	68 87 36 81 00       	push   $0x813687
  8100cf:	e8 7a e3 ff ff       	call   80e44e <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  8100d4:	83 ec 04             	sub    $0x4,%esp
  8100d7:	53                   	push   %ebx
  8100d8:	ff 75 0c             	pushl  0xc(%ebp)
  8100db:	68 0c d0 b3 00       	push   $0xb3d00c
  8100e0:	e8 59 eb ff ff       	call   80ec3e <memmove>
	nsipcbuf.send.req_size = size;
  8100e5:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	nsipcbuf.send.req_flags = flags;
  8100eb:	8b 45 14             	mov    0x14(%ebp),%eax
  8100ee:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SEND);
  8100f3:	b8 08 00 00 00       	mov    $0x8,%eax
  8100f8:	e8 d9 fd ff ff       	call   80fed6 <nsipc>
}
  8100fd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810100:	c9                   	leave  
  810101:	c3                   	ret    

00810102 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  810102:	55                   	push   %ebp
  810103:	89 e5                	mov    %esp,%ebp
  810105:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  810108:	8b 45 08             	mov    0x8(%ebp),%eax
  81010b:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.socket.req_type = type;
  810110:	8b 45 0c             	mov    0xc(%ebp),%eax
  810113:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	nsipcbuf.socket.req_protocol = protocol;
  810118:	8b 45 10             	mov    0x10(%ebp),%eax
  81011b:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SOCKET);
  810120:	b8 09 00 00 00       	mov    $0x9,%eax
  810125:	e8 ac fd ff ff       	call   80fed6 <nsipc>
}
  81012a:	c9                   	leave  
  81012b:	c3                   	ret    

0081012c <free>:
	return v;
}

void
free(void *v)
{
  81012c:	55                   	push   %ebp
  81012d:	89 e5                	mov    %esp,%ebp
  81012f:	53                   	push   %ebx
  810130:	83 ec 04             	sub    $0x4,%esp
  810133:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  810136:	85 db                	test   %ebx,%ebx
  810138:	0f 84 97 00 00 00    	je     8101d5 <free+0xa9>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  81013e:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  810144:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  810149:	76 16                	jbe    810161 <free+0x35>
  81014b:	68 a0 36 81 00       	push   $0x8136a0
  810150:	68 87 23 81 00       	push   $0x812387
  810155:	6a 7a                	push   $0x7a
  810157:	68 d0 36 81 00       	push   $0x8136d0
  81015c:	e8 ed e2 ff ff       	call   80e44e <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  810161:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  810167:	eb 3a                	jmp    8101a3 <free+0x77>
		sys_page_unmap(0, c);
  810169:	83 ec 08             	sub    $0x8,%esp
  81016c:	53                   	push   %ebx
  81016d:	6a 00                	push   $0x0
  81016f:	e8 c0 ed ff ff       	call   80ef34 <sys_page_unmap>
		c += PGSIZE;
  810174:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  81017a:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  810180:	83 c4 10             	add    $0x10,%esp
  810183:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  810188:	76 19                	jbe    8101a3 <free+0x77>
  81018a:	68 dd 36 81 00       	push   $0x8136dd
  81018f:	68 87 23 81 00       	push   $0x812387
  810194:	68 81 00 00 00       	push   $0x81
  810199:	68 d0 36 81 00       	push   $0x8136d0
  81019e:	e8 ab e2 ff ff       	call   80e44e <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8101a3:	89 d8                	mov    %ebx,%eax
  8101a5:	c1 e8 0c             	shr    $0xc,%eax
  8101a8:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  8101af:	f6 c4 02             	test   $0x2,%ah
  8101b2:	75 b5                	jne    810169 <free+0x3d>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  8101b4:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  8101ba:	83 e8 01             	sub    $0x1,%eax
  8101bd:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  8101c3:	85 c0                	test   %eax,%eax
  8101c5:	75 0e                	jne    8101d5 <free+0xa9>
		sys_page_unmap(0, c);
  8101c7:	83 ec 08             	sub    $0x8,%esp
  8101ca:	53                   	push   %ebx
  8101cb:	6a 00                	push   $0x0
  8101cd:	e8 62 ed ff ff       	call   80ef34 <sys_page_unmap>
  8101d2:	83 c4 10             	add    $0x10,%esp
}
  8101d5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8101d8:	c9                   	leave  
  8101d9:	c3                   	ret    

008101da <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  8101da:	55                   	push   %ebp
  8101db:	89 e5                	mov    %esp,%ebp
  8101dd:	57                   	push   %edi
  8101de:	56                   	push   %esi
  8101df:	53                   	push   %ebx
  8101e0:	83 ec 1c             	sub    $0x1c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  8101e3:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  8101e8:	85 c0                	test   %eax,%eax
  8101ea:	75 22                	jne    81020e <malloc+0x34>
		mptr = mbegin;
  8101ec:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  8101f3:	00 00 08 

	n = ROUNDUP(n, 4);
  8101f6:	8b 45 08             	mov    0x8(%ebp),%eax
  8101f9:	83 c0 03             	add    $0x3,%eax
  8101fc:	83 e0 fc             	and    $0xfffffffc,%eax
  8101ff:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if (n >= MAXMALLOC)
  810202:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  810207:	76 74                	jbe    81027d <malloc+0xa3>
  810209:	e9 7a 01 00 00       	jmp    810388 <malloc+0x1ae>
	void *v;

	if (mptr == 0)
		mptr = mbegin;

	n = ROUNDUP(n, 4);
  81020e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  810211:	8d 53 03             	lea    0x3(%ebx),%edx
  810214:	83 e2 fc             	and    $0xfffffffc,%edx
  810217:	89 55 dc             	mov    %edx,-0x24(%ebp)

	if (n >= MAXMALLOC)
  81021a:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  810220:	0f 87 69 01 00 00    	ja     81038f <malloc+0x1b5>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  810226:	a9 ff 0f 00 00       	test   $0xfff,%eax
  81022b:	74 50                	je     81027d <malloc+0xa3>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  81022d:	89 c1                	mov    %eax,%ecx
  81022f:	c1 e9 0c             	shr    $0xc,%ecx
  810232:	8d 54 10 03          	lea    0x3(%eax,%edx,1),%edx
  810236:	c1 ea 0c             	shr    $0xc,%edx
  810239:	39 d1                	cmp    %edx,%ecx
  81023b:	75 20                	jne    81025d <malloc+0x83>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  81023d:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
  810243:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  810249:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  81024d:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810250:	01 c2                	add    %eax,%edx
  810252:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
			return v;
  810258:	e9 55 01 00 00       	jmp    8103b2 <malloc+0x1d8>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  81025d:	83 ec 0c             	sub    $0xc,%esp
  810260:	50                   	push   %eax
  810261:	e8 c6 fe ff ff       	call   81012c <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  810266:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  81026b:	05 00 10 00 00       	add    $0x1000,%eax
  810270:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  810275:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
  81027a:	83 c4 10             	add    $0x10,%esp
  81027d:	8b 35 d4 b1 b3 00    	mov    0xb3b1d4,%esi
	return 1;
}

void*
malloc(size_t n)
{
  810283:	c7 45 d8 02 00 00 00 	movl   $0x2,-0x28(%ebp)
  81028a:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  81028e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  810291:	8d 78 04             	lea    0x4(%eax),%edi
  810294:	89 75 e0             	mov    %esi,-0x20(%ebp)
  810297:	89 fb                	mov    %edi,%ebx
  810299:	8d 0c 37             	lea    (%edi,%esi,1),%ecx
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  81029c:	89 f0                	mov    %esi,%eax
  81029e:	eb 36                	jmp    8102d6 <malloc+0xfc>
		if (va >= (uintptr_t) mend
  8102a0:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  8102a5:	0f 87 eb 00 00 00    	ja     810396 <malloc+0x1bc>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  8102ab:	89 c2                	mov    %eax,%edx
  8102ad:	c1 ea 16             	shr    $0x16,%edx
  8102b0:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  8102b7:	f6 c2 01             	test   $0x1,%dl
  8102ba:	74 15                	je     8102d1 <malloc+0xf7>
  8102bc:	89 c2                	mov    %eax,%edx
  8102be:	c1 ea 0c             	shr    $0xc,%edx
  8102c1:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  8102c8:	f6 c2 01             	test   $0x1,%dl
  8102cb:	0f 85 c5 00 00 00    	jne    810396 <malloc+0x1bc>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8102d1:	05 00 10 00 00       	add    $0x1000,%eax
  8102d6:	39 c8                	cmp    %ecx,%eax
  8102d8:	72 c6                	jb     8102a0 <malloc+0xc6>
  8102da:	eb 79                	jmp    810355 <malloc+0x17b>
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
  8102dc:	be 00 00 00 08       	mov    $0x8000000,%esi
  8102e1:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
			if (++nwrap == 2)
  8102e5:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  8102e9:	75 a9                	jne    810294 <malloc+0xba>
  8102eb:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  8102f2:	00 00 08 
				return 0;	/* out of address space */
  8102f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8102fa:	e9 b3 00 00 00       	jmp    8103b2 <malloc+0x1d8>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  8102ff:	8d be 00 10 00 00    	lea    0x1000(%esi),%edi
  810305:	39 df                	cmp    %ebx,%edi
  810307:	19 c0                	sbb    %eax,%eax
  810309:	25 00 02 00 00       	and    $0x200,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  81030e:	83 ec 04             	sub    $0x4,%esp
  810311:	83 c8 07             	or     $0x7,%eax
  810314:	50                   	push   %eax
  810315:	03 15 d4 b1 b3 00    	add    0xb3b1d4,%edx
  81031b:	52                   	push   %edx
  81031c:	6a 00                	push   $0x0
  81031e:	e8 8c eb ff ff       	call   80eeaf <sys_page_alloc>
  810323:	83 c4 10             	add    $0x10,%esp
  810326:	85 c0                	test   %eax,%eax
  810328:	78 20                	js     81034a <malloc+0x170>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  81032a:	89 fe                	mov    %edi,%esi
  81032c:	eb 3a                	jmp    810368 <malloc+0x18e>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
				sys_page_unmap(0, mptr + i);
  81032e:	83 ec 08             	sub    $0x8,%esp
  810331:	89 f0                	mov    %esi,%eax
  810333:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  810339:	50                   	push   %eax
  81033a:	6a 00                	push   $0x0
  81033c:	e8 f3 eb ff ff       	call   80ef34 <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  810341:	81 ee 00 10 00 00    	sub    $0x1000,%esi
  810347:	83 c4 10             	add    $0x10,%esp
  81034a:	85 f6                	test   %esi,%esi
  81034c:	79 e0                	jns    81032e <malloc+0x154>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  81034e:	b8 00 00 00 00       	mov    $0x0,%eax
  810353:	eb 5d                	jmp    8103b2 <malloc+0x1d8>
  810355:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  810359:	74 08                	je     810363 <malloc+0x189>
  81035b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  81035e:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  810363:	be 00 00 00 00       	mov    $0x0,%esi
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  810368:	89 f2                	mov    %esi,%edx
  81036a:	39 f3                	cmp    %esi,%ebx
  81036c:	77 91                	ja     8102ff <malloc+0x125>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  81036e:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  810373:	c7 44 30 fc 02 00 00 	movl   $0x2,-0x4(%eax,%esi,1)
  81037a:	00 
	v = mptr;
	mptr += n;
  81037b:	8b 55 dc             	mov    -0x24(%ebp),%edx
  81037e:	01 c2                	add    %eax,%edx
  810380:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
	return v;
  810386:	eb 2a                	jmp    8103b2 <malloc+0x1d8>
		mptr = mbegin;

	n = ROUNDUP(n, 4);

	if (n >= MAXMALLOC)
		return 0;
  810388:	b8 00 00 00 00       	mov    $0x0,%eax
  81038d:	eb 23                	jmp    8103b2 <malloc+0x1d8>
  81038f:	b8 00 00 00 00       	mov    $0x0,%eax
  810394:	eb 1c                	jmp    8103b2 <malloc+0x1d8>
  810396:	8d 86 00 10 00 00    	lea    0x1000(%esi),%eax
  81039c:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
  8103a0:	89 c6                	mov    %eax,%esi
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  8103a2:	3d 00 00 00 10       	cmp    $0x10000000,%eax
  8103a7:	0f 85 e7 fe ff ff    	jne    810294 <malloc+0xba>
  8103ad:	e9 2a ff ff ff       	jmp    8102dc <malloc+0x102>
	ref = (uint32_t*) (mptr + i - 4);
	*ref = 2;	/* reference for mptr, reference for returned block */
	v = mptr;
	mptr += n;
	return v;
}
  8103b2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8103b5:	5b                   	pop    %ebx
  8103b6:	5e                   	pop    %esi
  8103b7:	5f                   	pop    %edi
  8103b8:	5d                   	pop    %ebp
  8103b9:	c3                   	ret    

008103ba <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  8103ba:	55                   	push   %ebp
  8103bb:	89 e5                	mov    %esp,%ebp
  8103bd:	56                   	push   %esi
  8103be:	53                   	push   %ebx
  8103bf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  8103c2:	83 ec 0c             	sub    $0xc,%esp
  8103c5:	ff 75 08             	pushl  0x8(%ebp)
  8103c8:	e8 0a f1 ff ff       	call   80f4d7 <fd2data>
  8103cd:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  8103cf:	83 c4 08             	add    $0x8,%esp
  8103d2:	68 f5 36 81 00       	push   $0x8136f5
  8103d7:	53                   	push   %ebx
  8103d8:	e8 cf e6 ff ff       	call   80eaac <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  8103dd:	8b 46 04             	mov    0x4(%esi),%eax
  8103e0:	2b 06                	sub    (%esi),%eax
  8103e2:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  8103e8:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  8103ef:	00 00 00 
	stat->st_dev = &devpipe;
  8103f2:	c7 83 88 00 00 00 24 	movl   $0x814324,0x88(%ebx)
  8103f9:	43 81 00 
	return 0;
}
  8103fc:	b8 00 00 00 00       	mov    $0x0,%eax
  810401:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810404:	5b                   	pop    %ebx
  810405:	5e                   	pop    %esi
  810406:	5d                   	pop    %ebp
  810407:	c3                   	ret    

00810408 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  810408:	55                   	push   %ebp
  810409:	89 e5                	mov    %esp,%ebp
  81040b:	53                   	push   %ebx
  81040c:	83 ec 0c             	sub    $0xc,%esp
  81040f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  810412:	53                   	push   %ebx
  810413:	6a 00                	push   $0x0
  810415:	e8 1a eb ff ff       	call   80ef34 <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  81041a:	89 1c 24             	mov    %ebx,(%esp)
  81041d:	e8 b5 f0 ff ff       	call   80f4d7 <fd2data>
  810422:	83 c4 08             	add    $0x8,%esp
  810425:	50                   	push   %eax
  810426:	6a 00                	push   $0x0
  810428:	e8 07 eb ff ff       	call   80ef34 <sys_page_unmap>
}
  81042d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810430:	c9                   	leave  
  810431:	c3                   	ret    

00810432 <_pipeisclosed>:
	return r;
}

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  810432:	55                   	push   %ebp
  810433:	89 e5                	mov    %esp,%ebp
  810435:	57                   	push   %edi
  810436:	56                   	push   %esi
  810437:	53                   	push   %ebx
  810438:	83 ec 1c             	sub    $0x1c,%esp
  81043b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  81043e:	89 d7                	mov    %edx,%edi
	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  810440:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  810445:	8b 70 58             	mov    0x58(%eax),%esi
		ret = pageref(fd) == pageref(p);
  810448:	83 ec 0c             	sub    $0xc,%esp
  81044b:	ff 75 e0             	pushl  -0x20(%ebp)
  81044e:	e8 b1 04 00 00       	call   810904 <pageref>
  810453:	89 c3                	mov    %eax,%ebx
  810455:	89 3c 24             	mov    %edi,(%esp)
  810458:	e8 a7 04 00 00       	call   810904 <pageref>
  81045d:	83 c4 10             	add    $0x10,%esp
  810460:	39 c3                	cmp    %eax,%ebx
  810462:	0f 94 c1             	sete   %cl
  810465:	0f b6 c9             	movzbl %cl,%ecx
  810468:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		nn = thisenv->env_runs;
  81046b:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  810471:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  810474:	39 ce                	cmp    %ecx,%esi
  810476:	74 1b                	je     810493 <_pipeisclosed+0x61>
			return ret;
		if (n != nn && ret == 1)
  810478:	39 c3                	cmp    %eax,%ebx
  81047a:	75 c4                	jne    810440 <_pipeisclosed+0xe>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  81047c:	8b 42 58             	mov    0x58(%edx),%eax
  81047f:	ff 75 e4             	pushl  -0x1c(%ebp)
  810482:	50                   	push   %eax
  810483:	56                   	push   %esi
  810484:	68 fc 36 81 00       	push   $0x8136fc
  810489:	e8 99 e0 ff ff       	call   80e527 <cprintf>
  81048e:	83 c4 10             	add    $0x10,%esp
  810491:	eb ad                	jmp    810440 <_pipeisclosed+0xe>
	}
}
  810493:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810496:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810499:	5b                   	pop    %ebx
  81049a:	5e                   	pop    %esi
  81049b:	5f                   	pop    %edi
  81049c:	5d                   	pop    %ebp
  81049d:	c3                   	ret    

0081049e <devpipe_write>:
	return i;
}

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  81049e:	55                   	push   %ebp
  81049f:	89 e5                	mov    %esp,%ebp
  8104a1:	57                   	push   %edi
  8104a2:	56                   	push   %esi
  8104a3:	53                   	push   %ebx
  8104a4:	83 ec 28             	sub    $0x28,%esp
  8104a7:	8b 75 08             	mov    0x8(%ebp),%esi
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  8104aa:	56                   	push   %esi
  8104ab:	e8 27 f0 ff ff       	call   80f4d7 <fd2data>
  8104b0:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8104b2:	83 c4 10             	add    $0x10,%esp
  8104b5:	bf 00 00 00 00       	mov    $0x0,%edi
  8104ba:	eb 4b                	jmp    810507 <devpipe_write+0x69>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  8104bc:	89 da                	mov    %ebx,%edx
  8104be:	89 f0                	mov    %esi,%eax
  8104c0:	e8 6d ff ff ff       	call   810432 <_pipeisclosed>
  8104c5:	85 c0                	test   %eax,%eax
  8104c7:	75 48                	jne    810511 <devpipe_write+0x73>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  8104c9:	e8 c2 e9 ff ff       	call   80ee90 <sys_yield>
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  8104ce:	8b 43 04             	mov    0x4(%ebx),%eax
  8104d1:	8b 0b                	mov    (%ebx),%ecx
  8104d3:	8d 51 20             	lea    0x20(%ecx),%edx
  8104d6:	39 d0                	cmp    %edx,%eax
  8104d8:	73 e2                	jae    8104bc <devpipe_write+0x1e>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  8104da:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8104dd:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  8104e1:	88 4d e7             	mov    %cl,-0x19(%ebp)
  8104e4:	89 c2                	mov    %eax,%edx
  8104e6:	c1 fa 1f             	sar    $0x1f,%edx
  8104e9:	89 d1                	mov    %edx,%ecx
  8104eb:	c1 e9 1b             	shr    $0x1b,%ecx
  8104ee:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  8104f1:	83 e2 1f             	and    $0x1f,%edx
  8104f4:	29 ca                	sub    %ecx,%edx
  8104f6:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  8104fa:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  8104fe:	83 c0 01             	add    $0x1,%eax
  810501:	89 43 04             	mov    %eax,0x4(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  810504:	83 c7 01             	add    $0x1,%edi
  810507:	3b 7d 10             	cmp    0x10(%ebp),%edi
  81050a:	75 c2                	jne    8104ce <devpipe_write+0x30>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  81050c:	8b 45 10             	mov    0x10(%ebp),%eax
  81050f:	eb 05                	jmp    810516 <devpipe_write+0x78>
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
				return 0;
  810511:	b8 00 00 00 00       	mov    $0x0,%eax
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
}
  810516:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810519:	5b                   	pop    %ebx
  81051a:	5e                   	pop    %esi
  81051b:	5f                   	pop    %edi
  81051c:	5d                   	pop    %ebp
  81051d:	c3                   	ret    

0081051e <devpipe_read>:
	return _pipeisclosed(fd, p);
}

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  81051e:	55                   	push   %ebp
  81051f:	89 e5                	mov    %esp,%ebp
  810521:	57                   	push   %edi
  810522:	56                   	push   %esi
  810523:	53                   	push   %ebx
  810524:	83 ec 18             	sub    $0x18,%esp
  810527:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  81052a:	57                   	push   %edi
  81052b:	e8 a7 ef ff ff       	call   80f4d7 <fd2data>
  810530:	89 c6                	mov    %eax,%esi
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  810532:	83 c4 10             	add    $0x10,%esp
  810535:	bb 00 00 00 00       	mov    $0x0,%ebx
  81053a:	eb 3d                	jmp    810579 <devpipe_read+0x5b>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  81053c:	85 db                	test   %ebx,%ebx
  81053e:	74 04                	je     810544 <devpipe_read+0x26>
				return i;
  810540:	89 d8                	mov    %ebx,%eax
  810542:	eb 44                	jmp    810588 <devpipe_read+0x6a>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  810544:	89 f2                	mov    %esi,%edx
  810546:	89 f8                	mov    %edi,%eax
  810548:	e8 e5 fe ff ff       	call   810432 <_pipeisclosed>
  81054d:	85 c0                	test   %eax,%eax
  81054f:	75 32                	jne    810583 <devpipe_read+0x65>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  810551:	e8 3a e9 ff ff       	call   80ee90 <sys_yield>
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  810556:	8b 06                	mov    (%esi),%eax
  810558:	3b 46 04             	cmp    0x4(%esi),%eax
  81055b:	74 df                	je     81053c <devpipe_read+0x1e>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  81055d:	99                   	cltd   
  81055e:	c1 ea 1b             	shr    $0x1b,%edx
  810561:	01 d0                	add    %edx,%eax
  810563:	83 e0 1f             	and    $0x1f,%eax
  810566:	29 d0                	sub    %edx,%eax
  810568:	0f b6 44 06 08       	movzbl 0x8(%esi,%eax,1),%eax
  81056d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810570:	88 04 19             	mov    %al,(%ecx,%ebx,1)
		p->p_rpos++;
  810573:	83 06 01             	addl   $0x1,(%esi)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  810576:	83 c3 01             	add    $0x1,%ebx
  810579:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  81057c:	75 d8                	jne    810556 <devpipe_read+0x38>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  81057e:	8b 45 10             	mov    0x10(%ebp),%eax
  810581:	eb 05                	jmp    810588 <devpipe_read+0x6a>
			// if we got any data, return it
			if (i > 0)
				return i;
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
				return 0;
  810583:	b8 00 00 00 00       	mov    $0x0,%eax
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
}
  810588:	8d 65 f4             	lea    -0xc(%ebp),%esp
  81058b:	5b                   	pop    %ebx
  81058c:	5e                   	pop    %esi
  81058d:	5f                   	pop    %edi
  81058e:	5d                   	pop    %ebp
  81058f:	c3                   	ret    

00810590 <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  810590:	55                   	push   %ebp
  810591:	89 e5                	mov    %esp,%ebp
  810593:	56                   	push   %esi
  810594:	53                   	push   %ebx
  810595:	83 ec 1c             	sub    $0x1c,%esp
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  810598:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81059b:	50                   	push   %eax
  81059c:	e8 4d ef ff ff       	call   80f4ee <fd_alloc>
  8105a1:	83 c4 10             	add    $0x10,%esp
  8105a4:	89 c2                	mov    %eax,%edx
  8105a6:	85 c0                	test   %eax,%eax
  8105a8:	0f 88 2c 01 00 00    	js     8106da <pipe+0x14a>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8105ae:	83 ec 04             	sub    $0x4,%esp
  8105b1:	68 07 04 00 00       	push   $0x407
  8105b6:	ff 75 f4             	pushl  -0xc(%ebp)
  8105b9:	6a 00                	push   $0x0
  8105bb:	e8 ef e8 ff ff       	call   80eeaf <sys_page_alloc>
  8105c0:	83 c4 10             	add    $0x10,%esp
  8105c3:	89 c2                	mov    %eax,%edx
  8105c5:	85 c0                	test   %eax,%eax
  8105c7:	0f 88 0d 01 00 00    	js     8106da <pipe+0x14a>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  8105cd:	83 ec 0c             	sub    $0xc,%esp
  8105d0:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8105d3:	50                   	push   %eax
  8105d4:	e8 15 ef ff ff       	call   80f4ee <fd_alloc>
  8105d9:	89 c3                	mov    %eax,%ebx
  8105db:	83 c4 10             	add    $0x10,%esp
  8105de:	85 c0                	test   %eax,%eax
  8105e0:	0f 88 e2 00 00 00    	js     8106c8 <pipe+0x138>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8105e6:	83 ec 04             	sub    $0x4,%esp
  8105e9:	68 07 04 00 00       	push   $0x407
  8105ee:	ff 75 f0             	pushl  -0x10(%ebp)
  8105f1:	6a 00                	push   $0x0
  8105f3:	e8 b7 e8 ff ff       	call   80eeaf <sys_page_alloc>
  8105f8:	89 c3                	mov    %eax,%ebx
  8105fa:	83 c4 10             	add    $0x10,%esp
  8105fd:	85 c0                	test   %eax,%eax
  8105ff:	0f 88 c3 00 00 00    	js     8106c8 <pipe+0x138>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  810605:	83 ec 0c             	sub    $0xc,%esp
  810608:	ff 75 f4             	pushl  -0xc(%ebp)
  81060b:	e8 c7 ee ff ff       	call   80f4d7 <fd2data>
  810610:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810612:	83 c4 0c             	add    $0xc,%esp
  810615:	68 07 04 00 00       	push   $0x407
  81061a:	50                   	push   %eax
  81061b:	6a 00                	push   $0x0
  81061d:	e8 8d e8 ff ff       	call   80eeaf <sys_page_alloc>
  810622:	89 c3                	mov    %eax,%ebx
  810624:	83 c4 10             	add    $0x10,%esp
  810627:	85 c0                	test   %eax,%eax
  810629:	0f 88 89 00 00 00    	js     8106b8 <pipe+0x128>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  81062f:	83 ec 0c             	sub    $0xc,%esp
  810632:	ff 75 f0             	pushl  -0x10(%ebp)
  810635:	e8 9d ee ff ff       	call   80f4d7 <fd2data>
  81063a:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  810641:	50                   	push   %eax
  810642:	6a 00                	push   $0x0
  810644:	56                   	push   %esi
  810645:	6a 00                	push   $0x0
  810647:	e8 a6 e8 ff ff       	call   80eef2 <sys_page_map>
  81064c:	89 c3                	mov    %eax,%ebx
  81064e:	83 c4 20             	add    $0x20,%esp
  810651:	85 c0                	test   %eax,%eax
  810653:	78 55                	js     8106aa <pipe+0x11a>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  810655:	8b 15 24 43 81 00    	mov    0x814324,%edx
  81065b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81065e:	89 10                	mov    %edx,(%eax)
	fd0->fd_omode = O_RDONLY;
  810660:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810663:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	fd1->fd_dev_id = devpipe.dev_id;
  81066a:	8b 15 24 43 81 00    	mov    0x814324,%edx
  810670:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810673:	89 10                	mov    %edx,(%eax)
	fd1->fd_omode = O_WRONLY;
  810675:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810678:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  81067f:	83 ec 0c             	sub    $0xc,%esp
  810682:	ff 75 f4             	pushl  -0xc(%ebp)
  810685:	e8 3d ee ff ff       	call   80f4c7 <fd2num>
  81068a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81068d:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  81068f:	83 c4 04             	add    $0x4,%esp
  810692:	ff 75 f0             	pushl  -0x10(%ebp)
  810695:	e8 2d ee ff ff       	call   80f4c7 <fd2num>
  81069a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81069d:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  8106a0:	83 c4 10             	add    $0x10,%esp
  8106a3:	ba 00 00 00 00       	mov    $0x0,%edx
  8106a8:	eb 30                	jmp    8106da <pipe+0x14a>

    err3:
	sys_page_unmap(0, va);
  8106aa:	83 ec 08             	sub    $0x8,%esp
  8106ad:	56                   	push   %esi
  8106ae:	6a 00                	push   $0x0
  8106b0:	e8 7f e8 ff ff       	call   80ef34 <sys_page_unmap>
  8106b5:	83 c4 10             	add    $0x10,%esp
    err2:
	sys_page_unmap(0, fd1);
  8106b8:	83 ec 08             	sub    $0x8,%esp
  8106bb:	ff 75 f0             	pushl  -0x10(%ebp)
  8106be:	6a 00                	push   $0x0
  8106c0:	e8 6f e8 ff ff       	call   80ef34 <sys_page_unmap>
  8106c5:	83 c4 10             	add    $0x10,%esp
    err1:
	sys_page_unmap(0, fd0);
  8106c8:	83 ec 08             	sub    $0x8,%esp
  8106cb:	ff 75 f4             	pushl  -0xc(%ebp)
  8106ce:	6a 00                	push   $0x0
  8106d0:	e8 5f e8 ff ff       	call   80ef34 <sys_page_unmap>
  8106d5:	83 c4 10             	add    $0x10,%esp
  8106d8:	89 da                	mov    %ebx,%edx
    err:
	return r;
}
  8106da:	89 d0                	mov    %edx,%eax
  8106dc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8106df:	5b                   	pop    %ebx
  8106e0:	5e                   	pop    %esi
  8106e1:	5d                   	pop    %ebp
  8106e2:	c3                   	ret    

008106e3 <pipeisclosed>:
	}
}

int
pipeisclosed(int fdnum)
{
  8106e3:	55                   	push   %ebp
  8106e4:	89 e5                	mov    %esp,%ebp
  8106e6:	83 ec 20             	sub    $0x20,%esp
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8106e9:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8106ec:	50                   	push   %eax
  8106ed:	ff 75 08             	pushl  0x8(%ebp)
  8106f0:	e8 48 ee ff ff       	call   80f53d <fd_lookup>
  8106f5:	83 c4 10             	add    $0x10,%esp
  8106f8:	85 c0                	test   %eax,%eax
  8106fa:	78 18                	js     810714 <pipeisclosed+0x31>
		return r;
	p = (struct Pipe*) fd2data(fd);
  8106fc:	83 ec 0c             	sub    $0xc,%esp
  8106ff:	ff 75 f4             	pushl  -0xc(%ebp)
  810702:	e8 d0 ed ff ff       	call   80f4d7 <fd2data>
	return _pipeisclosed(fd, p);
  810707:	89 c2                	mov    %eax,%edx
  810709:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81070c:	e8 21 fd ff ff       	call   810432 <_pipeisclosed>
  810711:	83 c4 10             	add    $0x10,%esp
}
  810714:	c9                   	leave  
  810715:	c3                   	ret    

00810716 <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  810716:	55                   	push   %ebp
  810717:	89 e5                	mov    %esp,%ebp
	USED(fd);

	return 0;
}
  810719:	b8 00 00 00 00       	mov    $0x0,%eax
  81071e:	5d                   	pop    %ebp
  81071f:	c3                   	ret    

00810720 <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  810720:	55                   	push   %ebp
  810721:	89 e5                	mov    %esp,%ebp
  810723:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  810726:	68 14 37 81 00       	push   $0x813714
  81072b:	ff 75 0c             	pushl  0xc(%ebp)
  81072e:	e8 79 e3 ff ff       	call   80eaac <strcpy>
	return 0;
}
  810733:	b8 00 00 00 00       	mov    $0x0,%eax
  810738:	c9                   	leave  
  810739:	c3                   	ret    

0081073a <devcons_write>:
	return 1;
}

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  81073a:	55                   	push   %ebp
  81073b:	89 e5                	mov    %esp,%ebp
  81073d:	57                   	push   %edi
  81073e:	56                   	push   %esi
  81073f:	53                   	push   %ebx
  810740:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  810746:	be 00 00 00 00       	mov    $0x0,%esi
		m = n - tot;
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  81074b:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  810751:	eb 2d                	jmp    810780 <devcons_write+0x46>
		m = n - tot;
  810753:	8b 5d 10             	mov    0x10(%ebp),%ebx
  810756:	29 f3                	sub    %esi,%ebx
		if (m > sizeof(buf) - 1)
  810758:	83 fb 7f             	cmp    $0x7f,%ebx
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
		m = n - tot;
  81075b:	ba 7f 00 00 00       	mov    $0x7f,%edx
  810760:	0f 47 da             	cmova  %edx,%ebx
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  810763:	83 ec 04             	sub    $0x4,%esp
  810766:	53                   	push   %ebx
  810767:	03 45 0c             	add    0xc(%ebp),%eax
  81076a:	50                   	push   %eax
  81076b:	57                   	push   %edi
  81076c:	e8 cd e4 ff ff       	call   80ec3e <memmove>
		sys_cputs(buf, m);
  810771:	83 c4 08             	add    $0x8,%esp
  810774:	53                   	push   %ebx
  810775:	57                   	push   %edi
  810776:	e8 78 e6 ff ff       	call   80edf3 <sys_cputs>
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  81077b:	01 de                	add    %ebx,%esi
  81077d:	83 c4 10             	add    $0x10,%esp
  810780:	89 f0                	mov    %esi,%eax
  810782:	3b 75 10             	cmp    0x10(%ebp),%esi
  810785:	72 cc                	jb     810753 <devcons_write+0x19>
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
}
  810787:	8d 65 f4             	lea    -0xc(%ebp),%esp
  81078a:	5b                   	pop    %ebx
  81078b:	5e                   	pop    %esi
  81078c:	5f                   	pop    %edi
  81078d:	5d                   	pop    %ebp
  81078e:	c3                   	ret    

0081078f <devcons_read>:
	return fd2num(fd);
}

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  81078f:	55                   	push   %ebp
  810790:	89 e5                	mov    %esp,%ebp
  810792:	83 ec 08             	sub    $0x8,%esp
  810795:	b8 00 00 00 00       	mov    $0x0,%eax
	int c;

	if (n == 0)
  81079a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  81079e:	74 2a                	je     8107ca <devcons_read+0x3b>
  8107a0:	eb 05                	jmp    8107a7 <devcons_read+0x18>
		return 0;

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  8107a2:	e8 e9 e6 ff ff       	call   80ee90 <sys_yield>
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  8107a7:	e8 65 e6 ff ff       	call   80ee11 <sys_cgetc>
  8107ac:	85 c0                	test   %eax,%eax
  8107ae:	74 f2                	je     8107a2 <devcons_read+0x13>
		sys_yield();
	if (c < 0)
  8107b0:	85 c0                	test   %eax,%eax
  8107b2:	78 16                	js     8107ca <devcons_read+0x3b>
		return c;
	if (c == 0x04)	// ctl-d is eof
  8107b4:	83 f8 04             	cmp    $0x4,%eax
  8107b7:	74 0c                	je     8107c5 <devcons_read+0x36>
		return 0;
	*(char*)vbuf = c;
  8107b9:	8b 55 0c             	mov    0xc(%ebp),%edx
  8107bc:	88 02                	mov    %al,(%edx)
	return 1;
  8107be:	b8 01 00 00 00       	mov    $0x1,%eax
  8107c3:	eb 05                	jmp    8107ca <devcons_read+0x3b>
	while ((c = sys_cgetc()) == 0)
		sys_yield();
	if (c < 0)
		return c;
	if (c == 0x04)	// ctl-d is eof
		return 0;
  8107c5:	b8 00 00 00 00       	mov    $0x0,%eax
	*(char*)vbuf = c;
	return 1;
}
  8107ca:	c9                   	leave  
  8107cb:	c3                   	ret    

008107cc <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  8107cc:	55                   	push   %ebp
  8107cd:	89 e5                	mov    %esp,%ebp
  8107cf:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  8107d2:	8b 45 08             	mov    0x8(%ebp),%eax
  8107d5:	88 45 f7             	mov    %al,-0x9(%ebp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  8107d8:	6a 01                	push   $0x1
  8107da:	8d 45 f7             	lea    -0x9(%ebp),%eax
  8107dd:	50                   	push   %eax
  8107de:	e8 10 e6 ff ff       	call   80edf3 <sys_cputs>
}
  8107e3:	83 c4 10             	add    $0x10,%esp
  8107e6:	c9                   	leave  
  8107e7:	c3                   	ret    

008107e8 <getchar>:

int
getchar(void)
{
  8107e8:	55                   	push   %ebp
  8107e9:	89 e5                	mov    %esp,%ebp
  8107eb:	83 ec 1c             	sub    $0x1c,%esp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  8107ee:	6a 01                	push   $0x1
  8107f0:	8d 45 f7             	lea    -0x9(%ebp),%eax
  8107f3:	50                   	push   %eax
  8107f4:	6a 00                	push   $0x0
  8107f6:	e8 a8 ef ff ff       	call   80f7a3 <read>
	if (r < 0)
  8107fb:	83 c4 10             	add    $0x10,%esp
  8107fe:	85 c0                	test   %eax,%eax
  810800:	78 0f                	js     810811 <getchar+0x29>
		return r;
	if (r < 1)
  810802:	85 c0                	test   %eax,%eax
  810804:	7e 06                	jle    81080c <getchar+0x24>
		return -E_EOF;
	return c;
  810806:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  81080a:	eb 05                	jmp    810811 <getchar+0x29>
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
	if (r < 0)
		return r;
	if (r < 1)
		return -E_EOF;
  81080c:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
	return c;
}
  810811:	c9                   	leave  
  810812:	c3                   	ret    

00810813 <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  810813:	55                   	push   %ebp
  810814:	89 e5                	mov    %esp,%ebp
  810816:	83 ec 20             	sub    $0x20,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810819:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81081c:	50                   	push   %eax
  81081d:	ff 75 08             	pushl  0x8(%ebp)
  810820:	e8 18 ed ff ff       	call   80f53d <fd_lookup>
  810825:	83 c4 10             	add    $0x10,%esp
  810828:	85 c0                	test   %eax,%eax
  81082a:	78 11                	js     81083d <iscons+0x2a>
		return r;
	return fd->fd_dev_id == devcons.dev_id;
  81082c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81082f:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810835:	39 10                	cmp    %edx,(%eax)
  810837:	0f 94 c0             	sete   %al
  81083a:	0f b6 c0             	movzbl %al,%eax
}
  81083d:	c9                   	leave  
  81083e:	c3                   	ret    

0081083f <opencons>:

int
opencons(void)
{
  81083f:	55                   	push   %ebp
  810840:	89 e5                	mov    %esp,%ebp
  810842:	83 ec 24             	sub    $0x24,%esp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  810845:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810848:	50                   	push   %eax
  810849:	e8 a0 ec ff ff       	call   80f4ee <fd_alloc>
  81084e:	83 c4 10             	add    $0x10,%esp
		return r;
  810851:	89 c2                	mov    %eax,%edx
opencons(void)
{
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  810853:	85 c0                	test   %eax,%eax
  810855:	78 3e                	js     810895 <opencons+0x56>
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  810857:	83 ec 04             	sub    $0x4,%esp
  81085a:	68 07 04 00 00       	push   $0x407
  81085f:	ff 75 f4             	pushl  -0xc(%ebp)
  810862:	6a 00                	push   $0x0
  810864:	e8 46 e6 ff ff       	call   80eeaf <sys_page_alloc>
  810869:	83 c4 10             	add    $0x10,%esp
		return r;
  81086c:	89 c2                	mov    %eax,%edx
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  81086e:	85 c0                	test   %eax,%eax
  810870:	78 23                	js     810895 <opencons+0x56>
		return r;
	fd->fd_dev_id = devcons.dev_id;
  810872:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810878:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81087b:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  81087d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810880:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  810887:	83 ec 0c             	sub    $0xc,%esp
  81088a:	50                   	push   %eax
  81088b:	e8 37 ec ff ff       	call   80f4c7 <fd2num>
  810890:	89 c2                	mov    %eax,%edx
  810892:	83 c4 10             	add    $0x10,%esp
}
  810895:	89 d0                	mov    %edx,%eax
  810897:	c9                   	leave  
  810898:	c3                   	ret    

00810899 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  810899:	55                   	push   %ebp
  81089a:	89 e5                	mov    %esp,%ebp
  81089c:	83 ec 08             	sub    $0x8,%esp
	int r;

	if (_pgfault_handler == 0) {
  81089f:	83 3d 00 e0 b3 00 00 	cmpl   $0x0,0xb3e000
  8108a6:	75 2e                	jne    8108d6 <set_pgfault_handler+0x3d>
		// First time through!
		// LAB 4: Your code here.
		// panic("set_pgfault_handler not implemented");

		sys_page_alloc(sys_getenvid(), (void *) (UXSTACKTOP - PGSIZE), PTE_SYSCALL);
  8108a8:	e8 c4 e5 ff ff       	call   80ee71 <sys_getenvid>
  8108ad:	83 ec 04             	sub    $0x4,%esp
  8108b0:	68 07 0e 00 00       	push   $0xe07
  8108b5:	68 00 f0 bf ee       	push   $0xeebff000
  8108ba:	50                   	push   %eax
  8108bb:	e8 ef e5 ff ff       	call   80eeaf <sys_page_alloc>
		sys_env_set_pgfault_upcall(sys_getenvid(), _pgfault_upcall);
  8108c0:	e8 ac e5 ff ff       	call   80ee71 <sys_getenvid>
  8108c5:	83 c4 08             	add    $0x8,%esp
  8108c8:	68 e0 08 81 00       	push   $0x8108e0
  8108cd:	50                   	push   %eax
  8108ce:	e8 27 e7 ff ff       	call   80effa <sys_env_set_pgfault_upcall>
  8108d3:	83 c4 10             	add    $0x10,%esp
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  8108d6:	8b 45 08             	mov    0x8(%ebp),%eax
  8108d9:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
}
  8108de:	c9                   	leave  
  8108df:	c3                   	ret    

008108e0 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  8108e0:	54                   	push   %esp
	movl _pgfault_handler, %eax
  8108e1:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
	call *%eax
  8108e6:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  8108e8:	83 c4 04             	add    $0x4,%esp
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.

	movl 48(%esp), %eax		// trap-time esp
  8108eb:	8b 44 24 30          	mov    0x30(%esp),%eax
	movl 40(%esp), %ebx		// trap-time eip
  8108ef:	8b 5c 24 28          	mov    0x28(%esp),%ebx

	// load eip into esp-4
	// in order to return to trap-time eip later, in the meantime not changing trap-time esp
	movl %ebx, -4(%eax)	
  8108f3:	89 58 fc             	mov    %ebx,-0x4(%eax)

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.

	addl $8, %esp 			// esp now points to trap-time registers
  8108f6:	83 c4 08             	add    $0x8,%esp
	popal					// pop to all registers
  8108f9:	61                   	popa   
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.

	addl $4, %esp			// esp now points to trap-time eflags
  8108fa:	83 c4 04             	add    $0x4,%esp
	popfl					// pop to eflags
  8108fd:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.

	popl %esp				// pop to esp
  8108fe:	5c                   	pop    %esp
	// subl $4, %esp		// arithmetic operation will change eflags!!!
	lea -4(%esp), %esp		// subl $4, %esp
  8108ff:	8d 64 24 fc          	lea    -0x4(%esp),%esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.

	ret
  810903:	c3                   	ret    

00810904 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  810904:	55                   	push   %ebp
  810905:	89 e5                	mov    %esp,%ebp
  810907:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  81090a:	89 d0                	mov    %edx,%eax
  81090c:	c1 e8 16             	shr    $0x16,%eax
  81090f:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
		return 0;
  810916:	b8 00 00 00 00       	mov    $0x0,%eax
int
pageref(void *v)
{
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  81091b:	f6 c1 01             	test   $0x1,%cl
  81091e:	74 1d                	je     81093d <pageref+0x39>
		return 0;
	pte = uvpt[PGNUM(v)];
  810920:	c1 ea 0c             	shr    $0xc,%edx
  810923:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(pte & PTE_P))
  81092a:	f6 c2 01             	test   $0x1,%dl
  81092d:	74 0e                	je     81093d <pageref+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  81092f:	c1 ea 0c             	shr    $0xc,%edx
  810932:	0f b7 04 d5 04 00 00 	movzwl -0x10fffffc(,%edx,8),%eax
  810939:	ef 
  81093a:	0f b7 c0             	movzwl %ax,%eax
}
  81093d:	5d                   	pop    %ebp
  81093e:	c3                   	ret    
  81093f:	90                   	nop

00810940 <__udivdi3>:
  810940:	55                   	push   %ebp
  810941:	57                   	push   %edi
  810942:	56                   	push   %esi
  810943:	53                   	push   %ebx
  810944:	83 ec 1c             	sub    $0x1c,%esp
  810947:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  81094b:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  81094f:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  810953:	8b 7c 24 38          	mov    0x38(%esp),%edi
  810957:	85 f6                	test   %esi,%esi
  810959:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  81095d:	89 ca                	mov    %ecx,%edx
  81095f:	89 f8                	mov    %edi,%eax
  810961:	75 3d                	jne    8109a0 <__udivdi3+0x60>
  810963:	39 cf                	cmp    %ecx,%edi
  810965:	0f 87 c5 00 00 00    	ja     810a30 <__udivdi3+0xf0>
  81096b:	85 ff                	test   %edi,%edi
  81096d:	89 fd                	mov    %edi,%ebp
  81096f:	75 0b                	jne    81097c <__udivdi3+0x3c>
  810971:	b8 01 00 00 00       	mov    $0x1,%eax
  810976:	31 d2                	xor    %edx,%edx
  810978:	f7 f7                	div    %edi
  81097a:	89 c5                	mov    %eax,%ebp
  81097c:	89 c8                	mov    %ecx,%eax
  81097e:	31 d2                	xor    %edx,%edx
  810980:	f7 f5                	div    %ebp
  810982:	89 c1                	mov    %eax,%ecx
  810984:	89 d8                	mov    %ebx,%eax
  810986:	89 cf                	mov    %ecx,%edi
  810988:	f7 f5                	div    %ebp
  81098a:	89 c3                	mov    %eax,%ebx
  81098c:	89 d8                	mov    %ebx,%eax
  81098e:	89 fa                	mov    %edi,%edx
  810990:	83 c4 1c             	add    $0x1c,%esp
  810993:	5b                   	pop    %ebx
  810994:	5e                   	pop    %esi
  810995:	5f                   	pop    %edi
  810996:	5d                   	pop    %ebp
  810997:	c3                   	ret    
  810998:	90                   	nop
  810999:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8109a0:	39 ce                	cmp    %ecx,%esi
  8109a2:	77 74                	ja     810a18 <__udivdi3+0xd8>
  8109a4:	0f bd fe             	bsr    %esi,%edi
  8109a7:	83 f7 1f             	xor    $0x1f,%edi
  8109aa:	0f 84 98 00 00 00    	je     810a48 <__udivdi3+0x108>
  8109b0:	bb 20 00 00 00       	mov    $0x20,%ebx
  8109b5:	89 f9                	mov    %edi,%ecx
  8109b7:	89 c5                	mov    %eax,%ebp
  8109b9:	29 fb                	sub    %edi,%ebx
  8109bb:	d3 e6                	shl    %cl,%esi
  8109bd:	89 d9                	mov    %ebx,%ecx
  8109bf:	d3 ed                	shr    %cl,%ebp
  8109c1:	89 f9                	mov    %edi,%ecx
  8109c3:	d3 e0                	shl    %cl,%eax
  8109c5:	09 ee                	or     %ebp,%esi
  8109c7:	89 d9                	mov    %ebx,%ecx
  8109c9:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8109cd:	89 d5                	mov    %edx,%ebp
  8109cf:	8b 44 24 08          	mov    0x8(%esp),%eax
  8109d3:	d3 ed                	shr    %cl,%ebp
  8109d5:	89 f9                	mov    %edi,%ecx
  8109d7:	d3 e2                	shl    %cl,%edx
  8109d9:	89 d9                	mov    %ebx,%ecx
  8109db:	d3 e8                	shr    %cl,%eax
  8109dd:	09 c2                	or     %eax,%edx
  8109df:	89 d0                	mov    %edx,%eax
  8109e1:	89 ea                	mov    %ebp,%edx
  8109e3:	f7 f6                	div    %esi
  8109e5:	89 d5                	mov    %edx,%ebp
  8109e7:	89 c3                	mov    %eax,%ebx
  8109e9:	f7 64 24 0c          	mull   0xc(%esp)
  8109ed:	39 d5                	cmp    %edx,%ebp
  8109ef:	72 10                	jb     810a01 <__udivdi3+0xc1>
  8109f1:	8b 74 24 08          	mov    0x8(%esp),%esi
  8109f5:	89 f9                	mov    %edi,%ecx
  8109f7:	d3 e6                	shl    %cl,%esi
  8109f9:	39 c6                	cmp    %eax,%esi
  8109fb:	73 07                	jae    810a04 <__udivdi3+0xc4>
  8109fd:	39 d5                	cmp    %edx,%ebp
  8109ff:	75 03                	jne    810a04 <__udivdi3+0xc4>
  810a01:	83 eb 01             	sub    $0x1,%ebx
  810a04:	31 ff                	xor    %edi,%edi
  810a06:	89 d8                	mov    %ebx,%eax
  810a08:	89 fa                	mov    %edi,%edx
  810a0a:	83 c4 1c             	add    $0x1c,%esp
  810a0d:	5b                   	pop    %ebx
  810a0e:	5e                   	pop    %esi
  810a0f:	5f                   	pop    %edi
  810a10:	5d                   	pop    %ebp
  810a11:	c3                   	ret    
  810a12:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810a18:	31 ff                	xor    %edi,%edi
  810a1a:	31 db                	xor    %ebx,%ebx
  810a1c:	89 d8                	mov    %ebx,%eax
  810a1e:	89 fa                	mov    %edi,%edx
  810a20:	83 c4 1c             	add    $0x1c,%esp
  810a23:	5b                   	pop    %ebx
  810a24:	5e                   	pop    %esi
  810a25:	5f                   	pop    %edi
  810a26:	5d                   	pop    %ebp
  810a27:	c3                   	ret    
  810a28:	90                   	nop
  810a29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810a30:	89 d8                	mov    %ebx,%eax
  810a32:	f7 f7                	div    %edi
  810a34:	31 ff                	xor    %edi,%edi
  810a36:	89 c3                	mov    %eax,%ebx
  810a38:	89 d8                	mov    %ebx,%eax
  810a3a:	89 fa                	mov    %edi,%edx
  810a3c:	83 c4 1c             	add    $0x1c,%esp
  810a3f:	5b                   	pop    %ebx
  810a40:	5e                   	pop    %esi
  810a41:	5f                   	pop    %edi
  810a42:	5d                   	pop    %ebp
  810a43:	c3                   	ret    
  810a44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810a48:	39 ce                	cmp    %ecx,%esi
  810a4a:	72 0c                	jb     810a58 <__udivdi3+0x118>
  810a4c:	31 db                	xor    %ebx,%ebx
  810a4e:	3b 44 24 08          	cmp    0x8(%esp),%eax
  810a52:	0f 87 34 ff ff ff    	ja     81098c <__udivdi3+0x4c>
  810a58:	bb 01 00 00 00       	mov    $0x1,%ebx
  810a5d:	e9 2a ff ff ff       	jmp    81098c <__udivdi3+0x4c>
  810a62:	66 90                	xchg   %ax,%ax
  810a64:	66 90                	xchg   %ax,%ax
  810a66:	66 90                	xchg   %ax,%ax
  810a68:	66 90                	xchg   %ax,%ax
  810a6a:	66 90                	xchg   %ax,%ax
  810a6c:	66 90                	xchg   %ax,%ax
  810a6e:	66 90                	xchg   %ax,%ax

00810a70 <__umoddi3>:
  810a70:	55                   	push   %ebp
  810a71:	57                   	push   %edi
  810a72:	56                   	push   %esi
  810a73:	53                   	push   %ebx
  810a74:	83 ec 1c             	sub    $0x1c,%esp
  810a77:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  810a7b:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  810a7f:	8b 74 24 34          	mov    0x34(%esp),%esi
  810a83:	8b 7c 24 38          	mov    0x38(%esp),%edi
  810a87:	85 d2                	test   %edx,%edx
  810a89:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  810a8d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810a91:	89 f3                	mov    %esi,%ebx
  810a93:	89 3c 24             	mov    %edi,(%esp)
  810a96:	89 74 24 04          	mov    %esi,0x4(%esp)
  810a9a:	75 1c                	jne    810ab8 <__umoddi3+0x48>
  810a9c:	39 f7                	cmp    %esi,%edi
  810a9e:	76 50                	jbe    810af0 <__umoddi3+0x80>
  810aa0:	89 c8                	mov    %ecx,%eax
  810aa2:	89 f2                	mov    %esi,%edx
  810aa4:	f7 f7                	div    %edi
  810aa6:	89 d0                	mov    %edx,%eax
  810aa8:	31 d2                	xor    %edx,%edx
  810aaa:	83 c4 1c             	add    $0x1c,%esp
  810aad:	5b                   	pop    %ebx
  810aae:	5e                   	pop    %esi
  810aaf:	5f                   	pop    %edi
  810ab0:	5d                   	pop    %ebp
  810ab1:	c3                   	ret    
  810ab2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810ab8:	39 f2                	cmp    %esi,%edx
  810aba:	89 d0                	mov    %edx,%eax
  810abc:	77 52                	ja     810b10 <__umoddi3+0xa0>
  810abe:	0f bd ea             	bsr    %edx,%ebp
  810ac1:	83 f5 1f             	xor    $0x1f,%ebp
  810ac4:	75 5a                	jne    810b20 <__umoddi3+0xb0>
  810ac6:	3b 54 24 04          	cmp    0x4(%esp),%edx
  810aca:	0f 82 e0 00 00 00    	jb     810bb0 <__umoddi3+0x140>
  810ad0:	39 0c 24             	cmp    %ecx,(%esp)
  810ad3:	0f 86 d7 00 00 00    	jbe    810bb0 <__umoddi3+0x140>
  810ad9:	8b 44 24 08          	mov    0x8(%esp),%eax
  810add:	8b 54 24 04          	mov    0x4(%esp),%edx
  810ae1:	83 c4 1c             	add    $0x1c,%esp
  810ae4:	5b                   	pop    %ebx
  810ae5:	5e                   	pop    %esi
  810ae6:	5f                   	pop    %edi
  810ae7:	5d                   	pop    %ebp
  810ae8:	c3                   	ret    
  810ae9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810af0:	85 ff                	test   %edi,%edi
  810af2:	89 fd                	mov    %edi,%ebp
  810af4:	75 0b                	jne    810b01 <__umoddi3+0x91>
  810af6:	b8 01 00 00 00       	mov    $0x1,%eax
  810afb:	31 d2                	xor    %edx,%edx
  810afd:	f7 f7                	div    %edi
  810aff:	89 c5                	mov    %eax,%ebp
  810b01:	89 f0                	mov    %esi,%eax
  810b03:	31 d2                	xor    %edx,%edx
  810b05:	f7 f5                	div    %ebp
  810b07:	89 c8                	mov    %ecx,%eax
  810b09:	f7 f5                	div    %ebp
  810b0b:	89 d0                	mov    %edx,%eax
  810b0d:	eb 99                	jmp    810aa8 <__umoddi3+0x38>
  810b0f:	90                   	nop
  810b10:	89 c8                	mov    %ecx,%eax
  810b12:	89 f2                	mov    %esi,%edx
  810b14:	83 c4 1c             	add    $0x1c,%esp
  810b17:	5b                   	pop    %ebx
  810b18:	5e                   	pop    %esi
  810b19:	5f                   	pop    %edi
  810b1a:	5d                   	pop    %ebp
  810b1b:	c3                   	ret    
  810b1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810b20:	8b 34 24             	mov    (%esp),%esi
  810b23:	bf 20 00 00 00       	mov    $0x20,%edi
  810b28:	89 e9                	mov    %ebp,%ecx
  810b2a:	29 ef                	sub    %ebp,%edi
  810b2c:	d3 e0                	shl    %cl,%eax
  810b2e:	89 f9                	mov    %edi,%ecx
  810b30:	89 f2                	mov    %esi,%edx
  810b32:	d3 ea                	shr    %cl,%edx
  810b34:	89 e9                	mov    %ebp,%ecx
  810b36:	09 c2                	or     %eax,%edx
  810b38:	89 d8                	mov    %ebx,%eax
  810b3a:	89 14 24             	mov    %edx,(%esp)
  810b3d:	89 f2                	mov    %esi,%edx
  810b3f:	d3 e2                	shl    %cl,%edx
  810b41:	89 f9                	mov    %edi,%ecx
  810b43:	89 54 24 04          	mov    %edx,0x4(%esp)
  810b47:	8b 54 24 0c          	mov    0xc(%esp),%edx
  810b4b:	d3 e8                	shr    %cl,%eax
  810b4d:	89 e9                	mov    %ebp,%ecx
  810b4f:	89 c6                	mov    %eax,%esi
  810b51:	d3 e3                	shl    %cl,%ebx
  810b53:	89 f9                	mov    %edi,%ecx
  810b55:	89 d0                	mov    %edx,%eax
  810b57:	d3 e8                	shr    %cl,%eax
  810b59:	89 e9                	mov    %ebp,%ecx
  810b5b:	09 d8                	or     %ebx,%eax
  810b5d:	89 d3                	mov    %edx,%ebx
  810b5f:	89 f2                	mov    %esi,%edx
  810b61:	f7 34 24             	divl   (%esp)
  810b64:	89 d6                	mov    %edx,%esi
  810b66:	d3 e3                	shl    %cl,%ebx
  810b68:	f7 64 24 04          	mull   0x4(%esp)
  810b6c:	39 d6                	cmp    %edx,%esi
  810b6e:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810b72:	89 d1                	mov    %edx,%ecx
  810b74:	89 c3                	mov    %eax,%ebx
  810b76:	72 08                	jb     810b80 <__umoddi3+0x110>
  810b78:	75 11                	jne    810b8b <__umoddi3+0x11b>
  810b7a:	39 44 24 08          	cmp    %eax,0x8(%esp)
  810b7e:	73 0b                	jae    810b8b <__umoddi3+0x11b>
  810b80:	2b 44 24 04          	sub    0x4(%esp),%eax
  810b84:	1b 14 24             	sbb    (%esp),%edx
  810b87:	89 d1                	mov    %edx,%ecx
  810b89:	89 c3                	mov    %eax,%ebx
  810b8b:	8b 54 24 08          	mov    0x8(%esp),%edx
  810b8f:	29 da                	sub    %ebx,%edx
  810b91:	19 ce                	sbb    %ecx,%esi
  810b93:	89 f9                	mov    %edi,%ecx
  810b95:	89 f0                	mov    %esi,%eax
  810b97:	d3 e0                	shl    %cl,%eax
  810b99:	89 e9                	mov    %ebp,%ecx
  810b9b:	d3 ea                	shr    %cl,%edx
  810b9d:	89 e9                	mov    %ebp,%ecx
  810b9f:	d3 ee                	shr    %cl,%esi
  810ba1:	09 d0                	or     %edx,%eax
  810ba3:	89 f2                	mov    %esi,%edx
  810ba5:	83 c4 1c             	add    $0x1c,%esp
  810ba8:	5b                   	pop    %ebx
  810ba9:	5e                   	pop    %esi
  810baa:	5f                   	pop    %edi
  810bab:	5d                   	pop    %ebp
  810bac:	c3                   	ret    
  810bad:	8d 76 00             	lea    0x0(%esi),%esi
  810bb0:	29 f9                	sub    %edi,%ecx
  810bb2:	19 d6                	sbb    %edx,%esi
  810bb4:	89 74 24 04          	mov    %esi,0x4(%esp)
  810bb8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810bbc:	e9 18 ff ff ff       	jmp    810ad9 <__umoddi3+0x69>
