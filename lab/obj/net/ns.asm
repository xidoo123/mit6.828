
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 fd e2 00 00       	call   80e32e <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	55                   	push   %ebp
  800034:	89 e5                	mov    %esp,%ebp
  800036:	83 ec 14             	sub    $0x14,%esp
  800039:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  80003c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800042:	50                   	push   %eax
  800043:	e8 f4 a3 00 00       	call   80a43c <thread_wakeup>
}
  800048:	83 c4 10             	add    $0x10,%esp
  80004b:	c9                   	leave  
  80004c:	c3                   	ret    

0080004d <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  80004d:	55                   	push   %ebp
  80004e:	89 e5                	mov    %esp,%ebp
  800050:	53                   	push   %ebx
  800051:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800054:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800057:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800059:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  80005c:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80005f:	50                   	push   %eax
  800060:	68 94 00 80 00       	push   $0x800094
  800065:	51                   	push   %ecx
  800066:	6a 00                	push   $0x0
  800068:	e8 3d a4 00 00       	call   80a4aa <thread_create>
	if (r < 0)
  80006d:	83 c4 10             	add    $0x10,%esp
  800070:	85 c0                	test   %eax,%eax
  800072:	79 1b                	jns    80008f <start_timer+0x42>
		panic("cannot create timer thread: %s", e2s(r));
  800074:	83 ec 0c             	sub    $0xc,%esp
  800077:	50                   	push   %eax
  800078:	e8 5c a7 00 00       	call   80a7d9 <e2s>
  80007d:	50                   	push   %eax
  80007e:	68 e0 0a 81 00       	push   $0x810ae0
  800083:	6a 7a                	push   $0x7a
  800085:	68 15 0c 81 00       	push   $0x810c15
  80008a:	e8 ff e2 00 00       	call   80e38e <_panic>
}
  80008f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800092:	c9                   	leave  
  800093:	c3                   	ret    

00800094 <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  800094:	55                   	push   %ebp
  800095:	89 e5                	mov    %esp,%ebp
  800097:	56                   	push   %esi
  800098:	53                   	push   %ebx
	struct timer_thread *t = (struct timer_thread *) arg;
  800099:	8b 75 08             	mov    0x8(%ebp),%esi

	for (;;) {
		uint32_t cur = sys_time_msec();
  80009c:	e8 3f ef 00 00       	call   80efe0 <sys_time_msec>
  8000a1:	89 c3                	mov    %eax,%ebx

		lwip_core_lock();
  8000a3:	e8 5b a3 00 00       	call   80a403 <lwip_core_lock>
		t->func();
  8000a8:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000ab:	e8 58 a3 00 00       	call   80a408 <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  8000b0:	83 ec 04             	sub    $0x4,%esp
  8000b3:	03 1e                	add    (%esi),%ebx
  8000b5:	53                   	push   %ebx
  8000b6:	6a 00                	push   $0x0
  8000b8:	6a 00                	push   $0x0
  8000ba:	e8 94 a5 00 00       	call   80a653 <thread_wait>
  8000bf:	83 c4 10             	add    $0x10,%esp
  8000c2:	eb d8                	jmp    80009c <net_timer+0x8>

008000c4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000c4:	55                   	push   %ebp
  8000c5:	89 e5                	mov    %esp,%ebp
  8000c7:	57                   	push   %edi
  8000c8:	56                   	push   %esi
  8000c9:	53                   	push   %ebx
  8000ca:	83 ec 7c             	sub    $0x7c,%esp
  8000cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000d0:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  8000d3:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000d6:	0f 87 0b 01 00 00    	ja     8001e7 <serve_thread+0x123>
  8000dc:	8b 03                	mov    (%ebx),%eax
  8000de:	ff 24 85 c0 0c 81 00 	jmp    *0x810cc0(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000e5:	8b 46 04             	mov    0x4(%esi),%eax
  8000e8:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000eb:	83 ec 04             	sub    $0x4,%esp
  8000ee:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000f1:	50                   	push   %eax
  8000f2:	8d 45 84             	lea    -0x7c(%ebp),%eax
  8000f5:	50                   	push   %eax
  8000f6:	ff 36                	pushl  (%esi)
  8000f8:	e8 27 0d 00 00       	call   800e24 <lwip_accept>
  8000fd:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  8000ff:	83 c4 0c             	add    $0xc,%esp
  800102:	6a 14                	push   $0x14
  800104:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800107:	50                   	push   %eax
  800108:	56                   	push   %esi
  800109:	e8 70 ea 00 00       	call   80eb7e <memmove>
  80010e:	83 c4 10             	add    $0x10,%esp
  800111:	e9 ec 00 00 00       	jmp    800202 <serve_thread+0x13e>
		break;
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800116:	83 ec 04             	sub    $0x4,%esp
  800119:	ff 76 14             	pushl  0x14(%esi)
  80011c:	8d 46 04             	lea    0x4(%esi),%eax
  80011f:	50                   	push   %eax
  800120:	ff 36                	pushl  (%esi)
  800122:	e8 ac 0e 00 00       	call   800fd3 <lwip_bind>
  800127:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  800129:	83 c4 10             	add    $0x10,%esp
  80012c:	e9 d1 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800131:	83 ec 08             	sub    $0x8,%esp
  800134:	ff 76 04             	pushl  0x4(%esi)
  800137:	ff 36                	pushl  (%esi)
  800139:	e8 98 19 00 00       	call   801ad6 <lwip_shutdown>
  80013e:	89 c7                	mov    %eax,%edi
		break;
  800140:	83 c4 10             	add    $0x10,%esp
  800143:	e9 ba 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  800148:	83 ec 0c             	sub    $0xc,%esp
  80014b:	ff 36                	pushl  (%esi)
  80014d:	e8 37 0f 00 00       	call   801089 <lwip_close>
  800152:	89 c7                	mov    %eax,%edi
		break;
  800154:	83 c4 10             	add    $0x10,%esp
  800157:	e9 a6 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80015c:	83 ec 04             	sub    $0x4,%esp
  80015f:	ff 76 14             	pushl  0x14(%esi)
  800162:	8d 46 04             	lea    0x4(%esi),%eax
  800165:	50                   	push   %eax
  800166:	ff 36                	pushl  (%esi)
  800168:	e8 a5 0f 00 00       	call   801112 <lwip_connect>
  80016d:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  80016f:	83 c4 10             	add    $0x10,%esp
  800172:	e9 8b 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  800177:	83 ec 08             	sub    $0x8,%esp
  80017a:	ff 76 04             	pushl  0x4(%esi)
  80017d:	ff 36                	pushl  (%esi)
  80017f:	e8 44 10 00 00       	call   8011c8 <lwip_listen>
  800184:	89 c7                	mov    %eax,%edi
		break;
  800186:	83 c4 10             	add    $0x10,%esp
  800189:	eb 77                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  80018b:	ff 76 08             	pushl  0x8(%esi)
  80018e:	ff 76 04             	pushl  0x4(%esi)
  800191:	56                   	push   %esi
  800192:	ff 36                	pushl  (%esi)
  800194:	e8 05 13 00 00       	call   80149e <lwip_recv>
  800199:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  80019b:	83 c4 10             	add    $0x10,%esp
  80019e:	eb 62                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001a0:	ff 76 08             	pushl  0x8(%esi)
  8001a3:	ff 76 04             	pushl  0x4(%esi)
  8001a6:	8d 46 0c             	lea    0xc(%esi),%eax
  8001a9:	50                   	push   %eax
  8001aa:	ff 36                	pushl  (%esi)
  8001ac:	e8 57 14 00 00       	call   801608 <lwip_send>
  8001b1:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  8001b3:	83 c4 10             	add    $0x10,%esp
  8001b6:	eb 4a                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8001b8:	83 ec 04             	sub    $0x4,%esp
  8001bb:	ff 76 08             	pushl  0x8(%esi)
  8001be:	ff 76 04             	pushl  0x4(%esi)
  8001c1:	ff 36                	pushl  (%esi)
  8001c3:	e8 d3 14 00 00       	call   80169b <lwip_socket>
  8001c8:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  8001ca:	83 c4 10             	add    $0x10,%esp
  8001cd:	eb 33                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  8001cf:	83 ec 08             	sub    $0x8,%esp
  8001d2:	56                   	push   %esi
  8001d3:	68 00 b2 b3 00       	push   $0xb3b200
  8001d8:	e8 eb a6 00 00       	call   80a8c8 <jif_input>
		r = 0;
		break;
  8001dd:	83 c4 10             	add    $0x10,%esp
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
				req->socket.req_protocol);
		break;
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
		r = 0;
  8001e0:	bf 00 00 00 00       	mov    $0x0,%edi
		break;
  8001e5:	eb 3d                	jmp    800224 <serve_thread+0x160>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  8001e7:	83 ec 04             	sub    $0x4,%esp
  8001ea:	56                   	push   %esi
  8001eb:	ff 73 04             	pushl  0x4(%ebx)
  8001ee:	68 00 0b 81 00       	push   $0x810b00
  8001f3:	e8 6f e2 00 00       	call   80e467 <cprintf>
		r = -E_INVAL;
		break;
  8001f8:	83 c4 10             	add    $0x10,%esp
		jif_input(&nif, (void *)&req->pkt);
		r = 0;
		break;
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
  8001fb:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		break;
  800200:	eb 22                	jmp    800224 <serve_thread+0x160>
	}

	if (r == -1) {
  800202:	83 ff ff             	cmp    $0xffffffff,%edi
  800205:	75 1d                	jne    800224 <serve_thread+0x160>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800207:	ff 33                	pushl  (%ebx)
  800209:	68 20 0c 81 00       	push   $0x810c20
  80020e:	6a 64                	push   $0x64
  800210:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800213:	56                   	push   %esi
  800214:	e8 80 e7 00 00       	call   80e999 <snprintf>
		perror(buf);
  800219:	89 34 24             	mov    %esi,(%esp)
  80021c:	e8 94 a5 00 00       	call   80a7b5 <perror>
  800221:	83 c4 10             	add    $0x10,%esp
	}

	if (args->reqno != NSREQ_INPUT)
  800224:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800227:	74 10                	je     800239 <serve_thread+0x175>
		ipc_send(args->whom, r, 0, 0);
  800229:	6a 00                	push   $0x0
  80022b:	6a 00                	push   $0x0
  80022d:	57                   	push   %edi
  80022e:	ff 73 04             	pushl  0x4(%ebx)
  800231:	e8 02 f1 00 00       	call   80f338 <ipc_send>
  800236:	83 c4 10             	add    $0x10,%esp

	put_buffer(args->req);
  800239:	8b 53 08             	mov    0x8(%ebx),%edx
}

static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  80023c:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  800242:	c1 e8 0c             	shr    $0xc,%eax
  800245:	c6 80 00 50 81 00 00 	movb   $0x0,0x815000(%eax)

	if (args->reqno != NSREQ_INPUT)
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
	sys_page_unmap(0, (void*) args->req);
  80024c:	83 ec 08             	sub    $0x8,%esp
  80024f:	52                   	push   %edx
  800250:	6a 00                	push   $0x0
  800252:	e8 1d ec 00 00       	call   80ee74 <sys_page_unmap>
	free(args);
  800257:	89 1c 24             	mov    %ebx,(%esp)
  80025a:	e8 cb fd 00 00       	call   81002a <free>
}
  80025f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800262:	5b                   	pop    %ebx
  800263:	5e                   	pop    %esi
  800264:	5f                   	pop    %edi
  800265:	5d                   	pop    %ebp
  800266:	c3                   	ret    

00800267 <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800267:	55                   	push   %ebp
  800268:	89 e5                	mov    %esp,%ebp
  80026a:	56                   	push   %esi
  80026b:	53                   	push   %ebx
  80026c:	83 ec 10             	sub    $0x10,%esp
  80026f:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  800272:	e8 8c a1 00 00       	call   80a403 <lwip_core_lock>

	uint32_t done = 0;
  800277:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  80027e:	83 ec 08             	sub    $0x8,%esp
  800281:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  800284:	53                   	push   %ebx
  800285:	68 33 00 80 00       	push   $0x800033
  80028a:	e8 05 21 00 00       	call   802394 <tcpip_init>
	lwip_core_unlock();
  80028f:	e8 74 a1 00 00       	call   80a408 <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  800294:	83 c4 0c             	add    $0xc,%esp
  800297:	6a ff                	push   $0xffffffff
  800299:	6a 00                	push   $0x0
  80029b:	53                   	push   %ebx
  80029c:	e8 b2 a3 00 00       	call   80a653 <thread_wait>
	lwip_core_lock();
  8002a1:	e8 5d a1 00 00       	call   80a403 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  8002a6:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002a9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002af:	8b 45 10             	mov    0x10(%ebp),%eax
  8002b2:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002b5:	83 c4 0c             	add    $0xc,%esp
  8002b8:	68 ba 64 80 00       	push   $0x8064ba
  8002bd:	68 bc a9 80 00       	push   $0x80a9bc
  8002c2:	68 14 50 81 00       	push   $0x815014
  8002c7:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002ca:	50                   	push   %eax
  8002cb:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002ce:	50                   	push   %eax
  8002cf:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002d2:	50                   	push   %eax
  8002d3:	68 00 b2 b3 00       	push   $0xb3b200
  8002d8:	e8 9f 42 00 00       	call   80457c <netif_add>
  8002dd:	83 c4 20             	add    $0x20,%esp
  8002e0:	85 c0                	test   %eax,%eax
  8002e2:	75 14                	jne    8002f8 <serve_init+0x91>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  8002e4:	83 ec 04             	sub    $0x4,%esp
  8002e7:	68 24 0b 81 00       	push   $0x810b24
  8002ec:	6a 5c                	push   $0x5c
  8002ee:	68 15 0c 81 00       	push   $0x810c15
  8002f3:	e8 96 e0 00 00       	call   80e38e <_panic>

	netif_set_default(nif);
  8002f8:	83 ec 0c             	sub    $0xc,%esp
  8002fb:	68 00 b2 b3 00       	push   $0xb3b200
  800300:	e8 2d 43 00 00       	call   804632 <netif_set_default>
	netif_set_up(nif);
  800305:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  80030c:	e8 2e 43 00 00       	call   80463f <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  800311:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800318:	b9 2f 0c 81 00       	mov    $0x810c2f,%ecx
  80031d:	ba 87 93 80 00       	mov    $0x809387,%edx
  800322:	b8 34 50 81 00       	mov    $0x815034,%eax
  800327:	e8 21 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  80032c:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  800333:	b9 39 0c 81 00       	mov    $0x810c39,%ecx
  800338:	ba 38 56 80 00       	mov    $0x805638,%edx
  80033d:	b8 28 50 81 00       	mov    $0x815028,%eax
  800342:	e8 06 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800347:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  80034e:	b9 45 0c 81 00       	mov    $0x810c45,%ecx
  800353:	ba 32 5c 80 00       	mov    $0x805c32,%edx
  800358:	b8 1c 50 81 00       	mov    $0x81501c,%eax
  80035d:	e8 eb fc ff ff       	call   80004d <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800362:	89 34 24             	mov    %esi,(%esp)
  800365:	e8 15 72 00 00       	call   80757f <inet_ntoa>
  80036a:	50                   	push   %eax
  80036b:	0f b6 05 2a b2 b3 00 	movzbl 0xb3b22a,%eax
  800372:	50                   	push   %eax
  800373:	0f b6 05 29 b2 b3 00 	movzbl 0xb3b229,%eax
  80037a:	50                   	push   %eax
  80037b:	0f b6 05 28 b2 b3 00 	movzbl 0xb3b228,%eax
  800382:	50                   	push   %eax
  800383:	0f b6 05 27 b2 b3 00 	movzbl 0xb3b227,%eax
  80038a:	50                   	push   %eax
  80038b:	0f b6 05 26 b2 b3 00 	movzbl 0xb3b226,%eax
  800392:	50                   	push   %eax
  800393:	0f b6 05 25 b2 b3 00 	movzbl 0xb3b225,%eax
  80039a:	50                   	push   %eax
  80039b:	68 44 0b 81 00       	push   $0x810b44
  8003a0:	e8 c2 e0 00 00       	call   80e467 <cprintf>
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  8003a5:	83 c4 30             	add    $0x30,%esp
  8003a8:	e8 5b a0 00 00       	call   80a408 <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  8003ad:	83 ec 0c             	sub    $0xc,%esp
  8003b0:	68 51 0c 81 00       	push   $0x810c51
  8003b5:	e8 ad e0 00 00       	call   80e467 <cprintf>
}
  8003ba:	83 c4 10             	add    $0x10,%esp
  8003bd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003c0:	5b                   	pop    %ebx
  8003c1:	5e                   	pop    %esi
  8003c2:	5d                   	pop    %ebp
  8003c3:	c3                   	ret    

008003c4 <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  8003c4:	55                   	push   %ebp
  8003c5:	89 e5                	mov    %esp,%ebp
  8003c7:	57                   	push   %edi
  8003c8:	56                   	push   %esi
  8003c9:	53                   	push   %ebx
  8003ca:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003cd:	8d 7d e0             	lea    -0x20(%ebp),%edi

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8003d0:	bb 00 00 00 00       	mov    $0x0,%ebx
  8003d5:	eb 08                	jmp    8003df <serve+0x1b>
			thread_yield();
  8003d7:	e8 f4 a1 00 00       	call   80a5d0 <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8003dc:	83 c3 01             	add    $0x1,%ebx
  8003df:	e8 77 a0 00 00       	call   80a45b <thread_wakeups_pending>
  8003e4:	85 c0                	test   %eax,%eax
  8003e6:	74 05                	je     8003ed <serve+0x29>
  8003e8:	83 fb 1f             	cmp    $0x1f,%ebx
  8003eb:	7e ea                	jle    8003d7 <serve+0x13>
			thread_yield();

		perm = 0;
  8003ed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8003f4:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8003f9:	80 b8 00 50 81 00 00 	cmpb   $0x0,0x815000(%eax)
  800400:	74 0a                	je     80040c <serve+0x48>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  800402:	83 c0 01             	add    $0x1,%eax
  800405:	83 f8 14             	cmp    $0x14,%eax
  800408:	75 ef                	jne    8003f9 <serve+0x35>
  80040a:	eb 05                	jmp    800411 <serve+0x4d>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  80040c:	83 f8 14             	cmp    $0x14,%eax
  80040f:	75 14                	jne    800425 <serve+0x61>
		panic("NS: buffer overflow");
  800411:	83 ec 04             	sub    $0x4,%esp
  800414:	68 6a 0c 81 00       	push   $0x810c6a
  800419:	6a 3f                	push   $0x3f
  80041b:	68 15 0c 81 00       	push   $0x810c15
  800420:	e8 69 df 00 00       	call   80e38e <_panic>
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  800425:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  80042b:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  80042e:	c6 80 00 50 81 00 01 	movb   $0x1,0x815000(%eax)
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800435:	83 ec 04             	sub    $0x4,%esp
  800438:	57                   	push   %edi
  800439:	53                   	push   %ebx
  80043a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80043d:	50                   	push   %eax
  80043e:	e8 8e ee 00 00       	call   80f2d1 <ipc_recv>
  800443:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800445:	83 c4 10             	add    $0x10,%esp
  800448:	83 f8 0c             	cmp    $0xc,%eax
  80044b:	75 5e                	jne    8004ab <serve+0xe7>
			process_timer(whom);
  80044d:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800450:	3b 35 18 50 81 00    	cmp    0x815018,%esi
  800456:	74 13                	je     80046b <serve+0xa7>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  800458:	83 ec 08             	sub    $0x8,%esp
  80045b:	56                   	push   %esi
  80045c:	68 80 0b 81 00       	push   $0x810b80
  800461:	e8 01 e0 00 00       	call   80e467 <cprintf>
  800466:	83 c4 10             	add    $0x10,%esp
  800469:	eb 2b                	jmp    800496 <serve+0xd2>
		return;
	}

	start = sys_time_msec();
  80046b:	e8 70 eb 00 00       	call   80efe0 <sys_time_msec>
  800470:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800473:	e8 58 a1 00 00       	call   80a5d0 <thread_yield>
	now = sys_time_msec();
  800478:	e8 63 eb 00 00       	call   80efe0 <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  80047d:	6a 00                	push   $0x0
  80047f:	6a 00                	push   $0x0
  800481:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800484:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  80048a:	29 c2                	sub    %eax,%edx
  80048c:	52                   	push   %edx
  80048d:	56                   	push   %esi
  80048e:	e8 a5 ee 00 00       	call   80f338 <ipc_send>
  800493:	83 c4 10             	add    $0x10,%esp
}

static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  800496:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  80049c:	c1 eb 0c             	shr    $0xc,%ebx
  80049f:	c6 83 00 50 81 00 00 	movb   $0x0,0x815000(%ebx)

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
			continue;
  8004a6:	e9 25 ff ff ff       	jmp    8003d0 <serve+0xc>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  8004ab:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  8004af:	75 18                	jne    8004c9 <serve+0x105>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  8004b1:	83 ec 08             	sub    $0x8,%esp
  8004b4:	ff 75 e4             	pushl  -0x1c(%ebp)
  8004b7:	68 bc 0b 81 00       	push   $0x810bbc
  8004bc:	e8 a6 df 00 00       	call   80e467 <cprintf>
			continue; // just leave it hanging...
  8004c1:	83 c4 10             	add    $0x10,%esp
  8004c4:	e9 07 ff ff ff       	jmp    8003d0 <serve+0xc>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  8004c9:	83 ec 0c             	sub    $0xc,%esp
  8004cc:	6a 0c                	push   $0xc
  8004ce:	e8 05 fc 00 00       	call   8100d8 <malloc>
		if (!args)
  8004d3:	83 c4 10             	add    $0x10,%esp
  8004d6:	85 c0                	test   %eax,%eax
  8004d8:	75 17                	jne    8004f1 <serve+0x12d>
			panic("could not allocate thread args structure");
  8004da:	83 ec 04             	sub    $0x4,%esp
  8004dd:	68 ec 0b 81 00       	push   $0x810bec
  8004e2:	68 27 01 00 00       	push   $0x127
  8004e7:	68 15 0c 81 00       	push   $0x810c15
  8004ec:	e8 9d de 00 00       	call   80e38e <_panic>

		args->reqno = reqno;
  8004f1:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  8004f3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8004f6:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8004f9:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8004fc:	50                   	push   %eax
  8004fd:	68 c4 00 80 00       	push   $0x8000c4
  800502:	68 7e 0c 81 00       	push   $0x810c7e
  800507:	6a 00                	push   $0x0
  800509:	e8 9c 9f 00 00       	call   80a4aa <thread_create>
		thread_yield(); // let the thread created run
  80050e:	e8 bd a0 00 00       	call   80a5d0 <thread_yield>
  800513:	83 c4 10             	add    $0x10,%esp
  800516:	e9 b5 fe ff ff       	jmp    8003d0 <serve+0xc>

0080051b <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  80051b:	55                   	push   %ebp
  80051c:	89 e5                	mov    %esp,%ebp
  80051e:	56                   	push   %esi
  80051f:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  800520:	83 ec 0c             	sub    $0xc,%esp
  800523:	68 8b 0c 81 00       	push   $0x810c8b
  800528:	e8 04 73 00 00       	call   807831 <inet_addr>
  80052d:	89 c6                	mov    %eax,%esi
  80052f:	c7 04 24 94 0c 81 00 	movl   $0x810c94,(%esp)
  800536:	e8 f6 72 00 00       	call   807831 <inet_addr>
  80053b:	89 c3                	mov    %eax,%ebx
  80053d:	c7 04 24 a2 0c 81 00 	movl   $0x810ca2,(%esp)
  800544:	e8 e8 72 00 00       	call   807831 <inet_addr>
  800549:	83 c4 0c             	add    $0xc,%esp
  80054c:	56                   	push   %esi
  80054d:	53                   	push   %ebx
  80054e:	50                   	push   %eax
  80054f:	e8 13 fd ff ff       	call   800267 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800554:	e8 6b fe ff ff       	call   8003c4 <serve>

00800559 <umain>:
}

void
umain(int argc, char **argv)
{
  800559:	55                   	push   %ebp
  80055a:	89 e5                	mov    %esp,%ebp
  80055c:	53                   	push   %ebx
  80055d:	83 ec 04             	sub    $0x4,%esp
	envid_t ns_envid = sys_getenvid();
  800560:	e8 4c e8 00 00       	call   80edb1 <sys_getenvid>
  800565:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800567:	c7 05 e8 42 81 00 1d 	movl   $0x81361d,0x8142e8
  80056e:	36 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800571:	e8 a4 eb 00 00       	call   80f11a <fork>
  800576:	a3 18 50 81 00       	mov    %eax,0x815018
	if (timer_envid < 0)
  80057b:	85 c0                	test   %eax,%eax
  80057d:	79 17                	jns    800596 <umain+0x3d>
		panic("error forking");
  80057f:	83 ec 04             	sub    $0x4,%esp
  800582:	68 ac 0c 81 00       	push   $0x810cac
  800587:	68 44 01 00 00       	push   $0x144
  80058c:	68 15 0c 81 00       	push   $0x810c15
  800591:	e8 f8 dd 00 00       	call   80e38e <_panic>
	else if (timer_envid == 0) {
  800596:	85 c0                	test   %eax,%eax
  800598:	75 16                	jne    8005b0 <umain+0x57>
		timer(ns_envid, TIMER_INTERVAL);
  80059a:	83 ec 08             	sub    $0x8,%esp
  80059d:	68 fa 00 00 00       	push   $0xfa
  8005a2:	53                   	push   %ebx
  8005a3:	e8 96 00 00 00       	call   80063e <timer>
		return;
  8005a8:	83 c4 10             	add    $0x10,%esp
  8005ab:	e9 89 00 00 00       	jmp    800639 <umain+0xe0>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8005b0:	e8 65 eb 00 00       	call   80f11a <fork>
	if (input_envid < 0)
  8005b5:	85 c0                	test   %eax,%eax
  8005b7:	79 17                	jns    8005d0 <umain+0x77>
		panic("error forking");
  8005b9:	83 ec 04             	sub    $0x4,%esp
  8005bc:	68 ac 0c 81 00       	push   $0x810cac
  8005c1:	68 4e 01 00 00       	push   $0x14e
  8005c6:	68 15 0c 81 00       	push   $0x810c15
  8005cb:	e8 be dd 00 00       	call   80e38e <_panic>
	else if (input_envid == 0) {
  8005d0:	85 c0                	test   %eax,%eax
  8005d2:	75 0e                	jne    8005e2 <umain+0x89>
		input(ns_envid);
  8005d4:	83 ec 0c             	sub    $0xc,%esp
  8005d7:	53                   	push   %ebx
  8005d8:	e8 f4 00 00 00       	call   8006d1 <input>
		return;
  8005dd:	83 c4 10             	add    $0x10,%esp
  8005e0:	eb 57                	jmp    800639 <umain+0xe0>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005e2:	e8 33 eb 00 00       	call   80f11a <fork>
  8005e7:	a3 14 50 81 00       	mov    %eax,0x815014
	if (output_envid < 0)
  8005ec:	85 c0                	test   %eax,%eax
  8005ee:	79 17                	jns    800607 <umain+0xae>
		panic("error forking");
  8005f0:	83 ec 04             	sub    $0x4,%esp
  8005f3:	68 ac 0c 81 00       	push   $0x810cac
  8005f8:	68 58 01 00 00       	push   $0x158
  8005fd:	68 15 0c 81 00       	push   $0x810c15
  800602:	e8 87 dd 00 00       	call   80e38e <_panic>
	else if (output_envid == 0) {
  800607:	85 c0                	test   %eax,%eax
  800609:	75 0e                	jne    800619 <umain+0xc0>
		output(ns_envid);
  80060b:	83 ec 0c             	sub    $0xc,%esp
  80060e:	53                   	push   %ebx
  80060f:	e8 cc 00 00 00       	call   8006e0 <output>
		return;
  800614:	83 c4 10             	add    $0x10,%esp
  800617:	eb 20                	jmp    800639 <umain+0xe0>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  800619:	e8 ef 9d 00 00       	call   80a40d <thread_init>
	thread_create(0, "main", tmain, 0);
  80061e:	6a 00                	push   $0x0
  800620:	68 1b 05 80 00       	push   $0x80051b
  800625:	68 ba 0c 81 00       	push   $0x810cba
  80062a:	6a 00                	push   $0x0
  80062c:	e8 79 9e 00 00       	call   80a4aa <thread_create>
	thread_yield();
  800631:	e8 9a 9f 00 00       	call   80a5d0 <thread_yield>
  800636:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  800639:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80063c:	c9                   	leave  
  80063d:	c3                   	ret    

0080063e <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  80063e:	55                   	push   %ebp
  80063f:	89 e5                	mov    %esp,%ebp
  800641:	57                   	push   %edi
  800642:	56                   	push   %esi
  800643:	53                   	push   %ebx
  800644:	83 ec 1c             	sub    $0x1c,%esp
  800647:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80064a:	e8 91 e9 00 00       	call   80efe0 <sys_time_msec>
  80064f:	03 45 0c             	add    0xc(%ebp),%eax
  800652:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  800654:	c7 05 e8 42 81 00 ec 	movl   $0x810cec,0x8142e8
  80065b:	0c 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80065e:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  800661:	eb 05                	jmp    800668 <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
  800663:	e8 68 e7 00 00       	call   80edd0 <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  800668:	e8 73 e9 00 00       	call   80efe0 <sys_time_msec>
  80066d:	89 c2                	mov    %eax,%edx
  80066f:	85 c0                	test   %eax,%eax
  800671:	78 04                	js     800677 <timer+0x39>
  800673:	39 c3                	cmp    %eax,%ebx
  800675:	77 ec                	ja     800663 <timer+0x25>
			sys_yield();
		}
		if (r < 0)
  800677:	85 c0                	test   %eax,%eax
  800679:	79 12                	jns    80068d <timer+0x4f>
			panic("sys_time_msec: %e", r);
  80067b:	52                   	push   %edx
  80067c:	68 f5 0c 81 00       	push   $0x810cf5
  800681:	6a 0f                	push   $0xf
  800683:	68 07 0d 81 00       	push   $0x810d07
  800688:	e8 01 dd 00 00       	call   80e38e <_panic>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  80068d:	6a 00                	push   $0x0
  80068f:	6a 00                	push   $0x0
  800691:	6a 0c                	push   $0xc
  800693:	56                   	push   %esi
  800694:	e8 9f ec 00 00       	call   80f338 <ipc_send>
  800699:	83 c4 10             	add    $0x10,%esp

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80069c:	83 ec 04             	sub    $0x4,%esp
  80069f:	6a 00                	push   $0x0
  8006a1:	6a 00                	push   $0x0
  8006a3:	57                   	push   %edi
  8006a4:	e8 28 ec 00 00       	call   80f2d1 <ipc_recv>
  8006a9:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8006ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8006ae:	83 c4 10             	add    $0x10,%esp
  8006b1:	39 f0                	cmp    %esi,%eax
  8006b3:	74 13                	je     8006c8 <timer+0x8a>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8006b5:	83 ec 08             	sub    $0x8,%esp
  8006b8:	50                   	push   %eax
  8006b9:	68 14 0d 81 00       	push   $0x810d14
  8006be:	e8 a4 dd 00 00       	call   80e467 <cprintf>
				continue;
  8006c3:	83 c4 10             	add    $0x10,%esp
  8006c6:	eb d4                	jmp    80069c <timer+0x5e>
			}

			stop = sys_time_msec() + to;
  8006c8:	e8 13 e9 00 00       	call   80efe0 <sys_time_msec>
  8006cd:	01 c3                	add    %eax,%ebx
  8006cf:	eb 97                	jmp    800668 <timer+0x2a>

008006d1 <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  8006d1:	55                   	push   %ebp
  8006d2:	89 e5                	mov    %esp,%ebp
	binaryname = "ns_input";
  8006d4:	c7 05 e8 42 81 00 4f 	movl   $0x810d4f,0x8142e8
  8006db:	0d 81 00 
	// 	- read a packet from the device driver
	//	- send it to the network server
	// Hint: When you IPC a page to the network server, it will be
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
}
  8006de:	5d                   	pop    %ebp
  8006df:	c3                   	ret    

008006e0 <output>:



void
output(envid_t ns_envid)
{
  8006e0:	55                   	push   %ebp
  8006e1:	89 e5                	mov    %esp,%ebp
  8006e3:	56                   	push   %esi
  8006e4:	53                   	push   %ebx
  8006e5:	83 ec 10             	sub    $0x10,%esp
	binaryname = "ns_output";
  8006e8:	c7 05 e8 42 81 00 58 	movl   $0x810d58,0x8142e8
  8006ef:	0d 81 00 
	uint32_t whom;
    int perm;
    int32_t req;

    while (1) {
        req = ipc_recv((envid_t *)&whom, &nsipcbuf, &perm);
  8006f2:	8d 75 f0             	lea    -0x10(%ebp),%esi
  8006f5:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8006f8:	83 ec 04             	sub    $0x4,%esp
  8006fb:	56                   	push   %esi
  8006fc:	68 00 d0 b3 00       	push   $0xb3d000
  800701:	53                   	push   %ebx
  800702:	e8 ca eb 00 00       	call   80f2d1 <ipc_recv>
        if (req != NSREQ_OUTPUT) {
  800707:	83 c4 10             	add    $0x10,%esp
  80070a:	83 f8 0b             	cmp    $0xb,%eax
  80070d:	75 e9                	jne    8006f8 <output+0x18>
  80070f:	eb 05                	jmp    800716 <output+0x36>
            continue;
        }
        while (sys_e1000_try_send(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len) < 0) {
            sys_yield();
  800711:	e8 ba e6 00 00       	call   80edd0 <sys_yield>
    while (1) {
        req = ipc_recv((envid_t *)&whom, &nsipcbuf, &perm);
        if (req != NSREQ_OUTPUT) {
            continue;
        }
        while (sys_e1000_try_send(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len) < 0) {
  800716:	83 ec 08             	sub    $0x8,%esp
  800719:	ff 35 00 d0 b3 00    	pushl  0xb3d000
  80071f:	68 04 d0 b3 00       	push   $0xb3d004
  800724:	e8 d6 e8 00 00       	call   80efff <sys_e1000_try_send>
  800729:	83 c4 10             	add    $0x10,%esp
  80072c:	85 c0                	test   %eax,%eax
  80072e:	78 e1                	js     800711 <output+0x31>
  800730:	eb c6                	jmp    8006f8 <output+0x18>

00800732 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  800732:	55                   	push   %ebp
  800733:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  800735:	83 f8 1f             	cmp    $0x1f,%eax
  800738:	76 11                	jbe    80074b <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  80073a:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  800741:	00 00 00 
    return NULL;
  800744:	b8 00 00 00 00       	mov    $0x0,%eax
  800749:	eb 30                	jmp    80077b <get_socket+0x49>
  }

  sock = &sockets[s];
  80074b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  800752:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  800755:	8d 0c 8d 60 50 81 00 	lea    0x815060(,%ecx,4),%ecx

  if (!sock->conn) {
  80075c:	01 c2                	add    %eax,%edx
  80075e:	83 3c 95 60 50 81 00 	cmpl   $0x0,0x815060(,%edx,4)
  800765:	00 
  800766:	75 11                	jne    800779 <get_socket+0x47>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  800768:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  80076f:	00 00 00 
    return NULL;
  800772:	b8 00 00 00 00       	mov    $0x0,%eax
  800777:	eb 02                	jmp    80077b <get_socket+0x49>
  }

  return sock;
  800779:	89 c8                	mov    %ecx,%eax
}
  80077b:	5d                   	pop    %ebp
  80077c:	c3                   	ret    

0080077d <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  80077d:	55                   	push   %ebp
  80077e:	89 e5                	mov    %esp,%ebp
  800780:	57                   	push   %edi
  800781:	56                   	push   %esi
  800782:	53                   	push   %ebx
  800783:	83 ec 40             	sub    $0x40,%esp
  800786:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800789:	89 55 cc             	mov    %edx,-0x34(%ebp)
  80078c:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  80078f:	6a 04                	push   $0x4
  800791:	6a 00                	push   $0x0
  800793:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800796:	50                   	push   %eax
  800797:	e8 95 e3 00 00       	call   80eb31 <memset>
  FD_ZERO(&lwriteset);
  80079c:	83 c4 0c             	add    $0xc,%esp
  80079f:	6a 04                	push   $0x4
  8007a1:	6a 00                	push   $0x0
  8007a3:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8007a6:	50                   	push   %eax
  8007a7:	e8 85 e3 00 00       	call   80eb31 <memset>
  FD_ZERO(&lexceptset);
  8007ac:	83 c4 0c             	add    $0xc,%esp
  8007af:	6a 04                	push   $0x4
  8007b1:	6a 00                	push   $0x0
  8007b3:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8007b6:	50                   	push   %eax
  8007b7:	e8 75 e3 00 00       	call   80eb31 <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  8007bc:	83 c4 10             	add    $0x10,%esp
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  int i, nready = 0;
  8007bf:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  8007c6:	bf 00 00 00 00       	mov    $0x0,%edi
  8007cb:	e9 80 00 00 00       	jmp    800850 <lwip_selscan+0xd3>
    if (FD_ISSET(i, readset)) {
  8007d0:	8d 5f 07             	lea    0x7(%edi),%ebx
  8007d3:	85 ff                	test   %edi,%edi
  8007d5:	0f 49 df             	cmovns %edi,%ebx
  8007d8:	c1 fb 03             	sar    $0x3,%ebx
  8007db:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  8007de:	89 fe                	mov    %edi,%esi
  8007e0:	83 e6 07             	and    $0x7,%esi
  8007e3:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8007e6:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8007ea:	0f a3 f0             	bt     %esi,%eax
  8007ed:	73 2c                	jae    80081b <lwip_selscan+0x9e>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  8007ef:	89 f8                	mov    %edi,%eax
  8007f1:	e8 3c ff ff ff       	call   800732 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8007f6:	85 c0                	test   %eax,%eax
  8007f8:	74 21                	je     80081b <lwip_selscan+0x9e>
  8007fa:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8007fe:	75 07                	jne    800807 <lwip_selscan+0x8a>
  800800:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800805:	74 14                	je     80081b <lwip_selscan+0x9e>
        FD_SET(i, &lreadset);
  800807:	b8 01 00 00 00       	mov    $0x1,%eax
  80080c:	89 f1                	mov    %esi,%ecx
  80080e:	d3 e0                	shl    %cl,%eax
  800810:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800813:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  800817:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  80081b:	8b 45 c8             	mov    -0x38(%ebp),%eax
  80081e:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  800822:	0f a3 f0             	bt     %esi,%eax
  800825:	73 26                	jae    80084d <lwip_selscan+0xd0>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  800827:	89 f8                	mov    %edi,%eax
  800829:	e8 04 ff ff ff       	call   800732 <get_socket>
      if (p_sock && p_sock->sendevent) {
  80082e:	85 c0                	test   %eax,%eax
  800830:	74 1b                	je     80084d <lwip_selscan+0xd0>
  800832:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800837:	74 14                	je     80084d <lwip_selscan+0xd0>
        FD_SET(i, &lwriteset);
  800839:	b8 01 00 00 00       	mov    $0x1,%eax
  80083e:	89 f1                	mov    %esi,%ecx
  800840:	d3 e0                	shl    %cl,%eax
  800842:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800845:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  800849:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  80084d:	83 c7 01             	add    $0x1,%edi
  800850:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  800853:	0f 8c 77 ff ff ff    	jl     8007d0 <lwip_selscan+0x53>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  800859:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80085c:	8b 55 cc             	mov    -0x34(%ebp),%edx
  80085f:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  800861:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800864:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  800867:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  800869:	83 ec 04             	sub    $0x4,%esp
  80086c:	6a 04                	push   $0x4
  80086e:	6a 00                	push   $0x0
  800870:	ff 75 08             	pushl  0x8(%ebp)
  800873:	e8 b9 e2 00 00       	call   80eb31 <memset>
  
  return nready;
}
  800878:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  80087b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80087e:	5b                   	pop    %ebx
  80087f:	5e                   	pop    %esi
  800880:	5f                   	pop    %edi
  800881:	5d                   	pop    %ebp
  800882:	c3                   	ret    

00800883 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800883:	55                   	push   %ebp
  800884:	89 e5                	mov    %esp,%ebp
  800886:	57                   	push   %edi
  800887:	56                   	push   %esi
  800888:	53                   	push   %ebx
  800889:	83 ec 3c             	sub    $0x3c,%esp
  80088c:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  80088f:	89 cf                	mov    %ecx,%edi
  800891:	8b 75 08             	mov    0x8(%ebp),%esi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800894:	e8 99 fe ff ff       	call   800732 <get_socket>
  if (!sock)
  800899:	85 c0                	test   %eax,%eax
  80089b:	0f 84 80 00 00 00    	je     800921 <lwip_getaddrname+0x9e>
  8008a1:	89 c3                	mov    %eax,%ebx
    return -1;

  memset(&sin, 0, sizeof(sin));
  8008a3:	83 ec 04             	sub    $0x4,%esp
  8008a6:	6a 10                	push   $0x10
  8008a8:	6a 00                	push   $0x0
  8008aa:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8008ad:	50                   	push   %eax
  8008ae:	e8 7e e2 00 00       	call   80eb31 <memset>
  sin.sin_len = sizeof(sin);
  8008b3:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  8008b7:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  8008bb:	89 f0                	mov    %esi,%eax
  8008bd:	0f b6 f0             	movzbl %al,%esi
  8008c0:	56                   	push   %esi
  8008c1:	8d 45 da             	lea    -0x26(%ebp),%eax
  8008c4:	50                   	push   %eax
  8008c5:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8008c8:	50                   	push   %eax
  8008c9:	ff 33                	pushl  (%ebx)
  8008cb:	e8 ee a2 00 00       	call   80abbe <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  8008d0:	83 c4 14             	add    $0x14,%esp
  8008d3:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  8008d7:	50                   	push   %eax
  8008d8:	e8 3b 6d 00 00       	call   807618 <htons>
  8008dd:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8008e1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8008e4:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  8008e7:	83 c4 10             	add    $0x10,%esp
  8008ea:	83 3f 10             	cmpl   $0x10,(%edi)
  8008ed:	76 06                	jbe    8008f5 <lwip_getaddrname+0x72>
    *namelen = sizeof(sin);
  8008ef:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(name, &sin, *namelen);
  8008f5:	83 ec 04             	sub    $0x4,%esp
  8008f8:	ff 37                	pushl  (%edi)
  8008fa:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8008fd:	50                   	push   %eax
  8008fe:	ff 75 c4             	pushl  -0x3c(%ebp)
  800901:	e8 e0 e2 00 00       	call   80ebe6 <memcpy>
  sock_set_errno(sock, 0);
  800906:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80090d:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  800914:	00 00 00 
  return 0;
  800917:	83 c4 10             	add    $0x10,%esp
  80091a:	b8 00 00 00 00       	mov    $0x0,%eax
  80091f:	eb 05                	jmp    800926 <lwip_getaddrname+0xa3>
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  if (!sock)
    return -1;
  800921:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    *namelen = sizeof(sin);

  SMEMCPY(name, &sin, *namelen);
  sock_set_errno(sock, 0);
  return 0;
}
  800926:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800929:	5b                   	pop    %ebx
  80092a:	5e                   	pop    %esi
  80092b:	5f                   	pop    %edi
  80092c:	5d                   	pop    %ebp
  80092d:	c3                   	ret    

0080092e <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  80092e:	55                   	push   %ebp
  80092f:	89 e5                	mov    %esp,%ebp
  800931:	57                   	push   %edi
  800932:	56                   	push   %esi
  800933:	53                   	push   %ebx
  800934:	83 ec 1c             	sub    $0x1c,%esp
  800937:	8b 7d 08             	mov    0x8(%ebp),%edi
  80093a:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  80093d:	85 ff                	test   %edi,%edi
  80093f:	0f 84 81 01 00 00    	je     800ac6 <event_callback+0x198>
    s = conn->socket;
  800945:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  800948:	85 db                	test   %ebx,%ebx
  80094a:	79 49                	jns    800995 <event_callback+0x67>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  80094c:	83 ec 0c             	sub    $0xc,%esp
  80094f:	ff 35 44 50 81 00    	pushl  0x815044
  800955:	e8 ca 46 00 00       	call   805024 <sys_sem_wait>
      if (conn->socket < 0) {
  80095a:	8b 47 1c             	mov    0x1c(%edi),%eax
  80095d:	83 c4 10             	add    $0x10,%esp
  800960:	85 c0                	test   %eax,%eax
  800962:	79 20                	jns    800984 <event_callback+0x56>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800964:	85 f6                	test   %esi,%esi
  800966:	75 06                	jne    80096e <event_callback+0x40>
          conn->socket--;
  800968:	83 e8 01             	sub    $0x1,%eax
  80096b:	89 47 1c             	mov    %eax,0x1c(%edi)
        }
        sys_sem_signal(socksem);
  80096e:	83 ec 0c             	sub    $0xc,%esp
  800971:	ff 35 44 50 81 00    	pushl  0x815044
  800977:	e8 9e 95 00 00       	call   809f1a <sys_sem_signal>
        return;
  80097c:	83 c4 10             	add    $0x10,%esp
  80097f:	e9 42 01 00 00       	jmp    800ac6 <event_callback+0x198>
      }
      sys_sem_signal(socksem);
  800984:	83 ec 0c             	sub    $0xc,%esp
  800987:	ff 35 44 50 81 00    	pushl  0x815044
  80098d:	e8 88 95 00 00       	call   809f1a <sys_sem_signal>
  800992:	83 c4 10             	add    $0x10,%esp
    }

    sock = get_socket(s);
  800995:	89 d8                	mov    %ebx,%eax
  800997:	e8 96 fd ff ff       	call   800732 <get_socket>
  80099c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  80099f:	85 c0                	test   %eax,%eax
  8009a1:	0f 84 1f 01 00 00    	je     800ac6 <event_callback+0x198>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  8009a7:	83 ec 0c             	sub    $0xc,%esp
  8009aa:	ff 35 40 50 81 00    	pushl  0x815040
  8009b0:	e8 6f 46 00 00       	call   805024 <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  8009b5:	83 c4 10             	add    $0x10,%esp
  8009b8:	83 fe 01             	cmp    $0x1,%esi
  8009bb:	74 1b                	je     8009d8 <event_callback+0xaa>
  8009bd:	83 fe 01             	cmp    $0x1,%esi
  8009c0:	72 0c                	jb     8009ce <event_callback+0xa0>
  8009c2:	83 fe 02             	cmp    $0x2,%esi
  8009c5:	74 1b                	je     8009e2 <event_callback+0xb4>
  8009c7:	83 fe 03             	cmp    $0x3,%esi
  8009ca:	74 21                	je     8009ed <event_callback+0xbf>
  8009cc:	eb 2a                	jmp    8009f8 <event_callback+0xca>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  8009ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009d1:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  8009d6:	eb 37                	jmp    800a0f <event_callback+0xe1>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  8009d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009db:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  8009e0:	eb 2d                	jmp    800a0f <event_callback+0xe1>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  8009e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009e5:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  8009eb:	eb 22                	jmp    800a0f <event_callback+0xe1>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  8009ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009f0:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  8009f6:	eb 17                	jmp    800a0f <event_callback+0xe1>
    default:
      LWIP_ASSERT("unknown event", 0);
  8009f8:	83 ec 04             	sub    $0x4,%esp
  8009fb:	68 62 0d 81 00       	push   $0x810d62
  800a00:	68 17 04 00 00       	push   $0x417
  800a05:	68 70 0d 81 00       	push   $0x810d70
  800a0a:	e8 7f d9 00 00       	call   80e38e <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  800a0f:	83 ec 0c             	sub    $0xc,%esp
  800a12:	ff 35 40 50 81 00    	pushl  0x815040
  800a18:	e8 fd 94 00 00       	call   809f1a <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800a1d:	8d 73 07             	lea    0x7(%ebx),%esi
  800a20:	83 c4 10             	add    $0x10,%esp
  800a23:	85 db                	test   %ebx,%ebx
  800a25:	0f 49 f3             	cmovns %ebx,%esi
  800a28:	c1 fe 03             	sar    $0x3,%esi
  800a2b:	89 d9                	mov    %ebx,%ecx
  800a2d:	83 e1 07             	and    $0x7,%ecx
  800a30:	bf 01 00 00 00       	mov    $0x1,%edi
  800a35:	d3 e7                	shl    %cl,%edi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  800a37:	83 ec 0c             	sub    $0xc,%esp
  800a3a:	ff 35 40 50 81 00    	pushl  0x815040
  800a40:	e8 df 45 00 00       	call   805024 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800a45:	8b 1d 48 50 81 00    	mov    0x815048,%ebx
  800a4b:	83 c4 10             	add    $0x10,%esp
  800a4e:	eb 3a                	jmp    800a8a <event_callback+0x15c>
      if (scb->sem_signalled == 0) {
  800a50:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800a54:	75 32                	jne    800a88 <event_callback+0x15a>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800a56:	8b 43 04             	mov    0x4(%ebx),%eax
  800a59:	85 c0                	test   %eax,%eax
  800a5b:	74 12                	je     800a6f <event_callback+0x141>
  800a5d:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800a61:	85 f8                	test   %edi,%eax
  800a63:	74 0a                	je     800a6f <event_callback+0x141>
          if (sock->rcvevent)
  800a65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a68:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800a6d:	75 21                	jne    800a90 <event_callback+0x162>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800a6f:	8b 43 08             	mov    0x8(%ebx),%eax
  800a72:	85 c0                	test   %eax,%eax
  800a74:	74 12                	je     800a88 <event_callback+0x15a>
  800a76:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800a7a:	85 f8                	test   %edi,%eax
  800a7c:	74 0a                	je     800a88 <event_callback+0x15a>
          if (sock->sendevent)
  800a7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a81:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800a86:	75 08                	jne    800a90 <event_callback+0x162>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  800a88:	8b 1b                	mov    (%ebx),%ebx
  800a8a:	85 db                	test   %ebx,%ebx
  800a8c:	75 c2                	jne    800a50 <event_callback+0x122>
  800a8e:	eb 25                	jmp    800ab5 <event_callback+0x187>
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
      scb->sem_signalled = 1;
  800a90:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800a97:	83 ec 0c             	sub    $0xc,%esp
  800a9a:	ff 35 40 50 81 00    	pushl  0x815040
  800aa0:	e8 75 94 00 00       	call   809f1a <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800aa5:	83 c4 04             	add    $0x4,%esp
  800aa8:	ff 73 14             	pushl  0x14(%ebx)
  800aab:	e8 6a 94 00 00       	call   809f1a <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  800ab0:	83 c4 10             	add    $0x10,%esp
  800ab3:	eb 82                	jmp    800a37 <event_callback+0x109>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  800ab5:	83 ec 0c             	sub    $0xc,%esp
  800ab8:	ff 35 40 50 81 00    	pushl  0x815040
  800abe:	e8 57 94 00 00       	call   809f1a <sys_sem_signal>
      break;
  800ac3:	83 c4 10             	add    $0x10,%esp
    }
  }
}
  800ac6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800ac9:	5b                   	pop    %ebx
  800aca:	5e                   	pop    %esi
  800acb:	5f                   	pop    %edi
  800acc:	5d                   	pop    %ebp
  800acd:	c3                   	ret    

00800ace <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  800ace:	55                   	push   %ebp
  800acf:	89 e5                	mov    %esp,%ebp
  800ad1:	56                   	push   %esi
  800ad2:	53                   	push   %ebx
  800ad3:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  800ad5:	83 ec 0c             	sub    $0xc,%esp
  800ad8:	ff 35 44 50 81 00    	pushl  0x815044
  800ade:	e8 41 45 00 00       	call   805024 <sys_sem_wait>
  800ae3:	b8 60 50 81 00       	mov    $0x815060,%eax
  800ae8:	83 c4 10             	add    $0x10,%esp

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800aeb:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800af0:	83 38 00             	cmpl   $0x0,(%eax)
  800af3:	75 59                	jne    800b4e <alloc_socket+0x80>
      sockets[i].conn       = newconn;
  800af5:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  800af8:	c1 e2 02             	shl    $0x2,%edx
  800afb:	89 b2 60 50 81 00    	mov    %esi,0x815060(%edx)
      sockets[i].lastdata   = NULL;
  800b01:	c7 82 64 50 81 00 00 	movl   $0x0,0x815064(%edx)
  800b08:	00 00 00 
      sockets[i].lastoffset = 0;
  800b0b:	66 c7 82 68 50 81 00 	movw   $0x0,0x815068(%edx)
  800b12:	00 00 
      sockets[i].rcvevent   = 0;
  800b14:	66 c7 82 6a 50 81 00 	movw   $0x0,0x81506a(%edx)
  800b1b:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800b1d:	66 c7 82 6c 50 81 00 	movw   $0x1,0x81506c(%edx)
  800b24:	01 00 
      sockets[i].flags      = 0;
  800b26:	66 c7 82 6e 50 81 00 	movw   $0x0,0x81506e(%edx)
  800b2d:	00 00 
      sockets[i].err        = 0;
  800b2f:	c7 82 70 50 81 00 00 	movl   $0x0,0x815070(%edx)
  800b36:	00 00 00 
      sys_sem_signal(socksem);
  800b39:	83 ec 0c             	sub    $0xc,%esp
  800b3c:	ff 35 44 50 81 00    	pushl  0x815044
  800b42:	e8 d3 93 00 00       	call   809f1a <sys_sem_signal>
      return i;
  800b47:	83 c4 10             	add    $0x10,%esp
  800b4a:	89 d8                	mov    %ebx,%eax
  800b4c:	eb 21                	jmp    800b6f <alloc_socket+0xa1>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800b4e:	83 c3 01             	add    $0x1,%ebx
  800b51:	83 c0 14             	add    $0x14,%eax
  800b54:	83 fb 20             	cmp    $0x20,%ebx
  800b57:	75 97                	jne    800af0 <alloc_socket+0x22>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  800b59:	83 ec 0c             	sub    $0xc,%esp
  800b5c:	ff 35 44 50 81 00    	pushl  0x815044
  800b62:	e8 b3 93 00 00       	call   809f1a <sys_sem_signal>
  return -1;
  800b67:	83 c4 10             	add    $0x10,%esp
  800b6a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  800b6f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800b72:	5b                   	pop    %ebx
  800b73:	5e                   	pop    %esi
  800b74:	5d                   	pop    %ebp
  800b75:	c3                   	ret    

00800b76 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800b76:	55                   	push   %ebp
  800b77:	89 e5                	mov    %esp,%ebp
  800b79:	53                   	push   %ebx
  800b7a:	83 ec 04             	sub    $0x4,%esp
  800b7d:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800b80:	85 c0                	test   %eax,%eax
  800b82:	75 17                	jne    800b9b <lwip_getsockopt_internal+0x25>
  800b84:	83 ec 04             	sub    $0x4,%esp
  800b87:	68 87 0d 81 00       	push   $0x810d87
  800b8c:	68 38 05 00 00       	push   $0x538
  800b91:	68 70 0d 81 00       	push   $0x810d70
  800b96:	e8 f3 d7 00 00       	call   80e38e <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800b9b:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800b9d:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800ba0:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800ba3:	8b 40 08             	mov    0x8(%eax),%eax
  800ba6:	83 f8 06             	cmp    $0x6,%eax
  800ba9:	0f 84 09 01 00 00    	je     800cb8 <lwip_getsockopt_internal+0x142>
  800baf:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800bb4:	74 0d                	je     800bc3 <lwip_getsockopt_internal+0x4d>
  800bb6:	85 c0                	test   %eax,%eax
  800bb8:	0f 85 26 01 00 00    	jne    800ce4 <lwip_getsockopt_internal+0x16e>
  800bbe:	e9 d1 00 00 00       	jmp    800c94 <lwip_getsockopt_internal+0x11e>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800bc3:	83 fa 20             	cmp    $0x20,%edx
  800bc6:	74 37                	je     800bff <lwip_getsockopt_internal+0x89>
  800bc8:	83 fa 20             	cmp    $0x20,%edx
  800bcb:	7f 10                	jg     800bdd <lwip_getsockopt_internal+0x67>
  800bcd:	83 fa 02             	cmp    $0x2,%edx
  800bd0:	74 2d                	je     800bff <lwip_getsockopt_internal+0x89>
  800bd2:	83 fa 08             	cmp    $0x8,%edx
  800bd5:	0f 85 09 01 00 00    	jne    800ce4 <lwip_getsockopt_internal+0x16e>
  800bdb:	eb 22                	jmp    800bff <lwip_getsockopt_internal+0x89>
  800bdd:	81 fa 08 10 00 00    	cmp    $0x1008,%edx
  800be3:	74 2c                	je     800c11 <lwip_getsockopt_internal+0x9b>
  800be5:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800beb:	0f 84 93 00 00 00    	je     800c84 <lwip_getsockopt_internal+0x10e>
  800bf1:	81 fa 07 10 00 00    	cmp    $0x1007,%edx
  800bf7:	0f 85 e7 00 00 00    	jne    800ce4 <lwip_getsockopt_internal+0x16e>
  800bfd:	eb 4f                	jmp    800c4e <lwip_getsockopt_internal+0xd8>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800bff:	8b 01                	mov    (%ecx),%eax
  800c01:	8b 40 08             	mov    0x8(%eax),%eax
  800c04:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800c08:	21 c2                	and    %eax,%edx
  800c0a:	89 13                	mov    %edx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  800c0c:	e9 d3 00 00 00       	jmp    800ce4 <lwip_getsockopt_internal+0x16e>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800c11:	8b 01                	mov    (%ecx),%eax
  800c13:	8b 10                	mov    (%eax),%edx
  800c15:	89 d0                	mov    %edx,%eax
  800c17:	25 f0 00 00 00       	and    $0xf0,%eax
  800c1c:	83 f8 20             	cmp    $0x20,%eax
  800c1f:	74 22                	je     800c43 <lwip_getsockopt_internal+0xcd>
  800c21:	83 f8 40             	cmp    $0x40,%eax
  800c24:	74 12                	je     800c38 <lwip_getsockopt_internal+0xc2>
  800c26:	83 f8 10             	cmp    $0x10,%eax
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
        break;
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  800c29:	b8 01 00 00 00       	mov    $0x1,%eax
  800c2e:	0f 44 d0             	cmove  %eax,%edx
  800c31:	89 13                	mov    %edx,(%ebx)
  800c33:	e9 ac 00 00 00       	jmp    800ce4 <lwip_getsockopt_internal+0x16e>
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  800c38:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  800c3e:	e9 a1 00 00 00       	jmp    800ce4 <lwip_getsockopt_internal+0x16e>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  800c43:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  800c49:	e9 96 00 00 00       	jmp    800ce4 <lwip_getsockopt_internal+0x16e>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  800c4e:	83 79 10 00          	cmpl   $0x0,0x10(%ecx)
  800c52:	75 22                	jne    800c76 <lwip_getsockopt_internal+0x100>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800c54:	8b 01                	mov    (%ecx),%eax
  800c56:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800c5a:	f7 d8                	neg    %eax
  800c5c:	ba 05 00 00 00       	mov    $0x5,%edx
  800c61:	83 f8 0e             	cmp    $0xe,%eax
  800c64:	77 07                	ja     800c6d <lwip_getsockopt_internal+0xf7>
  800c66:	8b 14 85 40 0e 81 00 	mov    0x810e40(,%eax,4),%edx
  800c6d:	89 51 10             	mov    %edx,0x10(%ecx)
  800c70:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
      } 
      *(int *)optval = sock->err;
  800c76:	8b 41 10             	mov    0x10(%ecx),%eax
  800c79:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  800c7b:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  800c82:	eb 60                	jmp    800ce4 <lwip_getsockopt_internal+0x16e>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800c84:	8b 01                	mov    (%ecx),%eax
  800c86:	8b 40 08             	mov    0x8(%eax),%eax
  800c89:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  800c8d:	83 e0 01             	and    $0x1,%eax
  800c90:	89 03                	mov    %eax,(%ebx)
      break;
  800c92:	eb 50                	jmp    800ce4 <lwip_getsockopt_internal+0x16e>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800c94:	83 fa 01             	cmp    $0x1,%edx
  800c97:	74 12                	je     800cab <lwip_getsockopt_internal+0x135>
  800c99:	83 fa 02             	cmp    $0x2,%edx
  800c9c:	75 46                	jne    800ce4 <lwip_getsockopt_internal+0x16e>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800c9e:	8b 01                	mov    (%ecx),%eax
  800ca0:	8b 40 08             	mov    0x8(%eax),%eax
  800ca3:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  800ca7:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  800ca9:	eb 39                	jmp    800ce4 <lwip_getsockopt_internal+0x16e>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  800cab:	8b 01                	mov    (%ecx),%eax
  800cad:	8b 40 08             	mov    0x8(%eax),%eax
  800cb0:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  800cb4:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  800cb6:	eb 2c                	jmp    800ce4 <lwip_getsockopt_internal+0x16e>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800cb8:	83 fa 01             	cmp    $0x1,%edx
  800cbb:	74 07                	je     800cc4 <lwip_getsockopt_internal+0x14e>
  800cbd:	83 fa 02             	cmp    $0x2,%edx
  800cc0:	74 15                	je     800cd7 <lwip_getsockopt_internal+0x161>
  800cc2:	eb 20                	jmp    800ce4 <lwip_getsockopt_internal+0x16e>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800cc4:	8b 01                	mov    (%ecx),%eax
  800cc6:	8b 40 08             	mov    0x8(%eax),%eax
  800cc9:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  800ccd:	83 e0 40             	and    $0x40,%eax
  800cd0:	0f b6 c0             	movzbl %al,%eax
  800cd3:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  800cd5:	eb 0d                	jmp    800ce4 <lwip_getsockopt_internal+0x16e>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800cd7:	8b 01                	mov    (%ecx),%eax
  800cd9:	8b 40 08             	mov    0x8(%eax),%eax
  800cdc:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  800ce2:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800ce4:	83 ec 0c             	sub    $0xc,%esp
  800ce7:	8b 01                	mov    (%ecx),%eax
  800ce9:	ff 70 10             	pushl  0x10(%eax)
  800cec:	e8 29 92 00 00       	call   809f1a <sys_sem_signal>
}
  800cf1:	83 c4 10             	add    $0x10,%esp
  800cf4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800cf7:	c9                   	leave  
  800cf8:	c3                   	ret    

00800cf9 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800cf9:	55                   	push   %ebp
  800cfa:	89 e5                	mov    %esp,%ebp
  800cfc:	53                   	push   %ebx
  800cfd:	83 ec 04             	sub    $0x4,%esp
  800d00:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800d03:	85 c0                	test   %eax,%eax
  800d05:	75 17                	jne    800d1e <lwip_setsockopt_internal+0x25>
  800d07:	83 ec 04             	sub    $0x4,%esp
  800d0a:	68 87 0d 81 00       	push   $0x810d87
  800d0f:	68 ae 06 00 00       	push   $0x6ae
  800d14:	68 70 0d 81 00       	push   $0x810d70
  800d19:	e8 70 d6 00 00       	call   80e38e <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800d1e:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800d20:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800d23:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800d26:	8b 40 08             	mov    0x8(%eax),%eax
  800d29:	83 f8 06             	cmp    $0x6,%eax
  800d2c:	0f 84 81 00 00 00    	je     800db3 <lwip_setsockopt_internal+0xba>
  800d32:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800d37:	74 0a                	je     800d43 <lwip_setsockopt_internal+0x4a>
  800d39:	85 c0                	test   %eax,%eax
  800d3b:	0f 85 a6 00 00 00    	jne    800de7 <lwip_setsockopt_internal+0xee>
  800d41:	eb 4e                	jmp    800d91 <lwip_setsockopt_internal+0x98>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800d43:	83 fa 20             	cmp    $0x20,%edx
  800d46:	74 11                	je     800d59 <lwip_setsockopt_internal+0x60>
  800d48:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800d4e:	74 26                	je     800d76 <lwip_setsockopt_internal+0x7d>
  800d50:	83 fa 08             	cmp    $0x8,%edx
  800d53:	0f 85 8e 00 00 00    	jne    800de7 <lwip_setsockopt_internal+0xee>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  800d59:	83 3b 00             	cmpl   $0x0,(%ebx)
  800d5c:	74 0b                	je     800d69 <lwip_setsockopt_internal+0x70>
        sock->conn->pcb.ip->so_options |= optname;
  800d5e:	8b 01                	mov    (%ecx),%eax
  800d60:	8b 40 08             	mov    0x8(%eax),%eax
  800d63:	66 09 50 08          	or     %dx,0x8(%eax)
  800d67:	eb 7e                	jmp    800de7 <lwip_setsockopt_internal+0xee>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  800d69:	8b 01                	mov    (%ecx),%eax
  800d6b:	8b 40 08             	mov    0x8(%eax),%eax
  800d6e:	f7 d2                	not    %edx
  800d70:	66 21 50 08          	and    %dx,0x8(%eax)
  800d74:	eb 71                	jmp    800de7 <lwip_setsockopt_internal+0xee>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  800d76:	83 3b 00             	cmpl   $0x0,(%ebx)
  800d79:	74 0b                	je     800d86 <lwip_setsockopt_internal+0x8d>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800d7b:	8b 01                	mov    (%ecx),%eax
  800d7d:	8b 40 08             	mov    0x8(%eax),%eax
  800d80:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800d84:	eb 61                	jmp    800de7 <lwip_setsockopt_internal+0xee>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800d86:	8b 01                	mov    (%ecx),%eax
  800d88:	8b 40 08             	mov    0x8(%eax),%eax
  800d8b:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800d8f:	eb 56                	jmp    800de7 <lwip_setsockopt_internal+0xee>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800d91:	83 fa 01             	cmp    $0x1,%edx
  800d94:	74 11                	je     800da7 <lwip_setsockopt_internal+0xae>
  800d96:	83 fa 02             	cmp    $0x2,%edx
  800d99:	75 4c                	jne    800de7 <lwip_setsockopt_internal+0xee>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800d9b:	8b 01                	mov    (%ecx),%eax
  800d9d:	8b 40 08             	mov    0x8(%eax),%eax
  800da0:	8b 13                	mov    (%ebx),%edx
  800da2:	88 50 0b             	mov    %dl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  800da5:	eb 40                	jmp    800de7 <lwip_setsockopt_internal+0xee>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800da7:	8b 01                	mov    (%ecx),%eax
  800da9:	8b 40 08             	mov    0x8(%eax),%eax
  800dac:	8b 13                	mov    (%ebx),%edx
  800dae:	88 50 0a             	mov    %dl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  800db1:	eb 34                	jmp    800de7 <lwip_setsockopt_internal+0xee>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800db3:	83 fa 01             	cmp    $0x1,%edx
  800db6:	74 07                	je     800dbf <lwip_setsockopt_internal+0xc6>
  800db8:	83 fa 02             	cmp    $0x2,%edx
  800dbb:	74 1d                	je     800dda <lwip_setsockopt_internal+0xe1>
  800dbd:	eb 28                	jmp    800de7 <lwip_setsockopt_internal+0xee>
    case TCP_NODELAY:
      if (*(int*)optval) {
  800dbf:	83 3b 00             	cmpl   $0x0,(%ebx)
  800dc2:	74 0b                	je     800dcf <lwip_setsockopt_internal+0xd6>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800dc4:	8b 01                	mov    (%ecx),%eax
  800dc6:	8b 40 08             	mov    0x8(%eax),%eax
  800dc9:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800dcd:	eb 18                	jmp    800de7 <lwip_setsockopt_internal+0xee>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800dcf:	8b 01                	mov    (%ecx),%eax
  800dd1:	8b 40 08             	mov    0x8(%eax),%eax
  800dd4:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800dd8:	eb 0d                	jmp    800de7 <lwip_setsockopt_internal+0xee>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800dda:	8b 01                	mov    (%ecx),%eax
  800ddc:	8b 40 08             	mov    0x8(%eax),%eax
  800ddf:	8b 13                	mov    (%ebx),%edx
  800de1:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800de7:	83 ec 0c             	sub    $0xc,%esp
  800dea:	8b 01                	mov    (%ecx),%eax
  800dec:	ff 70 10             	pushl  0x10(%eax)
  800def:	e8 26 91 00 00       	call   809f1a <sys_sem_signal>
}
  800df4:	83 c4 10             	add    $0x10,%esp
  800df7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800dfa:	c9                   	leave  
  800dfb:	c3                   	ret    

00800dfc <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  800dfc:	55                   	push   %ebp
  800dfd:	89 e5                	mov    %esp,%ebp
  800dff:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800e02:	6a 01                	push   $0x1
  800e04:	e8 65 8e 00 00       	call   809c6e <sys_sem_new>
  800e09:	a3 44 50 81 00       	mov    %eax,0x815044
  selectsem = sys_sem_new(1);
  800e0e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  800e15:	e8 54 8e 00 00       	call   809c6e <sys_sem_new>
  800e1a:	a3 40 50 81 00       	mov    %eax,0x815040
}
  800e1f:	83 c4 10             	add    $0x10,%esp
  800e22:	c9                   	leave  
  800e23:	c3                   	ret    

00800e24 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  800e24:	55                   	push   %ebp
  800e25:	89 e5                	mov    %esp,%ebp
  800e27:	57                   	push   %edi
  800e28:	56                   	push   %esi
  800e29:	53                   	push   %ebx
  800e2a:	83 ec 3c             	sub    $0x3c,%esp
  800e2d:	8b 7d 10             	mov    0x10(%ebp),%edi
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  800e30:	8b 45 08             	mov    0x8(%ebp),%eax
  800e33:	e8 fa f8 ff ff       	call   800732 <get_socket>
  if (!sock)
  800e38:	85 c0                	test   %eax,%eax
  800e3a:	0f 84 86 01 00 00    	je     800fc6 <lwip_accept+0x1a2>
  800e40:	89 c6                	mov    %eax,%esi
    return -1;

  newconn = netconn_accept(sock->conn);
  800e42:	83 ec 0c             	sub    $0xc,%esp
  800e45:	ff 30                	pushl  (%eax)
  800e47:	e8 28 9f 00 00       	call   80ad74 <netconn_accept>
  800e4c:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  800e4e:	83 c4 10             	add    $0x10,%esp
  800e51:	85 c0                	test   %eax,%eax
  800e53:	75 2c                	jne    800e81 <lwip_accept+0x5d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  800e55:	8b 06                	mov    (%esi),%eax
  800e57:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800e5b:	f7 d8                	neg    %eax
  800e5d:	ba 05 00 00 00       	mov    $0x5,%edx
  800e62:	83 f8 0e             	cmp    $0xe,%eax
  800e65:	77 07                	ja     800e6e <lwip_accept+0x4a>
  800e67:	8b 14 85 40 0e 81 00 	mov    0x810e40(,%eax,4),%edx
  800e6e:	89 56 10             	mov    %edx,0x10(%esi)
  800e71:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800e77:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800e7c:	e9 4a 01 00 00       	jmp    800fcb <lwip_accept+0x1a7>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  800e81:	6a 00                	push   $0x0
  800e83:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  800e86:	50                   	push   %eax
  800e87:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800e8a:	50                   	push   %eax
  800e8b:	53                   	push   %ebx
  800e8c:	e8 2d 9d 00 00       	call   80abbe <netconn_getaddr>
  800e91:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  800e94:	83 c4 10             	add    $0x10,%esp
  800e97:	84 c0                	test   %al,%al
  800e99:	74 36                	je     800ed1 <lwip_accept+0xad>
    netconn_delete(newconn);
  800e9b:	83 ec 0c             	sub    $0xc,%esp
  800e9e:	53                   	push   %ebx
  800e9f:	e8 b2 9c 00 00       	call   80ab56 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  800ea4:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  800ea8:	f7 d8                	neg    %eax
  800eaa:	83 c4 10             	add    $0x10,%esp
  800ead:	ba 05 00 00 00       	mov    $0x5,%edx
  800eb2:	83 f8 0e             	cmp    $0xe,%eax
  800eb5:	77 07                	ja     800ebe <lwip_accept+0x9a>
  800eb7:	8b 14 85 40 0e 81 00 	mov    0x810e40(,%eax,4),%edx
  800ebe:	89 56 10             	mov    %edx,0x10(%esi)
  800ec1:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800ec7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800ecc:	e9 fa 00 00 00       	jmp    800fcb <lwip_accept+0x1a7>
  }

  memset(&sin, 0, sizeof(sin));
  800ed1:	83 ec 04             	sub    $0x4,%esp
  800ed4:	6a 10                	push   $0x10
  800ed6:	6a 00                	push   $0x0
  800ed8:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800edb:	50                   	push   %eax
  800edc:	e8 50 dc 00 00       	call   80eb31 <memset>
  sin.sin_len = sizeof(sin);
  800ee1:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  800ee5:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  800ee9:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  800eed:	89 04 24             	mov    %eax,(%esp)
  800ef0:	e8 23 67 00 00       	call   807618 <htons>
  800ef5:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800ef9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800efc:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  800eff:	83 c4 10             	add    $0x10,%esp
  800f02:	83 3f 10             	cmpl   $0x10,(%edi)
  800f05:	76 06                	jbe    800f0d <lwip_accept+0xe9>
    *addrlen = sizeof(sin);
  800f07:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(addr, &sin, *addrlen);
  800f0d:	83 ec 04             	sub    $0x4,%esp
  800f10:	ff 37                	pushl  (%edi)
  800f12:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800f15:	50                   	push   %eax
  800f16:	ff 75 0c             	pushl  0xc(%ebp)
  800f19:	e8 c8 dc 00 00       	call   80ebe6 <memcpy>

  newsock = alloc_socket(newconn);
  800f1e:	89 d8                	mov    %ebx,%eax
  800f20:	e8 a9 fb ff ff       	call   800ace <alloc_socket>
  800f25:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  800f27:	83 c4 10             	add    $0x10,%esp
  800f2a:	83 f8 ff             	cmp    $0xffffffff,%eax
  800f2d:	75 24                	jne    800f53 <lwip_accept+0x12f>
    netconn_delete(newconn);
  800f2f:	83 ec 0c             	sub    $0xc,%esp
  800f32:	53                   	push   %ebx
  800f33:	e8 1e 9c 00 00       	call   80ab56 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  800f38:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  800f3f:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  800f46:	00 00 00 
    return -1;
  800f49:	83 c4 10             	add    $0x10,%esp
  800f4c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800f51:	eb 78                	jmp    800fcb <lwip_accept+0x1a7>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800f53:	83 f8 1f             	cmp    $0x1f,%eax
  800f56:	76 17                	jbe    800f6f <lwip_accept+0x14b>
  800f58:	83 ec 04             	sub    $0x4,%esp
  800f5b:	68 93 0d 81 00       	push   $0x810d93
  800f60:	68 25 01 00 00       	push   $0x125
  800f65:	68 70 0d 81 00       	push   $0x810d70
  800f6a:	e8 1f d4 00 00       	call   80e38e <_panic>
  newconn->callback = event_callback;
  800f6f:	c7 43 2c 2e 09 80 00 	movl   $0x80092e,0x2c(%ebx)
  nsock = &sockets[newsock];
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);

  sys_sem_wait(socksem);
  800f76:	83 ec 0c             	sub    $0xc,%esp
  800f79:	ff 35 44 50 81 00    	pushl  0x815044
  800f7f:	e8 a0 40 00 00       	call   805024 <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  800f84:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  800f87:	8d 14 85 60 50 81 00 	lea    0x815060(,%eax,4),%edx
  800f8e:	0f b7 42 0a          	movzwl 0xa(%edx),%eax
  800f92:	83 e8 01             	sub    $0x1,%eax
  800f95:	66 2b 43 1c          	sub    0x1c(%ebx),%ax
  800f99:	66 89 42 0a          	mov    %ax,0xa(%edx)
  newconn->socket = newsock;
  800f9d:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  800fa0:	83 c4 04             	add    $0x4,%esp
  800fa3:	ff 35 44 50 81 00    	pushl  0x815044
  800fa9:	e8 6c 8f 00 00       	call   809f1a <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  800fae:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  800fb5:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  800fbc:	00 00 00 
  return newsock;
  800fbf:	83 c4 10             	add    $0x10,%esp
  800fc2:	89 f8                	mov    %edi,%eax
  800fc4:	eb 05                	jmp    800fcb <lwip_accept+0x1a7>
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  if (!sock)
    return -1;
  800fc6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  return newsock;
}
  800fcb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800fce:	5b                   	pop    %ebx
  800fcf:	5e                   	pop    %esi
  800fd0:	5f                   	pop    %edi
  800fd1:	5d                   	pop    %ebp
  800fd2:	c3                   	ret    

00800fd3 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  800fd3:	55                   	push   %ebp
  800fd4:	89 e5                	mov    %esp,%ebp
  800fd6:	56                   	push   %esi
  800fd7:	53                   	push   %ebx
  800fd8:	83 ec 10             	sub    $0x10,%esp
  800fdb:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  800fde:	8b 45 08             	mov    0x8(%ebp),%eax
  800fe1:	e8 4c f7 ff ff       	call   800732 <get_socket>
  if (!sock)
  800fe6:	85 c0                	test   %eax,%eax
  800fe8:	0f 84 8f 00 00 00    	je     80107d <lwip_bind+0xaa>
  800fee:	89 c3                	mov    %eax,%ebx
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  800ff0:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  800ff4:	75 06                	jne    800ffc <lwip_bind+0x29>
  800ff6:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  800ffa:	74 17                	je     801013 <lwip_bind+0x40>
  800ffc:	83 ec 04             	sub    $0x4,%esp
  800fff:	68 a8 0d 81 00       	push   $0x810da8
  801004:	68 4a 01 00 00       	push   $0x14a
  801009:	68 70 0d 81 00       	push   $0x810d70
  80100e:	e8 7b d3 00 00       	call   80e38e <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801013:	8b 46 04             	mov    0x4(%esi),%eax
  801016:	89 45 f4             	mov    %eax,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  801019:	83 ec 0c             	sub    $0xc,%esp
  80101c:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801020:	50                   	push   %eax
  801021:	e8 ff 65 00 00       	call   807625 <ntohs>
  801026:	83 c4 0c             	add    $0xc,%esp
  801029:	0f b7 c0             	movzwl %ax,%eax
  80102c:	50                   	push   %eax
  80102d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801030:	50                   	push   %eax
  801031:	ff 33                	pushl  (%ebx)
  801033:	e8 12 9c 00 00       	call   80ac4a <netconn_bind>

  if (err != ERR_OK) {
  801038:	83 c4 10             	add    $0x10,%esp
  80103b:	84 c0                	test   %al,%al
  80103d:	74 26                	je     801065 <lwip_bind+0x92>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80103f:	0f be c0             	movsbl %al,%eax
  801042:	f7 d8                	neg    %eax
  801044:	ba 05 00 00 00       	mov    $0x5,%edx
  801049:	83 f8 0e             	cmp    $0xe,%eax
  80104c:	77 07                	ja     801055 <lwip_bind+0x82>
  80104e:	8b 14 85 40 0e 81 00 	mov    0x810e40(,%eax,4),%edx
  801055:	89 53 10             	mov    %edx,0x10(%ebx)
  801058:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  80105e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801063:	eb 1d                	jmp    801082 <lwip_bind+0xaf>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  801065:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80106c:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801073:	00 00 00 
  return 0;
  801076:	b8 00 00 00 00       	mov    $0x0,%eax
  80107b:	eb 05                	jmp    801082 <lwip_bind+0xaf>
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  80107d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  801082:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801085:	5b                   	pop    %ebx
  801086:	5e                   	pop    %esi
  801087:	5d                   	pop    %ebp
  801088:	c3                   	ret    

00801089 <lwip_close>:

int
lwip_close(int s)
{
  801089:	55                   	push   %ebp
  80108a:	89 e5                	mov    %esp,%ebp
  80108c:	53                   	push   %ebx
  80108d:	83 ec 04             	sub    $0x4,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  801090:	8b 45 08             	mov    0x8(%ebp),%eax
  801093:	e8 9a f6 ff ff       	call   800732 <get_socket>
  if (!sock) {
  801098:	85 c0                	test   %eax,%eax
  80109a:	74 6c                	je     801108 <lwip_close+0x7f>
  80109c:	89 c3                	mov    %eax,%ebx
    return -1;
  }

  netconn_delete(sock->conn);
  80109e:	83 ec 0c             	sub    $0xc,%esp
  8010a1:	ff 30                	pushl  (%eax)
  8010a3:	e8 ae 9a 00 00       	call   80ab56 <netconn_delete>

  sys_sem_wait(socksem);
  8010a8:	83 c4 04             	add    $0x4,%esp
  8010ab:	ff 35 44 50 81 00    	pushl  0x815044
  8010b1:	e8 6e 3f 00 00       	call   805024 <sys_sem_wait>
  if (sock->lastdata) {
  8010b6:	8b 43 04             	mov    0x4(%ebx),%eax
  8010b9:	83 c4 10             	add    $0x10,%esp
  8010bc:	85 c0                	test   %eax,%eax
  8010be:	74 0c                	je     8010cc <lwip_close+0x43>
    netbuf_delete(sock->lastdata);
  8010c0:	83 ec 0c             	sub    $0xc,%esp
  8010c3:	50                   	push   %eax
  8010c4:	e8 6c 13 00 00       	call   802435 <netbuf_delete>
  8010c9:	83 c4 10             	add    $0x10,%esp
  }
  sock->lastdata   = NULL;
  8010cc:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  8010d3:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  8010d9:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  8010df:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8010e6:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8010ed:	00 00 00 
  sys_sem_signal(socksem);
  8010f0:	83 ec 0c             	sub    $0xc,%esp
  8010f3:	ff 35 44 50 81 00    	pushl  0x815044
  8010f9:	e8 1c 8e 00 00       	call   809f1a <sys_sem_signal>
  return 0;
  8010fe:	83 c4 10             	add    $0x10,%esp
  801101:	b8 00 00 00 00       	mov    $0x0,%eax
  801106:	eb 05                	jmp    80110d <lwip_close+0x84>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  if (!sock) {
    return -1;
  801108:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  sock->lastoffset = 0;
  sock->conn       = NULL;
  sock_set_errno(sock, 0);
  sys_sem_signal(socksem);
  return 0;
}
  80110d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  801110:	c9                   	leave  
  801111:	c3                   	ret    

00801112 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  801112:	55                   	push   %ebp
  801113:	89 e5                	mov    %esp,%ebp
  801115:	56                   	push   %esi
  801116:	53                   	push   %ebx
  801117:	83 ec 10             	sub    $0x10,%esp
  80111a:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  80111d:	8b 45 08             	mov    0x8(%ebp),%eax
  801120:	e8 0d f6 ff ff       	call   800732 <get_socket>
  if (!sock)
  801125:	85 c0                	test   %eax,%eax
  801127:	0f 84 8f 00 00 00    	je     8011bc <lwip_connect+0xaa>
  80112d:	89 c3                	mov    %eax,%ebx
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80112f:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801133:	75 06                	jne    80113b <lwip_connect+0x29>
  801135:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  801139:	74 17                	je     801152 <lwip_connect+0x40>
  80113b:	83 ec 04             	sub    $0x4,%esp
  80113e:	68 c3 0d 81 00       	push   $0x810dc3
  801143:	68 86 01 00 00       	push   $0x186
  801148:	68 70 0d 81 00       	push   $0x810d70
  80114d:	e8 3c d2 00 00       	call   80e38e <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801152:	8b 46 04             	mov    0x4(%esi),%eax
  801155:	89 45 f4             	mov    %eax,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  801158:	83 ec 0c             	sub    $0xc,%esp
  80115b:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80115f:	50                   	push   %eax
  801160:	e8 c0 64 00 00       	call   807625 <ntohs>
  801165:	83 c4 0c             	add    $0xc,%esp
  801168:	0f b7 c0             	movzwl %ax,%eax
  80116b:	50                   	push   %eax
  80116c:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80116f:	50                   	push   %eax
  801170:	ff 33                	pushl  (%ebx)
  801172:	e8 24 9b 00 00       	call   80ac9b <netconn_connect>
  }

  if (err != ERR_OK) {
  801177:	83 c4 10             	add    $0x10,%esp
  80117a:	84 c0                	test   %al,%al
  80117c:	74 26                	je     8011a4 <lwip_connect+0x92>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80117e:	0f be c0             	movsbl %al,%eax
  801181:	f7 d8                	neg    %eax
  801183:	ba 05 00 00 00       	mov    $0x5,%edx
  801188:	83 f8 0e             	cmp    $0xe,%eax
  80118b:	77 07                	ja     801194 <lwip_connect+0x82>
  80118d:	8b 14 85 40 0e 81 00 	mov    0x810e40(,%eax,4),%edx
  801194:	89 53 10             	mov    %edx,0x10(%ebx)
  801197:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  80119d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8011a2:	eb 1d                	jmp    8011c1 <lwip_connect+0xaf>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8011a4:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8011ab:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8011b2:	00 00 00 
  return 0;
  8011b5:	b8 00 00 00 00       	mov    $0x0,%eax
  8011ba:	eb 05                	jmp    8011c1 <lwip_connect+0xaf>
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  8011bc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  8011c1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8011c4:	5b                   	pop    %ebx
  8011c5:	5e                   	pop    %esi
  8011c6:	5d                   	pop    %ebp
  8011c7:	c3                   	ret    

008011c8 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  8011c8:	55                   	push   %ebp
  8011c9:	89 e5                	mov    %esp,%ebp
  8011cb:	56                   	push   %esi
  8011cc:	53                   	push   %ebx
  8011cd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  8011d0:	8b 45 08             	mov    0x8(%ebp),%eax
  8011d3:	e8 5a f5 ff ff       	call   800732 <get_socket>
  if (!sock)
  8011d8:	85 c0                	test   %eax,%eax
  8011da:	74 6d                	je     801249 <lwip_listen+0x81>
  8011dc:	89 c6                	mov    %eax,%esi
  8011de:	85 db                	test   %ebx,%ebx
  8011e0:	b8 00 00 00 00       	mov    $0x0,%eax
  8011e5:	0f 48 d8             	cmovs  %eax,%ebx
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  8011e8:	83 ec 08             	sub    $0x8,%esp
  8011eb:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  8011f1:	b8 ff 00 00 00       	mov    $0xff,%eax
  8011f6:	0f 4f d8             	cmovg  %eax,%ebx
  8011f9:	0f b6 db             	movzbl %bl,%ebx
  8011fc:	53                   	push   %ebx
  8011fd:	ff 36                	pushl  (%esi)
  8011ff:	e8 2c 9b 00 00       	call   80ad30 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  801204:	83 c4 10             	add    $0x10,%esp
  801207:	84 c0                	test   %al,%al
  801209:	74 26                	je     801231 <lwip_listen+0x69>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80120b:	0f be c0             	movsbl %al,%eax
  80120e:	f7 d8                	neg    %eax
  801210:	ba 05 00 00 00       	mov    $0x5,%edx
  801215:	83 f8 0e             	cmp    $0xe,%eax
  801218:	77 07                	ja     801221 <lwip_listen+0x59>
  80121a:	8b 14 85 40 0e 81 00 	mov    0x810e40(,%eax,4),%edx
  801221:	89 56 10             	mov    %edx,0x10(%esi)
  801224:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  80122a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80122f:	eb 1d                	jmp    80124e <lwip_listen+0x86>
  }

  sock_set_errno(sock, 0);
  801231:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  801238:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80123f:	00 00 00 
  return 0;
  801242:	b8 00 00 00 00       	mov    $0x0,%eax
  801247:	eb 05                	jmp    80124e <lwip_listen+0x86>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  if (!sock)
    return -1;
  801249:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  }

  sock_set_errno(sock, 0);
  return 0;
}
  80124e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801251:	5b                   	pop    %ebx
  801252:	5e                   	pop    %esi
  801253:	5d                   	pop    %ebp
  801254:	c3                   	ret    

00801255 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  801255:	55                   	push   %ebp
  801256:	89 e5                	mov    %esp,%ebp
  801258:	57                   	push   %edi
  801259:	56                   	push   %esi
  80125a:	53                   	push   %ebx
  80125b:	83 ec 4c             	sub    $0x4c,%esp
  80125e:	8b 5d 14             	mov    0x14(%ebp),%ebx
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  801261:	8b 45 08             	mov    0x8(%ebp),%eax
  801264:	e8 c9 f4 ff ff       	call   800732 <get_socket>
  if (!sock)
  801269:	85 c0                	test   %eax,%eax
  80126b:	0f 84 04 02 00 00    	je     801475 <lwip_recvfrom+0x220>
  801271:	89 c7                	mov    %eax,%edi
  801273:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  801279:	89 d8                	mov    %ebx,%eax
  80127b:	83 e0 08             	and    $0x8,%eax
  80127e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  801281:	83 e3 01             	and    $0x1,%ebx
  801284:	89 5d b8             	mov    %ebx,-0x48(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  801287:	8b 77 04             	mov    0x4(%edi),%esi
  80128a:	85 f6                	test   %esi,%esi
  80128c:	0f 85 80 00 00 00    	jne    801312 <lwip_recvfrom+0xbd>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  801292:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801296:	75 06                	jne    80129e <lwip_recvfrom+0x49>
  801298:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  80129c:	74 22                	je     8012c0 <lwip_recvfrom+0x6b>
  80129e:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8012a3:	75 1b                	jne    8012c0 <lwip_recvfrom+0x6b>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  8012a5:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  8012ac:	c7 05 e0 b1 b3 00 0b 	movl   $0xb,0xb3b1e0
  8012b3:	00 00 00 
        return -1;
  8012b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012bb:	e9 ba 01 00 00       	jmp    80147a <lwip_recvfrom+0x225>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  8012c0:	83 ec 0c             	sub    $0xc,%esp
  8012c3:	ff 37                	pushl  (%edi)
  8012c5:	e8 1c 9b 00 00       	call   80ade6 <netconn_recv>
  8012ca:	89 c6                	mov    %eax,%esi
  8012cc:	89 47 04             	mov    %eax,0x4(%edi)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  8012cf:	83 c4 10             	add    $0x10,%esp
  8012d2:	85 c0                	test   %eax,%eax
  8012d4:	75 3c                	jne    801312 <lwip_recvfrom+0xbd>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  8012d6:	8b 17                	mov    (%edi),%edx
  8012d8:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  8012dc:	74 0b                	je     8012e9 <lwip_recvfrom+0x94>
  8012de:	b8 6e 00 00 00       	mov    $0x6e,%eax
  8012e3:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  8012e7:	74 17                	je     801300 <lwip_recvfrom+0xab>
  8012e9:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  8012ed:	f7 da                	neg    %edx
  8012ef:	b8 05 00 00 00       	mov    $0x5,%eax
  8012f4:	83 fa 0e             	cmp    $0xe,%edx
  8012f7:	77 07                	ja     801300 <lwip_recvfrom+0xab>
  8012f9:	8b 04 95 40 0e 81 00 	mov    0x810e40(,%edx,4),%eax
  801300:	89 47 10             	mov    %eax,0x10(%edi)
  801303:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
        return 0;
  801308:	b8 00 00 00 00       	mov    $0x0,%eax
  80130d:	e9 68 01 00 00       	jmp    80147a <lwip_recvfrom+0x225>
      }
    }

    buflen = netbuf_len(buf);
  801312:	8b 16                	mov    (%esi),%edx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  801314:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  801318:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  80131c:	29 c3                	sub    %eax,%ebx

    if (len > buflen) {
  80131e:	0f b7 cb             	movzwl %bx,%ecx
  801321:	89 4d bc             	mov    %ecx,-0x44(%ebp)
      copylen = buflen;
    } else {
      copylen = len;
  801324:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  801327:	66 0f 4e 5d 10       	cmovle 0x10(%ebp),%bx
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80132c:	0f b7 cb             	movzwl %bx,%ecx
  80132f:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  801332:	0f b7 c0             	movzwl %ax,%eax
  801335:	50                   	push   %eax
  801336:	51                   	push   %ecx
  801337:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  80133b:	03 45 0c             	add    0xc(%ebp),%eax
  80133e:	50                   	push   %eax
  80133f:	52                   	push   %edx
  801340:	e8 72 3b 00 00       	call   804eb7 <pbuf_copy_partial>

    off += copylen;
  801345:	66 01 5d c4          	add    %bx,-0x3c(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801349:	83 c4 04             	add    $0x4,%esp
  80134c:	ff 37                	pushl  (%edi)
  80134e:	e8 43 98 00 00       	call   80ab96 <netconn_type>
  801353:	83 c4 10             	add    $0x10,%esp
      len -= copylen;
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
        done = 1;
      }
    } else {
      done = 1;
  801356:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);

    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80135a:	83 f8 10             	cmp    $0x10,%eax
  80135d:	75 1d                	jne    80137c <lwip_recvfrom+0x127>
      len -= copylen;
  80135f:	8b 45 c0             	mov    -0x40(%ebp),%eax
  801362:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  801365:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801369:	7e 11                	jle    80137c <lwip_recvfrom+0x127>
  80136b:	8b 06                	mov    (%esi),%eax
  80136d:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  801371:	75 09                	jne    80137c <lwip_recvfrom+0x127>
        done = 1;
  801373:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  801378:	0f 94 45 c7          	sete   -0x39(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  80137c:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  801380:	75 3d                	jne    8013bf <lwip_recvfrom+0x16a>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  801382:	8b 07                	mov    (%edi),%eax
  801384:	83 38 10             	cmpl   $0x10,(%eax)
  801387:	75 13                	jne    80139c <lwip_recvfrom+0x147>
  801389:	8b 45 bc             	mov    -0x44(%ebp),%eax
  80138c:	2b 45 c0             	sub    -0x40(%ebp),%eax
  80138f:	85 c0                	test   %eax,%eax
  801391:	7e 09                	jle    80139c <lwip_recvfrom+0x147>
        sock->lastdata = buf;
  801393:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  801396:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  80139a:	eb 19                	jmp    8013b5 <lwip_recvfrom+0x160>
      } else {
        sock->lastdata = NULL;
  80139c:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  8013a3:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  8013a9:	83 ec 0c             	sub    $0xc,%esp
  8013ac:	56                   	push   %esi
  8013ad:	e8 83 10 00 00       	call   802435 <netbuf_delete>
  8013b2:	83 c4 10             	add    $0x10,%esp
      }
    } else {
      done = 1;
    }
  } while (!done);
  8013b5:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  8013b9:	0f 84 c8 fe ff ff    	je     801287 <lwip_recvfrom+0x32>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  8013bf:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8013c3:	0f 84 95 00 00 00    	je     80145e <lwip_recvfrom+0x209>
  8013c9:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8013cd:	0f 84 8b 00 00 00    	je     80145e <lwip_recvfrom+0x209>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8013d3:	83 ec 0c             	sub    $0xc,%esp
  8013d6:	ff 37                	pushl  (%edi)
  8013d8:	e8 b9 97 00 00       	call   80ab96 <netconn_type>
  8013dd:	83 c4 10             	add    $0x10,%esp
  8013e0:	83 f8 10             	cmp    $0x10,%eax
  8013e3:	75 19                	jne    8013fe <lwip_recvfrom+0x1a9>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
      netconn_getaddr(sock->conn, addr, &port, 0);
  8013e5:	6a 00                	push   $0x0
  8013e7:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  8013ea:	50                   	push   %eax
  8013eb:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8013ee:	50                   	push   %eax
  8013ef:	ff 37                	pushl  (%edi)
  8013f1:	e8 c8 97 00 00       	call   80abbe <netconn_getaddr>
  8013f6:	83 c4 10             	add    $0x10,%esp
  /* Check to see from where the data was.*/
  if (from && fromlen) {
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  8013f9:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  8013fc:	eb 0b                	jmp    801409 <lwip_recvfrom+0x1b4>
      netconn_getaddr(sock->conn, addr, &port, 0);
    } else {
      addr = netbuf_fromaddr(buf);
  8013fe:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  801401:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  801405:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  801409:	83 ec 04             	sub    $0x4,%esp
  80140c:	6a 10                	push   $0x10
  80140e:	6a 00                	push   $0x0
  801410:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801413:	50                   	push   %eax
  801414:	e8 18 d7 00 00       	call   80eb31 <memset>
    sin.sin_len = sizeof(sin);
  801419:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  80141d:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  801421:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  801425:	89 04 24             	mov    %eax,(%esp)
  801428:	e8 eb 61 00 00       	call   807618 <htons>
  80142d:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  801431:	8b 03                	mov    (%ebx),%eax
  801433:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  801436:	83 c4 10             	add    $0x10,%esp
  801439:	8b 45 1c             	mov    0x1c(%ebp),%eax
  80143c:	83 38 10             	cmpl   $0x10,(%eax)
  80143f:	76 06                	jbe    801447 <lwip_recvfrom+0x1f2>
      *fromlen = sizeof(sin);
  801441:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

    SMEMCPY(from, &sin, *fromlen);
  801447:	83 ec 04             	sub    $0x4,%esp
  80144a:	8b 45 1c             	mov    0x1c(%ebp),%eax
  80144d:	ff 30                	pushl  (%eax)
  80144f:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801452:	50                   	push   %eax
  801453:	ff 75 18             	pushl  0x18(%ebp)
  801456:	e8 8b d7 00 00       	call   80ebe6 <memcpy>
  80145b:	83 c4 10             	add    $0x10,%esp
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  80145e:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  801465:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80146c:	00 00 00 
  return off;
  80146f:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  801473:	eb 05                	jmp    80147a <lwip_recvfrom+0x225>
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  if (!sock)
    return -1;
  801475:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  return off;
}
  80147a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80147d:	5b                   	pop    %ebx
  80147e:	5e                   	pop    %esi
  80147f:	5f                   	pop    %edi
  801480:	5d                   	pop    %ebp
  801481:	c3                   	ret    

00801482 <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  801482:	55                   	push   %ebp
  801483:	89 e5                	mov    %esp,%ebp
  801485:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  801488:	6a 00                	push   $0x0
  80148a:	6a 00                	push   $0x0
  80148c:	6a 00                	push   $0x0
  80148e:	ff 75 10             	pushl  0x10(%ebp)
  801491:	ff 75 0c             	pushl  0xc(%ebp)
  801494:	ff 75 08             	pushl  0x8(%ebp)
  801497:	e8 b9 fd ff ff       	call   801255 <lwip_recvfrom>
}
  80149c:	c9                   	leave  
  80149d:	c3                   	ret    

0080149e <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  80149e:	55                   	push   %ebp
  80149f:	89 e5                	mov    %esp,%ebp
  8014a1:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8014a4:	6a 00                	push   $0x0
  8014a6:	6a 00                	push   $0x0
  8014a8:	ff 75 14             	pushl  0x14(%ebp)
  8014ab:	ff 75 10             	pushl  0x10(%ebp)
  8014ae:	ff 75 0c             	pushl  0xc(%ebp)
  8014b1:	ff 75 08             	pushl  0x8(%ebp)
  8014b4:	e8 9c fd ff ff       	call   801255 <lwip_recvfrom>
}
  8014b9:	c9                   	leave  
  8014ba:	c3                   	ret    

008014bb <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  8014bb:	55                   	push   %ebp
  8014bc:	89 e5                	mov    %esp,%ebp
  8014be:	57                   	push   %edi
  8014bf:	56                   	push   %esi
  8014c0:	53                   	push   %ebx
  8014c1:	83 ec 2c             	sub    $0x2c,%esp
  8014c4:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8014c7:	8b 75 18             	mov    0x18(%ebp),%esi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  8014ca:	8b 45 08             	mov    0x8(%ebp),%eax
  8014cd:	e8 60 f2 ff ff       	call   800732 <get_socket>
  if (!sock)
  8014d2:	85 c0                	test   %eax,%eax
  8014d4:	0f 84 21 01 00 00    	je     8015fb <lwip_sendto+0x140>
  8014da:	89 c7                	mov    %eax,%edi
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  8014dc:	8b 00                	mov    (%eax),%eax
  8014de:	83 38 10             	cmpl   $0x10,(%eax)
  8014e1:	75 17                	jne    8014fa <lwip_sendto+0x3f>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  8014e3:	ff 75 14             	pushl  0x14(%ebp)
  8014e6:	53                   	push   %ebx
  8014e7:	ff 75 0c             	pushl  0xc(%ebp)
  8014ea:	ff 75 08             	pushl  0x8(%ebp)
  8014ed:	e8 16 01 00 00       	call   801608 <lwip_send>
  8014f2:	83 c4 10             	add    $0x10,%esp
  8014f5:	e9 06 01 00 00       	jmp    801600 <lwip_sendto+0x145>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8014fa:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  801500:	76 17                	jbe    801519 <lwip_sendto+0x5e>
  801502:	83 ec 04             	sub    $0x4,%esp
  801505:	68 00 0e 81 00       	push   $0x810e00
  80150a:	68 97 02 00 00       	push   $0x297
  80150f:	68 70 0d 81 00       	push   $0x810d70
  801514:	e8 75 ce 00 00       	call   80e38e <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  801519:	85 f6                	test   %esi,%esi
  80151b:	75 06                	jne    801523 <lwip_sendto+0x68>
  80151d:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  801521:	74 23                	je     801546 <lwip_sendto+0x8b>
  801523:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  801527:	75 06                	jne    80152f <lwip_sendto+0x74>
  801529:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  80152d:	74 17                	je     801546 <lwip_sendto+0x8b>
  80152f:	83 ec 04             	sub    $0x4,%esp
  801532:	68 e1 0d 81 00       	push   $0x810de1
  801537:	68 9b 02 00 00       	push   $0x29b
  80153c:	68 70 0d 81 00       	push   $0x810d70
  801541:	e8 48 ce 00 00       	call   80e38e <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  801546:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80154d:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  801554:	85 f6                	test   %esi,%esi
  801556:	74 22                	je     80157a <lwip_sendto+0xbf>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  801558:	8b 46 04             	mov    0x4(%esi),%eax
  80155b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  80155e:	83 ec 0c             	sub    $0xc,%esp
  801561:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801565:	50                   	push   %eax
  801566:	e8 ba 60 00 00       	call   807625 <ntohs>
    buf.addr         = &remote_addr;
  80156b:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80156e:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  801571:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  801575:	83 c4 10             	add    $0x10,%esp
  801578:	eb 14                	jmp    80158e <lwip_sendto+0xd3>
  } else {
    remote_addr.addr = 0;
  80157a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  801581:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  801588:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  80158e:	83 ec 04             	sub    $0x4,%esp
  801591:	0f b7 c3             	movzwl %bx,%eax
  801594:	50                   	push   %eax
  801595:	ff 75 0c             	pushl  0xc(%ebp)
  801598:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80159b:	50                   	push   %eax
  80159c:	e8 96 0f 00 00       	call   802537 <netbuf_ref>
  8015a1:	0f be f0             	movsbl %al,%esi
  8015a4:	83 c4 10             	add    $0x10,%esp
  8015a7:	85 f6                	test   %esi,%esi
  8015a9:	75 14                	jne    8015bf <lwip_sendto+0x104>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  8015ab:	83 ec 08             	sub    $0x8,%esp
  8015ae:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8015b1:	50                   	push   %eax
  8015b2:	ff 37                	pushl  (%edi)
  8015b4:	e8 cf 99 00 00       	call   80af88 <netconn_send>
  8015b9:	0f be f0             	movsbl %al,%esi
  8015bc:	83 c4 10             	add    $0x10,%esp
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  8015bf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8015c2:	85 c0                	test   %eax,%eax
  8015c4:	74 0c                	je     8015d2 <lwip_sendto+0x117>
    pbuf_free(buf.p);
  8015c6:	83 ec 0c             	sub    $0xc,%esp
  8015c9:	50                   	push   %eax
  8015ca:	e8 98 31 00 00       	call   804767 <pbuf_free>
  8015cf:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  8015d2:	89 f2                	mov    %esi,%edx
  8015d4:	f7 da                	neg    %edx
  8015d6:	b8 05 00 00 00       	mov    $0x5,%eax
  8015db:	83 fa 0e             	cmp    $0xe,%edx
  8015de:	77 07                	ja     8015e7 <lwip_sendto+0x12c>
  8015e0:	8b 04 95 40 0e 81 00 	mov    0x810e40(,%edx,4),%eax
  8015e7:	89 47 10             	mov    %eax,0x10(%edi)
  8015ea:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return (err==ERR_OK?size:-1);
  8015ef:	85 f6                	test   %esi,%esi
  8015f1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8015f6:	0f 44 c3             	cmove  %ebx,%eax
  8015f9:	eb 05                	jmp    801600 <lwip_sendto+0x145>
  u16_t remote_port;
#endif

  sock = get_socket(s);
  if (!sock)
    return -1;
  8015fb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    pbuf_free(buf.p);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  801600:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801603:	5b                   	pop    %ebx
  801604:	5e                   	pop    %esi
  801605:	5f                   	pop    %edi
  801606:	5d                   	pop    %ebp
  801607:	c3                   	ret    

00801608 <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  801608:	55                   	push   %ebp
  801609:	89 e5                	mov    %esp,%ebp
  80160b:	57                   	push   %edi
  80160c:	56                   	push   %esi
  80160d:	53                   	push   %ebx
  80160e:	83 ec 0c             	sub    $0xc,%esp
  801611:	8b 7d 08             	mov    0x8(%ebp),%edi
  801614:	8b 5d 10             	mov    0x10(%ebp),%ebx
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  801617:	89 f8                	mov    %edi,%eax
  801619:	e8 14 f1 ff ff       	call   800732 <get_socket>
  if (!sock)
  80161e:	85 c0                	test   %eax,%eax
  801620:	74 6c                	je     80168e <lwip_send+0x86>
  801622:	89 c6                	mov    %eax,%esi
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  801624:	8b 10                	mov    (%eax),%edx
  801626:	83 3a 10             	cmpl   $0x10,(%edx)
  801629:	74 19                	je     801644 <lwip_send+0x3c>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  80162b:	83 ec 08             	sub    $0x8,%esp
  80162e:	6a 00                	push   $0x0
  801630:	6a 00                	push   $0x0
  801632:	ff 75 14             	pushl  0x14(%ebp)
  801635:	53                   	push   %ebx
  801636:	ff 75 0c             	pushl  0xc(%ebp)
  801639:	57                   	push   %edi
  80163a:	e8 7c fe ff ff       	call   8014bb <lwip_sendto>
  80163f:	83 c4 20             	add    $0x20,%esp
  801642:	eb 4f                	jmp    801693 <lwip_send+0x8b>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  801644:	8b 45 14             	mov    0x14(%ebp),%eax
  801647:	83 e0 10             	and    $0x10,%eax
  80164a:	83 f8 01             	cmp    $0x1,%eax
  80164d:	19 c0                	sbb    %eax,%eax
  80164f:	83 e0 fe             	and    $0xfffffffe,%eax
  801652:	83 c0 03             	add    $0x3,%eax
  801655:	50                   	push   %eax
  801656:	53                   	push   %ebx
  801657:	ff 75 0c             	pushl  0xc(%ebp)
  80165a:	52                   	push   %edx
  80165b:	e8 a4 99 00 00       	call   80b004 <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  801660:	0f be d0             	movsbl %al,%edx
  801663:	f7 da                	neg    %edx
  801665:	83 c4 10             	add    $0x10,%esp
  801668:	b9 05 00 00 00       	mov    $0x5,%ecx
  80166d:	83 fa 0e             	cmp    $0xe,%edx
  801670:	77 07                	ja     801679 <lwip_send+0x71>
  801672:	8b 0c 95 40 0e 81 00 	mov    0x810e40(,%edx,4),%ecx
  801679:	89 4e 10             	mov    %ecx,0x10(%esi)
  80167c:	89 0d e0 b1 b3 00    	mov    %ecx,0xb3b1e0
  return (err==ERR_OK?size:-1);
  801682:	84 c0                	test   %al,%al
  801684:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801689:	0f 44 c3             	cmove  %ebx,%eax
  80168c:	eb 05                	jmp    801693 <lwip_send+0x8b>
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  if (!sock)
    return -1;
  80168e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  801693:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801696:	5b                   	pop    %ebx
  801697:	5e                   	pop    %esi
  801698:	5f                   	pop    %edi
  801699:	5d                   	pop    %ebp
  80169a:	c3                   	ret    

0080169b <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  80169b:	55                   	push   %ebp
  80169c:	89 e5                	mov    %esp,%ebp
  80169e:	53                   	push   %ebx
  80169f:	83 ec 04             	sub    $0x4,%esp
  8016a2:	8b 45 0c             	mov    0xc(%ebp),%eax
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  8016a5:	83 f8 02             	cmp    $0x2,%eax
  8016a8:	74 27                	je     8016d1 <lwip_socket+0x36>
  8016aa:	83 f8 03             	cmp    $0x3,%eax
  8016ad:	74 07                	je     8016b6 <lwip_socket+0x1b>
  8016af:	83 f8 01             	cmp    $0x1,%eax
  8016b2:	75 5c                	jne    801710 <lwip_socket+0x75>
  8016b4:	eb 42                	jmp    8016f8 <lwip_socket+0x5d>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  8016b6:	83 ec 04             	sub    $0x4,%esp
  8016b9:	68 2e 09 80 00       	push   $0x80092e
  8016be:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  8016c2:	50                   	push   %eax
  8016c3:	6a 40                	push   $0x40
  8016c5:	e8 9e 93 00 00       	call   80aa68 <netconn_new_with_proto_and_callback>
  8016ca:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8016cc:	83 c4 10             	add    $0x10,%esp
  8016cf:	eb 50                	jmp    801721 <lwip_socket+0x86>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  8016d1:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  8016d8:	0f 94 c0             	sete   %al
  8016db:	0f b6 c0             	movzbl %al,%eax
  8016de:	83 c0 20             	add    $0x20,%eax
  8016e1:	83 ec 04             	sub    $0x4,%esp
  8016e4:	68 2e 09 80 00       	push   $0x80092e
  8016e9:	6a 00                	push   $0x0
  8016eb:	50                   	push   %eax
  8016ec:	e8 77 93 00 00       	call   80aa68 <netconn_new_with_proto_and_callback>
  8016f1:	89 c3                	mov    %eax,%ebx
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8016f3:	83 c4 10             	add    $0x10,%esp
  8016f6:	eb 29                	jmp    801721 <lwip_socket+0x86>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8016f8:	83 ec 04             	sub    $0x4,%esp
  8016fb:	68 2e 09 80 00       	push   $0x80092e
  801700:	6a 00                	push   $0x0
  801702:	6a 10                	push   $0x10
  801704:	e8 5f 93 00 00       	call   80aa68 <netconn_new_with_proto_and_callback>
  801709:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  80170b:	83 c4 10             	add    $0x10,%esp
  80170e:	eb 11                	jmp    801721 <lwip_socket+0x86>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  801710:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801717:	00 00 00 
    return -1;
  80171a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80171f:	eb 4b                	jmp    80176c <lwip_socket+0xd1>
  }

  if (!conn) {
  801721:	85 db                	test   %ebx,%ebx
  801723:	75 11                	jne    801736 <lwip_socket+0x9b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  801725:	c7 05 e0 b1 b3 00 69 	movl   $0x69,0xb3b1e0
  80172c:	00 00 00 
    return -1;
  80172f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801734:	eb 36                	jmp    80176c <lwip_socket+0xd1>
  }

  i = alloc_socket(conn);
  801736:	89 d8                	mov    %ebx,%eax
  801738:	e8 91 f3 ff ff       	call   800ace <alloc_socket>

  if (i == -1) {
  80173d:	83 f8 ff             	cmp    $0xffffffff,%eax
  801740:	75 1d                	jne    80175f <lwip_socket+0xc4>
    netconn_delete(conn);
  801742:	83 ec 0c             	sub    $0xc,%esp
  801745:	53                   	push   %ebx
  801746:	e8 0b 94 00 00       	call   80ab56 <netconn_delete>
    set_errno(ENFILE);
  80174b:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  801752:	00 00 00 
    return -1;
  801755:	83 c4 10             	add    $0x10,%esp
  801758:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80175d:	eb 0d                	jmp    80176c <lwip_socket+0xd1>
  }
  conn->socket = i;
  80175f:	89 43 1c             	mov    %eax,0x1c(%ebx)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  801762:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801769:	00 00 00 
  return i;
}
  80176c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80176f:	c9                   	leave  
  801770:	c3                   	ret    

00801771 <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  801771:	55                   	push   %ebp
  801772:	89 e5                	mov    %esp,%ebp
  801774:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  801777:	6a 00                	push   $0x0
  801779:	ff 75 10             	pushl  0x10(%ebp)
  80177c:	ff 75 0c             	pushl  0xc(%ebp)
  80177f:	ff 75 08             	pushl  0x8(%ebp)
  801782:	e8 81 fe ff ff       	call   801608 <lwip_send>
}
  801787:	c9                   	leave  
  801788:	c3                   	ret    

00801789 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  801789:	55                   	push   %ebp
  80178a:	89 e5                	mov    %esp,%ebp
  80178c:	57                   	push   %edi
  80178d:	56                   	push   %esi
  80178e:	53                   	push   %ebx
  80178f:	83 ec 58             	sub    $0x58,%esp
  801792:	8b 7d 0c             	mov    0xc(%ebp),%edi
  801795:	8b 75 10             	mov    0x10(%ebp),%esi
  801798:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  80179b:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  8017a2:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  8017a5:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  8017a8:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  8017ab:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  8017b2:	ff 35 40 50 81 00    	pushl  0x815040
  8017b8:	e8 67 38 00 00       	call   805024 <sys_sem_wait>

  if (readset)
  8017bd:	83 c4 10             	add    $0x10,%esp
  8017c0:	85 ff                	test   %edi,%edi
  8017c2:	74 07                	je     8017cb <lwip_select+0x42>
    lreadset = *readset;
  8017c4:	8b 07                	mov    (%edi),%eax
  8017c6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8017c9:	eb 13                	jmp    8017de <lwip_select+0x55>
  else
    FD_ZERO(&lreadset);
  8017cb:	83 ec 04             	sub    $0x4,%esp
  8017ce:	6a 04                	push   $0x4
  8017d0:	6a 00                	push   $0x0
  8017d2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8017d5:	50                   	push   %eax
  8017d6:	e8 56 d3 00 00       	call   80eb31 <memset>
  8017db:	83 c4 10             	add    $0x10,%esp
  if (writeset)
  8017de:	85 f6                	test   %esi,%esi
  8017e0:	74 07                	je     8017e9 <lwip_select+0x60>
    lwriteset = *writeset;
  8017e2:	8b 06                	mov    (%esi),%eax
  8017e4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8017e7:	eb 13                	jmp    8017fc <lwip_select+0x73>
  else
    FD_ZERO(&lwriteset);
  8017e9:	83 ec 04             	sub    $0x4,%esp
  8017ec:	6a 04                	push   $0x4
  8017ee:	6a 00                	push   $0x0
  8017f0:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8017f3:	50                   	push   %eax
  8017f4:	e8 38 d3 00 00       	call   80eb31 <memset>
  8017f9:	83 c4 10             	add    $0x10,%esp
  if (exceptset)
  8017fc:	85 db                	test   %ebx,%ebx
  8017fe:	74 07                	je     801807 <lwip_select+0x7e>
    lexceptset = *exceptset;
  801800:	8b 03                	mov    (%ebx),%eax
  801802:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801805:	eb 13                	jmp    80181a <lwip_select+0x91>
  else
    FD_ZERO(&lexceptset);
  801807:	83 ec 04             	sub    $0x4,%esp
  80180a:	6a 04                	push   $0x4
  80180c:	6a 00                	push   $0x0
  80180e:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801811:	50                   	push   %eax
  801812:	e8 1a d3 00 00       	call   80eb31 <memset>
  801817:	83 c4 10             	add    $0x10,%esp

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  80181a:	83 ec 0c             	sub    $0xc,%esp
  80181d:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801820:	50                   	push   %eax
  801821:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801824:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801827:	8b 45 08             	mov    0x8(%ebp),%eax
  80182a:	e8 4e ef ff ff       	call   80077d <lwip_selscan>
  80182f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  801832:	83 c4 10             	add    $0x10,%esp
  801835:	85 c0                	test   %eax,%eax
  801837:	0f 85 b5 01 00 00    	jne    8019f2 <lwip_select+0x269>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  80183d:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801841:	0f 84 4f 02 00 00    	je     801a96 <lwip_select+0x30d>
  801847:	8b 45 18             	mov    0x18(%ebp),%eax
  80184a:	83 38 00             	cmpl   $0x0,(%eax)
  80184d:	0f 85 dd 01 00 00    	jne    801a30 <lwip_select+0x2a7>
  801853:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  801857:	0f 85 d3 01 00 00    	jne    801a30 <lwip_select+0x2a7>
      sys_sem_signal(selectsem);
  80185d:	83 ec 0c             	sub    $0xc,%esp
  801860:	ff 35 40 50 81 00    	pushl  0x815040
  801866:	e8 af 86 00 00       	call   809f1a <sys_sem_signal>
      if (readset)
  80186b:	83 c4 10             	add    $0x10,%esp
  80186e:	85 ff                	test   %edi,%edi
  801870:	74 10                	je     801882 <lwip_select+0xf9>
        FD_ZERO(readset);
  801872:	83 ec 04             	sub    $0x4,%esp
  801875:	6a 04                	push   $0x4
  801877:	6a 00                	push   $0x0
  801879:	57                   	push   %edi
  80187a:	e8 b2 d2 00 00       	call   80eb31 <memset>
  80187f:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801882:	85 f6                	test   %esi,%esi
  801884:	74 10                	je     801896 <lwip_select+0x10d>
        FD_ZERO(writeset);
  801886:	83 ec 04             	sub    $0x4,%esp
  801889:	6a 04                	push   $0x4
  80188b:	6a 00                	push   $0x0
  80188d:	56                   	push   %esi
  80188e:	e8 9e d2 00 00       	call   80eb31 <memset>
  801893:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801896:	85 db                	test   %ebx,%ebx
  801898:	74 10                	je     8018aa <lwip_select+0x121>
        FD_ZERO(exceptset);
  80189a:	83 ec 04             	sub    $0x4,%esp
  80189d:	6a 04                	push   $0x4
  80189f:	6a 00                	push   $0x0
  8018a1:	53                   	push   %ebx
  8018a2:	e8 8a d2 00 00       	call   80eb31 <memset>
  8018a7:	83 c4 10             	add    $0x10,%esp
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  8018aa:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8018b1:	00 00 00 
  
      return 0;
  8018b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8018b9:	e9 10 02 00 00       	jmp    801ace <lwip_select+0x345>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  8018be:	83 ec 08             	sub    $0x8,%esp
  8018c1:	52                   	push   %edx
  8018c2:	ff 75 d8             	pushl  -0x28(%ebp)
  8018c5:	e8 19 39 00 00       	call   8051e3 <sys_sem_wait_timeout>
  8018ca:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  8018cd:	83 c4 04             	add    $0x4,%esp
  8018d0:	ff 35 40 50 81 00    	pushl  0x815040
  8018d6:	e8 49 37 00 00       	call   805024 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  8018db:	a1 48 50 81 00       	mov    0x815048,%eax
  8018e0:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  8018e3:	83 c4 10             	add    $0x10,%esp
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  8018e6:	89 d1                	mov    %edx,%ecx
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
  8018e8:	39 d0                	cmp    %edx,%eax
  8018ea:	75 19                	jne    801905 <lwip_select+0x17c>
      select_cb_list = select_cb.next;
  8018ec:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  8018ef:	a3 48 50 81 00       	mov    %eax,0x815048
  8018f4:	eb 13                	jmp    801909 <lwip_select+0x180>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  8018f6:	8b 10                	mov    (%eax),%edx
  8018f8:	39 ca                	cmp    %ecx,%edx
  8018fa:	75 07                	jne    801903 <lwip_select+0x17a>
          p_selcb->next = select_cb.next;
  8018fc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  8018ff:	89 10                	mov    %edx,(%eax)
          break;
  801901:	eb 06                	jmp    801909 <lwip_select+0x180>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801903:	89 d0                	mov    %edx,%eax
  801905:	85 c0                	test   %eax,%eax
  801907:	75 ed                	jne    8018f6 <lwip_select+0x16d>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  801909:	83 ec 0c             	sub    $0xc,%esp
  80190c:	ff 35 40 50 81 00    	pushl  0x815040
  801912:	e8 03 86 00 00       	call   809f1a <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  801917:	83 c4 04             	add    $0x4,%esp
  80191a:	ff 75 d8             	pushl  -0x28(%ebp)
  80191d:	e8 cd 83 00 00       	call   809cef <sys_sem_free>
    if (i == 0)  {
  801922:	83 c4 10             	add    $0x10,%esp
  801925:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801929:	75 50                	jne    80197b <lwip_select+0x1f2>
      /* Timeout */
      if (readset)
  80192b:	85 ff                	test   %edi,%edi
  80192d:	74 10                	je     80193f <lwip_select+0x1b6>
        FD_ZERO(readset);
  80192f:	83 ec 04             	sub    $0x4,%esp
  801932:	6a 04                	push   $0x4
  801934:	6a 00                	push   $0x0
  801936:	57                   	push   %edi
  801937:	e8 f5 d1 00 00       	call   80eb31 <memset>
  80193c:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  80193f:	85 f6                	test   %esi,%esi
  801941:	74 10                	je     801953 <lwip_select+0x1ca>
        FD_ZERO(writeset);
  801943:	83 ec 04             	sub    $0x4,%esp
  801946:	6a 04                	push   $0x4
  801948:	6a 00                	push   $0x0
  80194a:	56                   	push   %esi
  80194b:	e8 e1 d1 00 00       	call   80eb31 <memset>
  801950:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801953:	85 db                	test   %ebx,%ebx
  801955:	74 10                	je     801967 <lwip_select+0x1de>
        FD_ZERO(exceptset);
  801957:	83 ec 04             	sub    $0x4,%esp
  80195a:	6a 04                	push   $0x4
  80195c:	6a 00                	push   $0x0
  80195e:	53                   	push   %ebx
  80195f:	e8 cd d1 00 00       	call   80eb31 <memset>
  801964:	83 c4 10             	add    $0x10,%esp
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  801967:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80196e:	00 00 00 
  
      return 0;
  801971:	b8 00 00 00 00       	mov    $0x0,%eax
  801976:	e9 53 01 00 00       	jmp    801ace <lwip_select+0x345>
    }
    
    if (readset)
  80197b:	85 ff                	test   %edi,%edi
  80197d:	74 07                	je     801986 <lwip_select+0x1fd>
      lreadset = *readset;
  80197f:	8b 07                	mov    (%edi),%eax
  801981:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801984:	eb 13                	jmp    801999 <lwip_select+0x210>
    else
      FD_ZERO(&lreadset);
  801986:	83 ec 04             	sub    $0x4,%esp
  801989:	6a 04                	push   $0x4
  80198b:	6a 00                	push   $0x0
  80198d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801990:	50                   	push   %eax
  801991:	e8 9b d1 00 00       	call   80eb31 <memset>
  801996:	83 c4 10             	add    $0x10,%esp
    if (writeset)
  801999:	85 f6                	test   %esi,%esi
  80199b:	74 07                	je     8019a4 <lwip_select+0x21b>
      lwriteset = *writeset;
  80199d:	8b 06                	mov    (%esi),%eax
  80199f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8019a2:	eb 13                	jmp    8019b7 <lwip_select+0x22e>
    else
      FD_ZERO(&lwriteset);
  8019a4:	83 ec 04             	sub    $0x4,%esp
  8019a7:	6a 04                	push   $0x4
  8019a9:	6a 00                	push   $0x0
  8019ab:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8019ae:	50                   	push   %eax
  8019af:	e8 7d d1 00 00       	call   80eb31 <memset>
  8019b4:	83 c4 10             	add    $0x10,%esp
    if (exceptset)
  8019b7:	85 db                	test   %ebx,%ebx
  8019b9:	74 07                	je     8019c2 <lwip_select+0x239>
      lexceptset = *exceptset;
  8019bb:	8b 03                	mov    (%ebx),%eax
  8019bd:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8019c0:	eb 13                	jmp    8019d5 <lwip_select+0x24c>
    else
      FD_ZERO(&lexceptset);
  8019c2:	83 ec 04             	sub    $0x4,%esp
  8019c5:	6a 04                	push   $0x4
  8019c7:	6a 00                	push   $0x0
  8019c9:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8019cc:	50                   	push   %eax
  8019cd:	e8 5f d1 00 00       	call   80eb31 <memset>
  8019d2:	83 c4 10             	add    $0x10,%esp
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8019d5:	83 ec 0c             	sub    $0xc,%esp
  8019d8:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8019db:	50                   	push   %eax
  8019dc:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  8019df:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8019e2:	8b 45 08             	mov    0x8(%ebp),%eax
  8019e5:	e8 93 ed ff ff       	call   80077d <lwip_selscan>
  8019ea:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  8019ed:	83 c4 10             	add    $0x10,%esp
  8019f0:	eb 11                	jmp    801a03 <lwip_select+0x27a>
  } else
    sys_sem_signal(selectsem);
  8019f2:	83 ec 0c             	sub    $0xc,%esp
  8019f5:	ff 35 40 50 81 00    	pushl  0x815040
  8019fb:	e8 1a 85 00 00       	call   809f1a <sys_sem_signal>
  801a00:	83 c4 10             	add    $0x10,%esp
  
  if (readset)
  801a03:	85 ff                	test   %edi,%edi
  801a05:	74 05                	je     801a0c <lwip_select+0x283>
    *readset = lreadset;
  801a07:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801a0a:	89 07                	mov    %eax,(%edi)
  if (writeset)
  801a0c:	85 f6                	test   %esi,%esi
  801a0e:	74 05                	je     801a15 <lwip_select+0x28c>
    *writeset = lwriteset;
  801a10:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801a13:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801a15:	85 db                	test   %ebx,%ebx
  801a17:	74 05                	je     801a1e <lwip_select+0x295>
    *exceptset = lexceptset;
  801a19:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801a1c:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  801a1e:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801a25:	00 00 00 
  
  return nready;
  801a28:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801a2b:	e9 9e 00 00 00       	jmp    801ace <lwip_select+0x345>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801a30:	83 ec 0c             	sub    $0xc,%esp
  801a33:	6a 00                	push   $0x0
  801a35:	e8 34 82 00 00       	call   809c6e <sys_sem_new>
  801a3a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801a3d:	a1 48 50 81 00       	mov    0x815048,%eax
  801a42:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801a45:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801a48:	a3 48 50 81 00       	mov    %eax,0x815048
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801a4d:	83 c4 04             	add    $0x4,%esp
  801a50:	ff 35 40 50 81 00    	pushl  0x815040
  801a56:	e8 bf 84 00 00       	call   809f1a <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801a5b:	8b 45 18             	mov    0x18(%ebp),%eax
  801a5e:	8b 40 04             	mov    0x4(%eax),%eax
  801a61:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801a64:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  801a6a:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  801a6f:	89 c8                	mov    %ecx,%eax
  801a71:	f7 ea                	imul   %edx
  801a73:	c1 fa 06             	sar    $0x6,%edx
  801a76:	c1 f9 1f             	sar    $0x1f,%ecx
  801a79:	29 ca                	sub    %ecx,%edx
  801a7b:	8b 45 18             	mov    0x18(%ebp),%eax
  801a7e:	69 00 e8 03 00 00    	imul   $0x3e8,(%eax),%eax
      if(msectimeout == 0)
  801a84:	83 c4 10             	add    $0x10,%esp
  801a87:	01 c2                	add    %eax,%edx
        msectimeout = 1;
  801a89:	b8 01 00 00 00       	mov    $0x1,%eax
  801a8e:	0f 44 d0             	cmove  %eax,%edx
  801a91:	e9 28 fe ff ff       	jmp    8018be <lwip_select+0x135>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801a96:	83 ec 0c             	sub    $0xc,%esp
  801a99:	6a 00                	push   $0x0
  801a9b:	e8 ce 81 00 00       	call   809c6e <sys_sem_new>
  801aa0:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801aa3:	a1 48 50 81 00       	mov    0x815048,%eax
  801aa8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801aab:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801aae:	a3 48 50 81 00       	mov    %eax,0x815048
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801ab3:	83 c4 04             	add    $0x4,%esp
  801ab6:	ff 35 40 50 81 00    	pushl  0x815040
  801abc:	e8 59 84 00 00       	call   809f1a <sys_sem_signal>
  801ac1:	83 c4 10             	add    $0x10,%esp
    
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
  801ac4:	ba 00 00 00 00       	mov    $0x0,%edx
  801ac9:	e9 f0 fd ff ff       	jmp    8018be <lwip_select+0x135>
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  
  return nready;
}
  801ace:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801ad1:	5b                   	pop    %ebx
  801ad2:	5e                   	pop    %esi
  801ad3:	5f                   	pop    %edi
  801ad4:	5d                   	pop    %ebp
  801ad5:	c3                   	ret    

00801ad6 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  801ad6:	55                   	push   %ebp
  801ad7:	89 e5                	mov    %esp,%ebp
  801ad9:	83 ec 14             	sub    $0x14,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801adc:	ff 75 08             	pushl  0x8(%ebp)
  801adf:	e8 a5 f5 ff ff       	call   801089 <lwip_close>
}
  801ae4:	c9                   	leave  
  801ae5:	c3                   	ret    

00801ae6 <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  801ae6:	55                   	push   %ebp
  801ae7:	89 e5                	mov    %esp,%ebp
  801ae9:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801aec:	6a 00                	push   $0x0
  801aee:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801af1:	8b 55 0c             	mov    0xc(%ebp),%edx
  801af4:	8b 45 08             	mov    0x8(%ebp),%eax
  801af7:	e8 87 ed ff ff       	call   800883 <lwip_getaddrname>
}
  801afc:	c9                   	leave  
  801afd:	c3                   	ret    

00801afe <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  801afe:	55                   	push   %ebp
  801aff:	89 e5                	mov    %esp,%ebp
  801b01:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801b04:	6a 01                	push   $0x1
  801b06:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801b09:	8b 55 0c             	mov    0xc(%ebp),%edx
  801b0c:	8b 45 08             	mov    0x8(%ebp),%eax
  801b0f:	e8 6f ed ff ff       	call   800883 <lwip_getaddrname>
}
  801b14:	c9                   	leave  
  801b15:	c3                   	ret    

00801b16 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  801b16:	55                   	push   %ebp
  801b17:	89 e5                	mov    %esp,%ebp
  801b19:	57                   	push   %edi
  801b1a:	56                   	push   %esi
  801b1b:	53                   	push   %ebx
  801b1c:	83 ec 2c             	sub    $0x2c,%esp
  801b1f:	8b 75 0c             	mov    0xc(%ebp),%esi
  801b22:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  801b25:	8b 45 08             	mov    0x8(%ebp),%eax
  801b28:	e8 05 ec ff ff       	call   800732 <get_socket>
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801b2d:	85 c0                	test   %eax,%eax
  801b2f:	0f 84 7c 01 00 00    	je     801cb1 <lwip_getsockopt+0x19b>
  801b35:	89 c3                	mov    %eax,%ebx
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  801b37:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801b3b:	74 04                	je     801b41 <lwip_getsockopt+0x2b>
  801b3d:	85 ff                	test   %edi,%edi
  801b3f:	75 1b                	jne    801b5c <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  801b41:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801b48:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801b4f:	00 00 00 
    return -1;
  801b52:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801b57:	e9 95 01 00 00       	jmp    801cf1 <lwip_getsockopt+0x1db>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801b5c:	83 fe 06             	cmp    $0x6,%esi
  801b5f:	0f 84 9c 00 00 00    	je     801c01 <lwip_getsockopt+0xeb>
  801b65:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801b6b:	74 0f                	je     801b7c <lwip_getsockopt+0x66>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  801b6d:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801b72:	85 f6                	test   %esi,%esi
  801b74:	0f 85 c4 00 00 00    	jne    801c3e <lwip_getsockopt+0x128>
  801b7a:	eb 6f                	jmp    801beb <lwip_getsockopt+0xd5>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801b7c:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801b80:	74 39                	je     801bbb <lwip_getsockopt+0xa5>
  801b82:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801b86:	7f 12                	jg     801b9a <lwip_getsockopt+0x84>
  801b88:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  801b8c:	74 2d                	je     801bbb <lwip_getsockopt+0xa5>
  801b8e:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801b92:	0f 85 93 00 00 00    	jne    801c2b <lwip_getsockopt+0x115>
  801b98:	eb 21                	jmp    801bbb <lwip_getsockopt+0xa5>
  801b9a:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  801ba1:	0f 8c 84 00 00 00    	jl     801c2b <lwip_getsockopt+0x115>
  801ba7:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801bae:	7e 0b                	jle    801bbb <lwip_getsockopt+0xa5>
  801bb0:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801bb7:	74 10                	je     801bc9 <lwip_getsockopt+0xb3>
  801bb9:	eb 70                	jmp    801c2b <lwip_getsockopt+0x115>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  801bbb:	83 3f 03             	cmpl   $0x3,(%edi)
  801bbe:	0f 86 f4 00 00 00    	jbe    801cb8 <lwip_getsockopt+0x1a2>
  801bc4:	e9 8e 00 00 00       	jmp    801c57 <lwip_getsockopt+0x141>
      }
      break;

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801bc9:	83 3f 04             	cmpl   $0x4,(%edi)
  801bcc:	19 c0                	sbb    %eax,%eax
  801bce:	83 e0 16             	and    $0x16,%eax
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801bd1:	8b 13                	mov    (%ebx),%edx
  801bd3:	83 3a 20             	cmpl   $0x20,(%edx)
  801bd6:	0f 85 e3 00 00 00    	jne    801cbf <lwip_getsockopt+0x1a9>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801bdc:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801bdf:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801be3:	0f 85 e0 00 00 00    	jne    801cc9 <lwip_getsockopt+0x1b3>
  801be9:	eb 53                	jmp    801c3e <lwip_getsockopt+0x128>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801beb:	8b 45 10             	mov    0x10(%ebp),%eax
  801bee:	83 e8 01             	sub    $0x1,%eax
  801bf1:	83 f8 01             	cmp    $0x1,%eax
  801bf4:	77 3c                	ja     801c32 <lwip_getsockopt+0x11c>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  801bf6:	83 3f 03             	cmpl   $0x3,(%edi)
  801bf9:	0f 86 d4 00 00 00    	jbe    801cd3 <lwip_getsockopt+0x1bd>
  801bff:	eb 56                	jmp    801c57 <lwip_getsockopt+0x141>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  801c01:	83 3f 03             	cmpl   $0x3,(%edi)
  801c04:	0f 86 d3 00 00 00    	jbe    801cdd <lwip_getsockopt+0x1c7>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801c0a:	8b 10                	mov    (%eax),%edx
      return 0;
  801c0c:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801c11:	83 3a 10             	cmpl   $0x10,(%edx)
  801c14:	0f 85 d7 00 00 00    	jne    801cf1 <lwip_getsockopt+0x1db>
      return 0;

    switch (optname) {
  801c1a:	8b 45 10             	mov    0x10(%ebp),%eax
  801c1d:	83 e8 01             	sub    $0x1,%eax
  801c20:	83 f8 01             	cmp    $0x1,%eax
  801c23:	0f 87 be 00 00 00    	ja     801ce7 <lwip_getsockopt+0x1d1>
  801c29:	eb 0e                	jmp    801c39 <lwip_getsockopt+0x123>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801c2b:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801c30:	eb 0c                	jmp    801c3e <lwip_getsockopt+0x128>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801c32:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801c37:	eb 05                	jmp    801c3e <lwip_getsockopt+0x128>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801c39:	b8 00 00 00 00       	mov    $0x0,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  801c3e:	84 c0                	test   %al,%al
  801c40:	74 15                	je     801c57 <lwip_getsockopt+0x141>
    sock_set_errno(sock, err);
  801c42:	0f be c0             	movsbl %al,%eax
  801c45:	89 43 10             	mov    %eax,0x10(%ebx)
  801c48:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801c4d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801c52:	e9 9a 00 00 00       	jmp    801cf1 <lwip_getsockopt+0x1db>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  801c57:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801c5a:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801c5d:	8b 45 10             	mov    0x10(%ebp),%eax
  801c60:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801c63:	8b 45 14             	mov    0x14(%ebp),%eax
  801c66:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801c69:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  801c6c:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801c70:	83 ec 04             	sub    $0x4,%esp
  801c73:	6a 01                	push   $0x1
  801c75:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801c78:	50                   	push   %eax
  801c79:	68 76 0b 80 00       	push   $0x800b76
  801c7e:	e8 d4 05 00 00       	call   802257 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801c83:	83 c4 08             	add    $0x8,%esp
  801c86:	6a 00                	push   $0x0
  801c88:	8b 03                	mov    (%ebx),%eax
  801c8a:	ff 70 10             	pushl  0x10(%eax)
  801c8d:	e8 f6 82 00 00       	call   809f88 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  801c92:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  801c96:	0f be d0             	movsbl %al,%edx
  801c99:	89 53 10             	mov    %edx,0x10(%ebx)
  801c9c:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  return err ? -1 : 0;
  801ca2:	83 c4 10             	add    $0x10,%esp
  801ca5:	84 c0                	test   %al,%al
  801ca7:	0f 95 c0             	setne  %al
  801caa:	0f b6 c0             	movzbl %al,%eax
  801cad:	f7 d8                	neg    %eax
  801caf:	eb 40                	jmp    801cf1 <lwip_getsockopt+0x1db>
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  801cb1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801cb6:	eb 39                	jmp    801cf1 <lwip_getsockopt+0x1db>
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801cb8:	b8 16 00 00 00       	mov    $0x16,%eax
  801cbd:	eb 83                	jmp    801c42 <lwip_getsockopt+0x12c>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  801cbf:	b8 61 00 00 00       	mov    $0x61,%eax
  801cc4:	e9 79 ff ff ff       	jmp    801c42 <lwip_getsockopt+0x12c>
  801cc9:	b8 61 00 00 00       	mov    $0x61,%eax
  801cce:	e9 6f ff ff ff       	jmp    801c42 <lwip_getsockopt+0x12c>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801cd3:	b8 16 00 00 00       	mov    $0x16,%eax
  801cd8:	e9 65 ff ff ff       	jmp    801c42 <lwip_getsockopt+0x12c>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
      err = EINVAL;
  801cdd:	b8 16 00 00 00       	mov    $0x16,%eax
  801ce2:	e9 5b ff ff ff       	jmp    801c42 <lwip_getsockopt+0x12c>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801ce7:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801cec:	e9 51 ff ff ff       	jmp    801c42 <lwip_getsockopt+0x12c>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  801cf1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801cf4:	5b                   	pop    %ebx
  801cf5:	5e                   	pop    %esi
  801cf6:	5f                   	pop    %edi
  801cf7:	5d                   	pop    %ebp
  801cf8:	c3                   	ret    

00801cf9 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  801cf9:	55                   	push   %ebp
  801cfa:	89 e5                	mov    %esp,%ebp
  801cfc:	57                   	push   %edi
  801cfd:	56                   	push   %esi
  801cfe:	53                   	push   %ebx
  801cff:	83 ec 2c             	sub    $0x2c,%esp
  801d02:	8b 75 0c             	mov    0xc(%ebp),%esi
  801d05:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801d08:	8b 45 08             	mov    0x8(%ebp),%eax
  801d0b:	e8 22 ea ff ff       	call   800732 <get_socket>
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801d10:	85 c0                	test   %eax,%eax
  801d12:	0f 84 47 01 00 00    	je     801e5f <lwip_setsockopt+0x166>
  801d18:	89 c3                	mov    %eax,%ebx
    return -1;

  if (NULL == optval) {
  801d1a:	85 ff                	test   %edi,%edi
  801d1c:	75 1b                	jne    801d39 <lwip_setsockopt+0x40>
    sock_set_errno(sock, EFAULT);
  801d1e:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801d25:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801d2c:	00 00 00 
    return -1;
  801d2f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d34:	e9 63 01 00 00       	jmp    801e9c <lwip_setsockopt+0x1a3>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801d39:	83 fe 06             	cmp    $0x6,%esi
  801d3c:	74 7e                	je     801dbc <lwip_setsockopt+0xc3>
  801d3e:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801d44:	74 0f                	je     801d55 <lwip_setsockopt+0x5c>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  801d46:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801d4b:	85 f6                	test   %esi,%esi
  801d4d:	0f 85 a0 00 00 00    	jne    801df3 <lwip_setsockopt+0xfa>
  801d53:	eb 50                	jmp    801da5 <lwip_setsockopt+0xac>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801d55:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801d59:	74 18                	je     801d73 <lwip_setsockopt+0x7a>
  801d5b:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801d62:	74 1e                	je     801d82 <lwip_setsockopt+0x89>
#endif /* LWIP_UDP */
      break;
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  801d64:	b8 5c 00 00 00       	mov    $0x5c,%eax
  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801d69:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801d6d:	0f 85 80 00 00 00    	jne    801df3 <lwip_setsockopt+0xfa>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  801d73:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801d77:	0f 86 e9 00 00 00    	jbe    801e66 <lwip_setsockopt+0x16d>
  801d7d:	e9 87 00 00 00       	jmp    801e09 <lwip_setsockopt+0x110>
        err = EINVAL;
      }
      break;
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801d82:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801d86:	19 c0                	sbb    %eax,%eax
  801d88:	83 e0 16             	and    $0x16,%eax
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801d8b:	8b 13                	mov    (%ebx),%edx
  801d8d:	83 3a 20             	cmpl   $0x20,(%edx)
  801d90:	0f 85 d7 00 00 00    	jne    801e6d <lwip_setsockopt+0x174>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801d96:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801d99:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801d9d:	0f 85 d1 00 00 00    	jne    801e74 <lwip_setsockopt+0x17b>
  801da3:	eb 4e                	jmp    801df3 <lwip_setsockopt+0xfa>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801da5:	8b 45 10             	mov    0x10(%ebp),%eax
  801da8:	83 e8 01             	sub    $0x1,%eax
  801dab:	83 f8 01             	cmp    $0x1,%eax
  801dae:	77 37                	ja     801de7 <lwip_setsockopt+0xee>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  801db0:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801db4:	0f 86 c4 00 00 00    	jbe    801e7e <lwip_setsockopt+0x185>
  801dba:	eb 4d                	jmp    801e09 <lwip_setsockopt+0x110>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  801dbc:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801dc0:	0f 86 c2 00 00 00    	jbe    801e88 <lwip_setsockopt+0x18f>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801dc6:	8b 10                	mov    (%eax),%edx
      return 0;
  801dc8:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801dcd:	83 3a 10             	cmpl   $0x10,(%edx)
  801dd0:	0f 85 c6 00 00 00    	jne    801e9c <lwip_setsockopt+0x1a3>
      return 0;

    switch (optname) {
  801dd6:	8b 45 10             	mov    0x10(%ebp),%eax
  801dd9:	83 e8 01             	sub    $0x1,%eax
  801ddc:	83 f8 01             	cmp    $0x1,%eax
  801ddf:	0f 87 ad 00 00 00    	ja     801e92 <lwip_setsockopt+0x199>
  801de5:	eb 07                	jmp    801dee <lwip_setsockopt+0xf5>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  801de7:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801dec:	eb 05                	jmp    801df3 <lwip_setsockopt+0xfa>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  801dee:	b8 00 00 00 00       	mov    $0x0,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  801df3:	85 c0                	test   %eax,%eax
  801df5:	74 12                	je     801e09 <lwip_setsockopt+0x110>
    sock_set_errno(sock, err);
  801df7:	89 43 10             	mov    %eax,0x10(%ebx)
  801dfa:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801dff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801e04:	e9 93 00 00 00       	jmp    801e9c <lwip_setsockopt+0x1a3>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  801e09:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801e0c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801e0f:	8b 45 10             	mov    0x10(%ebp),%eax
  801e12:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  801e15:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  801e18:	8d 45 18             	lea    0x18(%ebp),%eax
  801e1b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801e1e:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  801e22:	83 ec 04             	sub    $0x4,%esp
  801e25:	6a 01                	push   $0x1
  801e27:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801e2a:	50                   	push   %eax
  801e2b:	68 f9 0c 80 00       	push   $0x800cf9
  801e30:	e8 22 04 00 00       	call   802257 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801e35:	83 c4 08             	add    $0x8,%esp
  801e38:	6a 00                	push   $0x0
  801e3a:	8b 03                	mov    (%ebx),%eax
  801e3c:	ff 70 10             	pushl  0x10(%eax)
  801e3f:	e8 44 81 00 00       	call   809f88 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  801e44:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  801e48:	89 43 10             	mov    %eax,0x10(%ebx)
  801e4b:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return err ? -1 : 0;
  801e50:	83 c4 10             	add    $0x10,%esp
  801e53:	85 c0                	test   %eax,%eax
  801e55:	0f 95 c0             	setne  %al
  801e58:	0f b6 c0             	movzbl %al,%eax
  801e5b:	f7 d8                	neg    %eax
  801e5d:	eb 3d                	jmp    801e9c <lwip_setsockopt+0x1a3>
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  801e5f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801e64:	eb 36                	jmp    801e9c <lwip_setsockopt+0x1a3>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801e66:	b8 16 00 00 00       	mov    $0x16,%eax
  801e6b:	eb 8a                	jmp    801df7 <lwip_setsockopt+0xfe>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  801e6d:	b8 61 00 00 00       	mov    $0x61,%eax
  801e72:	eb 83                	jmp    801df7 <lwip_setsockopt+0xfe>
  801e74:	b8 61 00 00 00       	mov    $0x61,%eax
  801e79:	e9 79 ff ff ff       	jmp    801df7 <lwip_setsockopt+0xfe>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801e7e:	b8 16 00 00 00       	mov    $0x16,%eax
  801e83:	e9 6f ff ff ff       	jmp    801df7 <lwip_setsockopt+0xfe>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
      err = EINVAL;
  801e88:	b8 16 00 00 00       	mov    $0x16,%eax
  801e8d:	e9 65 ff ff ff       	jmp    801df7 <lwip_setsockopt+0xfe>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  801e92:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e97:	e9 5b ff ff ff       	jmp    801df7 <lwip_setsockopt+0xfe>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  801e9c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801e9f:	5b                   	pop    %ebx
  801ea0:	5e                   	pop    %esi
  801ea1:	5f                   	pop    %edi
  801ea2:	5d                   	pop    %ebp
  801ea3:	c3                   	ret    

00801ea4 <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  801ea4:	55                   	push   %ebp
  801ea5:	89 e5                	mov    %esp,%ebp
  801ea7:	56                   	push   %esi
  801ea8:	53                   	push   %ebx
  801ea9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801eac:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  801eaf:	8b 45 08             	mov    0x8(%ebp),%eax
  801eb2:	e8 7b e8 ff ff       	call   800732 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  801eb7:	85 c0                	test   %eax,%eax
  801eb9:	0f 84 af 00 00 00    	je     801f6e <lwip_ioctl+0xca>
    return -1;

  switch (cmd) {
  801ebf:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  801ec5:	74 60                	je     801f27 <lwip_ioctl+0x83>
  801ec7:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  801ecd:	0f 85 83 00 00 00    	jne    801f56 <lwip_ioctl+0xb2>
  case FIONREAD:
    if (!argp) {
  801ed3:	85 f6                	test   %esi,%esi
  801ed5:	75 1b                	jne    801ef2 <lwip_ioctl+0x4e>
      sock_set_errno(sock, EINVAL);
  801ed7:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  801ede:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801ee5:	00 00 00 
      return -1;
  801ee8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801eed:	e9 81 00 00 00       	jmp    801f73 <lwip_ioctl+0xcf>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  801ef2:	8b 10                	mov    (%eax),%edx
  801ef4:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  801ef8:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  801efb:	8b 48 04             	mov    0x4(%eax),%ecx
  801efe:	85 c9                	test   %ecx,%ecx
  801f00:	74 0d                	je     801f0f <lwip_ioctl+0x6b>
      buflen = netbuf_len(sock->lastdata);
  801f02:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  801f04:	66 03 51 08          	add    0x8(%ecx),%dx
  801f08:	66 2b 50 08          	sub    0x8(%eax),%dx
  801f0c:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  801f0f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801f16:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801f1d:	00 00 00 
    return 0;
  801f20:	b8 00 00 00 00       	mov    $0x0,%eax
  801f25:	eb 4c                	jmp    801f73 <lwip_ioctl+0xcf>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  801f27:	85 f6                	test   %esi,%esi
  801f29:	74 0d                	je     801f38 <lwip_ioctl+0x94>
  801f2b:	83 3e 00             	cmpl   $0x0,(%esi)
  801f2e:	74 08                	je     801f38 <lwip_ioctl+0x94>
      sock->flags |= O_NONBLOCK;
  801f30:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
  801f36:	eb 06                	jmp    801f3e <lwip_ioctl+0x9a>
    else
      sock->flags &= ~O_NONBLOCK;
  801f38:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  801f3e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801f45:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801f4c:	00 00 00 
    return 0;
  801f4f:	b8 00 00 00 00       	mov    $0x0,%eax
  801f54:	eb 1d                	jmp    801f73 <lwip_ioctl+0xcf>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  801f56:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  801f5d:	c7 05 e0 b1 b3 00 26 	movl   $0x26,0xb3b1e0
  801f64:	00 00 00 
    return -1;
  801f67:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f6c:	eb 05                	jmp    801f73 <lwip_ioctl+0xcf>
{
  struct lwip_socket *sock = get_socket(s);
  u16_t buflen = 0;

  if (!sock)
    return -1;
  801f6e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  801f73:	5b                   	pop    %ebx
  801f74:	5e                   	pop    %esi
  801f75:	5d                   	pop    %ebp
  801f76:	c3                   	ret    

00801f77 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  801f77:	55                   	push   %ebp
  801f78:	89 e5                	mov    %esp,%ebp
  801f7a:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  801f7d:	e8 fe 40 00 00       	call   806080 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  801f82:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  801f89:	75 09                	jne    801f94 <tcpip_tcp_timer+0x1d>
  801f8b:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  801f92:	74 19                	je     801fad <tcpip_tcp_timer+0x36>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  801f94:	83 ec 04             	sub    $0x4,%esp
  801f97:	6a 00                	push   $0x0
  801f99:	68 77 1f 80 00       	push   $0x801f77
  801f9e:	68 fa 00 00 00       	push   $0xfa
  801fa3:	e8 0a 31 00 00       	call   8050b2 <sys_timeout>
  801fa8:	83 c4 10             	add    $0x10,%esp
  801fab:	eb 0a                	jmp    801fb7 <tcpip_tcp_timer+0x40>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  801fad:	c7 05 e0 52 81 00 00 	movl   $0x0,0x8152e0
  801fb4:	00 00 00 
  }
}
  801fb7:	c9                   	leave  
  801fb8:	c3                   	ret    

00801fb9 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  801fb9:	55                   	push   %ebp
  801fba:	89 e5                	mov    %esp,%ebp
  801fbc:	53                   	push   %ebx
  801fbd:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  801fc0:	6a 00                	push   $0x0
  801fc2:	68 6f 21 80 00       	push   $0x80216f
  801fc7:	68 e8 03 00 00       	push   $0x3e8
  801fcc:	e8 e1 30 00 00       	call   8050b2 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  801fd1:	83 c4 0c             	add    $0xc,%esp
  801fd4:	6a 00                	push   $0x0
  801fd6:	68 4b 21 80 00       	push   $0x80214b
  801fdb:	68 88 13 00 00       	push   $0x1388
  801fe0:	e8 cd 30 00 00       	call   8050b2 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  801fe5:	83 c4 0c             	add    $0xc,%esp
  801fe8:	6a 00                	push   $0x0
  801fea:	68 27 21 80 00       	push   $0x802127
  801fef:	68 60 ea 00 00       	push   $0xea60
  801ff4:	e8 b9 30 00 00       	call   8050b2 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  801ff9:	83 c4 0c             	add    $0xc,%esp
  801ffc:	6a 00                	push   $0x0
  801ffe:	68 03 21 80 00       	push   $0x802103
  802003:	68 f4 01 00 00       	push   $0x1f4
  802008:	e8 a5 30 00 00       	call   8050b2 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  80200d:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  802012:	83 c4 10             	add    $0x10,%esp
  802015:	85 c0                	test   %eax,%eax
  802017:	74 0e                	je     802027 <tcpip_thread+0x6e>
    tcpip_init_done(tcpip_init_done_arg);
  802019:	83 ec 0c             	sub    $0xc,%esp
  80201c:	ff 35 e4 52 81 00    	pushl  0x8152e4
  802022:	ff d0                	call   *%eax
  802024:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  802027:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80202a:	83 ec 08             	sub    $0x8,%esp
  80202d:	53                   	push   %ebx
  80202e:	ff 35 00 40 81 00    	pushl  0x814000
  802034:	e8 57 2f 00 00       	call   804f90 <sys_mbox_fetch>
    switch (msg->type) {
  802039:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80203c:	83 c4 10             	add    $0x10,%esp
  80203f:	8b 02                	mov    (%edx),%eax
  802041:	83 f8 01             	cmp    $0x1,%eax
  802044:	74 22                	je     802068 <tcpip_thread+0xaf>
  802046:	83 f8 01             	cmp    $0x1,%eax
  802049:	72 0c                	jb     802057 <tcpip_thread+0x9e>
  80204b:	83 f8 02             	cmp    $0x2,%eax
  80204e:	74 53                	je     8020a3 <tcpip_thread+0xea>
  802050:	83 f8 03             	cmp    $0x3,%eax
  802053:	74 6c                	je     8020c1 <tcpip_thread+0x108>
  802055:	eb d3                	jmp    80202a <tcpip_thread+0x71>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  802057:	8b 42 08             	mov    0x8(%edx),%eax
  80205a:	83 ec 0c             	sub    $0xc,%esp
  80205d:	8d 50 04             	lea    0x4(%eax),%edx
  802060:	52                   	push   %edx
  802061:	ff 10                	call   *(%eax)
      break;
  802063:	83 c4 10             	add    $0x10,%esp
  802066:	eb c2                	jmp    80202a <tcpip_thread+0x71>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  802068:	8b 42 0c             	mov    0xc(%edx),%eax
  80206b:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  80206f:	74 11                	je     802082 <tcpip_thread+0xc9>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  802071:	83 ec 08             	sub    $0x8,%esp
  802074:	50                   	push   %eax
  802075:	ff 72 08             	pushl  0x8(%edx)
  802078:	e8 4b 7a 00 00       	call   809ac8 <ethernet_input>
  80207d:	83 c4 10             	add    $0x10,%esp
  802080:	eb 0f                	jmp    802091 <tcpip_thread+0xd8>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  802082:	83 ec 08             	sub    $0x8,%esp
  802085:	50                   	push   %eax
  802086:	ff 72 08             	pushl  0x8(%edx)
  802089:	e8 2c 44 00 00       	call   8064ba <ip_input>
  80208e:	83 c4 10             	add    $0x10,%esp
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  802091:	83 ec 08             	sub    $0x8,%esp
  802094:	ff 75 f4             	pushl  -0xc(%ebp)
  802097:	6a 09                	push   $0x9
  802099:	e8 56 23 00 00       	call   8043f4 <memp_free>
      break;
  80209e:	83 c4 10             	add    $0x10,%esp
  8020a1:	eb 87                	jmp    80202a <tcpip_thread+0x71>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  8020a3:	83 ec 0c             	sub    $0xc,%esp
  8020a6:	ff 72 0c             	pushl  0xc(%edx)
  8020a9:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8020ac:	83 c4 08             	add    $0x8,%esp
  8020af:	ff 75 f4             	pushl  -0xc(%ebp)
  8020b2:	6a 08                	push   $0x8
  8020b4:	e8 3b 23 00 00       	call   8043f4 <memp_free>
      break;
  8020b9:	83 c4 10             	add    $0x10,%esp
  8020bc:	e9 69 ff ff ff       	jmp    80202a <tcpip_thread+0x71>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  8020c1:	8b 42 08             	mov    0x8(%edx),%eax
  8020c4:	83 f8 ff             	cmp    $0xffffffff,%eax
  8020c7:	74 14                	je     8020dd <tcpip_thread+0x124>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  8020c9:	83 ec 04             	sub    $0x4,%esp
  8020cc:	ff 72 10             	pushl  0x10(%edx)
  8020cf:	ff 72 0c             	pushl  0xc(%edx)
  8020d2:	50                   	push   %eax
  8020d3:	e8 da 2f 00 00       	call   8050b2 <sys_timeout>
  8020d8:	83 c4 10             	add    $0x10,%esp
  8020db:	eb 11                	jmp    8020ee <tcpip_thread+0x135>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  8020dd:	83 ec 08             	sub    $0x8,%esp
  8020e0:	ff 72 10             	pushl  0x10(%edx)
  8020e3:	ff 72 0c             	pushl  0xc(%edx)
  8020e6:	e8 76 30 00 00       	call   805161 <sys_untimeout>
  8020eb:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8020ee:	83 ec 08             	sub    $0x8,%esp
  8020f1:	ff 75 f4             	pushl  -0xc(%ebp)
  8020f4:	6a 08                	push   $0x8
  8020f6:	e8 f9 22 00 00       	call   8043f4 <memp_free>
      break;
  8020fb:	83 c4 10             	add    $0x10,%esp
  8020fe:	e9 27 ff ff ff       	jmp    80202a <tcpip_thread+0x71>

00802103 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  802103:	55                   	push   %ebp
  802104:	89 e5                	mov    %esp,%ebp
  802106:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  802109:	e8 00 1b 00 00       	call   803c0e <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80210e:	83 ec 04             	sub    $0x4,%esp
  802111:	6a 00                	push   $0x0
  802113:	68 03 21 80 00       	push   $0x802103
  802118:	68 f4 01 00 00       	push   $0x1f4
  80211d:	e8 90 2f 00 00       	call   8050b2 <sys_timeout>
}
  802122:	83 c4 10             	add    $0x10,%esp
  802125:	c9                   	leave  
  802126:	c3                   	ret    

00802127 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  802127:	55                   	push   %ebp
  802128:	89 e5                	mov    %esp,%ebp
  80212a:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  80212d:	e8 18 19 00 00       	call   803a4a <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802132:	83 ec 04             	sub    $0x4,%esp
  802135:	6a 00                	push   $0x0
  802137:	68 27 21 80 00       	push   $0x802127
  80213c:	68 60 ea 00 00       	push   $0xea60
  802141:	e8 6c 2f 00 00       	call   8050b2 <sys_timeout>
}
  802146:	83 c4 10             	add    $0x10,%esp
  802149:	c9                   	leave  
  80214a:	c3                   	ret    

0080214b <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  80214b:	55                   	push   %ebp
  80214c:	89 e5                	mov    %esp,%ebp
  80214e:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  802151:	e8 31 72 00 00       	call   809387 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802156:	83 ec 04             	sub    $0x4,%esp
  802159:	6a 00                	push   $0x0
  80215b:	68 4b 21 80 00       	push   $0x80214b
  802160:	68 88 13 00 00       	push   $0x1388
  802165:	e8 48 2f 00 00       	call   8050b2 <sys_timeout>
}
  80216a:	83 c4 10             	add    $0x10,%esp
  80216d:	c9                   	leave  
  80216e:	c3                   	ret    

0080216f <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  80216f:	55                   	push   %ebp
  802170:	89 e5                	mov    %esp,%ebp
  802172:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  802175:	e8 09 4a 00 00       	call   806b83 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80217a:	83 ec 04             	sub    $0x4,%esp
  80217d:	6a 00                	push   $0x0
  80217f:	68 6f 21 80 00       	push   $0x80216f
  802184:	68 e8 03 00 00       	push   $0x3e8
  802189:	e8 24 2f 00 00       	call   8050b2 <sys_timeout>
}
  80218e:	83 c4 10             	add    $0x10,%esp
  802191:	c9                   	leave  
  802192:	c3                   	ret    

00802193 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  802193:	55                   	push   %ebp
  802194:	89 e5                	mov    %esp,%ebp
  802196:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  802199:	ff 75 08             	pushl  0x8(%ebp)
  80219c:	e8 c6 25 00 00       	call   804767 <pbuf_free>
}
  8021a1:	83 c4 10             	add    $0x10,%esp
  8021a4:	c9                   	leave  
  8021a5:	c3                   	ret    

008021a6 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  8021a6:	55                   	push   %ebp
  8021a7:	89 e5                	mov    %esp,%ebp
  8021a9:	83 ec 08             	sub    $0x8,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8021ac:	83 3d e0 52 81 00 00 	cmpl   $0x0,0x8152e0
  8021b3:	75 33                	jne    8021e8 <tcp_timer_needed+0x42>
  8021b5:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  8021bc:	75 09                	jne    8021c7 <tcp_timer_needed+0x21>
  8021be:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  8021c5:	74 21                	je     8021e8 <tcp_timer_needed+0x42>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  8021c7:	c7 05 e0 52 81 00 01 	movl   $0x1,0x8152e0
  8021ce:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8021d1:	83 ec 04             	sub    $0x4,%esp
  8021d4:	6a 00                	push   $0x0
  8021d6:	68 77 1f 80 00       	push   $0x801f77
  8021db:	68 fa 00 00 00       	push   $0xfa
  8021e0:	e8 cd 2e 00 00       	call   8050b2 <sys_timeout>
  8021e5:	83 c4 10             	add    $0x10,%esp
  }
}
  8021e8:	c9                   	leave  
  8021e9:	c3                   	ret    

008021ea <tcpip_input>:
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8021ea:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8021f1:	74 54                	je     802247 <tcpip_input+0x5d>
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  8021f3:	55                   	push   %ebp
  8021f4:	89 e5                	mov    %esp,%ebp
  8021f6:	53                   	push   %ebx
  8021f7:	83 ec 10             	sub    $0x10,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  8021fa:	6a 09                	push   $0x9
  8021fc:	e8 9d 21 00 00       	call   80439e <memp_malloc>
  802201:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802203:	83 c4 10             	add    $0x10,%esp
  802206:	85 c0                	test   %eax,%eax
  802208:	74 43                	je     80224d <tcpip_input+0x63>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  80220a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  802210:	8b 45 08             	mov    0x8(%ebp),%eax
  802213:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  802216:	8b 45 0c             	mov    0xc(%ebp),%eax
  802219:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80221c:	83 ec 08             	sub    $0x8,%esp
  80221f:	53                   	push   %ebx
  802220:	ff 35 00 40 81 00    	pushl  0x814000
  802226:	e8 6b 7e 00 00       	call   80a096 <sys_mbox_trypost>
  80222b:	83 c4 10             	add    $0x10,%esp
  80222e:	84 c0                	test   %al,%al
  802230:	74 20                	je     802252 <tcpip_input+0x68>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  802232:	83 ec 08             	sub    $0x8,%esp
  802235:	53                   	push   %ebx
  802236:	6a 09                	push   $0x9
  802238:	e8 b7 21 00 00       	call   8043f4 <memp_free>
      return ERR_MEM;
  80223d:	83 c4 10             	add    $0x10,%esp
  802240:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802245:	eb 0b                	jmp    802252 <tcpip_input+0x68>
    }
    return ERR_OK;
  }
  return ERR_VAL;
  802247:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80224c:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
    if (msg == NULL) {
      return ERR_MEM;
  80224d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  802252:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802255:	c9                   	leave  
  802256:	c3                   	ret    

00802257 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  802257:	55                   	push   %ebp
  802258:	89 e5                	mov    %esp,%ebp
  80225a:	56                   	push   %esi
  80225b:	53                   	push   %ebx
  80225c:	8b 75 10             	mov    0x10(%ebp),%esi
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80225f:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802266:	74 6f                	je     8022d7 <tcpip_callback_with_block+0x80>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  802268:	83 ec 0c             	sub    $0xc,%esp
  80226b:	6a 08                	push   $0x8
  80226d:	e8 2c 21 00 00       	call   80439e <memp_malloc>
  802272:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802274:	83 c4 10             	add    $0x10,%esp
  802277:	85 c0                	test   %eax,%eax
  802279:	74 63                	je     8022de <tcpip_callback_with_block+0x87>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  80227b:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  802281:	8b 45 08             	mov    0x8(%ebp),%eax
  802284:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  802287:	8b 45 0c             	mov    0xc(%ebp),%eax
  80228a:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  80228d:	89 f0                	mov    %esi,%eax
  80228f:	84 c0                	test   %al,%al
  802291:	74 19                	je     8022ac <tcpip_callback_with_block+0x55>
      sys_mbox_post(mbox, msg);
  802293:	83 ec 08             	sub    $0x8,%esp
  802296:	53                   	push   %ebx
  802297:	ff 35 00 40 81 00    	pushl  0x814000
  80229d:	e8 b7 7e 00 00       	call   80a159 <sys_mbox_post>
  8022a2:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  8022a5:	b8 00 00 00 00       	mov    $0x0,%eax
  8022aa:	eb 37                	jmp    8022e3 <tcpip_callback_with_block+0x8c>
    msg->msg.cb.f = f;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(mbox, msg);
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8022ac:	83 ec 08             	sub    $0x8,%esp
  8022af:	53                   	push   %ebx
  8022b0:	ff 35 00 40 81 00    	pushl  0x814000
  8022b6:	e8 db 7d 00 00       	call   80a096 <sys_mbox_trypost>
  8022bb:	83 c4 10             	add    $0x10,%esp
  8022be:	84 c0                	test   %al,%al
  8022c0:	74 21                	je     8022e3 <tcpip_callback_with_block+0x8c>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  8022c2:	83 ec 08             	sub    $0x8,%esp
  8022c5:	53                   	push   %ebx
  8022c6:	6a 08                	push   $0x8
  8022c8:	e8 27 21 00 00       	call   8043f4 <memp_free>
        return ERR_MEM;
  8022cd:	83 c4 10             	add    $0x10,%esp
  8022d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022d5:	eb 0c                	jmp    8022e3 <tcpip_callback_with_block+0x8c>
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
  8022d7:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8022dc:	eb 05                	jmp    8022e3 <tcpip_callback_with_block+0x8c>
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  8022de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  8022e3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8022e6:	5b                   	pop    %ebx
  8022e7:	5e                   	pop    %esi
  8022e8:	5d                   	pop    %ebp
  8022e9:	c3                   	ret    

008022ea <tcpip_timeout>:
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8022ea:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8022f1:	74 45                	je     802338 <tcpip_timeout+0x4e>
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8022f3:	55                   	push   %ebp
  8022f4:	89 e5                	mov    %esp,%ebp
  8022f6:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8022f9:	6a 08                	push   $0x8
  8022fb:	e8 9e 20 00 00       	call   80439e <memp_malloc>
    if (msg == NULL) {
  802300:	83 c4 10             	add    $0x10,%esp
  802303:	85 c0                	test   %eax,%eax
  802305:	74 37                	je     80233e <tcpip_timeout+0x54>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  802307:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  80230d:	8b 55 08             	mov    0x8(%ebp),%edx
  802310:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  802313:	8b 55 0c             	mov    0xc(%ebp),%edx
  802316:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  802319:	8b 55 10             	mov    0x10(%ebp),%edx
  80231c:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  80231f:	83 ec 08             	sub    $0x8,%esp
  802322:	50                   	push   %eax
  802323:	ff 35 00 40 81 00    	pushl  0x814000
  802329:	e8 2b 7e 00 00       	call   80a159 <sys_mbox_post>
    return ERR_OK;
  80232e:	83 c4 10             	add    $0x10,%esp
  802331:	b8 00 00 00 00       	mov    $0x0,%eax
  802336:	eb 0b                	jmp    802343 <tcpip_timeout+0x59>
  }
  return ERR_VAL;
  802338:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80233d:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  80233e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    msg->msg.tmo.arg = arg;
    sys_mbox_post(mbox, msg);
    return ERR_OK;
  }
  return ERR_VAL;
}
  802343:	c9                   	leave  
  802344:	c3                   	ret    

00802345 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  802345:	55                   	push   %ebp
  802346:	89 e5                	mov    %esp,%ebp
  802348:	53                   	push   %ebx
  802349:	83 ec 24             	sub    $0x24,%esp
  80234c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  80234f:	a1 00 40 81 00       	mov    0x814000,%eax
  802354:	83 f8 ff             	cmp    $0xffffffff,%eax
  802357:	74 31                	je     80238a <tcpip_apimsg+0x45>
    msg.type = TCPIP_MSG_API;
  802359:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  802360:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802363:	83 ec 08             	sub    $0x8,%esp
  802366:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  802369:	52                   	push   %edx
  80236a:	50                   	push   %eax
  80236b:	e8 e9 7d 00 00       	call   80a159 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  802370:	83 c4 08             	add    $0x8,%esp
  802373:	6a 00                	push   $0x0
  802375:	8b 43 04             	mov    0x4(%ebx),%eax
  802378:	ff 70 10             	pushl  0x10(%eax)
  80237b:	e8 08 7c 00 00       	call   809f88 <sys_arch_sem_wait>
    return ERR_OK;
  802380:	83 c4 10             	add    $0x10,%esp
  802383:	b8 00 00 00 00       	mov    $0x0,%eax
  802388:	eb 05                	jmp    80238f <tcpip_apimsg+0x4a>
  }
  return ERR_VAL;
  80238a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80238f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802392:	c9                   	leave  
  802393:	c3                   	ret    

00802394 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  802394:	55                   	push   %ebp
  802395:	89 e5                	mov    %esp,%ebp
  802397:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  80239a:	e8 6f 03 00 00       	call   80270e <lwip_init>

  tcpip_init_done = initfunc;
  80239f:	8b 45 08             	mov    0x8(%ebp),%eax
  8023a2:	a3 e8 52 81 00       	mov    %eax,0x8152e8
  tcpip_init_done_arg = arg;
  8023a7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8023aa:	a3 e4 52 81 00       	mov    %eax,0x8152e4
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  8023af:	83 ec 0c             	sub    $0xc,%esp
  8023b2:	6a 00                	push   $0x0
  8023b4:	e8 5e 7a 00 00       	call   809e17 <sys_mbox_new>
  8023b9:	a3 00 40 81 00       	mov    %eax,0x814000
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  8023be:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8023c5:	6a 00                	push   $0x0
  8023c7:	6a 00                	push   $0x0
  8023c9:	68 b9 1f 80 00       	push   $0x801fb9
  8023ce:	68 7c 0e 81 00       	push   $0x810e7c
  8023d3:	e8 b2 7e 00 00       	call   80a28a <sys_thread_new>
}
  8023d8:	83 c4 20             	add    $0x20,%esp
  8023db:	c9                   	leave  
  8023dc:	c3                   	ret    

008023dd <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  8023dd:	55                   	push   %ebp
  8023de:	89 e5                	mov    %esp,%ebp
  8023e0:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8023e3:	6a 00                	push   $0x0
  8023e5:	ff 75 08             	pushl  0x8(%ebp)
  8023e8:	68 93 21 80 00       	push   $0x802193
  8023ed:	e8 65 fe ff ff       	call   802257 <tcpip_callback_with_block>
}
  8023f2:	c9                   	leave  
  8023f3:	c3                   	ret    

008023f4 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  8023f4:	55                   	push   %ebp
  8023f5:	89 e5                	mov    %esp,%ebp
  8023f7:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  8023fa:	6a 00                	push   $0x0
  8023fc:	ff 75 08             	pushl  0x8(%ebp)
  8023ff:	68 c5 3e 80 00       	push   $0x803ec5
  802404:	e8 4e fe ff ff       	call   802257 <tcpip_callback_with_block>
}
  802409:	c9                   	leave  
  80240a:	c3                   	ret    

0080240b <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  80240b:	55                   	push   %ebp
  80240c:	89 e5                	mov    %esp,%ebp
  80240e:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  802411:	6a 06                	push   $0x6
  802413:	e8 86 1f 00 00       	call   80439e <memp_malloc>
  if (buf != NULL) {
  802418:	83 c4 10             	add    $0x10,%esp
  80241b:	85 c0                	test   %eax,%eax
  80241d:	74 14                	je     802433 <netbuf_new+0x28>
    buf->p = NULL;
  80241f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  802425:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  80242c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  802433:	c9                   	leave  
  802434:	c3                   	ret    

00802435 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  802435:	55                   	push   %ebp
  802436:	89 e5                	mov    %esp,%ebp
  802438:	53                   	push   %ebx
  802439:	83 ec 04             	sub    $0x4,%esp
  80243c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  80243f:	85 db                	test   %ebx,%ebx
  802441:	74 2d                	je     802470 <netbuf_delete+0x3b>
    if (buf->p != NULL) {
  802443:	8b 03                	mov    (%ebx),%eax
  802445:	85 c0                	test   %eax,%eax
  802447:	74 19                	je     802462 <netbuf_delete+0x2d>
      pbuf_free(buf->p);
  802449:	83 ec 0c             	sub    $0xc,%esp
  80244c:	50                   	push   %eax
  80244d:	e8 15 23 00 00       	call   804767 <pbuf_free>
      buf->p = buf->ptr = NULL;
  802452:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802459:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80245f:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  802462:	83 ec 08             	sub    $0x8,%esp
  802465:	53                   	push   %ebx
  802466:	6a 06                	push   $0x6
  802468:	e8 87 1f 00 00       	call   8043f4 <memp_free>
  80246d:	83 c4 10             	add    $0x10,%esp
  }
}
  802470:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802473:	c9                   	leave  
  802474:	c3                   	ret    

00802475 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  802475:	55                   	push   %ebp
  802476:	89 e5                	mov    %esp,%ebp
  802478:	56                   	push   %esi
  802479:	53                   	push   %ebx
  80247a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80247d:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  802480:	85 db                	test   %ebx,%ebx
  802482:	75 14                	jne    802498 <netbuf_alloc+0x23>
  802484:	83 ec 04             	sub    $0x4,%esp
  802487:	68 89 0e 81 00       	push   $0x810e89
  80248c:	6a 63                	push   $0x63
  80248e:	68 a3 0e 81 00       	push   $0x810ea3
  802493:	e8 f6 be 00 00       	call   80e38e <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  802498:	8b 03                	mov    (%ebx),%eax
  80249a:	85 c0                	test   %eax,%eax
  80249c:	74 0c                	je     8024aa <netbuf_alloc+0x35>
    pbuf_free(buf->p);
  80249e:	83 ec 0c             	sub    $0xc,%esp
  8024a1:	50                   	push   %eax
  8024a2:	e8 c0 22 00 00       	call   804767 <pbuf_free>
  8024a7:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  8024aa:	83 ec 04             	sub    $0x4,%esp
  8024ad:	6a 00                	push   $0x0
  8024af:	0f b7 c6             	movzwl %si,%eax
  8024b2:	50                   	push   %eax
  8024b3:	6a 00                	push   $0x0
  8024b5:	e8 73 23 00 00       	call   80482d <pbuf_alloc>
  8024ba:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8024bc:	83 c4 10             	add    $0x10,%esp
  8024bf:	85 c0                	test   %eax,%eax
  8024c1:	74 22                	je     8024e5 <netbuf_alloc+0x70>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8024c3:	66 3b 70 0a          	cmp    0xa(%eax),%si
  8024c7:	76 14                	jbe    8024dd <netbuf_alloc+0x68>
  8024c9:	83 ec 04             	sub    $0x4,%esp
  8024cc:	68 70 0f 81 00       	push   $0x810f70
  8024d1:	6a 6e                	push   $0x6e
  8024d3:	68 a3 0e 81 00       	push   $0x810ea3
  8024d8:	e8 b1 be 00 00       	call   80e38e <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8024dd:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  8024e0:	8b 40 04             	mov    0x4(%eax),%eax
  8024e3:	eb 05                	jmp    8024ea <netbuf_alloc+0x75>
  if (buf->p != NULL) {
    pbuf_free(buf->p);
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  if (buf->p == NULL) {
     return NULL;
  8024e5:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
  return buf->p->payload;
}
  8024ea:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8024ed:	5b                   	pop    %ebx
  8024ee:	5e                   	pop    %esi
  8024ef:	5d                   	pop    %ebp
  8024f0:	c3                   	ret    

008024f1 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8024f1:	55                   	push   %ebp
  8024f2:	89 e5                	mov    %esp,%ebp
  8024f4:	53                   	push   %ebx
  8024f5:	83 ec 04             	sub    $0x4,%esp
  8024f8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8024fb:	85 db                	test   %ebx,%ebx
  8024fd:	75 14                	jne    802513 <netbuf_free+0x22>
  8024ff:	83 ec 04             	sub    $0x4,%esp
  802502:	68 b9 0e 81 00       	push   $0x810eb9
  802507:	6a 7b                	push   $0x7b
  802509:	68 a3 0e 81 00       	push   $0x810ea3
  80250e:	e8 7b be 00 00       	call   80e38e <_panic>
  if (buf->p != NULL) {
  802513:	8b 03                	mov    (%ebx),%eax
  802515:	85 c0                	test   %eax,%eax
  802517:	74 0c                	je     802525 <netbuf_free+0x34>
    pbuf_free(buf->p);
  802519:	83 ec 0c             	sub    $0xc,%esp
  80251c:	50                   	push   %eax
  80251d:	e8 45 22 00 00       	call   804767 <pbuf_free>
  802522:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  802525:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  80252c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  802532:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802535:	c9                   	leave  
  802536:	c3                   	ret    

00802537 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  802537:	55                   	push   %ebp
  802538:	89 e5                	mov    %esp,%ebp
  80253a:	56                   	push   %esi
  80253b:	53                   	push   %ebx
  80253c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80253f:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802542:	85 db                	test   %ebx,%ebx
  802544:	75 17                	jne    80255d <netbuf_ref+0x26>
  802546:	83 ec 04             	sub    $0x4,%esp
  802549:	68 d2 0e 81 00       	push   $0x810ed2
  80254e:	68 8e 00 00 00       	push   $0x8e
  802553:	68 a3 0e 81 00       	push   $0x810ea3
  802558:	e8 31 be 00 00       	call   80e38e <_panic>
  if (buf->p != NULL) {
  80255d:	8b 03                	mov    (%ebx),%eax
  80255f:	85 c0                	test   %eax,%eax
  802561:	74 0c                	je     80256f <netbuf_ref+0x38>
    pbuf_free(buf->p);
  802563:	83 ec 0c             	sub    $0xc,%esp
  802566:	50                   	push   %eax
  802567:	e8 fb 21 00 00       	call   804767 <pbuf_free>
  80256c:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  80256f:	83 ec 04             	sub    $0x4,%esp
  802572:	6a 02                	push   $0x2
  802574:	6a 00                	push   $0x0
  802576:	6a 00                	push   $0x0
  802578:	e8 b0 22 00 00       	call   80482d <pbuf_alloc>
  80257d:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  80257f:	83 c4 10             	add    $0x10,%esp
  802582:	85 c0                	test   %eax,%eax
  802584:	75 0e                	jne    802594 <netbuf_ref+0x5d>
    buf->ptr = NULL;
  802586:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  80258d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802592:	eb 1a                	jmp    8025ae <netbuf_ref+0x77>
  }
  buf->p->payload = (void*)dataptr;
  802594:	8b 55 0c             	mov    0xc(%ebp),%edx
  802597:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  80259a:	8b 03                	mov    (%ebx),%eax
  80259c:	66 89 70 08          	mov    %si,0x8(%eax)
  8025a0:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  8025a4:	8b 03                	mov    (%ebx),%eax
  8025a6:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  8025a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8025ae:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8025b1:	5b                   	pop    %ebx
  8025b2:	5e                   	pop    %esi
  8025b3:	5d                   	pop    %ebp
  8025b4:	c3                   	ret    

008025b5 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  8025b5:	55                   	push   %ebp
  8025b6:	89 e5                	mov    %esp,%ebp
  8025b8:	56                   	push   %esi
  8025b9:	53                   	push   %ebx
  8025ba:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8025bd:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8025c0:	85 db                	test   %ebx,%ebx
  8025c2:	75 17                	jne    8025db <netbuf_chain+0x26>
  8025c4:	83 ec 04             	sub    $0x4,%esp
  8025c7:	68 ea 0e 81 00       	push   $0x810eea
  8025cc:	68 a6 00 00 00       	push   $0xa6
  8025d1:	68 a3 0e 81 00       	push   $0x810ea3
  8025d6:	e8 b3 bd 00 00       	call   80e38e <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8025db:	85 f6                	test   %esi,%esi
  8025dd:	75 17                	jne    8025f6 <netbuf_chain+0x41>
  8025df:	83 ec 04             	sub    $0x4,%esp
  8025e2:	68 03 0f 81 00       	push   $0x810f03
  8025e7:	68 a7 00 00 00       	push   $0xa7
  8025ec:	68 a3 0e 81 00       	push   $0x810ea3
  8025f1:	e8 98 bd 00 00       	call   80e38e <_panic>
  pbuf_chain(head->p, tail->p);
  8025f6:	83 ec 08             	sub    $0x8,%esp
  8025f9:	ff 36                	pushl  (%esi)
  8025fb:	ff 33                	pushl  (%ebx)
  8025fd:	e8 59 26 00 00       	call   804c5b <pbuf_chain>
  head->ptr = head->p;
  802602:	8b 03                	mov    (%ebx),%eax
  802604:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  802607:	83 c4 08             	add    $0x8,%esp
  80260a:	56                   	push   %esi
  80260b:	6a 06                	push   $0x6
  80260d:	e8 e2 1d 00 00       	call   8043f4 <memp_free>
}
  802612:	83 c4 10             	add    $0x10,%esp
  802615:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802618:	5b                   	pop    %ebx
  802619:	5e                   	pop    %esi
  80261a:	5d                   	pop    %ebp
  80261b:	c3                   	ret    

0080261c <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  80261c:	55                   	push   %ebp
  80261d:	89 e5                	mov    %esp,%ebp
  80261f:	53                   	push   %ebx
  802620:	83 ec 04             	sub    $0x4,%esp
  802623:	8b 45 08             	mov    0x8(%ebp),%eax
  802626:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  802629:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  80262c:	85 c0                	test   %eax,%eax
  80262e:	75 17                	jne    802647 <netbuf_data+0x2b>
  802630:	83 ec 04             	sub    $0x4,%esp
  802633:	68 1e 0f 81 00       	push   $0x810f1e
  802638:	68 b9 00 00 00       	push   $0xb9
  80263d:	68 a3 0e 81 00       	push   $0x810ea3
  802642:	e8 47 bd 00 00       	call   80e38e <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802647:	85 c9                	test   %ecx,%ecx
  802649:	75 17                	jne    802662 <netbuf_data+0x46>
  80264b:	83 ec 04             	sub    $0x4,%esp
  80264e:	68 37 0f 81 00       	push   $0x810f37
  802653:	68 ba 00 00 00       	push   $0xba
  802658:	68 a3 0e 81 00       	push   $0x810ea3
  80265d:	e8 2c bd 00 00       	call   80e38e <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802662:	85 d2                	test   %edx,%edx
  802664:	75 17                	jne    80267d <netbuf_data+0x61>
  802666:	83 ec 04             	sub    $0x4,%esp
  802669:	68 54 0f 81 00       	push   $0x810f54
  80266e:	68 bb 00 00 00       	push   $0xbb
  802673:	68 a3 0e 81 00       	push   $0x810ea3
  802678:	e8 11 bd 00 00       	call   80e38e <_panic>

  if (buf->ptr == NULL) {
  80267d:	8b 58 04             	mov    0x4(%eax),%ebx
  802680:	85 db                	test   %ebx,%ebx
  802682:	74 16                	je     80269a <netbuf_data+0x7e>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802684:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802687:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  802689:	8b 40 04             	mov    0x4(%eax),%eax
  80268c:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  802690:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  802693:	b8 00 00 00 00       	mov    $0x0,%eax
  802698:	eb 05                	jmp    80269f <netbuf_data+0x83>
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
    return ERR_BUF;
  80269a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  }
  *dataptr = buf->ptr->payload;
  *len = buf->ptr->len;
  return ERR_OK;
}
  80269f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8026a2:	c9                   	leave  
  8026a3:	c3                   	ret    

008026a4 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  8026a4:	55                   	push   %ebp
  8026a5:	89 e5                	mov    %esp,%ebp
  8026a7:	83 ec 08             	sub    $0x8,%esp
  8026aa:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8026ad:	85 c0                	test   %eax,%eax
  8026af:	75 17                	jne    8026c8 <netbuf_next+0x24>
  8026b1:	83 ec 04             	sub    $0x4,%esp
  8026b4:	68 b9 0e 81 00       	push   $0x810eb9
  8026b9:	68 d2 00 00 00       	push   $0xd2
  8026be:	68 a3 0e 81 00       	push   $0x810ea3
  8026c3:	e8 c6 bc 00 00       	call   80e38e <_panic>
  if (buf->ptr->next == NULL) {
  8026c8:	8b 50 04             	mov    0x4(%eax),%edx
  8026cb:	8b 12                	mov    (%edx),%edx
  8026cd:	85 d2                	test   %edx,%edx
  8026cf:	74 0b                	je     8026dc <netbuf_next+0x38>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  8026d1:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
  8026d4:	83 3a 00             	cmpl   $0x0,(%edx)
  8026d7:	0f 94 c0             	sete   %al
  8026da:	eb 05                	jmp    8026e1 <netbuf_next+0x3d>
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  if (buf->ptr->next == NULL) {
    return -1;
  8026dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  buf->ptr = buf->ptr->next;
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  8026e1:	c9                   	leave  
  8026e2:	c3                   	ret    

008026e3 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8026e3:	55                   	push   %ebp
  8026e4:	89 e5                	mov    %esp,%ebp
  8026e6:	83 ec 08             	sub    $0x8,%esp
  8026e9:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8026ec:	85 c0                	test   %eax,%eax
  8026ee:	75 17                	jne    802707 <netbuf_first+0x24>
  8026f0:	83 ec 04             	sub    $0x4,%esp
  8026f3:	68 b9 0e 81 00       	push   $0x810eb9
  8026f8:	68 e7 00 00 00       	push   $0xe7
  8026fd:	68 a3 0e 81 00       	push   $0x810ea3
  802702:	e8 87 bc 00 00       	call   80e38e <_panic>
  buf->ptr = buf->p;
  802707:	8b 10                	mov    (%eax),%edx
  802709:	89 50 04             	mov    %edx,0x4(%eax)
}
  80270c:	c9                   	leave  
  80270d:	c3                   	ret    

0080270e <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  80270e:	55                   	push   %ebp
  80270f:	89 e5                	mov    %esp,%ebp
  802711:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  802714:	e8 c0 74 00 00       	call   809bd9 <sys_init>
  mem_init();
  802719:	e8 41 17 00 00       	call   803e5f <mem_init>
  memp_init();
  80271e:	e8 24 1c 00 00       	call   804347 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  802723:	e8 d4 e6 ff ff       	call   800dfc <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  802728:	c9                   	leave  
  802729:	c3                   	ret    

0080272a <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  80272a:	55                   	push   %ebp
  80272b:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  80272d:	38 10                	cmp    %dl,(%eax)
  80272f:	74 06                	je     802737 <dhcp_set_state+0xd>
    dhcp->state = new_state;
  802731:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  802733:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  802737:	5d                   	pop    %ebp
  802738:	c3                   	ret    

00802739 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  802739:	55                   	push   %ebp
  80273a:	89 e5                	mov    %esp,%ebp
  80273c:	57                   	push   %edi
  80273d:	56                   	push   %esi
  80273e:	53                   	push   %ebx
  80273f:	83 ec 08             	sub    $0x8,%esp
  802742:	89 45 ec             	mov    %eax,-0x14(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802745:	8b 70 14             	mov    0x14(%eax),%esi
  802748:	85 f6                	test   %esi,%esi
  80274a:	0f 84 d5 00 00 00    	je     802825 <dhcp_get_option_ptr+0xec>
  802750:	0f b7 78 18          	movzwl 0x18(%eax),%edi
  802754:	b9 00 00 00 00       	mov    $0x0,%ecx
  802759:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80275d:	b8 00 00 00 00       	mov    $0x0,%eax
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802762:	66 85 ff             	test   %di,%di
  802765:	0f 84 d2 00 00 00    	je     80283d <dhcp_get_option_ptr+0x104>
  80276b:	eb 2d                	jmp    80279a <dhcp_get_option_ptr+0x61>
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80276d:	80 fb 34             	cmp    $0x34,%bl
  802770:	75 12                	jne    802784 <dhcp_get_option_ptr+0x4b>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  802772:	8d 41 02             	lea    0x2(%ecx),%eax
        overload = options[offset++];
  802775:	83 c1 03             	add    $0x3,%ecx
  802778:	0f b7 c0             	movzwl %ax,%eax
  80277b:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  80277f:	88 45 f0             	mov    %al,-0x10(%ebp)
  802782:	eb 16                	jmp    80279a <dhcp_get_option_ptr+0x61>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  802784:	38 d3                	cmp    %dl,%bl
  802786:	0f 84 b1 00 00 00    	je     80283d <dhcp_get_option_ptr+0x104>
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  80278c:	8d 41 01             	lea    0x1(%ecx),%eax
  80278f:	0f b7 c0             	movzwl %ax,%eax
  802792:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802796:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80279a:	66 39 f9             	cmp    %di,%cx
  80279d:	73 0d                	jae    8027ac <dhcp_get_option_ptr+0x73>
  80279f:	0f b7 c1             	movzwl %cx,%eax
  8027a2:	01 f0                	add    %esi,%eax
  8027a4:	0f b6 18             	movzbl (%eax),%ebx
  8027a7:	80 fb ff             	cmp    $0xff,%bl
  8027aa:	75 c1                	jne    80276d <dhcp_get_option_ptr+0x34>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  8027ac:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
  8027b0:	84 c0                	test   %al,%al
  8027b2:	74 78                	je     80282c <dhcp_get_option_ptr+0xf3>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  8027b4:	3c 01                	cmp    $0x1,%al
  8027b6:	75 10                	jne    8027c8 <dhcp_get_option_ptr+0x8f>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  8027b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8027bb:	8b 58 10             	mov    0x10(%eax),%ebx
  8027be:	83 c3 6c             	add    $0x6c,%ebx
        field_len = DHCP_FILE_LEN;
  8027c1:	be 80 00 00 00       	mov    $0x80,%esi
  8027c6:	eb 24                	jmp    8027ec <dhcp_get_option_ptr+0xb3>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  8027c8:	80 7d f0 02          	cmpb   $0x2,-0x10(%ebp)
  8027cc:	75 10                	jne    8027de <dhcp_get_option_ptr+0xa5>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  8027ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8027d1:	8b 58 10             	mov    0x10(%eax),%ebx
  8027d4:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_SNAME_LEN;
  8027d7:	be 40 00 00 00       	mov    $0x40,%esi
  8027dc:	eb 0e                	jmp    8027ec <dhcp_get_option_ptr+0xb3>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  8027de:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8027e1:	8b 58 10             	mov    0x10(%eax),%ebx
  8027e4:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  8027e7:	be c0 00 00 00       	mov    $0xc0,%esi
      }
      offset = 0;
  8027ec:	b9 00 00 00 00       	mov    $0x0,%ecx
  8027f1:	89 d7                	mov    %edx,%edi

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8027f3:	eb 14                	jmp    802809 <dhcp_get_option_ptr+0xd0>
        if (options[offset] == option_type) {
  8027f5:	89 f8                	mov    %edi,%eax
  8027f7:	38 d0                	cmp    %dl,%al
  8027f9:	74 3f                	je     80283a <dhcp_get_option_ptr+0x101>
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
          offset += 1 + options[offset];
  8027fb:	8d 41 01             	lea    0x1(%ecx),%eax
  8027fe:	0f b7 c0             	movzwl %ax,%eax
  802801:	0f b6 04 03          	movzbl (%ebx,%eax,1),%eax
  802805:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802809:	66 39 f1             	cmp    %si,%cx
  80280c:	73 25                	jae    802833 <dhcp_get_option_ptr+0xfa>
  80280e:	0f b7 c1             	movzwl %cx,%eax
  802811:	01 d8                	add    %ebx,%eax
  802813:	89 45 f0             	mov    %eax,-0x10(%ebp)
  802816:	0f b6 10             	movzbl (%eax),%edx
  802819:	80 fa ff             	cmp    $0xff,%dl
  80281c:	75 d7                	jne    8027f5 <dhcp_get_option_ptr+0xbc>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80281e:	b8 00 00 00 00       	mov    $0x0,%eax
  802823:	eb 18                	jmp    80283d <dhcp_get_option_ptr+0x104>
  802825:	b8 00 00 00 00       	mov    $0x0,%eax
  80282a:	eb 11                	jmp    80283d <dhcp_get_option_ptr+0x104>
  80282c:	b8 00 00 00 00       	mov    $0x0,%eax
  802831:	eb 0a                	jmp    80283d <dhcp_get_option_ptr+0x104>
  802833:	b8 00 00 00 00       	mov    $0x0,%eax
  802838:	eb 03                	jmp    80283d <dhcp_get_option_ptr+0x104>
  80283a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
  80283d:	83 c4 08             	add    $0x8,%esp
  802840:	5b                   	pop    %ebx
  802841:	5e                   	pop    %esi
  802842:	5f                   	pop    %edi
  802843:	5d                   	pop    %ebp
  802844:	c3                   	ret    

00802845 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  802845:	55                   	push   %ebp
  802846:	89 e5                	mov    %esp,%ebp
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802848:	0f b6 10             	movzbl (%eax),%edx
  80284b:	89 d1                	mov    %edx,%ecx
  80284d:	c1 e1 18             	shl    $0x18,%ecx
  802850:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  802854:	c1 e2 10             	shl    $0x10,%edx
  802857:	09 ca                	or     %ecx,%edx
  802859:	0f b6 48 03          	movzbl 0x3(%eax),%ecx
  80285d:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 16;
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
  80285f:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  802863:	c1 e0 08             	shl    $0x8,%eax
  802866:	09 d0                	or     %edx,%eax
}
  802868:	5d                   	pop    %ebp
  802869:	c3                   	ret    

0080286a <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  80286a:	55                   	push   %ebp
  80286b:	89 e5                	mov    %esp,%ebp
  80286d:	56                   	push   %esi
  80286e:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80286f:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802873:	66 83 f9 43          	cmp    $0x43,%cx
  802877:	76 17                	jbe    802890 <dhcp_option_byte+0x26>
  802879:	83 ec 04             	sub    $0x4,%esp
  80287c:	68 94 0f 81 00       	push   $0x810f94
  802881:	68 65 04 00 00       	push   $0x465
  802886:	68 e2 12 81 00       	push   $0x8112e2
  80288b:	e8 fe ba 00 00       	call   80e38e <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802890:	8b 58 20             	mov    0x20(%eax),%ebx
  802893:	8d 71 01             	lea    0x1(%ecx),%esi
  802896:	66 89 70 24          	mov    %si,0x24(%eax)
  80289a:	0f b7 c9             	movzwl %cx,%ecx
  80289d:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  8028a4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8028a7:	5b                   	pop    %ebx
  8028a8:	5e                   	pop    %esi
  8028a9:	5d                   	pop    %ebp
  8028aa:	c3                   	ret    

008028ab <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  8028ab:	55                   	push   %ebp
  8028ac:	89 e5                	mov    %esp,%ebp
  8028ae:	57                   	push   %edi
  8028af:	56                   	push   %esi
  8028b0:	53                   	push   %ebx
  8028b1:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  8028b4:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  8028b8:	0f b7 fb             	movzwl %bx,%edi
  8028bb:	0f b6 f1             	movzbl %cl,%esi
  8028be:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  8028c2:	83 fe 44             	cmp    $0x44,%esi
  8028c5:	76 17                	jbe    8028de <dhcp_option+0x33>
  8028c7:	83 ec 04             	sub    $0x4,%esp
  8028ca:	68 d0 0f 81 00       	push   $0x810fd0
  8028cf:	68 5a 04 00 00       	push   $0x45a
  8028d4:	68 e2 12 81 00       	push   $0x8112e2
  8028d9:	e8 b0 ba 00 00       	call   80e38e <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  8028de:	8b 70 20             	mov    0x20(%eax),%esi
  8028e1:	8d 7b 01             	lea    0x1(%ebx),%edi
  8028e4:	66 89 78 24          	mov    %di,0x24(%eax)
  8028e8:	0f b7 db             	movzwl %bx,%ebx
  8028eb:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  8028f2:	8b 58 20             	mov    0x20(%eax),%ebx
  8028f5:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8028f9:	8d 72 01             	lea    0x1(%edx),%esi
  8028fc:	66 89 70 24          	mov    %si,0x24(%eax)
  802900:	0f b7 d2             	movzwl %dx,%edx
  802903:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  80290a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80290d:	5b                   	pop    %ebx
  80290e:	5e                   	pop    %esi
  80290f:	5f                   	pop    %edi
  802910:	5d                   	pop    %ebp
  802911:	c3                   	ret    

00802912 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  802912:	55                   	push   %ebp
  802913:	89 e5                	mov    %esp,%ebp
  802915:	56                   	push   %esi
  802916:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802917:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  80291b:	0f b7 d9             	movzwl %cx,%ebx
  80291e:	83 c3 02             	add    $0x2,%ebx
  802921:	83 fb 44             	cmp    $0x44,%ebx
  802924:	76 17                	jbe    80293d <dhcp_option_short+0x2b>
  802926:	83 ec 04             	sub    $0x4,%esp
  802929:	68 18 10 81 00       	push   $0x811018
  80292e:	68 6c 04 00 00       	push   $0x46c
  802933:	68 e2 12 81 00       	push   $0x8112e2
  802938:	e8 51 ba 00 00       	call   80e38e <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  80293d:	8d 71 01             	lea    0x1(%ecx),%esi
  802940:	66 89 70 24          	mov    %si,0x24(%eax)
  802944:	0f b7 c9             	movzwl %cx,%ecx
  802947:	89 d3                	mov    %edx,%ebx
  802949:	66 c1 eb 08          	shr    $0x8,%bx
  80294d:	8b 70 20             	mov    0x20(%eax),%esi
  802950:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802957:	8b 58 20             	mov    0x20(%eax),%ebx
  80295a:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  80295e:	8d 71 01             	lea    0x1(%ecx),%esi
  802961:	66 89 70 24          	mov    %si,0x24(%eax)
  802965:	0f b7 c9             	movzwl %cx,%ecx
  802968:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  80296f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802972:	5b                   	pop    %ebx
  802973:	5e                   	pop    %esi
  802974:	5d                   	pop    %ebp
  802975:	c3                   	ret    

00802976 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  802976:	55                   	push   %ebp
  802977:	89 e5                	mov    %esp,%ebp
  802979:	53                   	push   %ebx
  80297a:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  80297d:	85 c0                	test   %eax,%eax
  80297f:	75 17                	jne    802998 <dhcp_option_trailer+0x22>
  802981:	83 ec 04             	sub    $0x4,%esp
  802984:	68 5c 10 81 00       	push   $0x81105c
  802989:	68 80 05 00 00       	push   $0x580
  80298e:	68 e2 12 81 00       	push   $0x8112e2
  802993:	e8 f6 b9 00 00       	call   80e38e <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802998:	8b 48 20             	mov    0x20(%eax),%ecx
  80299b:	85 c9                	test   %ecx,%ecx
  80299d:	75 17                	jne    8029b6 <dhcp_option_trailer+0x40>
  80299f:	83 ec 04             	sub    $0x4,%esp
  8029a2:	68 80 10 81 00       	push   $0x811080
  8029a7:	68 81 05 00 00       	push   $0x581
  8029ac:	68 e2 12 81 00       	push   $0x8112e2
  8029b1:	e8 d8 b9 00 00       	call   80e38e <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8029b6:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8029ba:	66 83 fa 43          	cmp    $0x43,%dx
  8029be:	76 17                	jbe    8029d7 <dhcp_option_trailer+0x61>
  8029c0:	83 ec 04             	sub    $0x4,%esp
  8029c3:	68 ac 10 81 00       	push   $0x8110ac
  8029c8:	68 82 05 00 00       	push   $0x582
  8029cd:	68 e2 12 81 00       	push   $0x8112e2
  8029d2:	e8 b7 b9 00 00       	call   80e38e <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  8029d7:	8d 5a 01             	lea    0x1(%edx),%ebx
  8029da:	66 89 58 24          	mov    %bx,0x24(%eax)
  8029de:	0f b7 d2             	movzwl %dx,%edx
  8029e1:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  8029e8:	ff 
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  8029e9:	eb 2c                	jmp    802a17 <dhcp_option_trailer+0xa1>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8029eb:	83 ec 04             	sub    $0x4,%esp
  8029ee:	68 ac 10 81 00       	push   $0x8110ac
  8029f3:	68 87 05 00 00       	push   $0x587
  8029f8:	68 e2 12 81 00       	push   $0x8112e2
  8029fd:	e8 8c b9 00 00       	call   80e38e <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802a02:	8b 48 20             	mov    0x20(%eax),%ecx
  802a05:	8d 5a 01             	lea    0x1(%edx),%ebx
  802a08:	66 89 58 24          	mov    %bx,0x24(%eax)
  802a0c:	0f b7 d2             	movzwl %dx,%edx
  802a0f:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802a16:	00 
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802a17:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802a1b:	66 83 fa 43          	cmp    $0x43,%dx
  802a1f:	76 e1                	jbe    802a02 <dhcp_option_trailer+0x8c>
  802a21:	f6 c2 03             	test   $0x3,%dl
  802a24:	75 c5                	jne    8029eb <dhcp_option_trailer+0x75>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  802a26:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802a29:	c9                   	leave  
  802a2a:	c3                   	ret    

00802a2b <dhcp_option_long>:
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  802a2b:	55                   	push   %ebp
  802a2c:	89 e5                	mov    %esp,%ebp
  802a2e:	56                   	push   %esi
  802a2f:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802a30:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a34:	0f b7 d9             	movzwl %cx,%ebx
  802a37:	83 c3 04             	add    $0x4,%ebx
  802a3a:	83 fb 44             	cmp    $0x44,%ebx
  802a3d:	76 17                	jbe    802a56 <dhcp_option_long+0x2b>
  802a3f:	83 ec 04             	sub    $0x4,%esp
  802a42:	68 ec 10 81 00       	push   $0x8110ec
  802a47:	68 74 04 00 00       	push   $0x474
  802a4c:	68 e2 12 81 00       	push   $0x8112e2
  802a51:	e8 38 b9 00 00       	call   80e38e <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802a56:	8d 71 01             	lea    0x1(%ecx),%esi
  802a59:	66 89 70 24          	mov    %si,0x24(%eax)
  802a5d:	0f b7 c9             	movzwl %cx,%ecx
  802a60:	89 d3                	mov    %edx,%ebx
  802a62:	c1 eb 18             	shr    $0x18,%ebx
  802a65:	8b 70 20             	mov    0x20(%eax),%esi
  802a68:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802a6f:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a73:	8d 71 01             	lea    0x1(%ecx),%esi
  802a76:	66 89 70 24          	mov    %si,0x24(%eax)
  802a7a:	0f b7 c9             	movzwl %cx,%ecx
  802a7d:	89 d3                	mov    %edx,%ebx
  802a7f:	c1 eb 10             	shr    $0x10,%ebx
  802a82:	8b 70 20             	mov    0x20(%eax),%esi
  802a85:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802a8c:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a90:	8d 71 01             	lea    0x1(%ecx),%esi
  802a93:	66 89 70 24          	mov    %si,0x24(%eax)
  802a97:	0f b7 c9             	movzwl %cx,%ecx
  802a9a:	0f b6 de             	movzbl %dh,%ebx
  802a9d:	8b 70 20             	mov    0x20(%eax),%esi
  802aa0:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802aa7:	8b 58 20             	mov    0x20(%eax),%ebx
  802aaa:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802aae:	8d 71 01             	lea    0x1(%ecx),%esi
  802ab1:	66 89 70 24          	mov    %si,0x24(%eax)
  802ab5:	0f b7 c9             	movzwl %cx,%ecx
  802ab8:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802abf:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802ac2:	5b                   	pop    %ebx
  802ac3:	5e                   	pop    %esi
  802ac4:	5d                   	pop    %ebp
  802ac5:	c3                   	ret    

00802ac6 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  802ac6:	55                   	push   %ebp
  802ac7:	89 e5                	mov    %esp,%ebp
  802ac9:	57                   	push   %edi
  802aca:	56                   	push   %esi
  802acb:	53                   	push   %ebx
  802acc:	83 ec 1c             	sub    $0x1c,%esp
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802acf:	85 c0                	test   %eax,%eax
  802ad1:	75 17                	jne    802aea <dhcp_create_request+0x24>
  802ad3:	83 ec 04             	sub    $0x4,%esp
  802ad6:	68 2c 11 81 00       	push   $0x81112c
  802adb:	68 2d 05 00 00       	push   $0x52d
  802ae0:	68 e2 12 81 00       	push   $0x8112e2
  802ae5:	e8 a4 b8 00 00       	call   80e38e <_panic>
  802aea:	89 c7                	mov    %eax,%edi
  dhcp = netif->dhcp;
  802aec:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802aef:	85 db                	test   %ebx,%ebx
  802af1:	75 17                	jne    802b0a <dhcp_create_request+0x44>
  802af3:	83 ec 04             	sub    $0x4,%esp
  802af6:	68 50 11 81 00       	push   $0x811150
  802afb:	68 2f 05 00 00       	push   $0x52f
  802b00:	68 e2 12 81 00       	push   $0x8112e2
  802b05:	e8 84 b8 00 00       	call   80e38e <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802b0a:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802b0e:	74 17                	je     802b27 <dhcp_create_request+0x61>
  802b10:	83 ec 04             	sub    $0x4,%esp
  802b13:	68 74 11 81 00       	push   $0x811174
  802b18:	68 30 05 00 00       	push   $0x530
  802b1d:	68 e2 12 81 00       	push   $0x8112e2
  802b22:	e8 67 b8 00 00       	call   80e38e <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802b27:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802b2b:	74 17                	je     802b44 <dhcp_create_request+0x7e>
  802b2d:	83 ec 04             	sub    $0x4,%esp
  802b30:	68 a0 11 81 00       	push   $0x8111a0
  802b35:	68 31 05 00 00       	push   $0x531
  802b3a:	68 e2 12 81 00       	push   $0x8112e2
  802b3f:	e8 4a b8 00 00       	call   80e38e <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802b44:	83 ec 04             	sub    $0x4,%esp
  802b47:	6a 00                	push   $0x0
  802b49:	68 34 01 00 00       	push   $0x134
  802b4e:	6a 00                	push   $0x0
  802b50:	e8 d8 1c 00 00       	call   80482d <pbuf_alloc>
  802b55:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802b58:	83 c4 10             	add    $0x10,%esp
  802b5b:	85 c0                	test   %eax,%eax
  802b5d:	0f 84 37 01 00 00    	je     802c9a <dhcp_create_request+0x1d4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802b63:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802b69:	77 17                	ja     802b82 <dhcp_create_request+0xbc>
  802b6b:	83 ec 04             	sub    $0x4,%esp
  802b6e:	68 cc 11 81 00       	push   $0x8111cc
  802b73:	68 38 05 00 00       	push   $0x538
  802b78:	68 e2 12 81 00       	push   $0x8112e2
  802b7d:	e8 0c b8 00 00       	call   80e38e <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  802b82:	8b 15 04 40 81 00    	mov    0x814004,%edx
  802b88:	8d 4a 01             	lea    0x1(%edx),%ecx
  802b8b:	89 0d 04 40 81 00    	mov    %ecx,0x814004
  802b91:	89 53 04             	mov    %edx,0x4(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802b94:	8b 40 04             	mov    0x4(%eax),%eax
  802b97:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802b9a:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802b9d:	8b 43 20             	mov    0x20(%ebx),%eax
  802ba0:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802ba4:	8b 43 20             	mov    0x20(%ebx),%eax
  802ba7:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802bab:	8b 43 20             	mov    0x20(%ebx),%eax
  802bae:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802bb2:	8b 73 20             	mov    0x20(%ebx),%esi
  802bb5:	83 ec 0c             	sub    $0xc,%esp
  802bb8:	ff 73 04             	pushl  0x4(%ebx)
  802bbb:	e8 72 4a 00 00       	call   807632 <htonl>
  802bc0:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  802bc3:	8b 43 20             	mov    0x20(%ebx),%eax
  802bc6:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802bcc:	8b 43 20             	mov    0x20(%ebx),%eax
  802bcf:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802bd5:	8b 43 20             	mov    0x20(%ebx),%eax
  802bd8:	8b 57 04             	mov    0x4(%edi),%edx
  802bdb:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802bde:	8b 43 20             	mov    0x20(%ebx),%eax
  802be1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802be8:	8b 43 20             	mov    0x20(%ebx),%eax
  802beb:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802bf2:	8b 43 20             	mov    0x20(%ebx),%eax
  802bf5:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802bfc:	83 c4 10             	add    $0x10,%esp
  802bff:	b8 00 00 00 00       	mov    $0x0,%eax
  802c04:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802c07:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  802c0a:	8b 59 20             	mov    0x20(%ecx),%ebx
  802c0d:	89 c1                	mov    %eax,%ecx
  802c0f:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  802c13:	ba 00 00 00 00       	mov    $0x0,%edx
  802c18:	66 39 c6             	cmp    %ax,%si
  802c1b:	76 05                	jbe    802c22 <dhcp_create_request+0x15c>
  802c1d:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  802c22:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  802c26:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802c29:	83 f8 10             	cmp    $0x10,%eax
  802c2c:	75 d9                	jne    802c07 <dhcp_create_request+0x141>
  802c2e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  802c31:	b8 00 00 00 00       	mov    $0x0,%eax
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  802c36:	8b 53 20             	mov    0x20(%ebx),%edx
  802c39:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  802c3e:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802c41:	83 f8 40             	cmp    $0x40,%eax
  802c44:	75 f0                	jne    802c36 <dhcp_create_request+0x170>
  802c46:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  802c4b:	8b 53 20             	mov    0x20(%ebx),%edx
  802c4e:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  802c53:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802c56:	3d 80 00 00 00       	cmp    $0x80,%eax
  802c5b:	75 ee                	jne    802c4b <dhcp_create_request+0x185>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802c5d:	8b 73 20             	mov    0x20(%ebx),%esi
  802c60:	83 ec 0c             	sub    $0xc,%esp
  802c63:	68 63 53 82 63       	push   $0x63825363
  802c68:	e8 c5 49 00 00       	call   807632 <htonl>
  802c6d:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802c73:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802c79:	83 c4 10             	add    $0x10,%esp
  802c7c:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802c81:	8b 53 20             	mov    0x20(%ebx),%edx
  802c84:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  802c8b:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802c8e:	83 f8 44             	cmp    $0x44,%eax
  802c91:	75 ee                	jne    802c81 <dhcp_create_request+0x1bb>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  802c93:	b8 00 00 00 00       	mov    $0x0,%eax
  802c98:	eb 05                	jmp    802c9f <dhcp_create_request+0x1d9>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  802c9a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  802c9f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802ca2:	5b                   	pop    %ebx
  802ca3:	5e                   	pop    %esi
  802ca4:	5f                   	pop    %edi
  802ca5:	5d                   	pop    %ebp
  802ca6:	c3                   	ret    

00802ca7 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  802ca7:	55                   	push   %ebp
  802ca8:	89 e5                	mov    %esp,%ebp
  802caa:	53                   	push   %ebx
  802cab:	83 ec 04             	sub    $0x4,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802cae:	85 c0                	test   %eax,%eax
  802cb0:	75 17                	jne    802cc9 <dhcp_delete_request+0x22>
  802cb2:	83 ec 04             	sub    $0x4,%esp
  802cb5:	68 10 12 81 00       	push   $0x811210
  802cba:	68 69 05 00 00       	push   $0x569
  802cbf:	68 e2 12 81 00       	push   $0x8112e2
  802cc4:	e8 c5 b6 00 00       	call   80e38e <_panic>
  dhcp = netif->dhcp;
  802cc9:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802ccc:	85 db                	test   %ebx,%ebx
  802cce:	75 17                	jne    802ce7 <dhcp_delete_request+0x40>
  802cd0:	83 ec 04             	sub    $0x4,%esp
  802cd3:	68 34 12 81 00       	push   $0x811234
  802cd8:	68 6b 05 00 00       	push   $0x56b
  802cdd:	68 e2 12 81 00       	push   $0x8112e2
  802ce2:	e8 a7 b6 00 00       	call   80e38e <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802ce7:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802cea:	85 c0                	test   %eax,%eax
  802cec:	75 17                	jne    802d05 <dhcp_delete_request+0x5e>
  802cee:	83 ec 04             	sub    $0x4,%esp
  802cf1:	68 58 12 81 00       	push   $0x811258
  802cf6:	68 6c 05 00 00       	push   $0x56c
  802cfb:	68 e2 12 81 00       	push   $0x8112e2
  802d00:	e8 89 b6 00 00       	call   80e38e <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802d05:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802d09:	75 17                	jne    802d22 <dhcp_delete_request+0x7b>
  802d0b:	83 ec 04             	sub    $0x4,%esp
  802d0e:	68 84 12 81 00       	push   $0x811284
  802d13:	68 6d 05 00 00       	push   $0x56d
  802d18:	68 e2 12 81 00       	push   $0x8112e2
  802d1d:	e8 6c b6 00 00       	call   80e38e <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  802d22:	83 ec 0c             	sub    $0xc,%esp
  802d25:	50                   	push   %eax
  802d26:	e8 3c 1a 00 00       	call   804767 <pbuf_free>
  }
  dhcp->p_out = NULL;
  802d2b:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802d32:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  802d39:	83 c4 10             	add    $0x10,%esp
  802d3c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802d3f:	c9                   	leave  
  802d40:	c3                   	ret    

00802d41 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  802d41:	55                   	push   %ebp
  802d42:	89 e5                	mov    %esp,%ebp
  802d44:	57                   	push   %edi
  802d45:	56                   	push   %esi
  802d46:	53                   	push   %ebx
  802d47:	83 ec 0c             	sub    $0xc,%esp
  802d4a:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802d4c:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802d4f:	ba 04 00 00 00       	mov    $0x4,%edx
  802d54:	89 d8                	mov    %ebx,%eax
  802d56:	e8 cf f9 ff ff       	call   80272a <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  802d5b:	89 f8                	mov    %edi,%eax
  802d5d:	e8 64 fd ff ff       	call   802ac6 <dhcp_create_request>
  802d62:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802d64:	84 c0                	test   %al,%al
  802d66:	0f 85 89 00 00 00    	jne    802df5 <dhcp_rebind+0xb4>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802d6c:	b9 01 00 00 00       	mov    $0x1,%ecx
  802d71:	ba 35 00 00 00       	mov    $0x35,%edx
  802d76:	89 d8                	mov    %ebx,%eax
  802d78:	e8 2e fb ff ff       	call   8028ab <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802d7d:	ba 03 00 00 00       	mov    $0x3,%edx
  802d82:	89 d8                	mov    %ebx,%eax
  802d84:	e8 e1 fa ff ff       	call   80286a <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802d89:	b9 02 00 00 00       	mov    $0x2,%ecx
  802d8e:	ba 39 00 00 00       	mov    $0x39,%edx
  802d93:	89 d8                	mov    %ebx,%eax
  802d95:	e8 11 fb ff ff       	call   8028ab <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802d9a:	ba 40 02 00 00       	mov    $0x240,%edx
  802d9f:	89 d8                	mov    %ebx,%eax
  802da1:	e8 6c fb ff ff       	call   802912 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  802da6:	89 d8                	mov    %ebx,%eax
  802da8:	e8 c9 fb ff ff       	call   802976 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802dad:	83 ec 08             	sub    $0x8,%esp
  802db0:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802db4:	66 05 f0 00          	add    $0xf0,%ax
  802db8:	0f b7 c0             	movzwl %ax,%eax
  802dbb:	50                   	push   %eax
  802dbc:	ff 73 1c             	pushl  0x1c(%ebx)
  802dbf:	e8 ec 1c 00 00       	call   804ab0 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802dc4:	83 c4 0c             	add    $0xc,%esp
  802dc7:	6a 43                	push   $0x43
  802dc9:	68 a4 1b 81 00       	push   $0x811ba4
  802dce:	ff 73 08             	pushl  0x8(%ebx)
  802dd1:	e8 f6 5f 00 00       	call   808dcc <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802dd6:	89 3c 24             	mov    %edi,(%esp)
  802dd9:	6a 43                	push   $0x43
  802ddb:	68 a0 1b 81 00       	push   $0x811ba0
  802de0:	ff 73 1c             	pushl  0x1c(%ebx)
  802de3:	ff 73 08             	pushl  0x8(%ebx)
  802de6:	e8 fb 5d 00 00       	call   808be6 <udp_sendto_if>
    dhcp_delete_request(netif);
  802deb:	83 c4 20             	add    $0x20,%esp
  802dee:	89 f8                	mov    %edi,%eax
  802df0:	e8 b2 fe ff ff       	call   802ca7 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  802df5:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802df9:	83 c0 01             	add    $0x1,%eax
  802dfc:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802dff:	ba 10 27 00 00       	mov    $0x2710,%edx
  802e04:	3c 09                	cmp    $0x9,%al
  802e06:	77 08                	ja     802e10 <dhcp_rebind+0xcf>
  802e08:	0f b6 c0             	movzbl %al,%eax
  802e0b:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802e10:	0f b7 c2             	movzwl %dx,%eax
  802e13:	05 f3 01 00 00       	add    $0x1f3,%eax
  802e18:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  802e1d:	f7 ea                	imul   %edx
  802e1f:	c1 fa 05             	sar    $0x5,%edx
  802e22:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  802e26:	89 f0                	mov    %esi,%eax
  802e28:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802e2b:	5b                   	pop    %ebx
  802e2c:	5e                   	pop    %esi
  802e2d:	5f                   	pop    %edi
  802e2e:	5d                   	pop    %ebp
  802e2f:	c3                   	ret    

00802e30 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  802e30:	55                   	push   %ebp
  802e31:	89 e5                	mov    %esp,%ebp
  802e33:	57                   	push   %edi
  802e34:	56                   	push   %esi
  802e35:	53                   	push   %ebx
  802e36:	83 ec 0c             	sub    $0xc,%esp
  802e39:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802e3b:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  802e3e:	a1 a4 1b 81 00       	mov    0x811ba4,%eax
  802e43:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  802e46:	89 f8                	mov    %edi,%eax
  802e48:	e8 79 fc ff ff       	call   802ac6 <dhcp_create_request>
  802e4d:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802e4f:	84 c0                	test   %al,%al
  802e51:	0f 85 d6 00 00 00    	jne    802f2d <dhcp_discover+0xfd>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802e57:	b9 01 00 00 00       	mov    $0x1,%ecx
  802e5c:	ba 35 00 00 00       	mov    $0x35,%edx
  802e61:	89 d8                	mov    %ebx,%eax
  802e63:	e8 43 fa ff ff       	call   8028ab <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  802e68:	ba 01 00 00 00       	mov    $0x1,%edx
  802e6d:	89 d8                	mov    %ebx,%eax
  802e6f:	e8 f6 f9 ff ff       	call   80286a <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802e74:	b9 02 00 00 00       	mov    $0x2,%ecx
  802e79:	ba 39 00 00 00       	mov    $0x39,%edx
  802e7e:	89 d8                	mov    %ebx,%eax
  802e80:	e8 26 fa ff ff       	call   8028ab <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802e85:	ba 40 02 00 00       	mov    $0x240,%edx
  802e8a:	89 d8                	mov    %ebx,%eax
  802e8c:	e8 81 fa ff ff       	call   802912 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  802e91:	b9 04 00 00 00       	mov    $0x4,%ecx
  802e96:	ba 37 00 00 00       	mov    $0x37,%edx
  802e9b:	89 d8                	mov    %ebx,%eax
  802e9d:	e8 09 fa ff ff       	call   8028ab <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  802ea2:	ba 01 00 00 00       	mov    $0x1,%edx
  802ea7:	89 d8                	mov    %ebx,%eax
  802ea9:	e8 bc f9 ff ff       	call   80286a <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  802eae:	ba 03 00 00 00       	mov    $0x3,%edx
  802eb3:	89 d8                	mov    %ebx,%eax
  802eb5:	e8 b0 f9 ff ff       	call   80286a <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  802eba:	ba 1c 00 00 00       	mov    $0x1c,%edx
  802ebf:	89 d8                	mov    %ebx,%eax
  802ec1:	e8 a4 f9 ff ff       	call   80286a <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  802ec6:	ba 06 00 00 00       	mov    $0x6,%edx
  802ecb:	89 d8                	mov    %ebx,%eax
  802ecd:	e8 98 f9 ff ff       	call   80286a <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  802ed2:	89 d8                	mov    %ebx,%eax
  802ed4:	e8 9d fa ff ff       	call   802976 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802ed9:	83 ec 08             	sub    $0x8,%esp
  802edc:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802ee0:	66 05 f0 00          	add    $0xf0,%ax
  802ee4:	0f b7 c0             	movzwl %ax,%eax
  802ee7:	50                   	push   %eax
  802ee8:	ff 73 1c             	pushl  0x1c(%ebx)
  802eeb:	e8 c0 1b 00 00       	call   804ab0 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802ef0:	83 c4 0c             	add    $0xc,%esp
  802ef3:	6a 43                	push   $0x43
  802ef5:	68 a4 1b 81 00       	push   $0x811ba4
  802efa:	ff 73 08             	pushl  0x8(%ebx)
  802efd:	e8 ca 5e 00 00       	call   808dcc <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802f02:	89 3c 24             	mov    %edi,(%esp)
  802f05:	6a 43                	push   $0x43
  802f07:	68 a0 1b 81 00       	push   $0x811ba0
  802f0c:	ff 73 1c             	pushl  0x1c(%ebx)
  802f0f:	ff 73 08             	pushl  0x8(%ebx)
  802f12:	e8 cf 5c 00 00       	call   808be6 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  802f17:	83 c4 20             	add    $0x20,%esp
  802f1a:	89 f8                	mov    %edi,%eax
  802f1c:	e8 86 fd ff ff       	call   802ca7 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  802f21:	ba 06 00 00 00       	mov    $0x6,%edx
  802f26:	89 d8                	mov    %ebx,%eax
  802f28:	e8 fd f7 ff ff       	call   80272a <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  802f2d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802f31:	83 c0 01             	add    $0x1,%eax
  802f34:	88 43 01             	mov    %al,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  802f37:	ba 10 27 00 00       	mov    $0x2710,%edx
  802f3c:	3c 03                	cmp    $0x3,%al
  802f3e:	77 0b                	ja     802f4b <dhcp_discover+0x11b>
  802f40:	0f b6 c0             	movzbl %al,%eax
  802f43:	83 c0 01             	add    $0x1,%eax
  802f46:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802f4b:	0f b7 c2             	movzwl %dx,%eax
  802f4e:	05 f3 01 00 00       	add    $0x1f3,%eax
  802f53:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  802f58:	f7 ea                	imul   %edx
  802f5a:	c1 fa 05             	sar    $0x5,%edx
  802f5d:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  802f61:	89 f0                	mov    %esi,%eax
  802f63:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802f66:	5b                   	pop    %ebx
  802f67:	5e                   	pop    %esi
  802f68:	5f                   	pop    %edi
  802f69:	5d                   	pop    %ebp
  802f6a:	c3                   	ret    

00802f6b <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  802f6b:	55                   	push   %ebp
  802f6c:	89 e5                	mov    %esp,%ebp
  802f6e:	57                   	push   %edi
  802f6f:	56                   	push   %esi
  802f70:	53                   	push   %ebx
  802f71:	83 ec 0c             	sub    $0xc,%esp
  802f74:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802f76:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  802f79:	e8 48 fb ff ff       	call   802ac6 <dhcp_create_request>
  802f7e:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802f80:	84 c0                	test   %al,%al
  802f82:	0f 85 20 01 00 00    	jne    8030a8 <dhcp_select+0x13d>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802f88:	b9 01 00 00 00       	mov    $0x1,%ecx
  802f8d:	ba 35 00 00 00       	mov    $0x35,%edx
  802f92:	89 d8                	mov    %ebx,%eax
  802f94:	e8 12 f9 ff ff       	call   8028ab <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802f99:	ba 03 00 00 00       	mov    $0x3,%edx
  802f9e:	89 d8                	mov    %ebx,%eax
  802fa0:	e8 c5 f8 ff ff       	call   80286a <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802fa5:	b9 02 00 00 00       	mov    $0x2,%ecx
  802faa:	ba 39 00 00 00       	mov    $0x39,%edx
  802faf:	89 d8                	mov    %ebx,%eax
  802fb1:	e8 f5 f8 ff ff       	call   8028ab <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802fb6:	ba 40 02 00 00       	mov    $0x240,%edx
  802fbb:	89 d8                	mov    %ebx,%eax
  802fbd:	e8 50 f9 ff ff       	call   802912 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  802fc2:	b9 04 00 00 00       	mov    $0x4,%ecx
  802fc7:	ba 32 00 00 00       	mov    $0x32,%edx
  802fcc:	89 d8                	mov    %ebx,%eax
  802fce:	e8 d8 f8 ff ff       	call   8028ab <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  802fd3:	83 ec 0c             	sub    $0xc,%esp
  802fd6:	ff 73 30             	pushl  0x30(%ebx)
  802fd9:	e8 75 48 00 00       	call   807853 <ntohl>
  802fde:	89 c2                	mov    %eax,%edx
  802fe0:	89 d8                	mov    %ebx,%eax
  802fe2:	e8 44 fa ff ff       	call   802a2b <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  802fe7:	b9 04 00 00 00       	mov    $0x4,%ecx
  802fec:	ba 36 00 00 00       	mov    $0x36,%edx
  802ff1:	89 d8                	mov    %ebx,%eax
  802ff3:	e8 b3 f8 ff ff       	call   8028ab <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  802ff8:	83 c4 04             	add    $0x4,%esp
  802ffb:	ff 73 2c             	pushl  0x2c(%ebx)
  802ffe:	e8 50 48 00 00       	call   807853 <ntohl>
  803003:	89 c2                	mov    %eax,%edx
  803005:	89 d8                	mov    %ebx,%eax
  803007:	e8 1f fa ff ff       	call   802a2b <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80300c:	b9 04 00 00 00       	mov    $0x4,%ecx
  803011:	ba 37 00 00 00       	mov    $0x37,%edx
  803016:	89 d8                	mov    %ebx,%eax
  803018:	e8 8e f8 ff ff       	call   8028ab <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80301d:	ba 01 00 00 00       	mov    $0x1,%edx
  803022:	89 d8                	mov    %ebx,%eax
  803024:	e8 41 f8 ff ff       	call   80286a <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  803029:	ba 03 00 00 00       	mov    $0x3,%edx
  80302e:	89 d8                	mov    %ebx,%eax
  803030:	e8 35 f8 ff ff       	call   80286a <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  803035:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80303a:	89 d8                	mov    %ebx,%eax
  80303c:	e8 29 f8 ff ff       	call   80286a <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803041:	ba 06 00 00 00       	mov    $0x6,%edx
  803046:	89 d8                	mov    %ebx,%eax
  803048:	e8 1d f8 ff ff       	call   80286a <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  80304d:	89 d8                	mov    %ebx,%eax
  80304f:	e8 22 f9 ff ff       	call   802976 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803054:	83 c4 08             	add    $0x8,%esp
  803057:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80305b:	66 05 f0 00          	add    $0xf0,%ax
  80305f:	0f b7 c0             	movzwl %ax,%eax
  803062:	50                   	push   %eax
  803063:	ff 73 1c             	pushl  0x1c(%ebx)
  803066:	e8 45 1a 00 00       	call   804ab0 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80306b:	89 3c 24             	mov    %edi,(%esp)
  80306e:	6a 43                	push   $0x43
  803070:	68 a0 1b 81 00       	push   $0x811ba0
  803075:	ff 73 1c             	pushl  0x1c(%ebx)
  803078:	ff 73 08             	pushl  0x8(%ebx)
  80307b:	e8 66 5b 00 00       	call   808be6 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803080:	83 c4 1c             	add    $0x1c,%esp
  803083:	6a 43                	push   $0x43
  803085:	68 a4 1b 81 00       	push   $0x811ba4
  80308a:	ff 73 08             	pushl  0x8(%ebx)
  80308d:	e8 3a 5d 00 00       	call   808dcc <udp_connect>
    dhcp_delete_request(netif);
  803092:	89 f8                	mov    %edi,%eax
  803094:	e8 0e fc ff ff       	call   802ca7 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  803099:	ba 01 00 00 00       	mov    $0x1,%edx
  80309e:	89 d8                	mov    %ebx,%eax
  8030a0:	e8 85 f6 ff ff       	call   80272a <dhcp_set_state>
  8030a5:	83 c4 10             	add    $0x10,%esp
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8030a8:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8030ac:	83 c0 01             	add    $0x1,%eax
  8030af:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  8030b2:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  8030b7:	3c 03                	cmp    $0x3,%al
  8030b9:	77 08                	ja     8030c3 <dhcp_select+0x158>
  8030bb:	0f b6 c0             	movzbl %al,%eax
  8030be:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8030c3:	0f b7 c2             	movzwl %dx,%eax
  8030c6:	05 f3 01 00 00       	add    $0x1f3,%eax
  8030cb:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8030d0:	f7 ea                	imul   %edx
  8030d2:	c1 fa 05             	sar    $0x5,%edx
  8030d5:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8030d9:	89 f0                	mov    %esi,%eax
  8030db:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8030de:	5b                   	pop    %ebx
  8030df:	5e                   	pop    %esi
  8030e0:	5f                   	pop    %edi
  8030e1:	5d                   	pop    %ebp
  8030e2:	c3                   	ret    

008030e3 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  8030e3:	55                   	push   %ebp
  8030e4:	89 e5                	mov    %esp,%ebp
  8030e6:	53                   	push   %ebx
  8030e7:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  8030ea:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8030ed:	6a 00                	push   $0x0
  8030ef:	8d 53 30             	lea    0x30(%ebx),%edx
  8030f2:	52                   	push   %edx
  8030f3:	50                   	push   %eax
  8030f4:	e8 9e 66 00 00       	call   809797 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  8030f9:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8030fd:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  803103:	ba 08 00 00 00       	mov    $0x8,%edx
  803108:	89 d8                	mov    %ebx,%eax
  80310a:	e8 1b f6 ff ff       	call   80272a <dhcp_set_state>
}
  80310f:	83 c4 10             	add    $0x10,%esp
  803112:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803115:	c9                   	leave  
  803116:	c3                   	ret    

00803117 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  803117:	55                   	push   %ebp
  803118:	89 e5                	mov    %esp,%ebp
  80311a:	56                   	push   %esi
  80311b:	53                   	push   %ebx
  80311c:	83 ec 10             	sub    $0x10,%esp
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80311f:	85 c0                	test   %eax,%eax
  803121:	75 17                	jne    80313a <dhcp_bind+0x23>
  803123:	83 ec 04             	sub    $0x4,%esp
  803126:	68 f7 12 81 00       	push   $0x8112f7
  80312b:	68 3d 03 00 00       	push   $0x33d
  803130:	68 e2 12 81 00       	push   $0x8112e2
  803135:	e8 54 b2 00 00       	call   80e38e <_panic>
  80313a:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  80313c:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80313f:	85 db                	test   %ebx,%ebx
  803141:	75 17                	jne    80315a <dhcp_bind+0x43>
  803143:	83 ec 04             	sub    $0x4,%esp
  803146:	68 10 13 81 00       	push   $0x811310
  80314b:	68 3f 03 00 00       	push   $0x33f
  803150:	68 e2 12 81 00       	push   $0x8112e2
  803155:	e8 34 b2 00 00       	call   80e38e <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  80315a:	8b 53 50             	mov    0x50(%ebx),%edx
  80315d:	83 fa ff             	cmp    $0xffffffff,%edx
  803160:	74 2c                	je     80318e <dhcp_bind+0x77>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803162:	83 c2 1e             	add    $0x1e,%edx
  803165:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  80316a:	89 d0                	mov    %edx,%eax
  80316c:	f7 e1                	mul    %ecx
  80316e:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  803171:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  803177:	b8 ff ff 00 00       	mov    $0xffff,%eax
  80317c:	0f 47 d0             	cmova  %eax,%edx
  80317f:	66 85 d2             	test   %dx,%dx
  803182:	b8 01 00 00 00       	mov    $0x1,%eax
  803187:	0f 44 d0             	cmove  %eax,%edx
  80318a:	66 89 53 28          	mov    %dx,0x28(%ebx)
      dhcp->t1_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80318e:	8b 53 54             	mov    0x54(%ebx),%edx
  803191:	83 fa ff             	cmp    $0xffffffff,%edx
  803194:	74 2c                	je     8031c2 <dhcp_bind+0xab>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803196:	83 c2 1e             	add    $0x1e,%edx
  803199:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  80319e:	89 d0                	mov    %edx,%eax
  8031a0:	f7 e1                	mul    %ecx
  8031a2:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  8031a5:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  8031ab:	b8 ff ff 00 00       	mov    $0xffff,%eax
  8031b0:	0f 47 d0             	cmova  %eax,%edx
  8031b3:	66 85 d2             	test   %dx,%dx
  8031b6:	b8 01 00 00 00       	mov    $0x1,%eax
  8031bb:	0f 44 d0             	cmove  %eax,%edx
  8031be:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8031c2:	83 fb cc             	cmp    $0xffffffcc,%ebx
  8031c5:	0f 84 c4 00 00 00    	je     80328f <dhcp_bind+0x178>
  8031cb:	8b 43 34             	mov    0x34(%ebx),%eax
  8031ce:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  8031d1:	85 c0                	test   %eax,%eax
  8031d3:	75 55                	jne    80322a <dhcp_bind+0x113>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  8031d5:	83 ec 0c             	sub    $0xc,%esp
  8031d8:	6a 00                	push   $0x0
  8031da:	e8 74 46 00 00       	call   807853 <ntohl>
  8031df:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  8031e2:	83 c4 10             	add    $0x10,%esp
  8031e5:	84 c0                	test   %al,%al
  8031e7:	78 15                	js     8031fe <dhcp_bind+0xe7>
      sn_mask.addr = htonl(0xff000000);
  8031e9:	83 ec 0c             	sub    $0xc,%esp
  8031ec:	68 00 00 00 ff       	push   $0xff000000
  8031f1:	e8 3c 44 00 00       	call   807632 <htonl>
  8031f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8031f9:	83 c4 10             	add    $0x10,%esp
  8031fc:	eb 2c                	jmp    80322a <dhcp_bind+0x113>
    } else if (first_octet >= 192) {
  8031fe:	3c bf                	cmp    $0xbf,%al
  803200:	76 15                	jbe    803217 <dhcp_bind+0x100>
      sn_mask.addr = htonl(0xffffff00);
  803202:	83 ec 0c             	sub    $0xc,%esp
  803205:	68 00 ff ff ff       	push   $0xffffff00
  80320a:	e8 23 44 00 00       	call   807632 <htonl>
  80320f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803212:	83 c4 10             	add    $0x10,%esp
  803215:	eb 13                	jmp    80322a <dhcp_bind+0x113>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  803217:	83 ec 0c             	sub    $0xc,%esp
  80321a:	68 00 00 ff ff       	push   $0xffff0000
  80321f:	e8 0e 44 00 00       	call   807632 <htonl>
  803224:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803227:	83 c4 10             	add    $0x10,%esp
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  80322a:	83 fb c8             	cmp    $0xffffffc8,%ebx
  80322d:	74 0a                	je     803239 <dhcp_bind+0x122>
  80322f:	8b 43 38             	mov    0x38(%ebx),%eax
  803232:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  803235:	85 c0                	test   %eax,%eax
  803237:	75 19                	jne    803252 <dhcp_bind+0x13b>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  803239:	8b 43 30             	mov    0x30(%ebx),%eax
  80323c:	23 45 f4             	and    -0xc(%ebp),%eax
  80323f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  803242:	83 ec 0c             	sub    $0xc,%esp
  803245:	6a 01                	push   $0x1
  803247:	e8 e6 43 00 00       	call   807632 <htonl>
  80324c:	09 45 f0             	or     %eax,-0x10(%ebp)
  80324f:	83 c4 10             	add    $0x10,%esp
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  803252:	83 ec 08             	sub    $0x8,%esp
  803255:	8d 43 30             	lea    0x30(%ebx),%eax
  803258:	50                   	push   %eax
  803259:	56                   	push   %esi
  80325a:	e8 55 12 00 00       	call   8044b4 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  80325f:	83 c4 08             	add    $0x8,%esp
  803262:	8d 45 f4             	lea    -0xc(%ebp),%eax
  803265:	50                   	push   %eax
  803266:	56                   	push   %esi
  803267:	e8 ab 13 00 00       	call   804617 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  80326c:	83 c4 08             	add    $0x8,%esp
  80326f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  803272:	50                   	push   %eax
  803273:	56                   	push   %esi
  803274:	e8 83 13 00 00       	call   8045fc <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  803279:	89 34 24             	mov    %esi,(%esp)
  80327c:	e8 be 13 00 00       	call   80463f <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  803281:	ba 0a 00 00 00       	mov    $0xa,%edx
  803286:	89 d8                	mov    %ebx,%eax
  803288:	e8 9d f4 ff ff       	call   80272a <dhcp_set_state>
}
  80328d:	eb 0c                	jmp    80329b <dhcp_bind+0x184>
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80328f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  803296:	e9 3a ff ff ff       	jmp    8031d5 <dhcp_bind+0xbe>
  netif_set_gw(netif, &gw_addr);
  /* bring the interface up */
  netif_set_up(netif);
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
}
  80329b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80329e:	5b                   	pop    %ebx
  80329f:	5e                   	pop    %esi
  8032a0:	5d                   	pop    %ebp
  8032a1:	c3                   	ret    

008032a2 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  8032a2:	55                   	push   %ebp
  8032a3:	89 e5                	mov    %esp,%ebp
  8032a5:	53                   	push   %ebx
  8032a6:	83 ec 04             	sub    $0x4,%esp
  8032a9:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  8032ab:	8b 40 10             	mov    0x10(%eax),%eax
  8032ae:	85 c0                	test   %eax,%eax
  8032b0:	74 13                	je     8032c5 <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  8032b2:	83 ec 0c             	sub    $0xc,%esp
  8032b5:	50                   	push   %eax
  8032b6:	e8 0a 0c 00 00       	call   803ec5 <mem_free>
    dhcp->msg_in = NULL;
  8032bb:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8032c2:	83 c4 10             	add    $0x10,%esp
  }
  if (dhcp->options_in) {
  8032c5:	8b 43 14             	mov    0x14(%ebx),%eax
  8032c8:	85 c0                	test   %eax,%eax
  8032ca:	74 19                	je     8032e5 <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  8032cc:	83 ec 0c             	sub    $0xc,%esp
  8032cf:	50                   	push   %eax
  8032d0:	e8 f0 0b 00 00       	call   803ec5 <mem_free>
    dhcp->options_in = NULL;
  8032d5:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  8032dc:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  8032e2:	83 c4 10             	add    $0x10,%esp
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  8032e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8032e8:	c9                   	leave  
  8032e9:	c3                   	ret    

008032ea <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  8032ea:	55                   	push   %ebp
  8032eb:	89 e5                	mov    %esp,%ebp
  8032ed:	57                   	push   %edi
  8032ee:	56                   	push   %esi
  8032ef:	53                   	push   %ebx
  8032f0:	83 ec 1c             	sub    $0x1c,%esp
  8032f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
  8032f6:	8b 73 20             	mov    0x20(%ebx),%esi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  8032f9:	8b 45 10             	mov    0x10(%ebp),%eax
  8032fc:	8b 48 04             	mov    0x4(%eax),%ecx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  8032ff:	89 46 0c             	mov    %eax,0xc(%esi)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  803302:	80 39 02             	cmpb   $0x2,(%ecx)
  803305:	0f 85 b8 03 00 00    	jne    8036c3 <dhcp_recv+0x3d9>
  80330b:	0f b6 7b 24          	movzbl 0x24(%ebx),%edi
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80330f:	b8 00 00 00 00       	mov    $0x0,%eax
  803314:	eb 12                	jmp    803328 <dhcp_recv+0x3e>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  803316:	0f b6 54 03 25       	movzbl 0x25(%ebx,%eax,1),%edx
  80331b:	83 c0 01             	add    $0x1,%eax
  80331e:	3a 54 01 1b          	cmp    0x1b(%ecx,%eax,1),%dl
  803322:	0f 85 9b 03 00 00    	jne    8036c3 <dhcp_recv+0x3d9>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  803328:	39 f8                	cmp    %edi,%eax
  80332a:	75 ea                	jne    803316 <dhcp_recv+0x2c>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  80332c:	83 ec 0c             	sub    $0xc,%esp
  80332f:	ff 71 04             	pushl  0x4(%ecx)
  803332:	e8 1c 45 00 00       	call   807853 <ntohl>
  803337:	83 c4 10             	add    $0x10,%esp
  80333a:	3b 46 04             	cmp    0x4(%esi),%eax
  80333d:	0f 85 80 03 00 00    	jne    8036c3 <dhcp_recv+0x3d9>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  803343:	85 f6                	test   %esi,%esi
  803345:	75 17                	jne    80335e <dhcp_recv+0x74>
  803347:	83 ec 04             	sub    $0x4,%esp
  80334a:	68 1b 13 81 00       	push   $0x81131b
  80334f:	68 89 04 00 00       	push   $0x489
  803354:	68 e2 12 81 00       	push   $0x8112e2
  803359:	e8 30 b0 00 00       	call   80e38e <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80335e:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
  803362:	75 17                	jne    80337b <dhcp_recv+0x91>
  803364:	83 ec 04             	sub    $0x4,%esp
  803367:	68 28 13 81 00       	push   $0x811328
  80336c:	68 8a 04 00 00       	push   $0x48a
  803371:	68 e2 12 81 00       	push   $0x8112e2
  803376:	e8 13 b0 00 00       	call   80e38e <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80337b:	89 f0                	mov    %esi,%eax
  80337d:	e8 20 ff ff ff       	call   8032a2 <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  803382:	8b 46 0c             	mov    0xc(%esi),%eax
  803385:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  803389:	66 3d f0 00          	cmp    $0xf0,%ax
  80338d:	76 22                	jbe    8033b1 <dhcp_recv+0xc7>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80338f:	66 2d f0 00          	sub    $0xf0,%ax
  803393:	66 89 46 18          	mov    %ax,0x18(%esi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  803397:	83 ec 0c             	sub    $0xc,%esp
  80339a:	0f b7 c0             	movzwl %ax,%eax
  80339d:	50                   	push   %eax
  80339e:	e8 d4 0d 00 00       	call   804177 <mem_malloc>
  8033a3:	89 46 14             	mov    %eax,0x14(%esi)
    if (dhcp->options_in == NULL) {
  8033a6:	83 c4 10             	add    $0x10,%esp
  8033a9:	85 c0                	test   %eax,%eax
  8033ab:	0f 84 12 03 00 00    	je     8036c3 <dhcp_recv+0x3d9>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8033b1:	83 ec 0c             	sub    $0xc,%esp
  8033b4:	68 f0 00 00 00       	push   $0xf0
  8033b9:	e8 b9 0d 00 00       	call   804177 <mem_malloc>
  8033be:	89 46 10             	mov    %eax,0x10(%esi)
  if (dhcp->msg_in == NULL) {
  8033c1:	83 c4 10             	add    $0x10,%esp
  8033c4:	85 c0                	test   %eax,%eax
  8033c6:	75 1a                	jne    8033e2 <dhcp_recv+0xf8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  8033c8:	83 ec 0c             	sub    $0xc,%esp
  8033cb:	ff 76 14             	pushl  0x14(%esi)
  8033ce:	e8 f2 0a 00 00       	call   803ec5 <mem_free>
    dhcp->options_in = NULL;
  8033d3:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
  8033da:	83 c4 10             	add    $0x10,%esp
  8033dd:	e9 e1 02 00 00       	jmp    8036c3 <dhcp_recv+0x3d9>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8033e2:	6a 00                	push   $0x0
  8033e4:	68 f0 00 00 00       	push   $0xf0
  8033e9:	50                   	push   %eax
  8033ea:	ff 76 0c             	pushl  0xc(%esi)
  8033ed:	e8 c5 1a 00 00       	call   804eb7 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8033f2:	83 c4 10             	add    $0x10,%esp
  8033f5:	66 3d f0 00          	cmp    $0xf0,%ax
  8033f9:	74 17                	je     803412 <dhcp_recv+0x128>
  8033fb:	83 ec 04             	sub    $0x4,%esp
  8033fe:	68 b0 12 81 00       	push   $0x8112b0
  803403:	68 a0 04 00 00       	push   $0x4a0
  803408:	68 e2 12 81 00       	push   $0x8112e2
  80340d:	e8 7c af 00 00       	call   80e38e <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  803412:	8b 46 14             	mov    0x14(%esi),%eax
  803415:	85 c0                	test   %eax,%eax
  803417:	0f 84 ba 02 00 00    	je     8036d7 <dhcp_recv+0x3ed>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80341d:	68 f0 00 00 00       	push   $0xf0
  803422:	0f b7 56 18          	movzwl 0x18(%esi),%edx
  803426:	52                   	push   %edx
  803427:	50                   	push   %eax
  803428:	ff 76 0c             	pushl  0xc(%esi)
  80342b:	e8 87 1a 00 00       	call   804eb7 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803430:	83 c4 10             	add    $0x10,%esp
  803433:	66 3b 46 18          	cmp    0x18(%esi),%ax
  803437:	0f 84 9a 02 00 00    	je     8036d7 <dhcp_recv+0x3ed>
  80343d:	83 ec 04             	sub    $0x4,%esp
  803440:	68 38 13 81 00       	push   $0x811338
  803445:	68 a7 04 00 00       	push   $0x4a7
  80344a:	68 e2 12 81 00       	push   $0x8112e2
  80344f:	e8 3a af 00 00       	call   80e38e <_panic>
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  803454:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  803458:	3c 05                	cmp    $0x5,%al
  80345a:	0f 85 a3 01 00 00    	jne    803603 <dhcp_recv+0x319>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  803460:	0f b6 06             	movzbl (%esi),%eax
  803463:	3c 01                	cmp    $0x1,%al
  803465:	0f 85 7b 01 00 00    	jne    8035e6 <dhcp_recv+0x2fc>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  80346b:	8b 7b 20             	mov    0x20(%ebx),%edi
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  80346e:	c7 47 34 00 00 00 00 	movl   $0x0,0x34(%edi)
  dhcp->offered_gw_addr.addr = 0;
  803475:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  dhcp->offered_bc_addr.addr = 0;
  80347c:	c7 47 3c 00 00 00 00 	movl   $0x0,0x3c(%edi)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  803483:	ba 33 00 00 00       	mov    $0x33,%edx
  803488:	89 f8                	mov    %edi,%eax
  80348a:	e8 aa f2 ff ff       	call   802739 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80348f:	85 c0                	test   %eax,%eax
  803491:	74 0b                	je     80349e <dhcp_recv+0x1b4>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  803493:	83 c0 02             	add    $0x2,%eax
  803496:	e8 aa f3 ff ff       	call   802845 <dhcp_get_option_long>
  80349b:	89 47 4c             	mov    %eax,0x4c(%edi)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  80349e:	ba 3a 00 00 00       	mov    $0x3a,%edx
  8034a3:	89 f8                	mov    %edi,%eax
  8034a5:	e8 8f f2 ff ff       	call   802739 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8034aa:	85 c0                	test   %eax,%eax
  8034ac:	74 0d                	je     8034bb <dhcp_recv+0x1d1>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  8034ae:	83 c0 02             	add    $0x2,%eax
  8034b1:	e8 8f f3 ff ff       	call   802845 <dhcp_get_option_long>
  8034b6:	89 47 50             	mov    %eax,0x50(%edi)
  8034b9:	eb 08                	jmp    8034c3 <dhcp_recv+0x1d9>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  8034bb:	8b 47 4c             	mov    0x4c(%edi),%eax
  8034be:	d1 e8                	shr    %eax
  8034c0:	89 47 50             	mov    %eax,0x50(%edi)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  8034c3:	ba 3b 00 00 00       	mov    $0x3b,%edx
  8034c8:	89 f8                	mov    %edi,%eax
  8034ca:	e8 6a f2 ff ff       	call   802739 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8034cf:	85 c0                	test   %eax,%eax
  8034d1:	74 0d                	je     8034e0 <dhcp_recv+0x1f6>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  8034d3:	83 c0 02             	add    $0x2,%eax
  8034d6:	e8 6a f3 ff ff       	call   802845 <dhcp_get_option_long>
  8034db:	89 47 54             	mov    %eax,0x54(%edi)
  8034de:	eb 06                	jmp    8034e6 <dhcp_recv+0x1fc>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  8034e0:	8b 47 4c             	mov    0x4c(%edi),%eax
  8034e3:	89 47 54             	mov    %eax,0x54(%edi)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8034e6:	8b 47 10             	mov    0x10(%edi),%eax
  8034e9:	83 f8 f0             	cmp    $0xfffffff0,%eax
  8034ec:	74 05                	je     8034f3 <dhcp_recv+0x209>
  8034ee:	8b 40 10             	mov    0x10(%eax),%eax
  8034f1:	eb 05                	jmp    8034f8 <dhcp_recv+0x20e>
  8034f3:	b8 00 00 00 00       	mov    $0x0,%eax
  8034f8:	89 47 30             	mov    %eax,0x30(%edi)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8034fb:	ba 01 00 00 00       	mov    $0x1,%edx
  803500:	89 f8                	mov    %edi,%eax
  803502:	e8 32 f2 ff ff       	call   802739 <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  803507:	85 c0                	test   %eax,%eax
  803509:	74 17                	je     803522 <dhcp_recv+0x238>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80350b:	83 c0 02             	add    $0x2,%eax
  80350e:	e8 32 f3 ff ff       	call   802845 <dhcp_get_option_long>
  803513:	83 ec 0c             	sub    $0xc,%esp
  803516:	50                   	push   %eax
  803517:	e8 16 41 00 00       	call   807632 <htonl>
  80351c:	89 47 34             	mov    %eax,0x34(%edi)
  80351f:	83 c4 10             	add    $0x10,%esp
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  803522:	ba 03 00 00 00       	mov    $0x3,%edx
  803527:	89 f8                	mov    %edi,%eax
  803529:	e8 0b f2 ff ff       	call   802739 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80352e:	85 c0                	test   %eax,%eax
  803530:	74 17                	je     803549 <dhcp_recv+0x25f>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803532:	83 c0 02             	add    $0x2,%eax
  803535:	e8 0b f3 ff ff       	call   802845 <dhcp_get_option_long>
  80353a:	83 ec 0c             	sub    $0xc,%esp
  80353d:	50                   	push   %eax
  80353e:	e8 ef 40 00 00       	call   807632 <htonl>
  803543:	89 47 38             	mov    %eax,0x38(%edi)
  803546:	83 c4 10             	add    $0x10,%esp
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  803549:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80354e:	89 f8                	mov    %edi,%eax
  803550:	e8 e4 f1 ff ff       	call   802739 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803555:	85 c0                	test   %eax,%eax
  803557:	74 17                	je     803570 <dhcp_recv+0x286>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803559:	83 c0 02             	add    $0x2,%eax
  80355c:	e8 e4 f2 ff ff       	call   802845 <dhcp_get_option_long>
  803561:	83 ec 0c             	sub    $0xc,%esp
  803564:	50                   	push   %eax
  803565:	e8 c8 40 00 00       	call   807632 <htonl>
  80356a:	89 47 3c             	mov    %eax,0x3c(%edi)
  80356d:	83 c4 10             	add    $0x10,%esp
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  803570:	ba 06 00 00 00       	mov    $0x6,%edx
  803575:	89 f8                	mov    %edi,%eax
  803577:	e8 bd f1 ff ff       	call   802739 <dhcp_get_option_ptr>
  80357c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (option_ptr != NULL) {
  80357f:	85 c0                	test   %eax,%eax
  803581:	74 51                	je     8035d4 <dhcp_recv+0x2ea>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803583:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  803587:	c0 e8 02             	shr    $0x2,%al
  80358a:	0f b6 c0             	movzbl %al,%eax
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
  80358d:	83 f8 03             	cmp    $0x3,%eax
  803590:	ba 02 00 00 00       	mov    $0x2,%edx
  803595:	0f 43 c2             	cmovae %edx,%eax
  803598:	89 47 40             	mov    %eax,0x40(%edi)
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  80359b:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80359f:	89 5d 08             	mov    %ebx,0x8(%ebp)
  8035a2:	eb 24                	jmp    8035c8 <dhcp_recv+0x2de>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  8035a4:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  8035a8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8035ab:	8d 44 99 02          	lea    0x2(%ecx,%ebx,4),%eax
  8035af:	e8 91 f2 ff ff       	call   802845 <dhcp_get_option_long>
  8035b4:	83 ec 0c             	sub    $0xc,%esp
  8035b7:	50                   	push   %eax
  8035b8:	e8 75 40 00 00       	call   807632 <htonl>
  8035bd:	89 44 9f 44          	mov    %eax,0x44(%edi,%ebx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  8035c1:	80 45 e7 01          	addb   $0x1,-0x19(%ebp)
  8035c5:	83 c4 10             	add    $0x10,%esp
  8035c8:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  8035cc:	3b 47 40             	cmp    0x40(%edi),%eax
  8035cf:	72 d3                	jb     8035a4 <dhcp_recv+0x2ba>
  8035d1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  8035d4:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  8035da:	89 d8                	mov    %ebx,%eax
  8035dc:	e8 02 fb ff ff       	call   8030e3 <dhcp_check>
  8035e1:	e9 dd 00 00 00       	jmp    8036c3 <dhcp_recv+0x3d9>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  8035e6:	83 e8 03             	sub    $0x3,%eax
  8035e9:	3c 02                	cmp    $0x2,%al
  8035eb:	0f 87 d2 00 00 00    	ja     8036c3 <dhcp_recv+0x3d9>
      dhcp->request_timeout = 0;
  8035f1:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
      dhcp_bind(netif);
  8035f7:	89 d8                	mov    %ebx,%eax
  8035f9:	e8 19 fb ff ff       	call   803117 <dhcp_bind>
  8035fe:	e9 c0 00 00 00       	jmp    8036c3 <dhcp_recv+0x3d9>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  803603:	3c 06                	cmp    $0x6,%al
  803605:	75 67                	jne    80366e <dhcp_recv+0x384>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  803607:	0f b6 06             	movzbl (%esi),%eax
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80360a:	8d 50 fd             	lea    -0x3(%eax),%edx
  80360d:	80 fa 02             	cmp    $0x2,%dl
  803610:	76 08                	jbe    80361a <dhcp_recv+0x330>
  803612:	3c 01                	cmp    $0x1,%al
  803614:	0f 85 a9 00 00 00    	jne    8036c3 <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  80361a:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803620:	8b 7b 20             	mov    0x20(%ebx),%edi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  803623:	83 ec 0c             	sub    $0xc,%esp
  803626:	53                   	push   %ebx
  803627:	e8 44 10 00 00       	call   804670 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  80362c:	83 c4 08             	add    $0x8,%esp
  80362f:	68 a4 1b 81 00       	push   $0x811ba4
  803634:	53                   	push   %ebx
  803635:	e8 7a 0e 00 00       	call   8044b4 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  80363a:	83 c4 08             	add    $0x8,%esp
  80363d:	68 a4 1b 81 00       	push   $0x811ba4
  803642:	53                   	push   %ebx
  803643:	e8 b4 0f 00 00       	call   8045fc <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  803648:	83 c4 08             	add    $0x8,%esp
  80364b:	68 a4 1b 81 00       	push   $0x811ba4
  803650:	53                   	push   %ebx
  803651:	e8 c1 0f 00 00       	call   804617 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803656:	ba 0c 00 00 00       	mov    $0xc,%edx
  80365b:	89 f8                	mov    %edi,%eax
  80365d:	e8 c8 f0 ff ff       	call   80272a <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  803662:	89 d8                	mov    %ebx,%eax
  803664:	e8 c7 f7 ff ff       	call   802e30 <dhcp_discover>
  803669:	83 c4 10             	add    $0x10,%esp
  80366c:	eb 55                	jmp    8036c3 <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80366e:	3c 02                	cmp    $0x2,%al
  803670:	75 51                	jne    8036c3 <dhcp_recv+0x3d9>
  803672:	80 3e 06             	cmpb   $0x6,(%esi)
  803675:	75 4c                	jne    8036c3 <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  803677:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  80367d:	8b 7b 20             	mov    0x20(%ebx),%edi
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  803680:	ba 36 00 00 00       	mov    $0x36,%edx
  803685:	89 f8                	mov    %edi,%eax
  803687:	e8 ad f0 ff ff       	call   802739 <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  80368c:	85 c0                	test   %eax,%eax
  80368e:	74 33                	je     8036c3 <dhcp_recv+0x3d9>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803690:	83 c0 02             	add    $0x2,%eax
  803693:	e8 ad f1 ff ff       	call   802845 <dhcp_get_option_long>
  803698:	83 ec 0c             	sub    $0xc,%esp
  80369b:	50                   	push   %eax
  80369c:	e8 91 3f 00 00       	call   807632 <htonl>
  8036a1:	89 47 2c             	mov    %eax,0x2c(%edi)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  8036a4:	8b 47 10             	mov    0x10(%edi),%eax
  8036a7:	83 c4 10             	add    $0x10,%esp
  8036aa:	83 f8 f0             	cmp    $0xfffffff0,%eax
  8036ad:	74 05                	je     8036b4 <dhcp_recv+0x3ca>
  8036af:	8b 40 10             	mov    0x10(%eax),%eax
  8036b2:	eb 05                	jmp    8036b9 <dhcp_recv+0x3cf>
  8036b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8036b9:	89 47 30             	mov    %eax,0x30(%edi)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  8036bc:	89 d8                	mov    %ebx,%eax
  8036be:	e8 a8 f8 ff ff       	call   802f6b <dhcp_select>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  8036c3:	83 ec 0c             	sub    $0xc,%esp
  8036c6:	ff 75 10             	pushl  0x10(%ebp)
  8036c9:	e8 99 10 00 00       	call   804767 <pbuf_free>
  dhcp->p = NULL;
  8036ce:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
}
  8036d5:	eb 16                	jmp    8036ed <dhcp_recv+0x403>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  8036d7:	ba 35 00 00 00       	mov    $0x35,%edx
  8036dc:	89 f0                	mov    %esi,%eax
  8036de:	e8 56 f0 ff ff       	call   802739 <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  8036e3:	85 c0                	test   %eax,%eax
  8036e5:	0f 85 69 fd ff ff    	jne    803454 <dhcp_recv+0x16a>
  8036eb:	eb d6                	jmp    8036c3 <dhcp_recv+0x3d9>
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  dhcp->p = NULL;
}
  8036ed:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8036f0:	5b                   	pop    %ebx
  8036f1:	5e                   	pop    %esi
  8036f2:	5f                   	pop    %edi
  8036f3:	5d                   	pop    %ebp
  8036f4:	c3                   	ret    

008036f5 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  8036f5:	55                   	push   %ebp
  8036f6:	89 e5                	mov    %esp,%ebp
  8036f8:	57                   	push   %edi
  8036f9:	56                   	push   %esi
  8036fa:	53                   	push   %ebx
  8036fb:	83 ec 18             	sub    $0x18,%esp
  8036fe:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803701:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  803704:	6a 58                	push   $0x58
  803706:	e8 6c 0a 00 00       	call   804177 <mem_malloc>
  if (dhcp == NULL) {
  80370b:	83 c4 10             	add    $0x10,%esp
  80370e:	85 c0                	test   %eax,%eax
  803710:	0f 84 1d 01 00 00    	je     803833 <dhcp_inform+0x13e>
  803716:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  803718:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  80371b:	83 ec 04             	sub    $0x4,%esp
  80371e:	6a 58                	push   $0x58
  803720:	6a 00                	push   $0x0
  803722:	50                   	push   %eax
  803723:	e8 09 b4 00 00       	call   80eb31 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  803728:	e8 83 57 00 00       	call   808eb0 <udp_new>
  80372d:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  803730:	83 c4 10             	add    $0x10,%esp
  803733:	85 c0                	test   %eax,%eax
  803735:	75 11                	jne    803748 <dhcp_inform+0x53>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  803737:	83 ec 0c             	sub    $0xc,%esp
  80373a:	53                   	push   %ebx
  80373b:	e8 85 07 00 00       	call   803ec5 <mem_free>
    return;
  803740:	83 c4 10             	add    $0x10,%esp
  803743:	e9 eb 00 00 00       	jmp    803833 <dhcp_inform+0x13e>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803748:	89 f0                	mov    %esi,%eax
  80374a:	e8 77 f3 ff ff       	call   802ac6 <dhcp_create_request>
  if (result == ERR_OK) {
  80374f:	84 c0                	test   %al,%al
  803751:	0f 85 d3 00 00 00    	jne    80382a <dhcp_inform+0x135>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803757:	b9 01 00 00 00       	mov    $0x1,%ecx
  80375c:	ba 35 00 00 00       	mov    $0x35,%edx
  803761:	89 d8                	mov    %ebx,%eax
  803763:	e8 43 f1 ff ff       	call   8028ab <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803768:	ba 08 00 00 00       	mov    $0x8,%edx
  80376d:	89 d8                	mov    %ebx,%eax
  80376f:	e8 f6 f0 ff ff       	call   80286a <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803774:	b9 02 00 00 00       	mov    $0x2,%ecx
  803779:	ba 39 00 00 00       	mov    $0x39,%edx
  80377e:	89 d8                	mov    %ebx,%eax
  803780:	e8 26 f1 ff ff       	call   8028ab <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  803785:	ba 40 02 00 00       	mov    $0x240,%edx
  80378a:	89 d8                	mov    %ebx,%eax
  80378c:	e8 81 f1 ff ff       	call   802912 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  803791:	89 d8                	mov    %ebx,%eax
  803793:	e8 de f1 ff ff       	call   802976 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803798:	83 ec 08             	sub    $0x8,%esp
  80379b:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80379f:	66 05 f0 00          	add    $0xf0,%ax
  8037a3:	0f b7 c0             	movzwl %ax,%eax
  8037a6:	50                   	push   %eax
  8037a7:	ff 73 1c             	pushl  0x1c(%ebx)
  8037aa:	e8 01 13 00 00       	call   804ab0 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  8037af:	83 c4 0c             	add    $0xc,%esp
  8037b2:	6a 44                	push   $0x44
  8037b4:	68 a4 1b 81 00       	push   $0x811ba4
  8037b9:	ff 73 08             	pushl  0x8(%ebx)
  8037bc:	e8 69 53 00 00       	call   808b2a <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  8037c1:	83 c4 0c             	add    $0xc,%esp
  8037c4:	6a 43                	push   $0x43
  8037c6:	68 a0 1b 81 00       	push   $0x811ba0
  8037cb:	ff 73 08             	pushl  0x8(%ebx)
  8037ce:	e8 f9 55 00 00       	call   808dcc <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8037d3:	89 34 24             	mov    %esi,(%esp)
  8037d6:	6a 43                	push   $0x43
  8037d8:	68 a0 1b 81 00       	push   $0x811ba0
  8037dd:	ff 73 1c             	pushl  0x1c(%ebx)
  8037e0:	ff 73 08             	pushl  0x8(%ebx)
  8037e3:	e8 fe 53 00 00       	call   808be6 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8037e8:	83 c4 1c             	add    $0x1c,%esp
  8037eb:	6a 43                	push   $0x43
  8037ed:	68 a4 1b 81 00       	push   $0x811ba4
  8037f2:	ff 73 08             	pushl  0x8(%ebx)
  8037f5:	e8 d2 55 00 00       	call   808dcc <udp_connect>
    dhcp_delete_request(netif);
  8037fa:	89 f0                	mov    %esi,%eax
  8037fc:	e8 a6 f4 ff ff       	call   802ca7 <dhcp_delete_request>
  803801:	83 c4 10             	add    $0x10,%esp
  803804:	eb 24                	jmp    80382a <dhcp_inform+0x135>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
      udp_remove(dhcp->pcb);
  803806:	83 ec 0c             	sub    $0xc,%esp
  803809:	50                   	push   %eax
  80380a:	e8 5d 56 00 00       	call   808e6c <udp_remove>
  80380f:	83 c4 10             	add    $0x10,%esp
    }
    dhcp->pcb = NULL;
  803812:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  803819:	83 ec 0c             	sub    $0xc,%esp
  80381c:	53                   	push   %ebx
  80381d:	e8 a3 06 00 00       	call   803ec5 <mem_free>
    netif->dhcp = old_dhcp;
  803822:	89 7e 20             	mov    %edi,0x20(%esi)
  803825:	83 c4 10             	add    $0x10,%esp
  803828:	eb 09                	jmp    803833 <dhcp_inform+0x13e>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  80382a:	8b 43 08             	mov    0x8(%ebx),%eax
  80382d:	85 c0                	test   %eax,%eax
  80382f:	75 d5                	jne    803806 <dhcp_inform+0x111>
  803831:	eb df                	jmp    803812 <dhcp_inform+0x11d>
    }
    dhcp->pcb = NULL;
    mem_free((void *)dhcp);
    netif->dhcp = old_dhcp;
  }
}
  803833:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803836:	5b                   	pop    %ebx
  803837:	5e                   	pop    %esi
  803838:	5f                   	pop    %edi
  803839:	5d                   	pop    %ebp
  80383a:	c3                   	ret    

0080383b <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  80383b:	55                   	push   %ebp
  80383c:	89 e5                	mov    %esp,%ebp
  80383e:	56                   	push   %esi
  80383f:	53                   	push   %ebx
  803840:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803843:	85 f6                	test   %esi,%esi
  803845:	75 17                	jne    80385e <dhcp_arp_reply+0x23>
  803847:	83 ec 04             	sub    $0x4,%esp
  80384a:	68 02 13 81 00       	push   $0x811302
  80384f:	68 b5 02 00 00       	push   $0x2b5
  803854:	68 e2 12 81 00       	push   $0x8112e2
  803859:	e8 30 ab 00 00       	call   80e38e <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  80385e:	8b 5e 20             	mov    0x20(%esi),%ebx
  803861:	85 db                	test   %ebx,%ebx
  803863:	0f 84 ea 00 00 00    	je     803953 <dhcp_arp_reply+0x118>
  803869:	80 3b 08             	cmpb   $0x8,(%ebx)
  80386c:	0f 85 e1 00 00 00    	jne    803953 <dhcp_arp_reply+0x118>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  803872:	8b 45 0c             	mov    0xc(%ebp),%eax
  803875:	8b 4b 30             	mov    0x30(%ebx),%ecx
  803878:	39 08                	cmp    %ecx,(%eax)
  80387a:	0f 85 d3 00 00 00    	jne    803953 <dhcp_arp_reply+0x118>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803880:	ba 0c 00 00 00       	mov    $0xc,%edx
  803885:	89 d8                	mov    %ebx,%eax
  803887:	e8 9e ee ff ff       	call   80272a <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80388c:	89 f0                	mov    %esi,%eax
  80388e:	e8 33 f2 ff ff       	call   802ac6 <dhcp_create_request>
  if (result == ERR_OK) {
  803893:	84 c0                	test   %al,%al
  803895:	0f 85 ae 00 00 00    	jne    803949 <dhcp_arp_reply+0x10e>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80389b:	b9 01 00 00 00       	mov    $0x1,%ecx
  8038a0:	ba 35 00 00 00       	mov    $0x35,%edx
  8038a5:	89 d8                	mov    %ebx,%eax
  8038a7:	e8 ff ef ff ff       	call   8028ab <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  8038ac:	ba 04 00 00 00       	mov    $0x4,%edx
  8038b1:	89 d8                	mov    %ebx,%eax
  8038b3:	e8 b2 ef ff ff       	call   80286a <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8038b8:	b9 02 00 00 00       	mov    $0x2,%ecx
  8038bd:	ba 39 00 00 00       	mov    $0x39,%edx
  8038c2:	89 d8                	mov    %ebx,%eax
  8038c4:	e8 e2 ef ff ff       	call   8028ab <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8038c9:	ba 40 02 00 00       	mov    $0x240,%edx
  8038ce:	89 d8                	mov    %ebx,%eax
  8038d0:	e8 3d f0 ff ff       	call   802912 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8038d5:	b9 04 00 00 00       	mov    $0x4,%ecx
  8038da:	ba 32 00 00 00       	mov    $0x32,%edx
  8038df:	89 d8                	mov    %ebx,%eax
  8038e1:	e8 c5 ef ff ff       	call   8028ab <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8038e6:	83 ec 0c             	sub    $0xc,%esp
  8038e9:	ff 73 30             	pushl  0x30(%ebx)
  8038ec:	e8 62 3f 00 00       	call   807853 <ntohl>
  8038f1:	89 c2                	mov    %eax,%edx
  8038f3:	89 d8                	mov    %ebx,%eax
  8038f5:	e8 31 f1 ff ff       	call   802a2b <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  8038fa:	89 d8                	mov    %ebx,%eax
  8038fc:	e8 75 f0 ff ff       	call   802976 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803901:	83 c4 08             	add    $0x8,%esp
  803904:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803908:	66 05 f0 00          	add    $0xf0,%ax
  80390c:	0f b7 c0             	movzwl %ax,%eax
  80390f:	50                   	push   %eax
  803910:	ff 73 1c             	pushl  0x1c(%ebx)
  803913:	e8 98 11 00 00       	call   804ab0 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803918:	83 c4 0c             	add    $0xc,%esp
  80391b:	6a 43                	push   $0x43
  80391d:	68 a4 1b 81 00       	push   $0x811ba4
  803922:	ff 73 08             	pushl  0x8(%ebx)
  803925:	e8 a2 54 00 00       	call   808dcc <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80392a:	89 34 24             	mov    %esi,(%esp)
  80392d:	6a 43                	push   $0x43
  80392f:	68 a0 1b 81 00       	push   $0x811ba0
  803934:	ff 73 1c             	pushl  0x1c(%ebx)
  803937:	ff 73 08             	pushl  0x8(%ebx)
  80393a:	e8 a7 52 00 00       	call   808be6 <udp_sendto_if>
    dhcp_delete_request(netif);
  80393f:	83 c4 20             	add    $0x20,%esp
  803942:	89 f0                	mov    %esi,%eax
  803944:	e8 5e f3 ff ff       	call   802ca7 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803949:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80394d:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  803953:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803956:	5b                   	pop    %ebx
  803957:	5e                   	pop    %esi
  803958:	5d                   	pop    %ebp
  803959:	c3                   	ret    

0080395a <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  80395a:	55                   	push   %ebp
  80395b:	89 e5                	mov    %esp,%ebp
  80395d:	57                   	push   %edi
  80395e:	56                   	push   %esi
  80395f:	53                   	push   %ebx
  803960:	83 ec 1c             	sub    $0x1c,%esp
  803963:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  803966:	8b 5f 20             	mov    0x20(%edi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803969:	ba 05 00 00 00       	mov    $0x5,%edx
  80396e:	89 d8                	mov    %ebx,%eax
  803970:	e8 b5 ed ff ff       	call   80272a <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803975:	89 f8                	mov    %edi,%eax
  803977:	e8 4a f1 ff ff       	call   802ac6 <dhcp_create_request>
  80397c:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  80397e:	84 c0                	test   %al,%al
  803980:	0f 85 89 00 00 00    	jne    803a0f <dhcp_renew+0xb5>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803986:	b9 01 00 00 00       	mov    $0x1,%ecx
  80398b:	ba 35 00 00 00       	mov    $0x35,%edx
  803990:	89 d8                	mov    %ebx,%eax
  803992:	e8 14 ef ff ff       	call   8028ab <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803997:	ba 03 00 00 00       	mov    $0x3,%edx
  80399c:	89 d8                	mov    %ebx,%eax
  80399e:	e8 c7 ee ff ff       	call   80286a <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8039a3:	b9 02 00 00 00       	mov    $0x2,%ecx
  8039a8:	ba 39 00 00 00       	mov    $0x39,%edx
  8039ad:	89 d8                	mov    %ebx,%eax
  8039af:	e8 f7 ee ff ff       	call   8028ab <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  8039b4:	ba 40 02 00 00       	mov    $0x240,%edx
  8039b9:	89 d8                	mov    %ebx,%eax
  8039bb:	e8 52 ef ff ff       	call   802912 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  8039c0:	89 d8                	mov    %ebx,%eax
  8039c2:	e8 af ef ff ff       	call   802976 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8039c7:	83 ec 08             	sub    $0x8,%esp
  8039ca:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8039ce:	66 05 f0 00          	add    $0xf0,%ax
  8039d2:	0f b7 c0             	movzwl %ax,%eax
  8039d5:	50                   	push   %eax
  8039d6:	ff 73 1c             	pushl  0x1c(%ebx)
  8039d9:	e8 d2 10 00 00       	call   804ab0 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  8039de:	8d 43 2c             	lea    0x2c(%ebx),%eax
  8039e1:	83 c4 0c             	add    $0xc,%esp
  8039e4:	6a 43                	push   $0x43
  8039e6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8039e9:	50                   	push   %eax
  8039ea:	ff 73 08             	pushl  0x8(%ebx)
  8039ed:	e8 da 53 00 00       	call   808dcc <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  8039f2:	89 3c 24             	mov    %edi,(%esp)
  8039f5:	6a 43                	push   $0x43
  8039f7:	ff 75 e4             	pushl  -0x1c(%ebp)
  8039fa:	ff 73 1c             	pushl  0x1c(%ebx)
  8039fd:	ff 73 08             	pushl  0x8(%ebx)
  803a00:	e8 e1 51 00 00       	call   808be6 <udp_sendto_if>
    dhcp_delete_request(netif);
  803a05:	83 c4 20             	add    $0x20,%esp
  803a08:	89 f8                	mov    %edi,%eax
  803a0a:	e8 98 f2 ff ff       	call   802ca7 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803a0f:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803a13:	83 c0 01             	add    $0x1,%eax
  803a16:	88 43 01             	mov    %al,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803a19:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  803a1e:	3c 09                	cmp    $0x9,%al
  803a20:	77 08                	ja     803a2a <dhcp_renew+0xd0>
  803a22:	0f b6 c0             	movzbl %al,%eax
  803a25:	66 69 d0 d0 07       	imul   $0x7d0,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803a2a:	0f b7 c2             	movzwl %dx,%eax
  803a2d:	05 f3 01 00 00       	add    $0x1f3,%eax
  803a32:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  803a37:	f7 ea                	imul   %edx
  803a39:	c1 fa 05             	sar    $0x5,%edx
  803a3c:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803a40:	89 f0                	mov    %esi,%eax
  803a42:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803a45:	5b                   	pop    %ebx
  803a46:	5e                   	pop    %esi
  803a47:	5f                   	pop    %edi
  803a48:	5d                   	pop    %ebp
  803a49:	c3                   	ret    

00803a4a <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  803a4a:	55                   	push   %ebp
  803a4b:	89 e5                	mov    %esp,%ebp
  803a4d:	53                   	push   %ebx
  803a4e:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803a51:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  803a57:	eb 6b                	jmp    803ac4 <dhcp_coarse_tmr+0x7a>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  803a59:	8b 43 20             	mov    0x20(%ebx),%eax
  803a5c:	85 c0                	test   %eax,%eax
  803a5e:	74 62                	je     803ac2 <dhcp_coarse_tmr+0x78>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  803a60:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803a64:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803a67:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803a6b:	66 83 fa 01          	cmp    $0x1,%dx
  803a6f:	75 1d                	jne    803a8e <dhcp_coarse_tmr+0x44>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803a71:	8b 43 20             	mov    0x20(%ebx),%eax
  803a74:	0f b6 00             	movzbl (%eax),%eax
  803a77:	89 c2                	mov    %eax,%edx
  803a79:	83 e2 fb             	and    $0xfffffffb,%edx
  803a7c:	80 fa 01             	cmp    $0x1,%dl
  803a7f:	74 04                	je     803a85 <dhcp_coarse_tmr+0x3b>
  803a81:	3c 0a                	cmp    $0xa,%al
  803a83:	75 3d                	jne    803ac2 <dhcp_coarse_tmr+0x78>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  803a85:	89 d8                	mov    %ebx,%eax
  803a87:	e8 b5 f2 ff ff       	call   802d41 <dhcp_rebind>
  803a8c:	eb 34                	jmp    803ac2 <dhcp_coarse_tmr+0x78>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803a8e:	8b 53 20             	mov    0x20(%ebx),%edx
  803a91:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803a95:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803a98:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803a9c:	66 83 f8 01          	cmp    $0x1,%ax
  803aa0:	75 20                	jne    803ac2 <dhcp_coarse_tmr+0x78>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803aa2:	8b 43 20             	mov    0x20(%ebx),%eax
  803aa5:	0f b6 00             	movzbl (%eax),%eax
  803aa8:	89 c2                	mov    %eax,%edx
  803aaa:	83 e2 fb             	and    $0xfffffffb,%edx
  803aad:	80 fa 01             	cmp    $0x1,%dl
  803ab0:	74 04                	je     803ab6 <dhcp_coarse_tmr+0x6c>
  803ab2:	3c 0a                	cmp    $0xa,%al
  803ab4:	75 0c                	jne    803ac2 <dhcp_coarse_tmr+0x78>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  803ab6:	83 ec 0c             	sub    $0xc,%esp
  803ab9:	53                   	push   %ebx
  803aba:	e8 9b fe ff ff       	call   80395a <dhcp_renew>
  803abf:	83 c4 10             	add    $0x10,%esp
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  803ac2:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  803ac4:	85 db                	test   %ebx,%ebx
  803ac6:	75 91                	jne    803a59 <dhcp_coarse_tmr+0xf>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  803ac8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803acb:	c9                   	leave  
  803acc:	c3                   	ret    

00803acd <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  803acd:	55                   	push   %ebp
  803ace:	89 e5                	mov    %esp,%ebp
  803ad0:	57                   	push   %edi
  803ad1:	56                   	push   %esi
  803ad2:	53                   	push   %ebx
  803ad3:	83 ec 1c             	sub    $0x1c,%esp
  803ad6:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803ad9:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  803adc:	ba 0d 00 00 00       	mov    $0xd,%edx
  803ae1:	89 d8                	mov    %ebx,%eax
  803ae3:	e8 42 ec ff ff       	call   80272a <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  803ae8:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803aef:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803af6:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803afd:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803b04:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803b0b:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803b12:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803b19:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803b20:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803b27:	89 f0                	mov    %esi,%eax
  803b29:	e8 98 ef ff ff       	call   802ac6 <dhcp_create_request>
  803b2e:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803b30:	84 c0                	test   %al,%al
  803b32:	75 6c                	jne    803ba0 <dhcp_release+0xd3>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803b34:	b9 01 00 00 00       	mov    $0x1,%ecx
  803b39:	ba 35 00 00 00       	mov    $0x35,%edx
  803b3e:	89 d8                	mov    %ebx,%eax
  803b40:	e8 66 ed ff ff       	call   8028ab <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803b45:	ba 07 00 00 00       	mov    $0x7,%edx
  803b4a:	89 d8                	mov    %ebx,%eax
  803b4c:	e8 19 ed ff ff       	call   80286a <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  803b51:	89 d8                	mov    %ebx,%eax
  803b53:	e8 1e ee ff ff       	call   802976 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803b58:	83 ec 08             	sub    $0x8,%esp
  803b5b:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803b5f:	66 05 f0 00          	add    $0xf0,%ax
  803b63:	0f b7 c0             	movzwl %ax,%eax
  803b66:	50                   	push   %eax
  803b67:	ff 73 1c             	pushl  0x1c(%ebx)
  803b6a:	e8 41 0f 00 00       	call   804ab0 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803b6f:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803b72:	83 c4 0c             	add    $0xc,%esp
  803b75:	6a 43                	push   $0x43
  803b77:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803b7a:	50                   	push   %eax
  803b7b:	ff 73 08             	pushl  0x8(%ebx)
  803b7e:	e8 49 52 00 00       	call   808dcc <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803b83:	89 34 24             	mov    %esi,(%esp)
  803b86:	6a 43                	push   $0x43
  803b88:	ff 75 e4             	pushl  -0x1c(%ebp)
  803b8b:	ff 73 1c             	pushl  0x1c(%ebx)
  803b8e:	ff 73 08             	pushl  0x8(%ebx)
  803b91:	e8 50 50 00 00       	call   808be6 <udp_sendto_if>
    dhcp_delete_request(netif);
  803b96:	83 c4 20             	add    $0x20,%esp
  803b99:	89 f0                	mov    %esi,%eax
  803b9b:	e8 07 f1 ff ff       	call   802ca7 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803ba0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803ba4:	83 c0 01             	add    $0x1,%eax
  803ba7:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803baa:	ba 10 27 00 00       	mov    $0x2710,%edx
  803baf:	3c 09                	cmp    $0x9,%al
  803bb1:	77 08                	ja     803bbb <dhcp_release+0xee>
  803bb3:	0f b6 c0             	movzbl %al,%eax
  803bb6:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803bbb:	0f b7 c2             	movzwl %dx,%eax
  803bbe:	05 f3 01 00 00       	add    $0x1f3,%eax
  803bc3:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  803bc8:	f7 ea                	imul   %edx
  803bca:	c1 fa 05             	sar    $0x5,%edx
  803bcd:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  803bd1:	83 ec 0c             	sub    $0xc,%esp
  803bd4:	56                   	push   %esi
  803bd5:	e8 96 0a 00 00       	call   804670 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803bda:	83 c4 08             	add    $0x8,%esp
  803bdd:	68 a4 1b 81 00       	push   $0x811ba4
  803be2:	56                   	push   %esi
  803be3:	e8 cc 08 00 00       	call   8044b4 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803be8:	83 c4 08             	add    $0x8,%esp
  803beb:	68 a4 1b 81 00       	push   $0x811ba4
  803bf0:	56                   	push   %esi
  803bf1:	e8 06 0a 00 00       	call   8045fc <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803bf6:	83 c4 08             	add    $0x8,%esp
  803bf9:	68 a4 1b 81 00       	push   $0x811ba4
  803bfe:	56                   	push   %esi
  803bff:	e8 13 0a 00 00       	call   804617 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  803c04:	89 f8                	mov    %edi,%eax
  803c06:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803c09:	5b                   	pop    %ebx
  803c0a:	5e                   	pop    %esi
  803c0b:	5f                   	pop    %edi
  803c0c:	5d                   	pop    %ebp
  803c0d:	c3                   	ret    

00803c0e <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  803c0e:	55                   	push   %ebp
  803c0f:	89 e5                	mov    %esp,%ebp
  803c11:	53                   	push   %ebx
  803c12:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803c15:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  803c1b:	e9 c6 00 00 00       	jmp    803ce6 <dhcp_fine_tmr+0xd8>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  803c20:	8b 53 20             	mov    0x20(%ebx),%edx
  803c23:	85 d2                	test   %edx,%edx
  803c25:	0f 84 b9 00 00 00    	je     803ce4 <dhcp_fine_tmr+0xd6>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  803c2b:	0f b7 42 26          	movzwl 0x26(%edx),%eax
  803c2f:	66 83 f8 01          	cmp    $0x1,%ax
  803c33:	76 0c                	jbe    803c41 <dhcp_fine_tmr+0x33>
        netif->dhcp->request_timeout--;
  803c35:	83 e8 01             	sub    $0x1,%eax
  803c38:	66 89 42 26          	mov    %ax,0x26(%edx)
  803c3c:	e9 a3 00 00 00       	jmp    803ce4 <dhcp_fine_tmr+0xd6>
      }
      else if (netif->dhcp->request_timeout == 1) {
  803c41:	66 83 f8 01          	cmp    $0x1,%ax
  803c45:	0f 85 99 00 00 00    	jne    803ce4 <dhcp_fine_tmr+0xd6>
        netif->dhcp->request_timeout--;
  803c4b:	66 c7 42 26 00 00    	movw   $0x0,0x26(%edx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803c51:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803c54:	0f b6 02             	movzbl (%edx),%eax
  803c57:	3c 0c                	cmp    $0xc,%al
  803c59:	74 04                	je     803c5f <dhcp_fine_tmr+0x51>
  803c5b:	3c 06                	cmp    $0x6,%al
  803c5d:	75 09                	jne    803c68 <dhcp_fine_tmr+0x5a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  803c5f:	89 d8                	mov    %ebx,%eax
  803c61:	e8 ca f1 ff ff       	call   802e30 <dhcp_discover>
  803c66:	eb 7c                	jmp    803ce4 <dhcp_fine_tmr+0xd6>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  803c68:	3c 01                	cmp    $0x1,%al
  803c6a:	75 24                	jne    803c90 <dhcp_fine_tmr+0x82>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  803c6c:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803c70:	77 09                	ja     803c7b <dhcp_fine_tmr+0x6d>
      dhcp_select(netif);
  803c72:	89 d8                	mov    %ebx,%eax
  803c74:	e8 f2 f2 ff ff       	call   802f6b <dhcp_select>
  803c79:	eb 69                	jmp    803ce4 <dhcp_fine_tmr+0xd6>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  803c7b:	83 ec 0c             	sub    $0xc,%esp
  803c7e:	53                   	push   %ebx
  803c7f:	e8 49 fe ff ff       	call   803acd <dhcp_release>
      dhcp_discover(netif);
  803c84:	89 d8                	mov    %ebx,%eax
  803c86:	e8 a5 f1 ff ff       	call   802e30 <dhcp_discover>
  803c8b:	83 c4 10             	add    $0x10,%esp
  803c8e:	eb 54                	jmp    803ce4 <dhcp_fine_tmr+0xd6>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  803c90:	3c 08                	cmp    $0x8,%al
  803c92:	75 18                	jne    803cac <dhcp_fine_tmr+0x9e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  803c94:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803c98:	77 09                	ja     803ca3 <dhcp_fine_tmr+0x95>
      dhcp_check(netif);
  803c9a:	89 d8                	mov    %ebx,%eax
  803c9c:	e8 42 f4 ff ff       	call   8030e3 <dhcp_check>
  803ca1:	eb 41                	jmp    803ce4 <dhcp_fine_tmr+0xd6>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  803ca3:	89 d8                	mov    %ebx,%eax
  803ca5:	e8 6d f4 ff ff       	call   803117 <dhcp_bind>
  803caa:	eb 38                	jmp    803ce4 <dhcp_fine_tmr+0xd6>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  803cac:	3c 05                	cmp    $0x5,%al
  803cae:	75 0e                	jne    803cbe <dhcp_fine_tmr+0xb0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  803cb0:	83 ec 0c             	sub    $0xc,%esp
  803cb3:	53                   	push   %ebx
  803cb4:	e8 a1 fc ff ff       	call   80395a <dhcp_renew>
  803cb9:	83 c4 10             	add    $0x10,%esp
  803cbc:	eb 26                	jmp    803ce4 <dhcp_fine_tmr+0xd6>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  803cbe:	3c 04                	cmp    $0x4,%al
  803cc0:	75 22                	jne    803ce4 <dhcp_fine_tmr+0xd6>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  803cc2:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803cc6:	77 09                	ja     803cd1 <dhcp_fine_tmr+0xc3>
      dhcp_rebind(netif);
  803cc8:	89 d8                	mov    %ebx,%eax
  803cca:	e8 72 f0 ff ff       	call   802d41 <dhcp_rebind>
  803ccf:	eb 13                	jmp    803ce4 <dhcp_fine_tmr+0xd6>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  803cd1:	83 ec 0c             	sub    $0xc,%esp
  803cd4:	53                   	push   %ebx
  803cd5:	e8 f3 fd ff ff       	call   803acd <dhcp_release>
      dhcp_discover(netif);
  803cda:	89 d8                	mov    %ebx,%eax
  803cdc:	e8 4f f1 ff ff       	call   802e30 <dhcp_discover>
  803ce1:	83 c4 10             	add    $0x10,%esp
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  803ce4:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  803ce6:	85 db                	test   %ebx,%ebx
  803ce8:	0f 85 32 ff ff ff    	jne    803c20 <dhcp_fine_tmr+0x12>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  803cee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803cf1:	c9                   	leave  
  803cf2:	c3                   	ret    

00803cf3 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  803cf3:	55                   	push   %ebp
  803cf4:	89 e5                	mov    %esp,%ebp
  803cf6:	56                   	push   %esi
  803cf7:	53                   	push   %ebx
  803cf8:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803cfb:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  803cfe:	85 f6                	test   %esi,%esi
  803d00:	75 17                	jne    803d19 <dhcp_stop+0x26>
  803d02:	83 ec 04             	sub    $0x4,%esp
  803d05:	68 54 13 81 00       	push   $0x811354
  803d0a:	68 2c 04 00 00       	push   $0x42c
  803d0f:	68 e2 12 81 00       	push   $0x8112e2
  803d14:	e8 75 a6 00 00       	call   80e38e <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  803d19:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  803d1d:	85 db                	test   %ebx,%ebx
  803d1f:	74 4e                	je     803d6f <dhcp_stop+0x7c>
    if (dhcp->pcb != NULL) {
  803d21:	8b 43 08             	mov    0x8(%ebx),%eax
  803d24:	85 c0                	test   %eax,%eax
  803d26:	74 13                	je     803d3b <dhcp_stop+0x48>
      udp_remove(dhcp->pcb);
  803d28:	83 ec 0c             	sub    $0xc,%esp
  803d2b:	50                   	push   %eax
  803d2c:	e8 3b 51 00 00       	call   808e6c <udp_remove>
      dhcp->pcb = NULL;
  803d31:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  803d38:	83 c4 10             	add    $0x10,%esp
    }
    if (dhcp->p != NULL) {
  803d3b:	8b 43 0c             	mov    0xc(%ebx),%eax
  803d3e:	85 c0                	test   %eax,%eax
  803d40:	74 13                	je     803d55 <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  803d42:	83 ec 0c             	sub    $0xc,%esp
  803d45:	50                   	push   %eax
  803d46:	e8 1c 0a 00 00       	call   804767 <pbuf_free>
      dhcp->p = NULL;
  803d4b:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  803d52:	83 c4 10             	add    $0x10,%esp
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  803d55:	89 d8                	mov    %ebx,%eax
  803d57:	e8 46 f5 ff ff       	call   8032a2 <dhcp_free_reply>
    mem_free((void *)dhcp);
  803d5c:	83 ec 0c             	sub    $0xc,%esp
  803d5f:	53                   	push   %ebx
  803d60:	e8 60 01 00 00       	call   803ec5 <mem_free>
    netif->dhcp = NULL;
  803d65:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803d6c:	83 c4 10             	add    $0x10,%esp
  }
}
  803d6f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803d72:	5b                   	pop    %ebx
  803d73:	5e                   	pop    %esi
  803d74:	5d                   	pop    %ebp
  803d75:	c3                   	ret    

00803d76 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  803d76:	55                   	push   %ebp
  803d77:	89 e5                	mov    %esp,%ebp
  803d79:	56                   	push   %esi
  803d7a:	53                   	push   %ebx
  803d7b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803d7e:	85 db                	test   %ebx,%ebx
  803d80:	75 17                	jne    803d99 <dhcp_start+0x23>
  803d82:	83 ec 04             	sub    $0x4,%esp
  803d85:	68 02 13 81 00       	push   $0x811302
  803d8a:	68 38 02 00 00       	push   $0x238
  803d8f:	68 e2 12 81 00       	push   $0x8112e2
  803d94:	e8 f5 a5 00 00       	call   80e38e <_panic>
  dhcp = netif->dhcp;
  803d99:	8b 73 20             	mov    0x20(%ebx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  803d9c:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  803da0:	85 f6                	test   %esi,%esi
  803da2:	75 1a                	jne    803dbe <dhcp_start+0x48>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  803da4:	83 ec 0c             	sub    $0xc,%esp
  803da7:	6a 58                	push   $0x58
  803da9:	e8 c9 03 00 00       	call   804177 <mem_malloc>
  803dae:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  803db0:	83 c4 10             	add    $0x10,%esp
  803db3:	85 c0                	test   %eax,%eax
  803db5:	0f 84 98 00 00 00    	je     803e53 <dhcp_start+0xdd>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  803dbb:	89 43 20             	mov    %eax,0x20(%ebx)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  803dbe:	83 ec 04             	sub    $0x4,%esp
  803dc1:	6a 58                	push   $0x58
  803dc3:	6a 00                	push   $0x0
  803dc5:	56                   	push   %esi
  803dc6:	e8 66 ad 00 00       	call   80eb31 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  803dcb:	e8 e0 50 00 00       	call   808eb0 <udp_new>
  803dd0:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803dd3:	83 c4 10             	add    $0x10,%esp
  803dd6:	85 c0                	test   %eax,%eax
  803dd8:	75 1a                	jne    803df4 <dhcp_start+0x7e>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  803dda:	83 ec 0c             	sub    $0xc,%esp
  803ddd:	56                   	push   %esi
  803dde:	e8 e2 00 00 00       	call   803ec5 <mem_free>
    netif->dhcp = dhcp = NULL;
  803de3:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  803dea:	83 c4 10             	add    $0x10,%esp
  803ded:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803df2:	eb 64                	jmp    803e58 <dhcp_start+0xe2>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803df4:	83 ec 04             	sub    $0x4,%esp
  803df7:	6a 44                	push   $0x44
  803df9:	68 a4 1b 81 00       	push   $0x811ba4
  803dfe:	50                   	push   %eax
  803dff:	e8 26 4d 00 00       	call   808b2a <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803e04:	83 c4 0c             	add    $0xc,%esp
  803e07:	6a 43                	push   $0x43
  803e09:	68 a4 1b 81 00       	push   $0x811ba4
  803e0e:	ff 76 08             	pushl  0x8(%esi)
  803e11:	e8 b6 4f 00 00       	call   808dcc <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803e16:	83 c4 0c             	add    $0xc,%esp
  803e19:	53                   	push   %ebx
  803e1a:	68 ea 32 80 00       	push   $0x8032ea
  803e1f:	ff 76 08             	pushl  0x8(%esi)
  803e22:	e8 31 50 00 00       	call   808e58 <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  803e27:	89 d8                	mov    %ebx,%eax
  803e29:	e8 02 f0 ff ff       	call   802e30 <dhcp_discover>
  if (result != ERR_OK) {
  803e2e:	83 c4 10             	add    $0x10,%esp
  803e31:	84 c0                	test   %al,%al
  803e33:	74 13                	je     803e48 <dhcp_start+0xd2>
    /* free resources allocated above */
    dhcp_stop(netif);
  803e35:	83 ec 0c             	sub    $0xc,%esp
  803e38:	53                   	push   %ebx
  803e39:	e8 b5 fe ff ff       	call   803cf3 <dhcp_stop>
    return ERR_MEM;
  803e3e:	83 c4 10             	add    $0x10,%esp
  803e41:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803e46:	eb 10                	jmp    803e58 <dhcp_start+0xe2>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  803e48:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
  return result;
  803e4c:	b8 00 00 00 00       	mov    $0x0,%eax
  803e51:	eb 05                	jmp    803e58 <dhcp_start+0xe2>
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
    if (dhcp == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  803e53:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  return result;
}
  803e58:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803e5b:	5b                   	pop    %ebx
  803e5c:	5e                   	pop    %esi
  803e5d:	5d                   	pop    %ebp
  803e5e:	c3                   	ret    

00803e5f <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  803e5f:	55                   	push   %ebp
  803e60:	89 e5                	mov    %esp,%ebp
  803e62:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  803e65:	b8 23 53 81 00       	mov    $0x815323,%eax
  803e6a:	83 e0 fc             	and    $0xfffffffc,%eax
  803e6d:	a3 0c 53 81 00       	mov    %eax,0x81530c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  803e72:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  803e78:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  803e7f:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  803e83:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  803e89:	89 15 08 53 81 00    	mov    %edx,0x815308
  ram_end->used = 1;
  803e8f:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  803e96:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  803e9d:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  803ea0:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  803ea7:	00 22 00 

  mem_sem = sys_sem_new(1);
  803eaa:	6a 01                	push   $0x1
  803eac:	e8 bd 5d 00 00       	call   809c6e <sys_sem_new>
  803eb1:	a3 00 53 81 00       	mov    %eax,0x815300

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  803eb6:	a1 0c 53 81 00       	mov    0x81530c,%eax
  803ebb:	a3 04 53 81 00       	mov    %eax,0x815304

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  803ec0:	83 c4 10             	add    $0x10,%esp
  803ec3:	c9                   	leave  
  803ec4:	c3                   	ret    

00803ec5 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  803ec5:	55                   	push   %ebp
  803ec6:	89 e5                	mov    %esp,%ebp
  803ec8:	56                   	push   %esi
  803ec9:	53                   	push   %ebx
  803eca:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  803ecd:	85 db                	test   %ebx,%ebx
  803ecf:	0f 84 52 01 00 00    	je     804027 <mem_free+0x162>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  803ed5:	f6 c3 03             	test   $0x3,%bl
  803ed8:	74 17                	je     803ef1 <mem_free+0x2c>
  803eda:	83 ec 04             	sub    $0x4,%esp
  803edd:	68 70 13 81 00       	push   $0x811370
  803ee2:	68 30 01 00 00       	push   $0x130
  803ee7:	68 67 14 81 00       	push   $0x811467
  803eec:	e8 9d a4 00 00       	call   80e38e <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  803ef1:	3b 1d 0c 53 81 00    	cmp    0x81530c,%ebx
  803ef7:	72 08                	jb     803f01 <mem_free+0x3c>
  803ef9:	3b 1d 08 53 81 00    	cmp    0x815308,%ebx
  803eff:	72 17                	jb     803f18 <mem_free+0x53>
  803f01:	83 ec 04             	sub    $0x4,%esp
  803f04:	68 7b 14 81 00       	push   $0x81147b
  803f09:	68 33 01 00 00       	push   $0x133
  803f0e:	68 67 14 81 00       	push   $0x811467
  803f13:	e8 76 a4 00 00       	call   80e38e <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  803f18:	83 ec 08             	sub    $0x8,%esp
  803f1b:	6a 00                	push   $0x0
  803f1d:	ff 35 00 53 81 00    	pushl  0x815300
  803f23:	e8 60 60 00 00       	call   809f88 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  803f28:	83 c4 10             	add    $0x10,%esp
  803f2b:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  803f2f:	75 17                	jne    803f48 <mem_free+0x83>
  803f31:	83 ec 04             	sub    $0x4,%esp
  803f34:	68 92 14 81 00       	push   $0x811492
  803f39:	68 43 01 00 00       	push   $0x143
  803f3e:	68 67 14 81 00       	push   $0x811467
  803f43:	e8 46 a4 00 00       	call   80e38e <_panic>
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  803f48:	8d 53 f4             	lea    -0xc(%ebx),%edx
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
  803f4b:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  803f4f:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  803f55:	73 06                	jae    803f5d <mem_free+0x98>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  803f57:	89 15 04 53 81 00    	mov    %edx,0x815304
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  803f5d:	8b 0d 0c 53 81 00    	mov    0x81530c,%ecx
  803f63:	39 ca                	cmp    %ecx,%edx
  803f65:	73 17                	jae    803f7e <mem_free+0xb9>
  803f67:	83 ec 04             	sub    $0x4,%esp
  803f6a:	68 a6 14 81 00       	push   $0x8114a6
  803f6f:	68 e3 00 00 00       	push   $0xe3
  803f74:	68 67 14 81 00       	push   $0x811467
  803f79:	e8 10 a4 00 00       	call   80e38e <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  803f7e:	8b 35 08 53 81 00    	mov    0x815308,%esi
  803f84:	39 f2                	cmp    %esi,%edx
  803f86:	72 17                	jb     803f9f <mem_free+0xda>
  803f88:	83 ec 04             	sub    $0x4,%esp
  803f8b:	68 bd 14 81 00       	push   $0x8114bd
  803f90:	68 e4 00 00 00       	push   $0xe4
  803f95:	68 67 14 81 00       	push   $0x811467
  803f9a:	e8 ef a3 00 00       	call   80e38e <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  803f9f:	8b 43 f4             	mov    -0xc(%ebx),%eax
  803fa2:	3d 00 00 22 00       	cmp    $0x220000,%eax
  803fa7:	76 17                	jbe    803fc0 <mem_free+0xfb>
  803fa9:	83 ec 04             	sub    $0x4,%esp
  803fac:	68 94 13 81 00       	push   $0x811394
  803fb1:	68 e8 00 00 00       	push   $0xe8
  803fb6:	68 67 14 81 00       	push   $0x811467
  803fbb:	e8 ce a3 00 00       	call   80e38e <_panic>

  nmem = (struct mem *)&ram[mem->next];
  803fc0:	01 c8                	add    %ecx,%eax
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  803fc2:	39 c2                	cmp    %eax,%edx
  803fc4:	74 27                	je     803fed <mem_free+0x128>
  803fc6:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  803fca:	75 21                	jne    803fed <mem_free+0x128>
  803fcc:	39 c6                	cmp    %eax,%esi
  803fce:	74 1d                	je     803fed <mem_free+0x128>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  803fd0:	3b 05 04 53 81 00    	cmp    0x815304,%eax
  803fd6:	75 06                	jne    803fde <mem_free+0x119>
      lfree = mem;
  803fd8:	89 15 04 53 81 00    	mov    %edx,0x815304
    }
    mem->next = nmem->next;
  803fde:	8b 30                	mov    (%eax),%esi
  803fe0:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  803fe3:	8b 00                	mov    (%eax),%eax
  803fe5:	89 d6                	mov    %edx,%esi
  803fe7:	29 ce                	sub    %ecx,%esi
  803fe9:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  803fed:	8b 73 f8             	mov    -0x8(%ebx),%esi
  803ff0:	8d 04 31             	lea    (%ecx,%esi,1),%eax
  if (pmem != mem && pmem->used == 0) {
  803ff3:	39 c2                	cmp    %eax,%edx
  803ff5:	74 1f                	je     804016 <mem_free+0x151>
  803ff7:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  803ffb:	75 19                	jne    804016 <mem_free+0x151>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  803ffd:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  804003:	75 05                	jne    80400a <mem_free+0x145>
      lfree = pmem;
  804005:	a3 04 53 81 00       	mov    %eax,0x815304
    }
    pmem->next = mem->next;
  80400a:	8b 53 f4             	mov    -0xc(%ebx),%edx
  80400d:	89 10                	mov    %edx,(%eax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  80400f:	8b 43 f4             	mov    -0xc(%ebx),%eax
  804012:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  804016:	83 ec 0c             	sub    $0xc,%esp
  804019:	ff 35 00 53 81 00    	pushl  0x815300
  80401f:	e8 f6 5e 00 00       	call   809f1a <sys_sem_signal>
  804024:	83 c4 10             	add    $0x10,%esp
}
  804027:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80402a:	5b                   	pop    %ebx
  80402b:	5e                   	pop    %esi
  80402c:	5d                   	pop    %ebp
  80402d:	c3                   	ret    

0080402e <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80402e:	55                   	push   %ebp
  80402f:	89 e5                	mov    %esp,%ebp
  804031:	57                   	push   %edi
  804032:	56                   	push   %esi
  804033:	53                   	push   %ebx
  804034:	83 ec 1c             	sub    $0x1c,%esp
  804037:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80403a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80403d:	8d 58 03             	lea    0x3(%eax),%ebx
  804040:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  804043:	83 fb 0b             	cmp    $0xb,%ebx
  804046:	76 0d                	jbe    804055 <mem_realloc+0x27>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  804048:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  80404e:	76 0a                	jbe    80405a <mem_realloc+0x2c>
  804050:	e9 15 01 00 00       	jmp    80416a <mem_realloc+0x13c>
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  804055:	bb 0c 00 00 00       	mov    $0xc,%ebx

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80405a:	a1 0c 53 81 00       	mov    0x81530c,%eax
  80405f:	39 f0                	cmp    %esi,%eax
  804061:	77 08                	ja     80406b <mem_realloc+0x3d>
  804063:	3b 35 08 53 81 00    	cmp    0x815308,%esi
  804069:	72 17                	jb     804082 <mem_realloc+0x54>
  80406b:	83 ec 04             	sub    $0x4,%esp
  80406e:	68 d7 14 81 00       	push   $0x8114d7
  804073:	68 79 01 00 00       	push   $0x179
  804078:	68 67 14 81 00       	push   $0x811467
  80407d:	e8 0c a3 00 00       	call   80e38e <_panic>
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  804082:	8d 56 f4             	lea    -0xc(%esi),%edx
  804085:	29 c2                	sub    %eax,%edx
  804087:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80408a:	8b 46 f4             	mov    -0xc(%esi),%eax
  80408d:	8d 78 f4             	lea    -0xc(%eax),%edi
  804090:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804092:	39 df                	cmp    %ebx,%edi
  804094:	73 17                	jae    8040ad <mem_realloc+0x7f>
  804096:	83 ec 04             	sub    $0x4,%esp
  804099:	68 c0 13 81 00       	push   $0x8113c0
  80409e:	68 8a 01 00 00       	push   $0x18a
  8040a3:	68 67 14 81 00       	push   $0x811467
  8040a8:	e8 e1 a2 00 00       	call   80e38e <_panic>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
    /* No change in size, simply return */
    return rmem;
  8040ad:	89 f0                	mov    %esi,%eax
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  8040af:	39 df                	cmp    %ebx,%edi
  8040b1:	0f 84 b8 00 00 00    	je     80416f <mem_realloc+0x141>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8040b7:	83 ec 08             	sub    $0x8,%esp
  8040ba:	6a 00                	push   $0x0
  8040bc:	ff 35 00 53 81 00    	pushl  0x815300
  8040c2:	e8 c1 5e 00 00       	call   809f88 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  8040c7:	a1 0c 53 81 00       	mov    0x81530c,%eax
  8040cc:	89 c2                	mov    %eax,%edx
  8040ce:	03 56 f4             	add    -0xc(%esi),%edx
  if(mem2->used == 0) {
  8040d1:	83 c4 10             	add    $0x10,%esp
  8040d4:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8040d8:	75 3c                	jne    804116 <mem_realloc+0xe8>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  8040da:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8040dc:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8040df:	8d 5c 3b 0c          	lea    0xc(%ebx,%edi,1),%ebx
    if (lfree == mem2) {
  8040e3:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  8040e9:	75 09                	jne    8040f4 <mem_realloc+0xc6>
      lfree = (struct mem *)&ram[ptr2];
  8040eb:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  8040ee:	89 15 04 53 81 00    	mov    %edx,0x815304
    }
    mem2 = (struct mem *)&ram[ptr2];
  8040f4:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  8040f7:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  8040fb:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  8040fd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  804100:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  804103:	89 5e f4             	mov    %ebx,-0xc(%esi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804106:	8b 12                	mov    (%edx),%edx
  804108:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80410e:	74 45                	je     804155 <mem_realloc+0x127>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804110:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
  804114:	eb 3f                	jmp    804155 <mem_realloc+0x127>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  804116:	8d 53 18             	lea    0x18(%ebx),%edx
  804119:	39 d7                	cmp    %edx,%edi
  80411b:	72 38                	jb     804155 <mem_realloc+0x127>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80411d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  804120:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  804124:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  804127:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  80412d:	73 06                	jae    804135 <mem_realloc+0x107>
      lfree = mem2;
  80412f:	89 15 04 53 81 00    	mov    %edx,0x815304
    }
    mem2->used = 0;
  804135:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  804139:	8b 5e f4             	mov    -0xc(%esi),%ebx
  80413c:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  80413e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804141:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  804144:	89 4e f4             	mov    %ecx,-0xc(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804147:	8b 12                	mov    (%edx),%edx
  804149:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80414f:	74 04                	je     804155 <mem_realloc+0x127>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804151:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  804155:	83 ec 0c             	sub    $0xc,%esp
  804158:	ff 35 00 53 81 00    	pushl  0x815300
  80415e:	e8 b7 5d 00 00       	call   809f1a <sys_sem_signal>
  return rmem;
  804163:	83 c4 10             	add    $0x10,%esp
  804166:	89 f0                	mov    %esi,%eax
  804168:	eb 05                	jmp    80416f <mem_realloc+0x141>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  80416a:	b8 00 00 00 00       	mov    $0x0,%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
  80416f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804172:	5b                   	pop    %ebx
  804173:	5e                   	pop    %esi
  804174:	5f                   	pop    %edi
  804175:	5d                   	pop    %ebp
  804176:	c3                   	ret    

00804177 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  804177:	55                   	push   %ebp
  804178:	89 e5                	mov    %esp,%ebp
  80417a:	57                   	push   %edi
  80417b:	56                   	push   %esi
  80417c:	53                   	push   %ebx
  80417d:	83 ec 1c             	sub    $0x1c,%esp
  804180:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  804183:	85 f6                	test   %esi,%esi
  804185:	0f 84 72 01 00 00    	je     8042fd <mem_malloc+0x186>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  80418b:	83 c6 03             	add    $0x3,%esi
  80418e:	83 e6 fc             	and    $0xfffffffc,%esi

  if(size < MIN_SIZE_ALIGNED) {
  804191:	83 fe 0b             	cmp    $0xb,%esi
  804194:	76 0d                	jbe    8041a3 <mem_malloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  804196:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  80419c:	76 0a                	jbe    8041a8 <mem_malloc+0x31>
  80419e:	e9 61 01 00 00       	jmp    804304 <mem_malloc+0x18d>
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  8041a3:	be 0c 00 00 00       	mov    $0xc,%esi
  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  8041a8:	83 ec 08             	sub    $0x8,%esp
  8041ab:	6a 00                	push   $0x0
  8041ad:	ff 35 00 53 81 00    	pushl  0x815300
  8041b3:	e8 d0 5d 00 00       	call   809f88 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  8041b8:	8b 15 0c 53 81 00    	mov    0x81530c,%edx
  8041be:	a1 04 53 81 00       	mov    0x815304,%eax
  8041c3:	29 d0                	sub    %edx,%eax
  8041c5:	83 c4 10             	add    $0x10,%esp
  8041c8:	bf 00 00 22 00       	mov    $0x220000,%edi
  8041cd:	29 f7                	sub    %esi,%edi
  8041cf:	e9 09 01 00 00       	jmp    8042dd <mem_malloc+0x166>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  8041d4:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  8041d7:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  8041db:	0f 85 fa 00 00 00    	jne    8042db <mem_malloc+0x164>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  8041e1:	8b 0b                	mov    (%ebx),%ecx
  8041e3:	83 e9 0c             	sub    $0xc,%ecx
  8041e6:	29 c1                	sub    %eax,%ecx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  8041e8:	39 f1                	cmp    %esi,%ecx
  8041ea:	0f 82 eb 00 00 00    	jb     8042db <mem_malloc+0x164>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  8041f0:	8d 7e 18             	lea    0x18(%esi),%edi
  8041f3:	39 f9                	cmp    %edi,%ecx
  8041f5:	72 2d                	jb     804224 <mem_malloc+0xad>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  8041f7:	8d 7c 30 0c          	lea    0xc(%eax,%esi,1),%edi
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  8041fb:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  8041fe:	8d 0c 3a             	lea    (%edx,%edi,1),%ecx
          mem2->used = 0;
  804201:	c6 41 08 00          	movb   $0x0,0x8(%ecx)
          mem2->next = mem->next;
  804205:	8b 3b                	mov    (%ebx),%edi
  804207:	89 39                	mov    %edi,(%ecx)
          mem2->prev = ptr;
  804209:	89 41 04             	mov    %eax,0x4(%ecx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  80420c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80420f:	89 3b                	mov    %edi,(%ebx)
          mem->used = 1;
  804211:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  804215:	8b 01                	mov    (%ecx),%eax
  804217:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80421c:	74 0a                	je     804228 <mem_malloc+0xb1>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80421e:	89 7c 02 04          	mov    %edi,0x4(%edx,%eax,1)
  804222:	eb 04                	jmp    804228 <mem_malloc+0xb1>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  804224:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  804228:	a1 04 53 81 00       	mov    0x815304,%eax
  80422d:	39 c3                	cmp    %eax,%ebx
  80422f:	75 3c                	jne    80426d <mem_malloc+0xf6>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  804231:	8b 0d 08 53 81 00    	mov    0x815308,%ecx
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  804237:	8b 3d 0c 53 81 00    	mov    0x81530c,%edi
  80423d:	ba 00 00 00 00       	mov    $0x0,%edx
  804242:	eb 0b                	jmp    80424f <mem_malloc+0xd8>
  804244:	89 fa                	mov    %edi,%edx
  804246:	03 10                	add    (%eax),%edx
  804248:	89 d0                	mov    %edx,%eax
  80424a:	ba 01 00 00 00       	mov    $0x1,%edx
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80424f:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  804253:	75 0b                	jne    804260 <mem_malloc+0xe9>
  804255:	84 d2                	test   %dl,%dl
  804257:	74 14                	je     80426d <mem_malloc+0xf6>
  804259:	a3 04 53 81 00       	mov    %eax,0x815304
  80425e:	eb 0d                	jmp    80426d <mem_malloc+0xf6>
  804260:	39 c1                	cmp    %eax,%ecx
  804262:	75 e0                	jne    804244 <mem_malloc+0xcd>
  804264:	84 d2                	test   %dl,%dl
  804266:	74 05                	je     80426d <mem_malloc+0xf6>
  804268:	a3 04 53 81 00       	mov    %eax,0x815304
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80426d:	83 ec 0c             	sub    $0xc,%esp
  804270:	ff 35 00 53 81 00    	pushl  0x815300
  804276:	e8 9f 5c 00 00       	call   809f1a <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80427b:	8d 44 33 0c          	lea    0xc(%ebx,%esi,1),%eax
  80427f:	83 c4 10             	add    $0x10,%esp
  804282:	39 05 08 53 81 00    	cmp    %eax,0x815308
  804288:	73 17                	jae    8042a1 <mem_malloc+0x12a>
  80428a:	83 ec 04             	sub    $0x4,%esp
  80428d:	68 e4 13 81 00       	push   $0x8113e4
  804292:	68 4b 02 00 00       	push   $0x24b
  804297:	68 67 14 81 00       	push   $0x811467
  80429c:	e8 ed a0 00 00       	call   80e38e <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  8042a1:	8d 43 0c             	lea    0xc(%ebx),%eax
  8042a4:	a8 03                	test   $0x3,%al
  8042a6:	74 17                	je     8042bf <mem_malloc+0x148>
  8042a8:	83 ec 04             	sub    $0x4,%esp
  8042ab:	68 14 14 81 00       	push   $0x811414
  8042b0:	68 4d 02 00 00       	push   $0x24d
  8042b5:	68 67 14 81 00       	push   $0x811467
  8042ba:	e8 cf a0 00 00       	call   80e38e <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  8042bf:	f6 c3 03             	test   $0x3,%bl
  8042c2:	74 45                	je     804309 <mem_malloc+0x192>
  8042c4:	83 ec 04             	sub    $0x4,%esp
  8042c7:	68 44 14 81 00       	push   $0x811444
  8042cc:	68 4f 02 00 00       	push   $0x24f
  8042d1:	68 67 14 81 00       	push   $0x811467
  8042d6:	e8 b3 a0 00 00       	call   80e38e <_panic>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  8042db:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  8042dd:	39 f8                	cmp    %edi,%eax
  8042df:	0f 82 ef fe ff ff    	jb     8041d4 <mem_malloc+0x5d>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  8042e5:	83 ec 0c             	sub    $0xc,%esp
  8042e8:	ff 35 00 53 81 00    	pushl  0x815300
  8042ee:	e8 27 5c 00 00       	call   809f1a <sys_sem_signal>
  return NULL;
  8042f3:	83 c4 10             	add    $0x10,%esp
  8042f6:	b8 00 00 00 00       	mov    $0x0,%eax
  8042fb:	eb 0c                	jmp    804309 <mem_malloc+0x192>
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
  8042fd:	b8 00 00 00 00       	mov    $0x0,%eax
  804302:	eb 05                	jmp    804309 <mem_malloc+0x192>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  804304:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
}
  804309:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80430c:	5b                   	pop    %ebx
  80430d:	5e                   	pop    %esi
  80430e:	5f                   	pop    %edi
  80430f:	5d                   	pop    %ebp
  804310:	c3                   	ret    

00804311 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  804311:	55                   	push   %ebp
  804312:	89 e5                	mov    %esp,%ebp
  804314:	56                   	push   %esi
  804315:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  804316:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  804319:	0f af 5d 08          	imul   0x8(%ebp),%ebx
  80431d:	83 ec 0c             	sub    $0xc,%esp
  804320:	53                   	push   %ebx
  804321:	e8 51 fe ff ff       	call   804177 <mem_malloc>
  804326:	89 c6                	mov    %eax,%esi
  if (p) {
  804328:	83 c4 10             	add    $0x10,%esp
  80432b:	85 c0                	test   %eax,%eax
  80432d:	74 0f                	je     80433e <mem_calloc+0x2d>
    /* zero the memory */
    memset(p, 0, count * size);
  80432f:	83 ec 04             	sub    $0x4,%esp
  804332:	53                   	push   %ebx
  804333:	6a 00                	push   $0x0
  804335:	50                   	push   %eax
  804336:	e8 f6 a7 00 00       	call   80eb31 <memset>
  80433b:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  80433e:	89 f0                	mov    %esi,%eax
  804340:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804343:	5b                   	pop    %ebx
  804344:	5e                   	pop    %esi
  804345:	5d                   	pop    %ebp
  804346:	c3                   	ret    

00804347 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  804347:	55                   	push   %ebp
  804348:	89 e5                	mov    %esp,%ebp
  80434a:	57                   	push   %edi
  80434b:	56                   	push   %esi
  80434c:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80434d:	b8 43 53 a3 00       	mov    $0xa35343,%eax
  804352:	83 e0 fc             	and    $0xfffffffc,%eax
  804355:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  80435a:	c7 84 12 c0 43 b3 00 	movl   $0x0,0xb343c0(%edx,%edx,1)
  804361:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804365:	0f b7 b2 68 15 81 00 	movzwl 0x811568(%edx),%esi
  80436c:	b9 00 00 00 00       	mov    $0x0,%ecx
  804371:	eb 19                	jmp    80438c <memp_init+0x45>
      memp->next = memp_tab[i];
  804373:	bb c0 43 b3 00       	mov    $0xb343c0,%ebx
  804378:	8b 3c 53             	mov    (%ebx,%edx,2),%edi
  80437b:	89 38                	mov    %edi,(%eax)
      memp_tab[i] = memp;
  80437d:	89 04 53             	mov    %eax,(%ebx,%edx,2)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  804380:	0f b7 9a 84 15 81 00 	movzwl 0x811584(%edx),%ebx
  804387:	01 d8                	add    %ebx,%eax
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804389:	83 c1 01             	add    $0x1,%ecx
  80438c:	66 39 f1             	cmp    %si,%cx
  80438f:	75 e2                	jne    804373 <memp_init+0x2c>
  804391:	83 c2 02             	add    $0x2,%edx
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  804394:	83 fa 1c             	cmp    $0x1c,%edx
  804397:	75 c1                	jne    80435a <memp_init+0x13>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  804399:	5b                   	pop    %ebx
  80439a:	5e                   	pop    %esi
  80439b:	5f                   	pop    %edi
  80439c:	5d                   	pop    %ebp
  80439d:	c3                   	ret    

0080439e <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80439e:	55                   	push   %ebp
  80439f:	89 e5                	mov    %esp,%ebp
  8043a1:	83 ec 08             	sub    $0x8,%esp
  8043a4:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  8043a7:	83 fa 0d             	cmp    $0xd,%edx
  8043aa:	76 17                	jbe    8043c3 <memp_malloc+0x25>
  8043ac:	83 ec 04             	sub    $0x4,%esp
  8043af:	68 f1 14 81 00       	push   $0x8114f1
  8043b4:	68 2d 01 00 00       	push   $0x12d
  8043b9:	68 0e 15 81 00       	push   $0x81150e
  8043be:	e8 cb 9f 00 00       	call   80e38e <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  8043c3:	8b 04 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%eax
  
  if (memp != NULL) {    
  8043ca:	85 c0                	test   %eax,%eax
  8043cc:	74 24                	je     8043f2 <memp_malloc+0x54>
    memp_tab[type] = memp->next;    
  8043ce:	8b 08                	mov    (%eax),%ecx
  8043d0:	89 0c 95 c0 43 b3 00 	mov    %ecx,0xb343c0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  8043d7:	a8 03                	test   $0x3,%al
  8043d9:	74 17                	je     8043f2 <memp_malloc+0x54>
  8043db:	83 ec 04             	sub    $0x4,%esp
  8043de:	68 24 15 81 00       	push   $0x811524
  8043e3:	68 3f 01 00 00       	push   $0x13f
  8043e8:	68 0e 15 81 00       	push   $0x81150e
  8043ed:	e8 9c 9f 00 00       	call   80e38e <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  8043f2:	c9                   	leave  
  8043f3:	c3                   	ret    

008043f4 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8043f4:	55                   	push   %ebp
  8043f5:	89 e5                	mov    %esp,%ebp
  8043f7:	83 ec 08             	sub    $0x8,%esp
  8043fa:	8b 55 08             	mov    0x8(%ebp),%edx
  8043fd:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  804400:	85 c0                	test   %eax,%eax
  804402:	74 2b                	je     80442f <memp_free+0x3b>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  804404:	a8 03                	test   $0x3,%al
  804406:	74 17                	je     80441f <memp_free+0x2b>
  804408:	83 ec 04             	sub    $0x4,%esp
  80440b:	68 48 15 81 00       	push   $0x811548
  804410:	68 5b 01 00 00       	push   $0x15b
  804415:	68 0e 15 81 00       	push   $0x81150e
  80441a:	e8 6f 9f 00 00       	call   80e38e <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  80441f:	8b 0c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ecx
  804426:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  804428:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  80442f:	c9                   	leave  
  804430:	c3                   	ret    

00804431 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  804431:	55                   	push   %ebp
  804432:	89 e5                	mov    %esp,%ebp
  804434:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  804437:	85 c9                	test   %ecx,%ecx
  804439:	74 38                	je     804473 <netif_remove+0x42>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  80443b:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804440:	39 c1                	cmp    %eax,%ecx
  804442:	75 17                	jne    80445b <netif_remove+0x2a>
    netif_list = netif->next;
  804444:	8b 01                	mov    (%ecx),%eax
  804446:	a3 34 b2 b3 00       	mov    %eax,0xb3b234
  80444b:	eb 14                	jmp    804461 <netif_remove+0x30>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  80444d:	8b 10                	mov    (%eax),%edx
  80444f:	39 d1                	cmp    %edx,%ecx
  804451:	75 06                	jne    804459 <netif_remove+0x28>
        tmpNetif->next = netif->next;
  804453:	8b 11                	mov    (%ecx),%edx
  804455:	89 10                	mov    %edx,(%eax)
  804457:	eb 08                	jmp    804461 <netif_remove+0x30>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804459:	89 d0                	mov    %edx,%eax
  80445b:	85 c0                	test   %eax,%eax
  80445d:	75 ee                	jne    80444d <netif_remove+0x1c>
  80445f:	eb 12                	jmp    804473 <netif_remove+0x42>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804461:	3b 0d 38 b2 b3 00    	cmp    0xb3b238,%ecx
  804467:	75 0a                	jne    804473 <netif_remove+0x42>
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804469:	c7 05 38 b2 b3 00 00 	movl   $0x0,0xb3b238
  804470:	00 00 00 
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804473:	5d                   	pop    %ebp
  804474:	c3                   	ret    

00804475 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  804475:	55                   	push   %ebp
  804476:	89 e5                	mov    %esp,%ebp
  804478:	53                   	push   %ebx
  804479:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  80447c:	85 c9                	test   %ecx,%ecx
  80447e:	74 2c                	je     8044ac <netif_find+0x37>
    return NULL;
  }

  num = name[2] - '0';
  804480:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  804484:	8d 50 d0             	lea    -0x30(%eax),%edx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804487:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  80448c:	eb 18                	jmp    8044a6 <netif_find+0x31>
    if (num == netif->num &&
  80448e:	3a 50 31             	cmp    0x31(%eax),%dl
  804491:	75 11                	jne    8044a4 <netif_find+0x2f>
  804493:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  804497:	38 19                	cmp    %bl,(%ecx)
  804499:	75 09                	jne    8044a4 <netif_find+0x2f>
       name[0] == netif->name[0] &&
  80449b:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  80449f:	38 59 01             	cmp    %bl,0x1(%ecx)
  8044a2:	74 0d                	je     8044b1 <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8044a4:	8b 00                	mov    (%eax),%eax
  8044a6:	85 c0                	test   %eax,%eax
  8044a8:	75 e4                	jne    80448e <netif_find+0x19>
  8044aa:	eb 05                	jmp    8044b1 <netif_find+0x3c>
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    return NULL;
  8044ac:	b8 00 00 00 00       	mov    $0x0,%eax
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  8044b1:	5b                   	pop    %ebx
  8044b2:	5d                   	pop    %ebp
  8044b3:	c3                   	ret    

008044b4 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  8044b4:	55                   	push   %ebp
  8044b5:	89 e5                	mov    %esp,%ebp
  8044b7:	57                   	push   %edi
  8044b8:	56                   	push   %esi
  8044b9:	53                   	push   %ebx
  8044ba:	83 ec 0c             	sub    $0xc,%esp
  8044bd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8044c0:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  8044c3:	8b 43 04             	mov    0x4(%ebx),%eax
  8044c6:	39 06                	cmp    %eax,(%esi)
  8044c8:	74 54                	je     80451e <netif_set_ipaddr+0x6a>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  8044ca:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    while (pcb != NULL) {
  8044cf:	eb 1d                	jmp    8044ee <netif_set_ipaddr+0x3a>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8044d1:	8b 4b 04             	mov    0x4(%ebx),%ecx
  8044d4:	39 08                	cmp    %ecx,(%eax)
  8044d6:	75 13                	jne    8044eb <netif_set_ipaddr+0x37>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  8044d8:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  8044db:	83 ec 0c             	sub    $0xc,%esp
  8044de:	50                   	push   %eax
  8044df:	e8 42 16 00 00       	call   805b26 <tcp_abort>
  8044e4:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  8044e7:	89 f8                	mov    %edi,%eax
  8044e9:	eb 03                	jmp    8044ee <netif_set_ipaddr+0x3a>
      } else {
        pcb = pcb->next;
  8044eb:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  8044ee:	85 c0                	test   %eax,%eax
  8044f0:	75 df                	jne    8044d1 <netif_set_ipaddr+0x1d>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8044f2:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  8044f7:	eb 21                	jmp    80451a <netif_set_ipaddr+0x66>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  8044f9:	85 c0                	test   %eax,%eax
  8044fb:	74 1a                	je     804517 <netif_set_ipaddr+0x63>
  8044fd:	8b 10                	mov    (%eax),%edx
  8044ff:	85 d2                	test   %edx,%edx
  804501:	74 14                	je     804517 <netif_set_ipaddr+0x63>
  804503:	3b 53 04             	cmp    0x4(%ebx),%edx
  804506:	75 0f                	jne    804517 <netif_set_ipaddr+0x63>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  804508:	85 f6                	test   %esi,%esi
  80450a:	74 04                	je     804510 <netif_set_ipaddr+0x5c>
  80450c:	8b 16                	mov    (%esi),%edx
  80450e:	eb 05                	jmp    804515 <netif_set_ipaddr+0x61>
  804510:	ba 00 00 00 00       	mov    $0x0,%edx
  804515:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804517:	8b 40 0c             	mov    0xc(%eax),%eax
  80451a:	85 c0                	test   %eax,%eax
  80451c:	75 db                	jne    8044f9 <netif_set_ipaddr+0x45>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80451e:	85 f6                	test   %esi,%esi
  804520:	74 04                	je     804526 <netif_set_ipaddr+0x72>
  804522:	8b 06                	mov    (%esi),%eax
  804524:	eb 05                	jmp    80452b <netif_set_ipaddr+0x77>
  804526:	b8 00 00 00 00       	mov    $0x0,%eax
  80452b:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  80452e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804531:	5b                   	pop    %ebx
  804532:	5e                   	pop    %esi
  804533:	5f                   	pop    %edi
  804534:	5d                   	pop    %ebp
  804535:	c3                   	ret    

00804536 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  804536:	55                   	push   %ebp
  804537:	89 e5                	mov    %esp,%ebp
  804539:	57                   	push   %edi
  80453a:	56                   	push   %esi
  80453b:	53                   	push   %ebx
  80453c:	83 ec 14             	sub    $0x14,%esp
  80453f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804542:	8b 7d 10             	mov    0x10(%ebp),%edi
  804545:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  804548:	ff 75 0c             	pushl  0xc(%ebp)
  80454b:	53                   	push   %ebx
  80454c:	e8 63 ff ff ff       	call   8044b4 <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  804551:	83 c4 10             	add    $0x10,%esp
  804554:	85 ff                	test   %edi,%edi
  804556:	74 04                	je     80455c <netif_set_addr+0x26>
  804558:	8b 07                	mov    (%edi),%eax
  80455a:	eb 05                	jmp    804561 <netif_set_addr+0x2b>
  80455c:	b8 00 00 00 00       	mov    $0x0,%eax
  804561:	89 43 08             	mov    %eax,0x8(%ebx)
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  ip_addr_set(&(netif->gw), gw);
  804564:	85 f6                	test   %esi,%esi
  804566:	74 04                	je     80456c <netif_set_addr+0x36>
  804568:	8b 06                	mov    (%esi),%eax
  80456a:	eb 05                	jmp    804571 <netif_set_addr+0x3b>
  80456c:	b8 00 00 00 00       	mov    $0x0,%eax
  804571:	89 43 0c             	mov    %eax,0xc(%ebx)
    struct ip_addr *gw)
{
  netif_set_ipaddr(netif, ipaddr);
  netif_set_netmask(netif, netmask);
  netif_set_gw(netif, gw);
}
  804574:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804577:	5b                   	pop    %ebx
  804578:	5e                   	pop    %esi
  804579:	5f                   	pop    %edi
  80457a:	5d                   	pop    %ebp
  80457b:	c3                   	ret    

0080457c <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  80457c:	55                   	push   %ebp
  80457d:	89 e5                	mov    %esp,%ebp
  80457f:	53                   	push   %ebx
  804580:	83 ec 04             	sub    $0x4,%esp
  804583:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  804586:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  80458d:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804594:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  80459b:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  80459f:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  8045a6:	8b 45 18             	mov    0x18(%ebp),%eax
  8045a9:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  8045ac:	0f b6 05 f8 43 b3 00 	movzbl 0xb343f8,%eax
  8045b3:	8d 50 01             	lea    0x1(%eax),%edx
  8045b6:	88 15 f8 43 b3 00    	mov    %dl,0xb343f8
  8045bc:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  8045bf:	8b 45 20             	mov    0x20(%ebp),%eax
  8045c2:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  8045c5:	ff 75 14             	pushl  0x14(%ebp)
  8045c8:	ff 75 10             	pushl  0x10(%ebp)
  8045cb:	ff 75 0c             	pushl  0xc(%ebp)
  8045ce:	53                   	push   %ebx
  8045cf:	e8 62 ff ff ff       	call   804536 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  8045d4:	89 1c 24             	mov    %ebx,(%esp)
  8045d7:	ff 55 1c             	call   *0x1c(%ebp)
  8045da:	83 c4 10             	add    $0x10,%esp
  8045dd:	84 c0                	test   %al,%al
  8045df:	75 11                	jne    8045f2 <netif_add+0x76>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  8045e1:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  8045e6:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  8045e8:	89 1d 34 b2 b3 00    	mov    %ebx,0xb3b234
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  8045ee:	89 d8                	mov    %ebx,%eax
  8045f0:	eb 05                	jmp    8045f7 <netif_add+0x7b>

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    return NULL;
  8045f2:	b8 00 00 00 00       	mov    $0x0,%eax
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  8045f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8045fa:	c9                   	leave  
  8045fb:	c3                   	ret    

008045fc <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  8045fc:	55                   	push   %ebp
  8045fd:	89 e5                	mov    %esp,%ebp
  8045ff:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&(netif->gw), gw);
  804602:	85 c0                	test   %eax,%eax
  804604:	74 04                	je     80460a <netif_set_gw+0xe>
  804606:	8b 10                	mov    (%eax),%edx
  804608:	eb 05                	jmp    80460f <netif_set_gw+0x13>
  80460a:	ba 00 00 00 00       	mov    $0x0,%edx
  80460f:	8b 45 08             	mov    0x8(%ebp),%eax
  804612:	89 50 0c             	mov    %edx,0xc(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  804615:	5d                   	pop    %ebp
  804616:	c3                   	ret    

00804617 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  804617:	55                   	push   %ebp
  804618:	89 e5                	mov    %esp,%ebp
  80461a:	8b 45 0c             	mov    0xc(%ebp),%eax
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  80461d:	85 c0                	test   %eax,%eax
  80461f:	74 04                	je     804625 <netif_set_netmask+0xe>
  804621:	8b 10                	mov    (%eax),%edx
  804623:	eb 05                	jmp    80462a <netif_set_netmask+0x13>
  804625:	ba 00 00 00 00       	mov    $0x0,%edx
  80462a:	8b 45 08             	mov    0x8(%ebp),%eax
  80462d:	89 50 08             	mov    %edx,0x8(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  804630:	5d                   	pop    %ebp
  804631:	c3                   	ret    

00804632 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  804632:	55                   	push   %ebp
  804633:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804635:	8b 45 08             	mov    0x8(%ebp),%eax
  804638:	a3 38 b2 b3 00       	mov    %eax,0xb3b238
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80463d:	5d                   	pop    %ebp
  80463e:	c3                   	ret    

0080463f <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  80463f:	55                   	push   %ebp
  804640:	89 e5                	mov    %esp,%ebp
  804642:	83 ec 08             	sub    $0x8,%esp
  804645:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  804648:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  80464c:	a8 01                	test   $0x1,%al
  80464e:	75 1e                	jne    80466e <netif_set_up+0x2f>
    netif->flags |= NETIF_FLAG_UP;
  804650:	89 c1                	mov    %eax,%ecx
  804652:	83 c9 01             	or     $0x1,%ecx
  804655:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  804658:	a8 20                	test   $0x20,%al
  80465a:	74 12                	je     80466e <netif_set_up+0x2f>
      etharp_query(netif, &(netif->ip_addr), NULL);
  80465c:	83 ec 04             	sub    $0x4,%esp
  80465f:	6a 00                	push   $0x0
  804661:	8d 42 04             	lea    0x4(%edx),%eax
  804664:	50                   	push   %eax
  804665:	52                   	push   %edx
  804666:	e8 2c 51 00 00       	call   809797 <etharp_query>
  80466b:	83 c4 10             	add    $0x10,%esp
    }
#endif /* LWIP_ARP */
    
  }
}
  80466e:	c9                   	leave  
  80466f:	c3                   	ret    

00804670 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804670:	55                   	push   %ebp
  804671:	89 e5                	mov    %esp,%ebp
  804673:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  804676:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  80467a:	a8 01                	test   $0x1,%al
  80467c:	74 06                	je     804684 <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  80467e:	83 e0 fe             	and    $0xfffffffe,%eax
  804681:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804684:	5d                   	pop    %ebp
  804685:	c3                   	ret    

00804686 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804686:	55                   	push   %ebp
  804687:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  804689:	8b 45 08             	mov    0x8(%ebp),%eax
  80468c:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804690:	83 e0 01             	and    $0x1,%eax
}
  804693:	5d                   	pop    %ebp
  804694:	c3                   	ret    

00804695 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804695:	55                   	push   %ebp
  804696:	89 e5                	mov    %esp,%ebp
  804698:	56                   	push   %esi
  804699:	53                   	push   %ebx
  80469a:	8b 55 08             	mov    0x8(%ebp),%edx
  80469d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  8046a0:	85 d2                	test   %edx,%edx
  8046a2:	75 17                	jne    8046bb <pbuf_header+0x26>
  8046a4:	83 ec 04             	sub    $0x4,%esp
  8046a7:	68 64 16 81 00       	push   $0x811664
  8046ac:	68 64 01 00 00       	push   $0x164
  8046b1:	68 a0 15 81 00       	push   $0x8115a0
  8046b6:	e8 d3 9c 00 00       	call   80e38e <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  8046bb:	66 85 c9             	test   %cx,%cx
  8046be:	0f 84 97 00 00 00    	je     80475b <pbuf_header+0xc6>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  8046c4:	89 ce                	mov    %ecx,%esi

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  8046c6:	66 85 c9             	test   %cx,%cx
  8046c9:	79 1f                	jns    8046ea <pbuf_header+0x55>
    increment_magnitude = -header_size_increment;
  8046cb:	f7 de                	neg    %esi
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  8046cd:	66 3b 72 0a          	cmp    0xa(%edx),%si
  8046d1:	76 17                	jbe    8046ea <pbuf_header+0x55>
  8046d3:	83 ec 04             	sub    $0x4,%esp
  8046d6:	68 b5 15 81 00       	push   $0x8115b5
  8046db:	68 6b 01 00 00       	push   $0x16b
  8046e0:	68 a0 15 81 00       	push   $0x8115a0
  8046e5:	e8 a4 9c 00 00       	call   80e38e <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  8046ea:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  8046ee:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  8046f1:	66 85 c0             	test   %ax,%ax
  8046f4:	74 06                	je     8046fc <pbuf_header+0x67>
  8046f6:	66 83 f8 03          	cmp    $0x3,%ax
  8046fa:	75 13                	jne    80470f <pbuf_header+0x7a>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  8046fc:	0f bf c1             	movswl %cx,%eax
  8046ff:	29 c3                	sub    %eax,%ebx
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804701:	8d 72 10             	lea    0x10(%edx),%esi
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
  804704:	b8 01 00 00 00       	mov    $0x1,%eax
  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804709:	39 f3                	cmp    %esi,%ebx
  80470b:	73 3c                	jae    804749 <pbuf_header+0xb4>
  80470d:	eb 51                	jmp    804760 <pbuf_header+0xcb>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  80470f:	83 e8 01             	sub    $0x1,%eax
  804712:	66 83 f8 01          	cmp    $0x1,%ax
  804716:	77 1a                	ja     804732 <pbuf_header+0x9d>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  804718:	b8 01 00 00 00       	mov    $0x1,%eax
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80471d:	66 85 c9             	test   %cx,%cx
  804720:	79 3e                	jns    804760 <pbuf_header+0xcb>
  804722:	66 3b 72 0a          	cmp    0xa(%edx),%si
  804726:	77 38                	ja     804760 <pbuf_header+0xcb>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  804728:	0f bf c1             	movswl %cx,%eax
  80472b:	29 c3                	sub    %eax,%ebx
  80472d:	89 5a 04             	mov    %ebx,0x4(%edx)
  804730:	eb 1a                	jmp    80474c <pbuf_header+0xb7>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  804732:	83 ec 04             	sub    $0x4,%esp
  804735:	68 d3 15 81 00       	push   $0x8115d3
  80473a:	68 9a 01 00 00       	push   $0x19a
  80473f:	68 a0 15 81 00       	push   $0x8115a0
  804744:	e8 45 9c 00 00       	call   80e38e <_panic>
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  804749:	89 5a 04             	mov    %ebx,0x4(%edx)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  80474c:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  804750:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  804754:	b8 00 00 00 00       	mov    $0x0,%eax
  804759:	eb 05                	jmp    804760 <pbuf_header+0xcb>
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
  80475b:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
  804760:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804763:	5b                   	pop    %ebx
  804764:	5e                   	pop    %esi
  804765:	5d                   	pop    %ebp
  804766:	c3                   	ret    

00804767 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  804767:	55                   	push   %ebp
  804768:	89 e5                	mov    %esp,%ebp
  80476a:	56                   	push   %esi
  80476b:	53                   	push   %ebx
  80476c:	8b 55 08             	mov    0x8(%ebp),%edx
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  80476f:	85 d2                	test   %edx,%edx
  804771:	75 17                	jne    80478a <pbuf_free+0x23>
    LWIP_ASSERT("p != NULL", p != NULL);
  804773:	83 ec 04             	sub    $0x4,%esp
  804776:	68 64 16 81 00       	push   $0x811664
  80477b:	68 d0 01 00 00       	push   $0x1d0
  804780:	68 a0 15 81 00       	push   $0x8115a0
  804785:	e8 04 9c 00 00       	call   80e38e <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  80478a:	80 7a 0c 03          	cmpb   $0x3,0xc(%edx)
  80478e:	76 17                	jbe    8047a7 <pbuf_free+0x40>
  804790:	83 ec 04             	sub    $0x4,%esp
  804793:	68 e1 15 81 00       	push   $0x8115e1
  804798:	68 db 01 00 00       	push   $0x1db
  80479d:	68 a0 15 81 00       	push   $0x8115a0
  8047a2:	e8 e7 9b 00 00       	call   80e38e <_panic>
  8047a7:	bb 00 00 00 00       	mov    $0x0,%ebx
  8047ac:	eb 02                	jmp    8047b0 <pbuf_free+0x49>
      } else {
        mem_free(p);
      }
      count++;
      /* proceed to next pbuf */
      p = q;
  8047ae:	89 f2                	mov    %esi,%edx
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  8047b0:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
  8047b4:	66 85 c0             	test   %ax,%ax
  8047b7:	75 17                	jne    8047d0 <pbuf_free+0x69>
  8047b9:	83 ec 04             	sub    $0x4,%esp
  8047bc:	68 f6 15 81 00       	push   $0x8115f6
  8047c1:	68 e8 01 00 00       	push   $0x1e8
  8047c6:	68 a0 15 81 00       	push   $0x8115a0
  8047cb:	e8 be 9b 00 00       	call   80e38e <_panic>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  8047d0:	83 e8 01             	sub    $0x1,%eax
  8047d3:	66 89 42 0e          	mov    %ax,0xe(%edx)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  8047d7:	66 85 c0             	test   %ax,%ax
  8047da:	75 48                	jne    804824 <pbuf_free+0xbd>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  8047dc:	8b 32                	mov    (%edx),%esi
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  8047de:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  8047e2:	66 83 f8 03          	cmp    $0x3,%ax
  8047e6:	75 10                	jne    8047f8 <pbuf_free+0x91>
        memp_free(MEMP_PBUF_POOL, p);
  8047e8:	83 ec 08             	sub    $0x8,%esp
  8047eb:	52                   	push   %edx
  8047ec:	6a 0d                	push   $0xd
  8047ee:	e8 01 fc ff ff       	call   8043f4 <memp_free>
  8047f3:	83 c4 10             	add    $0x10,%esp
  8047f6:	eb 25                	jmp    80481d <pbuf_free+0xb6>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  8047f8:	83 e8 01             	sub    $0x1,%eax
  8047fb:	66 83 f8 01          	cmp    $0x1,%ax
  8047ff:	77 10                	ja     804811 <pbuf_free+0xaa>
        memp_free(MEMP_PBUF, p);
  804801:	83 ec 08             	sub    $0x8,%esp
  804804:	52                   	push   %edx
  804805:	6a 0c                	push   $0xc
  804807:	e8 e8 fb ff ff       	call   8043f4 <memp_free>
  80480c:	83 c4 10             	add    $0x10,%esp
  80480f:	eb 0c                	jmp    80481d <pbuf_free+0xb6>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  804811:	83 ec 0c             	sub    $0xc,%esp
  804814:	52                   	push   %edx
  804815:	e8 ab f6 ff ff       	call   803ec5 <mem_free>
  80481a:	83 c4 10             	add    $0x10,%esp
      }
      count++;
  80481d:	83 c3 01             	add    $0x1,%ebx
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  804820:	85 f6                	test   %esi,%esi
  804822:	75 8a                	jne    8047ae <pbuf_free+0x47>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  804824:	89 d8                	mov    %ebx,%eax
  804826:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804829:	5b                   	pop    %ebx
  80482a:	5e                   	pop    %esi
  80482b:	5d                   	pop    %ebp
  80482c:	c3                   	ret    

0080482d <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  80482d:	55                   	push   %ebp
  80482e:	89 e5                	mov    %esp,%ebp
  804830:	57                   	push   %edi
  804831:	56                   	push   %esi
  804832:	53                   	push   %ebx
  804833:	83 ec 1c             	sub    $0x1c,%esp
  804836:	8b 45 08             	mov    0x8(%ebp),%eax
  804839:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  80483c:	83 f8 01             	cmp    $0x1,%eax
  80483f:	74 18                	je     804859 <pbuf_alloc+0x2c>
  804841:	83 f8 01             	cmp    $0x1,%eax
  804844:	72 0c                	jb     804852 <pbuf_alloc+0x25>
  804846:	83 f8 02             	cmp    $0x2,%eax
  804849:	74 18                	je     804863 <pbuf_alloc+0x36>
  80484b:	83 f8 03             	cmp    $0x3,%eax
  80484e:	74 34                	je     804884 <pbuf_alloc+0x57>
  804850:	eb 1b                	jmp    80486d <pbuf_alloc+0x40>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  804852:	bf 14 00 00 00       	mov    $0x14,%edi
  804857:	eb 05                	jmp    80485e <pbuf_alloc+0x31>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804859:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  80485e:	83 c7 14             	add    $0x14,%edi
  804861:	eb 05                	jmp    804868 <pbuf_alloc+0x3b>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804863:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  804868:	83 c7 0e             	add    $0xe,%edi
    break;
  80486b:	eb 1c                	jmp    804889 <pbuf_alloc+0x5c>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  80486d:	83 ec 04             	sub    $0x4,%esp
  804870:	68 0c 16 81 00       	push   $0x81160c
  804875:	68 8a 00 00 00       	push   $0x8a
  80487a:	68 a0 15 81 00       	push   $0x8115a0
  80487f:	e8 0a 9b 00 00       	call   80e38e <_panic>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804884:	bf 00 00 00 00       	mov    $0x0,%edi
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  804889:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  80488d:	77 0f                	ja     80489e <pbuf_alloc+0x71>
  80488f:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  804893:	0f 82 60 01 00 00    	jb     8049f9 <pbuf_alloc+0x1cc>
  804899:	e9 a1 01 00 00       	jmp    804a3f <pbuf_alloc+0x212>
  80489e:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
  8048a2:	0f 85 c8 01 00 00    	jne    804a70 <pbuf_alloc+0x243>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  8048a8:	83 ec 0c             	sub    $0xc,%esp
  8048ab:	6a 0d                	push   $0xd
  8048ad:	e8 ec fa ff ff       	call   80439e <memp_malloc>
  8048b2:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  8048b4:	83 c4 10             	add    $0x10,%esp
  8048b7:	85 c0                	test   %eax,%eax
  8048b9:	0f 84 d6 01 00 00    	je     804a95 <pbuf_alloc+0x268>
      return NULL;
    }
    p->type = type;
  8048bf:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  8048c3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  8048c9:	0f b7 ff             	movzwl %di,%edi
  8048cc:	8d 54 38 13          	lea    0x13(%eax,%edi,1),%edx
  8048d0:	83 e2 fc             	and    $0xfffffffc,%edx
  8048d3:	89 50 04             	mov    %edx,0x4(%eax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  8048d6:	66 89 58 08          	mov    %bx,0x8(%eax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  8048da:	0f b7 db             	movzwl %bx,%ebx
  8048dd:	83 c7 03             	add    $0x3,%edi
  8048e0:	83 e7 fc             	and    $0xfffffffc,%edi
  8048e3:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  8048e8:	29 f8                	sub    %edi,%eax
  8048ea:	39 d8                	cmp    %ebx,%eax
  8048ec:	0f 4f c3             	cmovg  %ebx,%eax
  8048ef:	66 89 46 0a          	mov    %ax,0xa(%esi)
  8048f3:	0f b7 c0             	movzwl %ax,%eax
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  8048f6:	8d 8e e0 07 00 00    	lea    0x7e0(%esi),%ecx
  8048fc:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8048ff:	01 c2                	add    %eax,%edx
  804901:	39 d1                	cmp    %edx,%ecx
  804903:	73 17                	jae    80491c <pbuf_alloc+0xef>
  804905:	83 ec 04             	sub    $0x4,%esp
  804908:	68 24 17 81 00       	push   $0x811724
  80490d:	68 a3 00 00 00       	push   $0xa3
  804912:	68 a0 15 81 00       	push   $0x8115a0
  804917:	e8 72 9a 00 00       	call   80e38e <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  80491c:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  804922:	29 c3                	sub    %eax,%ebx
    p->ref = 1;

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  804924:	89 f7                	mov    %esi,%edi
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  804926:	e9 c1 00 00 00       	jmp    8049ec <pbuf_alloc+0x1bf>
      q = memp_malloc(MEMP_PBUF_POOL);
  80492b:	83 ec 0c             	sub    $0xc,%esp
  80492e:	6a 0d                	push   $0xd
  804930:	e8 69 fa ff ff       	call   80439e <memp_malloc>
      if (q == NULL) {
  804935:	83 c4 10             	add    $0x10,%esp
  804938:	85 c0                	test   %eax,%eax
  80493a:	75 16                	jne    804952 <pbuf_alloc+0x125>
        /* free chain so far allocated */
        pbuf_free(p);
  80493c:	83 ec 0c             	sub    $0xc,%esp
  80493f:	56                   	push   %esi
  804940:	e8 22 fe ff ff       	call   804767 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
  804945:	83 c4 10             	add    $0x10,%esp
  804948:	b8 00 00 00 00       	mov    $0x0,%eax
  80494d:	e9 56 01 00 00       	jmp    804aa8 <pbuf_alloc+0x27b>
      }
      q->type = type;
  804952:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804956:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  80495a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  804960:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804962:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  804968:	7e 17                	jle    804981 <pbuf_alloc+0x154>
  80496a:	83 ec 04             	sub    $0x4,%esp
  80496d:	68 27 16 81 00       	push   $0x811627
  804972:	68 bc 00 00 00       	push   $0xbc
  804977:	68 a0 15 81 00       	push   $0x8115a0
  80497c:	e8 0d 9a 00 00       	call   80e38e <_panic>
      q->tot_len = (u16_t)rem_len;
  804981:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804985:	0f b7 d3             	movzwl %bx,%edx
  804988:	81 fa d0 07 00 00    	cmp    $0x7d0,%edx
  80498e:	bf d0 07 00 00       	mov    $0x7d0,%edi
  804993:	0f 4f d7             	cmovg  %edi,%edx
  804996:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  80499a:	8d 48 10             	lea    0x10(%eax),%ecx
  80499d:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  8049a0:	f6 c1 03             	test   $0x3,%cl
  8049a3:	74 17                	je     8049bc <pbuf_alloc+0x18f>
  8049a5:	83 ec 04             	sub    $0x4,%esp
  8049a8:	68 58 17 81 00       	push   $0x811758
  8049ad:	68 c2 00 00 00       	push   $0xc2
  8049b2:	68 a0 15 81 00       	push   $0x8115a0
  8049b7:	e8 d2 99 00 00       	call   80e38e <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  8049bc:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  8049c0:	03 4e 04             	add    0x4(%esi),%ecx
  8049c3:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  8049c6:	73 17                	jae    8049df <pbuf_alloc+0x1b2>
  8049c8:	83 ec 04             	sub    $0x4,%esp
  8049cb:	68 24 17 81 00       	push   $0x811724
  8049d0:	68 c5 00 00 00       	push   $0xc5
  8049d5:	68 a0 15 81 00       	push   $0x8115a0
  8049da:	e8 af 99 00 00       	call   80e38e <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  8049df:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  8049e5:	0f b7 d2             	movzwl %dx,%edx
  8049e8:	29 d3                	sub    %edx,%ebx
      /* remember this pbuf for linkage in next iteration */
      r = q;
  8049ea:	89 c7                	mov    %eax,%edi
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  8049ec:	85 db                	test   %ebx,%ebx
  8049ee:	0f 8f 37 ff ff ff    	jg     80492b <pbuf_alloc+0xfe>
  8049f4:	e9 8e 00 00 00       	jmp    804a87 <pbuf_alloc+0x25a>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  8049f9:	0f b7 ff             	movzwl %di,%edi
  8049fc:	83 ec 0c             	sub    $0xc,%esp
  8049ff:	8d 47 13             	lea    0x13(%edi),%eax
  804a02:	83 e0 fc             	and    $0xfffffffc,%eax
  804a05:	89 c2                	mov    %eax,%edx
  804a07:	0f b7 c3             	movzwl %bx,%eax
  804a0a:	83 c0 03             	add    $0x3,%eax
  804a0d:	83 e0 fc             	and    $0xfffffffc,%eax
  804a10:	01 d0                	add    %edx,%eax
  804a12:	50                   	push   %eax
  804a13:	e8 5f f7 ff ff       	call   804177 <mem_malloc>
  804a18:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  804a1a:	83 c4 10             	add    $0x10,%esp
  804a1d:	85 c0                	test   %eax,%eax
  804a1f:	74 7b                	je     804a9c <pbuf_alloc+0x26f>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  804a21:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  804a25:	83 e0 fc             	and    $0xfffffffc,%eax
  804a28:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  804a2b:	66 89 5e 08          	mov    %bx,0x8(%esi)
  804a2f:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  804a33:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  804a39:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  804a3d:	eb 48                	jmp    804a87 <pbuf_alloc+0x25a>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  804a3f:	83 ec 0c             	sub    $0xc,%esp
  804a42:	6a 0c                	push   $0xc
  804a44:	e8 55 f9 ff ff       	call   80439e <memp_malloc>
  804a49:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  804a4b:	83 c4 10             	add    $0x10,%esp
  804a4e:	85 c0                	test   %eax,%eax
  804a50:	74 51                	je     804aa3 <pbuf_alloc+0x276>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  804a52:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804a59:	66 89 58 08          	mov    %bx,0x8(%eax)
  804a5d:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  804a61:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804a67:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  804a6b:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  804a6e:	eb 17                	jmp    804a87 <pbuf_alloc+0x25a>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804a70:	83 ec 04             	sub    $0x4,%esp
  804a73:	68 3b 16 81 00       	push   $0x81163b
  804a78:	68 f1 00 00 00       	push   $0xf1
  804a7d:	68 a0 15 81 00       	push   $0x8115a0
  804a82:	e8 07 99 00 00       	call   80e38e <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  804a87:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  804a8d:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  804a91:	89 f0                	mov    %esi,%eax
  804a93:	eb 13                	jmp    804aa8 <pbuf_alloc+0x27b>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      return NULL;
  804a95:	b8 00 00 00 00       	mov    $0x0,%eax
  804a9a:	eb 0c                	jmp    804aa8 <pbuf_alloc+0x27b>
    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    if (p == NULL) {
      return NULL;
  804a9c:	b8 00 00 00 00       	mov    $0x0,%eax
  804aa1:	eb 05                	jmp    804aa8 <pbuf_alloc+0x27b>
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
    if (p == NULL) {
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  804aa3:	b8 00 00 00 00       	mov    $0x0,%eax
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  804aa8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804aab:	5b                   	pop    %ebx
  804aac:	5e                   	pop    %esi
  804aad:	5f                   	pop    %edi
  804aae:	5d                   	pop    %ebp
  804aaf:	c3                   	ret    

00804ab0 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  804ab0:	55                   	push   %ebp
  804ab1:	89 e5                	mov    %esp,%ebp
  804ab3:	57                   	push   %edi
  804ab4:	56                   	push   %esi
  804ab5:	53                   	push   %ebx
  804ab6:	83 ec 0c             	sub    $0xc,%esp
  804ab9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804abc:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804abf:	85 db                	test   %ebx,%ebx
  804ac1:	75 17                	jne    804ada <pbuf_realloc+0x2a>
  804ac3:	83 ec 04             	sub    $0x4,%esp
  804ac6:	68 56 16 81 00       	push   $0x811656
  804acb:	68 13 01 00 00       	push   $0x113
  804ad0:	68 a0 15 81 00       	push   $0x8115a0
  804ad5:	e8 b4 98 00 00       	call   80e38e <_panic>
  804ada:	89 f7                	mov    %esi,%edi
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804adc:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804ae0:	76 17                	jbe    804af9 <pbuf_realloc+0x49>
  804ae2:	83 ec 04             	sub    $0x4,%esp
  804ae5:	68 6e 16 81 00       	push   $0x81166e
  804aea:	68 17 01 00 00       	push   $0x117
  804aef:	68 a0 15 81 00       	push   $0x8115a0
  804af4:	e8 95 98 00 00       	call   80e38e <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  804af9:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  804afd:	66 39 f2             	cmp    %si,%dx
  804b00:	0f 86 b8 00 00 00    	jbe    804bbe <pbuf_realloc+0x10e>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  804b06:	0f b7 ce             	movzwl %si,%ecx
  804b09:	0f b7 c2             	movzwl %dx,%eax
  804b0c:	29 c1                	sub    %eax,%ecx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  804b0e:	eb 46                	jmp    804b56 <pbuf_realloc+0xa6>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  804b10:	29 c6                	sub    %eax,%esi
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804b12:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  804b18:	7e 17                	jle    804b31 <pbuf_realloc+0x81>
  804b1a:	83 ec 04             	sub    $0x4,%esp
  804b1d:	68 89 16 81 00       	push   $0x811689
  804b22:	68 2b 01 00 00       	push   $0x12b
  804b27:	68 a0 15 81 00       	push   $0x8115a0
  804b2c:	e8 5d 98 00 00       	call   80e38e <_panic>
    q->tot_len += (u16_t)grow;
  804b31:	89 f8                	mov    %edi,%eax
  804b33:	29 d0                	sub    %edx,%eax
  804b35:	66 01 43 08          	add    %ax,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  804b39:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804b3b:	85 db                	test   %ebx,%ebx
  804b3d:	75 17                	jne    804b56 <pbuf_realloc+0xa6>
  804b3f:	83 ec 04             	sub    $0x4,%esp
  804b42:	68 9a 16 81 00       	push   $0x81169a
  804b47:	68 2f 01 00 00       	push   $0x12f
  804b4c:	68 a0 15 81 00       	push   $0x8115a0
  804b51:	e8 38 98 00 00       	call   80e38e <_panic>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  804b56:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804b5a:	66 39 c6             	cmp    %ax,%si
  804b5d:	77 b1                	ja     804b10 <pbuf_realloc+0x60>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804b5f:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804b63:	75 39                	jne    804b9e <pbuf_realloc+0xee>
  804b65:	66 39 c6             	cmp    %ax,%si
  804b68:	74 34                	je     804b9e <pbuf_realloc+0xee>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804b6a:	8b 53 04             	mov    0x4(%ebx),%edx
  804b6d:	29 da                	sub    %ebx,%edx
  804b6f:	0f b7 c6             	movzwl %si,%eax
  804b72:	01 d0                	add    %edx,%eax
  804b74:	83 ec 08             	sub    $0x8,%esp
  804b77:	50                   	push   %eax
  804b78:	53                   	push   %ebx
  804b79:	e8 b0 f4 ff ff       	call   80402e <mem_realloc>
  804b7e:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804b80:	83 c4 10             	add    $0x10,%esp
  804b83:	85 c0                	test   %eax,%eax
  804b85:	75 17                	jne    804b9e <pbuf_realloc+0xee>
  804b87:	83 ec 04             	sub    $0x4,%esp
  804b8a:	68 b2 16 81 00       	push   $0x8116b2
  804b8f:	68 39 01 00 00       	push   $0x139
  804b94:	68 a0 15 81 00       	push   $0x8115a0
  804b99:	e8 f0 97 00 00       	call   80e38e <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  804b9e:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804ba2:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  804ba6:	8b 03                	mov    (%ebx),%eax
  804ba8:	85 c0                	test   %eax,%eax
  804baa:	74 0c                	je     804bb8 <pbuf_realloc+0x108>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  804bac:	83 ec 0c             	sub    $0xc,%esp
  804baf:	50                   	push   %eax
  804bb0:	e8 b2 fb ff ff       	call   804767 <pbuf_free>
  804bb5:	83 c4 10             	add    $0x10,%esp
  }
  /* q is last packet in chain */
  q->next = NULL;
  804bb8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  804bbe:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804bc1:	5b                   	pop    %ebx
  804bc2:	5e                   	pop    %esi
  804bc3:	5f                   	pop    %edi
  804bc4:	5d                   	pop    %ebp
  804bc5:	c3                   	ret    

00804bc6 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804bc6:	55                   	push   %ebp
  804bc7:	89 e5                	mov    %esp,%ebp
  804bc9:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  804bcc:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  804bd1:	eb 05                	jmp    804bd8 <pbuf_clen+0x12>
    ++len;
  804bd3:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  804bd6:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  804bd8:	85 d2                	test   %edx,%edx
  804bda:	75 f7                	jne    804bd3 <pbuf_clen+0xd>
    ++len;
    p = p->next;
  }
  return len;
}
  804bdc:	5d                   	pop    %ebp
  804bdd:	c3                   	ret    

00804bde <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804bde:	55                   	push   %ebp
  804bdf:	89 e5                	mov    %esp,%ebp
  804be1:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804be4:	85 c0                	test   %eax,%eax
  804be6:	74 05                	je     804bed <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804be8:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804bed:	5d                   	pop    %ebp
  804bee:	c3                   	ret    

00804bef <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804bef:	55                   	push   %ebp
  804bf0:	89 e5                	mov    %esp,%ebp
  804bf2:	53                   	push   %ebx
  804bf3:	83 ec 04             	sub    $0x4,%esp
  804bf6:	8b 45 08             	mov    0x8(%ebp),%eax
  804bf9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804bfc:	85 c0                	test   %eax,%eax
  804bfe:	74 04                	je     804c04 <pbuf_cat+0x15>
  804c00:	85 db                	test   %ebx,%ebx
  804c02:	75 21                	jne    804c25 <pbuf_cat+0x36>
  804c04:	83 ec 04             	sub    $0x4,%esp
  804c07:	68 88 17 81 00       	push   $0x811788
  804c0c:	68 42 02 00 00       	push   $0x242
  804c11:	68 a0 15 81 00       	push   $0x8115a0
  804c16:	e8 73 97 00 00       	call   80e38e <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804c1b:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804c1f:	66 01 48 08          	add    %cx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  804c23:	89 d0                	mov    %edx,%eax
  804c25:	8b 10                	mov    (%eax),%edx
  804c27:	85 d2                	test   %edx,%edx
  804c29:	75 f0                	jne    804c1b <pbuf_cat+0x2c>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804c2b:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804c2f:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804c33:	74 17                	je     804c4c <pbuf_cat+0x5d>
  804c35:	83 ec 04             	sub    $0x4,%esp
  804c38:	68 c0 17 81 00       	push   $0x8117c0
  804c3d:	68 4a 02 00 00       	push   $0x24a
  804c42:	68 a0 15 81 00       	push   $0x8115a0
  804c47:	e8 42 97 00 00       	call   80e38e <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804c4c:	66 03 53 08          	add    0x8(%ebx),%dx
  804c50:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804c54:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804c56:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804c59:	c9                   	leave  
  804c5a:	c3                   	ret    

00804c5b <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804c5b:	55                   	push   %ebp
  804c5c:	89 e5                	mov    %esp,%ebp
  804c5e:	53                   	push   %ebx
  804c5f:	83 ec 0c             	sub    $0xc,%esp
  804c62:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804c65:	53                   	push   %ebx
  804c66:	ff 75 08             	pushl  0x8(%ebp)
  804c69:	e8 81 ff ff ff       	call   804bef <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804c6e:	89 1c 24             	mov    %ebx,(%esp)
  804c71:	e8 68 ff ff ff       	call   804bde <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804c76:	83 c4 10             	add    $0x10,%esp
  804c79:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804c7c:	c9                   	leave  
  804c7d:	c3                   	ret    

00804c7e <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804c7e:	55                   	push   %ebp
  804c7f:	89 e5                	mov    %esp,%ebp
  804c81:	57                   	push   %edi
  804c82:	56                   	push   %esi
  804c83:	53                   	push   %ebx
  804c84:	83 ec 1c             	sub    $0x1c,%esp
  804c87:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804c8a:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804c8c:	85 f6                	test   %esi,%esi
  804c8e:	0f 84 80 00 00 00    	je     804d14 <pbuf_dechain+0x96>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804c94:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804c98:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804c9c:	0f b7 7e 08          	movzwl 0x8(%esi),%edi
  804ca0:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804ca3:	0f b7 d0             	movzwl %ax,%edx
  804ca6:	0f b7 f9             	movzwl %cx,%edi
  804ca9:	29 fa                	sub    %edi,%edx
  804cab:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  804cae:	74 17                	je     804cc7 <pbuf_dechain+0x49>
  804cb0:	83 ec 04             	sub    $0x4,%esp
  804cb3:	68 f0 17 81 00       	push   $0x8117f0
  804cb8:	68 80 02 00 00       	push   $0x280
  804cbd:	68 a0 15 81 00       	push   $0x8115a0
  804cc2:	e8 c7 96 00 00       	call   80e38e <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804cc7:	29 c8                	sub    %ecx,%eax
  804cc9:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804ccd:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804cd3:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804cd7:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804cdb:	83 ec 0c             	sub    $0xc,%esp
  804cde:	56                   	push   %esi
  804cdf:	e8 83 fa ff ff       	call   804767 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804ce4:	83 c4 10             	add    $0x10,%esp
  804ce7:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804ceb:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  804cef:	74 17                	je     804d08 <pbuf_dechain+0x8a>
  804cf1:	83 ec 04             	sub    $0x4,%esp
  804cf4:	68 cd 16 81 00       	push   $0x8116cd
  804cf9:	68 91 02 00 00       	push   $0x291
  804cfe:	68 a0 15 81 00       	push   $0x8115a0
  804d03:	e8 86 96 00 00       	call   80e38e <_panic>
  return ((tail_gone > 0) ? NULL : q);
  804d08:	84 c0                	test   %al,%al
  804d0a:	b8 00 00 00 00       	mov    $0x0,%eax
  804d0f:	0f 44 c6             	cmove  %esi,%eax
  804d12:	eb 0f                	jmp    804d23 <pbuf_dechain+0xa5>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804d14:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d18:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804d1c:	75 d3                	jne    804cf1 <pbuf_dechain+0x73>
  return ((tail_gone > 0) ? NULL : q);
  804d1e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804d23:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804d26:	5b                   	pop    %ebx
  804d27:	5e                   	pop    %esi
  804d28:	5f                   	pop    %edi
  804d29:	5d                   	pop    %ebp
  804d2a:	c3                   	ret    

00804d2b <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804d2b:	55                   	push   %ebp
  804d2c:	89 e5                	mov    %esp,%ebp
  804d2e:	57                   	push   %edi
  804d2f:	56                   	push   %esi
  804d30:	53                   	push   %ebx
  804d31:	83 ec 1c             	sub    $0x1c,%esp
  804d34:	8b 75 08             	mov    0x8(%ebp),%esi
  804d37:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804d3a:	85 f6                	test   %esi,%esi
  804d3c:	74 0e                	je     804d4c <pbuf_copy+0x21>
  804d3e:	85 db                	test   %ebx,%ebx
  804d40:	74 0a                	je     804d4c <pbuf_copy+0x21>
  804d42:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804d46:	66 39 46 08          	cmp    %ax,0x8(%esi)
  804d4a:	73 17                	jae    804d63 <pbuf_copy+0x38>
  804d4c:	83 ec 04             	sub    $0x4,%esp
  804d4f:	68 14 18 81 00       	push   $0x811814
  804d54:	68 b1 02 00 00       	push   $0x2b1
  804d59:	68 a0 15 81 00       	push   $0x8115a0
  804d5e:	e8 2b 96 00 00       	call   80e38e <_panic>
  804d63:	bf 00 00 00 00       	mov    $0x0,%edi
  804d68:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804d6e:	66 89 7d e6          	mov    %di,-0x1a(%ebp)
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  804d72:	85 f6                	test   %esi,%esi
  804d74:	75 17                	jne    804d8d <pbuf_copy+0x62>
  804d76:	83 ec 04             	sub    $0x4,%esp
  804d79:	68 e2 16 81 00       	push   $0x8116e2
  804d7e:	68 b6 02 00 00       	push   $0x2b6
  804d83:	68 a0 15 81 00       	push   $0x8115a0
  804d88:	e8 01 96 00 00       	call   80e38e <_panic>
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  804d8d:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  804d91:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804d95:	29 c1                	sub    %eax,%ecx
  804d97:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  804d9b:	0f b7 7d e6          	movzwl -0x1a(%ebp),%edi
  804d9f:	0f b7 c7             	movzwl %di,%eax
  804da2:	29 c2                	sub    %eax,%edx
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  804da4:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804da8:	29 f8                	sub    %edi,%eax
  804daa:	0f b7 7e 0a          	movzwl 0xa(%esi),%edi
  804dae:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  804db2:	39 d1                	cmp    %edx,%ecx
  804db4:	89 c1                	mov    %eax,%ecx
  804db6:	0f 4c cf             	cmovl  %edi,%ecx
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  804db9:	83 ec 04             	sub    $0x4,%esp
  804dbc:	66 89 4d e2          	mov    %cx,-0x1e(%ebp)
  804dc0:	0f b7 c1             	movzwl %cx,%eax
  804dc3:	50                   	push   %eax
  804dc4:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804dc8:	03 43 04             	add    0x4(%ebx),%eax
  804dcb:	50                   	push   %eax
  804dcc:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  804dd0:	0f b7 c7             	movzwl %di,%eax
  804dd3:	03 46 04             	add    0x4(%esi),%eax
  804dd6:	50                   	push   %eax
  804dd7:	e8 0a 9e 00 00       	call   80ebe6 <memcpy>
    offset_to += len;
  804ddc:	89 f8                	mov    %edi,%eax
  804dde:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  804de2:	01 c8                	add    %ecx,%eax
  804de4:	89 c2                	mov    %eax,%edx
  804de6:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    offset_from += len;
  804dea:	66 01 4d e6          	add    %cx,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804dee:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  804df2:	83 c4 10             	add    $0x10,%esp
  804df5:	66 39 c2             	cmp    %ax,%dx
  804df8:	76 17                	jbe    804e11 <pbuf_copy+0xe6>
  804dfa:	83 ec 04             	sub    $0x4,%esp
  804dfd:	68 ef 16 81 00       	push   $0x8116ef
  804e02:	68 c2 02 00 00       	push   $0x2c2
  804e07:	68 a0 15 81 00       	push   $0x8115a0
  804e0c:	e8 7d 95 00 00       	call   80e38e <_panic>
    if (offset_to == p_to->len) {
  804e11:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
  804e15:	75 08                	jne    804e1f <pbuf_copy+0xf4>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  804e17:	8b 36                	mov    (%esi),%esi
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
  804e19:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804e1f:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804e23:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  804e27:	76 17                	jbe    804e40 <pbuf_copy+0x115>
  804e29:	83 ec 04             	sub    $0x4,%esp
  804e2c:	68 06 17 81 00       	push   $0x811706
  804e31:	68 c8 02 00 00       	push   $0x2c8
  804e36:	68 a0 15 81 00       	push   $0x8115a0
  804e3b:	e8 4e 95 00 00       	call   80e38e <_panic>
    if (offset_from >= p_from->len) {
  804e40:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  804e44:	72 08                	jb     804e4e <pbuf_copy+0x123>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  804e46:	8b 1b                	mov    (%ebx),%ebx
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  804e48:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804e4e:	85 db                	test   %ebx,%ebx
  804e50:	74 26                	je     804e78 <pbuf_copy+0x14d>
  804e52:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804e56:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  804e5a:	75 1c                	jne    804e78 <pbuf_copy+0x14d>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804e5c:	83 3b 00             	cmpl   $0x0,(%ebx)
  804e5f:	74 17                	je     804e78 <pbuf_copy+0x14d>
  804e61:	83 ec 04             	sub    $0x4,%esp
  804e64:	68 44 18 81 00       	push   $0x811844
  804e69:	68 d2 02 00 00       	push   $0x2d2
  804e6e:	68 a0 15 81 00       	push   $0x8115a0
  804e73:	e8 16 95 00 00       	call   80e38e <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804e78:	85 f6                	test   %esi,%esi
  804e7a:	74 26                	je     804ea2 <pbuf_copy+0x177>
  804e7c:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  804e80:	66 39 46 0a          	cmp    %ax,0xa(%esi)
  804e84:	75 1c                	jne    804ea2 <pbuf_copy+0x177>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804e86:	83 3e 00             	cmpl   $0x0,(%esi)
  804e89:	74 17                	je     804ea2 <pbuf_copy+0x177>
  804e8b:	83 ec 04             	sub    $0x4,%esp
  804e8e:	68 44 18 81 00       	push   $0x811844
  804e93:	68 d7 02 00 00       	push   $0x2d7
  804e98:	68 a0 15 81 00       	push   $0x8115a0
  804e9d:	e8 ec 94 00 00       	call   80e38e <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  804ea2:	85 db                	test   %ebx,%ebx
  804ea4:	0f 85 c8 fe ff ff    	jne    804d72 <pbuf_copy+0x47>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  804eaa:	b8 00 00 00 00       	mov    $0x0,%eax
  804eaf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804eb2:	5b                   	pop    %ebx
  804eb3:	5e                   	pop    %esi
  804eb4:	5f                   	pop    %edi
  804eb5:	5d                   	pop    %ebp
  804eb6:	c3                   	ret    

00804eb7 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  804eb7:	55                   	push   %ebp
  804eb8:	89 e5                	mov    %esp,%ebp
  804eba:	57                   	push   %edi
  804ebb:	56                   	push   %esi
  804ebc:	53                   	push   %ebx
  804ebd:	83 ec 1c             	sub    $0x1c,%esp
  804ec0:	8b 75 08             	mov    0x8(%ebp),%esi
  804ec3:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  804ec7:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  804ecb:	85 f6                	test   %esi,%esi
  804ecd:	75 17                	jne    804ee6 <pbuf_copy_partial+0x2f>
  804ecf:	83 ec 04             	sub    $0x4,%esp
  804ed2:	68 70 18 81 00       	push   $0x811870
  804ed7:	68 ef 02 00 00       	push   $0x2ef
  804edc:	68 a0 15 81 00       	push   $0x8115a0
  804ee1:	e8 a8 94 00 00       	call   80e38e <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  804ee6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  804eea:	75 66                	jne    804f52 <pbuf_copy_partial+0x9b>
  804eec:	83 ec 04             	sub    $0x4,%esp
  804eef:	68 94 18 81 00       	push   $0x811894
  804ef4:	68 f0 02 00 00       	push   $0x2f0
  804ef9:	68 a0 15 81 00       	push   $0x8115a0
  804efe:	e8 8b 94 00 00       	call   80e38e <_panic>
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  804f03:	66 85 c0             	test   %ax,%ax
  804f06:	74 0d                	je     804f15 <pbuf_copy_partial+0x5e>
  804f08:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  804f0c:	66 39 d0             	cmp    %dx,%ax
  804f0f:	72 04                	jb     804f15 <pbuf_copy_partial+0x5e>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  804f11:	29 d0                	sub    %edx,%eax
  804f13:	eb 39                	jmp    804f4e <pbuf_copy_partial+0x97>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  804f15:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  804f19:	29 c3                	sub    %eax,%ebx
  804f1b:	66 39 df             	cmp    %bx,%di
  804f1e:	0f 46 df             	cmovbe %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  804f21:	83 ec 04             	sub    $0x4,%esp
  804f24:	0f b7 d3             	movzwl %bx,%edx
  804f27:	52                   	push   %edx
  804f28:	0f b7 c0             	movzwl %ax,%eax
  804f2b:	03 46 04             	add    0x4(%esi),%eax
  804f2e:	50                   	push   %eax
  804f2f:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804f33:	03 45 0c             	add    0xc(%ebp),%eax
  804f36:	50                   	push   %eax
  804f37:	e8 aa 9c 00 00       	call   80ebe6 <memcpy>
      copied_total += buf_copy_len;
  804f3c:	66 01 5d e4          	add    %bx,-0x1c(%ebp)
      left += buf_copy_len;
  804f40:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      len -= buf_copy_len;
  804f44:	29 df                	sub    %ebx,%edi
  804f46:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  804f49:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  804f4e:	8b 36                	mov    (%esi),%esi
  804f50:	eb 0c                	jmp    804f5e <pbuf_copy_partial+0xa7>
  804f52:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804f58:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804f5e:	66 85 ff             	test   %di,%di
  804f61:	74 04                	je     804f67 <pbuf_copy_partial+0xb0>
  804f63:	85 f6                	test   %esi,%esi
  804f65:	75 9c                	jne    804f03 <pbuf_copy_partial+0x4c>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  804f67:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804f6b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804f6e:	5b                   	pop    %ebx
  804f6f:	5e                   	pop    %esi
  804f70:	5f                   	pop    %edi
  804f71:	5d                   	pop    %ebp
  804f72:	c3                   	ret    

00804f73 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  804f73:	55                   	push   %ebp
  804f74:	89 e5                	mov    %esp,%ebp
  804f76:	83 ec 14             	sub    $0x14,%esp
  804f79:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  804f7c:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  804f81:	8b 40 04             	mov    0x4(%eax),%eax
  804f84:	ff 30                	pushl  (%eax)
  804f86:	e8 8f 4f 00 00       	call   809f1a <sys_sem_signal>
}
  804f8b:	83 c4 10             	add    $0x10,%esp
  804f8e:	c9                   	leave  
  804f8f:	c3                   	ret    

00804f90 <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  804f90:	55                   	push   %ebp
  804f91:	89 e5                	mov    %esp,%ebp
  804f93:	57                   	push   %edi
  804f94:	56                   	push   %esi
  804f95:	53                   	push   %ebx
  804f96:	83 ec 0c             	sub    $0xc,%esp
  804f99:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  804f9c:	e8 7b 53 00 00       	call   80a31c <sys_arch_timeouts>
  804fa1:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  804fa3:	85 c0                	test   %eax,%eax
  804fa5:	74 06                	je     804fad <sys_mbox_fetch+0x1d>
  804fa7:	8b 00                	mov    (%eax),%eax
  804fa9:	85 c0                	test   %eax,%eax
  804fab:	75 13                	jne    804fc0 <sys_mbox_fetch+0x30>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  804fad:	83 ec 04             	sub    $0x4,%esp
  804fb0:	6a 00                	push   $0x0
  804fb2:	57                   	push   %edi
  804fb3:	ff 75 08             	pushl  0x8(%ebp)
  804fb6:	e8 ce 51 00 00       	call   80a189 <sys_arch_mbox_fetch>
  804fbb:	83 c4 10             	add    $0x10,%esp
  804fbe:	eb 5c                	jmp    80501c <sys_mbox_fetch+0x8c>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  804fc0:	8b 40 04             	mov    0x4(%eax),%eax
  804fc3:	85 c0                	test   %eax,%eax
  804fc5:	74 15                	je     804fdc <sys_mbox_fetch+0x4c>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  804fc7:	83 ec 04             	sub    $0x4,%esp
  804fca:	50                   	push   %eax
  804fcb:	57                   	push   %edi
  804fcc:	ff 75 08             	pushl  0x8(%ebp)
  804fcf:	e8 b5 51 00 00       	call   80a189 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  804fd4:	83 c4 10             	add    $0x10,%esp
  804fd7:	83 f8 ff             	cmp    $0xffffffff,%eax
  804fda:	75 29                	jne    805005 <sys_mbox_fetch+0x75>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  804fdc:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  804fde:	8b 10                	mov    (%eax),%edx
  804fe0:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  804fe2:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  804fe5:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  804fe8:	83 ec 08             	sub    $0x8,%esp
  804feb:	50                   	push   %eax
  804fec:	6a 0b                	push   $0xb
  804fee:	e8 01 f4 ff ff       	call   8043f4 <memp_free>
      if (h != NULL) {
  804ff3:	83 c4 10             	add    $0x10,%esp
  804ff6:	85 db                	test   %ebx,%ebx
  804ff8:	74 a2                	je     804f9c <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  804ffa:	83 ec 0c             	sub    $0xc,%esp
  804ffd:	56                   	push   %esi
  804ffe:	ff d3                	call   *%ebx
  805000:	83 c4 10             	add    $0x10,%esp
  805003:	eb 97                	jmp    804f9c <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  805005:	8b 0b                	mov    (%ebx),%ecx
  805007:	8b 51 04             	mov    0x4(%ecx),%edx
  80500a:	39 d0                	cmp    %edx,%eax
  80500c:	73 07                	jae    805015 <sys_mbox_fetch+0x85>
        timeouts->next->time -= time_needed;
  80500e:	29 c2                	sub    %eax,%edx
  805010:	89 51 04             	mov    %edx,0x4(%ecx)
  805013:	eb 07                	jmp    80501c <sys_mbox_fetch+0x8c>
      } else {
        timeouts->next->time = 0;
  805015:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
      }
    }
  }
}
  80501c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80501f:	5b                   	pop    %ebx
  805020:	5e                   	pop    %esi
  805021:	5f                   	pop    %edi
  805022:	5d                   	pop    %ebp
  805023:	c3                   	ret    

00805024 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  805024:	55                   	push   %ebp
  805025:	89 e5                	mov    %esp,%ebp
  805027:	57                   	push   %edi
  805028:	56                   	push   %esi
  805029:	53                   	push   %ebx
  80502a:	83 ec 0c             	sub    $0xc,%esp
  80502d:	8b 75 08             	mov    0x8(%ebp),%esi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  805030:	e8 e7 52 00 00       	call   80a31c <sys_arch_timeouts>
  805035:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  805037:	85 c0                	test   %eax,%eax
  805039:	74 06                	je     805041 <sys_sem_wait+0x1d>
  80503b:	8b 00                	mov    (%eax),%eax
  80503d:	85 c0                	test   %eax,%eax
  80503f:	75 10                	jne    805051 <sys_sem_wait+0x2d>
    sys_arch_sem_wait(sem, 0);
  805041:	83 ec 08             	sub    $0x8,%esp
  805044:	6a 00                	push   $0x0
  805046:	56                   	push   %esi
  805047:	e8 3c 4f 00 00       	call   809f88 <sys_arch_sem_wait>
  80504c:	83 c4 10             	add    $0x10,%esp
  80504f:	eb 59                	jmp    8050aa <sys_sem_wait+0x86>
  } else {
    if (timeouts->next->time > 0) {
  805051:	8b 40 04             	mov    0x4(%eax),%eax
  805054:	85 c0                	test   %eax,%eax
  805056:	74 12                	je     80506a <sys_sem_wait+0x46>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  805058:	83 ec 08             	sub    $0x8,%esp
  80505b:	50                   	push   %eax
  80505c:	56                   	push   %esi
  80505d:	e8 26 4f 00 00       	call   809f88 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  805062:	83 c4 10             	add    $0x10,%esp
  805065:	83 f8 ff             	cmp    $0xffffffff,%eax
  805068:	75 29                	jne    805093 <sys_sem_wait+0x6f>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80506a:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  80506c:	8b 10                	mov    (%eax),%edx
  80506e:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  805070:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805073:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805076:	83 ec 08             	sub    $0x8,%esp
  805079:	50                   	push   %eax
  80507a:	6a 0b                	push   $0xb
  80507c:	e8 73 f3 ff ff       	call   8043f4 <memp_free>
      if (h != NULL) {
  805081:	83 c4 10             	add    $0x10,%esp
  805084:	85 db                	test   %ebx,%ebx
  805086:	74 a8                	je     805030 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  805088:	83 ec 0c             	sub    $0xc,%esp
  80508b:	57                   	push   %edi
  80508c:	ff d3                	call   *%ebx
  80508e:	83 c4 10             	add    $0x10,%esp
  805091:	eb 9d                	jmp    805030 <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  805093:	8b 0b                	mov    (%ebx),%ecx
  805095:	8b 51 04             	mov    0x4(%ecx),%edx
  805098:	39 d0                	cmp    %edx,%eax
  80509a:	73 07                	jae    8050a3 <sys_sem_wait+0x7f>
        timeouts->next->time -= time_needed;
  80509c:	29 c2                	sub    %eax,%edx
  80509e:	89 51 04             	mov    %edx,0x4(%ecx)
  8050a1:	eb 07                	jmp    8050aa <sys_sem_wait+0x86>
      } else {
        timeouts->next->time = 0;
  8050a3:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
      }
    }
  }
}
  8050aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8050ad:	5b                   	pop    %ebx
  8050ae:	5e                   	pop    %esi
  8050af:	5f                   	pop    %edi
  8050b0:	5d                   	pop    %ebp
  8050b1:	c3                   	ret    

008050b2 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8050b2:	55                   	push   %ebp
  8050b3:	89 e5                	mov    %esp,%ebp
  8050b5:	56                   	push   %esi
  8050b6:	53                   	push   %ebx
  8050b7:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  8050ba:	83 ec 0c             	sub    $0xc,%esp
  8050bd:	6a 0b                	push   $0xb
  8050bf:	e8 da f2 ff ff       	call   80439e <memp_malloc>
  if (timeout == NULL) {
  8050c4:	83 c4 10             	add    $0x10,%esp
  8050c7:	85 c0                	test   %eax,%eax
  8050c9:	75 17                	jne    8050e2 <sys_timeout+0x30>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  8050cb:	83 ec 04             	sub    $0x4,%esp
  8050ce:	68 b9 18 81 00       	push   $0x8118b9
  8050d3:	68 c3 00 00 00       	push   $0xc3
  8050d8:	68 d6 18 81 00       	push   $0x8118d6
  8050dd:	e8 ac 92 00 00       	call   80e38e <_panic>
  8050e2:	89 c3                	mov    %eax,%ebx
    return;
  }
  timeout->next = NULL;
  8050e4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  8050ea:	8b 45 0c             	mov    0xc(%ebp),%eax
  8050ed:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  8050f0:	8b 45 10             	mov    0x10(%ebp),%eax
  8050f3:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  8050f6:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  8050f9:	e8 1e 52 00 00       	call   80a31c <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  8050fe:	85 c0                	test   %eax,%eax
  805100:	75 17                	jne    805119 <sys_timeout+0x67>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  805102:	83 ec 04             	sub    $0x4,%esp
  805105:	68 ea 18 81 00       	push   $0x8118ea
  80510a:	68 d1 00 00 00       	push   $0xd1
  80510f:	68 d6 18 81 00       	push   $0x8118d6
  805114:	e8 75 92 00 00       	call   80e38e <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  805119:	8b 08                	mov    (%eax),%ecx
  80511b:	85 c9                	test   %ecx,%ecx
  80511d:	75 04                	jne    805123 <sys_timeout+0x71>
    timeouts->next = timeout;
  80511f:	89 18                	mov    %ebx,(%eax)
    return;
  805121:	eb 37                	jmp    80515a <sys_timeout+0xa8>
  }

  if (timeouts->next->time > msecs) {
  805123:	8b 51 04             	mov    0x4(%ecx),%edx
  805126:	39 d6                	cmp    %edx,%esi
  805128:	73 0f                	jae    805139 <sys_timeout+0x87>
    timeouts->next->time -= msecs;
  80512a:	29 f2                	sub    %esi,%edx
  80512c:	89 51 04             	mov    %edx,0x4(%ecx)
    timeout->next = timeouts->next;
  80512f:	8b 10                	mov    (%eax),%edx
  805131:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  805133:	89 18                	mov    %ebx,(%eax)
  805135:	eb 23                	jmp    80515a <sys_timeout+0xa8>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
      if (t->next == NULL || t->next->time > timeout->time) {
  805137:	89 d1                	mov    %edx,%ecx
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  805139:	8b 43 04             	mov    0x4(%ebx),%eax
  80513c:	2b 41 04             	sub    0x4(%ecx),%eax
  80513f:	89 43 04             	mov    %eax,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  805142:	8b 11                	mov    (%ecx),%edx
  805144:	85 d2                	test   %edx,%edx
  805146:	74 0c                	je     805154 <sys_timeout+0xa2>
  805148:	8b 72 04             	mov    0x4(%edx),%esi
  80514b:	39 f0                	cmp    %esi,%eax
  80514d:	73 e8                	jae    805137 <sys_timeout+0x85>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  80514f:	29 c6                	sub    %eax,%esi
  805151:	89 72 04             	mov    %esi,0x4(%edx)
        }
        timeout->next = t->next;
  805154:	8b 01                	mov    (%ecx),%eax
  805156:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  805158:	89 19                	mov    %ebx,(%ecx)
        break;
      }
    }
  }
}
  80515a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80515d:	5b                   	pop    %ebx
  80515e:	5e                   	pop    %esi
  80515f:	5d                   	pop    %ebp
  805160:	c3                   	ret    

00805161 <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  805161:	55                   	push   %ebp
  805162:	89 e5                	mov    %esp,%ebp
  805164:	57                   	push   %edi
  805165:	56                   	push   %esi
  805166:	53                   	push   %ebx
  805167:	83 ec 0c             	sub    $0xc,%esp
  80516a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80516d:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  805170:	e8 a7 51 00 00       	call   80a31c <sys_arch_timeouts>

  if (timeouts == NULL) {
  805175:	85 c0                	test   %eax,%eax
  805177:	75 17                	jne    805190 <sys_untimeout+0x2f>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  805179:	83 ec 04             	sub    $0x4,%esp
  80517c:	68 08 19 81 00       	push   $0x811908
  805181:	68 00 01 00 00       	push   $0x100
  805186:	68 d6 18 81 00       	push   $0x8118d6
  80518b:	e8 fe 91 00 00       	call   80e38e <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  805190:	8b 10                	mov    (%eax),%edx
  805192:	85 d2                	test   %edx,%edx
  805194:	74 45                	je     8051db <sys_untimeout+0x7a>
  805196:	bf 00 00 00 00       	mov    $0x0,%edi
  80519b:	eb 02                	jmp    80519f <sys_untimeout+0x3e>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80519d:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  80519f:	39 5a 08             	cmp    %ebx,0x8(%edx)
  8051a2:	75 2f                	jne    8051d3 <sys_untimeout+0x72>
  8051a4:	39 72 0c             	cmp    %esi,0xc(%edx)
  8051a7:	75 2a                	jne    8051d3 <sys_untimeout+0x72>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  8051a9:	85 ff                	test   %edi,%edi
  8051ab:	75 06                	jne    8051b3 <sys_untimeout+0x52>
        timeouts->next = t->next;
  8051ad:	8b 0a                	mov    (%edx),%ecx
  8051af:	89 08                	mov    %ecx,(%eax)
  8051b1:	eb 04                	jmp    8051b7 <sys_untimeout+0x56>
      else
        prev_t->next = t->next;
  8051b3:	8b 02                	mov    (%edx),%eax
  8051b5:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  8051b7:	8b 02                	mov    (%edx),%eax
  8051b9:	85 c0                	test   %eax,%eax
  8051bb:	74 06                	je     8051c3 <sys_untimeout+0x62>
        t->next->time += t->time;
  8051bd:	8b 4a 04             	mov    0x4(%edx),%ecx
  8051c0:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  8051c3:	83 ec 08             	sub    $0x8,%esp
  8051c6:	52                   	push   %edx
  8051c7:	6a 0b                	push   $0xb
  8051c9:	e8 26 f2 ff ff       	call   8043f4 <memp_free>
      return;
  8051ce:	83 c4 10             	add    $0x10,%esp
  8051d1:	eb 08                	jmp    8051db <sys_untimeout+0x7a>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  8051d3:	8b 0a                	mov    (%edx),%ecx
  8051d5:	89 d7                	mov    %edx,%edi
  8051d7:	85 c9                	test   %ecx,%ecx
  8051d9:	75 c2                	jne    80519d <sys_untimeout+0x3c>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  8051db:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8051de:	5b                   	pop    %ebx
  8051df:	5e                   	pop    %esi
  8051e0:	5f                   	pop    %edi
  8051e1:	5d                   	pop    %ebp
  8051e2:	c3                   	ret    

008051e3 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8051e3:	55                   	push   %ebp
  8051e4:	89 e5                	mov    %esp,%ebp
  8051e6:	83 ec 18             	sub    $0x18,%esp
  8051e9:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  8051ec:	8d 4d 08             	lea    0x8(%ebp),%ecx
  8051ef:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  8051f2:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  8051f8:	85 c0                	test   %eax,%eax
  8051fa:	74 15                	je     805211 <sys_sem_wait_timeout+0x2e>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  8051fc:	83 ec 04             	sub    $0x4,%esp
  8051ff:	8d 55 f0             	lea    -0x10(%ebp),%edx
  805202:	52                   	push   %edx
  805203:	68 73 4f 80 00       	push   $0x804f73
  805208:	50                   	push   %eax
  805209:	e8 a4 fe ff ff       	call   8050b2 <sys_timeout>
  80520e:	83 c4 10             	add    $0x10,%esp
  }
  sys_sem_wait(sem);
  805211:	83 ec 0c             	sub    $0xc,%esp
  805214:	ff 75 08             	pushl  0x8(%ebp)
  805217:	e8 08 fe ff ff       	call   805024 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80521c:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  80521f:	b8 00 00 00 00       	mov    $0x0,%eax
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  805224:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  805229:	75 19                	jne    805244 <sys_sem_wait_timeout+0x61>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  80522b:	83 ec 08             	sub    $0x8,%esp
  80522e:	8d 45 f0             	lea    -0x10(%ebp),%eax
  805231:	50                   	push   %eax
  805232:	68 73 4f 80 00       	push   $0x804f73
  805237:	e8 25 ff ff ff       	call   805161 <sys_untimeout>
    return 1;
  80523c:	83 c4 10             	add    $0x10,%esp
  80523f:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  805244:	c9                   	leave  
  805245:	c3                   	ret    

00805246 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  805246:	55                   	push   %ebp
  805247:	89 e5                	mov    %esp,%ebp
  805249:	53                   	push   %ebx
  80524a:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  80524d:	6a 00                	push   $0x0
  80524f:	e8 1a 4a 00 00       	call   809c6e <sys_sem_new>
  805254:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  805256:	83 c4 08             	add    $0x8,%esp
  805259:	ff 75 08             	pushl  0x8(%ebp)
  80525c:	50                   	push   %eax
  80525d:	e8 81 ff ff ff       	call   8051e3 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  805262:	89 1c 24             	mov    %ebx,(%esp)
  805265:	e8 85 4a 00 00       	call   809cef <sys_sem_free>
}
  80526a:	83 c4 10             	add    $0x10,%esp
  80526d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805270:	c9                   	leave  
  805271:	c3                   	ret    

00805272 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  805272:	55                   	push   %ebp
  805273:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  805275:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80527a:	5d                   	pop    %ebp
  80527b:	c3                   	ret    

0080527c <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80527c:	55                   	push   %ebp
  80527d:	89 e5                	mov    %esp,%ebp
  80527f:	57                   	push   %edi
  805280:	56                   	push   %esi
  805281:	53                   	push   %ebx
  805282:	83 ec 04             	sub    $0x4,%esp
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805285:	8b 35 3c b2 b3 00    	mov    0xb3b23c,%esi
  80528b:	0f b7 0d 0c 40 81 00 	movzwl 0x81400c,%ecx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805292:	8b 3d 50 b2 b3 00    	mov    0xb3b250,%edi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805298:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80529d:	89 45 f0             	mov    %eax,-0x10(%ebp)
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  8052a0:	bb 00 10 00 00       	mov    $0x1000,%ebx
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  8052a5:	89 c8                	mov    %ecx,%eax
  8052a7:	66 83 c0 01          	add    $0x1,%ax
    port = TCP_LOCAL_PORT_RANGE_START;
  8052ab:	0f 48 c3             	cmovs  %ebx,%eax
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8052ae:	89 f2                	mov    %esi,%edx
  8052b0:	eb 0c                	jmp    8052be <tcp_new_port+0x42>
    if (pcb->local_port == port) {
  8052b2:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  8052b6:	66 39 c8             	cmp    %cx,%ax
  8052b9:	74 ea                	je     8052a5 <tcp_new_port+0x29>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8052bb:	8b 52 0c             	mov    0xc(%edx),%edx
  8052be:	85 d2                	test   %edx,%edx
  8052c0:	75 f0                	jne    8052b2 <tcp_new_port+0x36>
  8052c2:	89 fa                	mov    %edi,%edx
  8052c4:	eb 0c                	jmp    8052d2 <tcp_new_port+0x56>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  8052c6:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  8052ca:	66 39 c8             	cmp    %cx,%ax
  8052cd:	74 d6                	je     8052a5 <tcp_new_port+0x29>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8052cf:	8b 52 0c             	mov    0xc(%edx),%edx
  8052d2:	85 d2                	test   %edx,%edx
  8052d4:	75 f0                	jne    8052c6 <tcp_new_port+0x4a>
  8052d6:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8052d9:	eb 0c                	jmp    8052e7 <tcp_new_port+0x6b>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  8052db:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  8052df:	66 39 c8             	cmp    %cx,%ax
  8052e2:	74 c1                	je     8052a5 <tcp_new_port+0x29>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8052e4:	8b 52 0c             	mov    0xc(%edx),%edx
  8052e7:	85 d2                	test   %edx,%edx
  8052e9:	75 f0                	jne    8052db <tcp_new_port+0x5f>
  8052eb:	66 a3 0c 40 81 00    	mov    %ax,0x81400c
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  8052f1:	83 c4 04             	add    $0x4,%esp
  8052f4:	5b                   	pop    %ebx
  8052f5:	5e                   	pop    %esi
  8052f6:	5f                   	pop    %edi
  8052f7:	5d                   	pop    %ebp
  8052f8:	c3                   	ret    

008052f9 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8052f9:	55                   	push   %ebp
  8052fa:	89 e5                	mov    %esp,%ebp
  8052fc:	57                   	push   %edi
  8052fd:	56                   	push   %esi
  8052fe:	53                   	push   %ebx
  8052ff:	83 ec 0c             	sub    $0xc,%esp
  805302:	8b 75 08             	mov    0x8(%ebp),%esi
  805305:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  805308:	8b 55 10             	mov    0x10(%ebp),%edx
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80530b:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  80530f:	74 17                	je     805328 <tcp_bind+0x2f>
  805311:	83 ec 04             	sub    $0x4,%esp
  805314:	68 28 19 81 00       	push   $0x811928
  805319:	68 05 01 00 00       	push   $0x105
  80531e:	68 0a 1b 81 00       	push   $0x811b0a
  805323:	e8 66 90 00 00       	call   80e38e <_panic>
  805328:	89 d0                	mov    %edx,%eax

  if (port == 0) {
  80532a:	66 85 d2             	test   %dx,%dx
  80532d:	75 05                	jne    805334 <tcp_bind+0x3b>
    port = tcp_new_port();
  80532f:	e8 48 ff ff ff       	call   80527c <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805334:	8b 15 44 b2 b3 00    	mov    0xb3b244,%edx
  80533a:	eb 35                	jmp    805371 <tcp_bind+0x78>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80533c:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  805340:	75 2c                	jne    80536e <tcp_bind+0x75>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805342:	85 d2                	test   %edx,%edx
  805344:	0f 84 f3 00 00 00    	je     80543d <tcp_bind+0x144>
  80534a:	8b 0a                	mov    (%edx),%ecx
  80534c:	85 db                	test   %ebx,%ebx
  80534e:	0f 84 f0 00 00 00    	je     805444 <tcp_bind+0x14b>
  805354:	85 c9                	test   %ecx,%ecx
  805356:	0f 84 e8 00 00 00    	je     805444 <tcp_bind+0x14b>
          ip_addr_isany(ipaddr) ||
  80535c:	8b 3b                	mov    (%ebx),%edi
  80535e:	39 f9                	cmp    %edi,%ecx
  805360:	0f 84 e5 00 00 00    	je     80544b <tcp_bind+0x152>
  805366:	85 ff                	test   %edi,%edi
  805368:	0f 84 dd 00 00 00    	je     80544b <tcp_bind+0x152>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80536e:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805371:	85 d2                	test   %edx,%edx
  805373:	75 c7                	jne    80533c <tcp_bind+0x43>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805375:	8b 15 3c b2 b3 00    	mov    0xb3b23c,%edx
  80537b:	eb 35                	jmp    8053b2 <tcp_bind+0xb9>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80537d:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  805381:	75 2c                	jne    8053af <tcp_bind+0xb6>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805383:	85 d2                	test   %edx,%edx
  805385:	0f 84 c7 00 00 00    	je     805452 <tcp_bind+0x159>
  80538b:	8b 0a                	mov    (%edx),%ecx
  80538d:	85 db                	test   %ebx,%ebx
  80538f:	0f 84 c4 00 00 00    	je     805459 <tcp_bind+0x160>
  805395:	85 c9                	test   %ecx,%ecx
  805397:	0f 84 bc 00 00 00    	je     805459 <tcp_bind+0x160>
          ip_addr_isany(ipaddr) ||
  80539d:	8b 3b                	mov    (%ebx),%edi
  80539f:	39 f9                	cmp    %edi,%ecx
  8053a1:	0f 84 b9 00 00 00    	je     805460 <tcp_bind+0x167>
  8053a7:	85 ff                	test   %edi,%edi
  8053a9:	0f 84 b1 00 00 00    	je     805460 <tcp_bind+0x167>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  8053af:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  8053b2:	85 d2                	test   %edx,%edx
  8053b4:	75 c7                	jne    80537d <tcp_bind+0x84>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8053b6:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8053bc:	eb 35                	jmp    8053f3 <tcp_bind+0xfa>
    if (cpcb->local_port == port) {
  8053be:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  8053c2:	75 2c                	jne    8053f0 <tcp_bind+0xf7>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8053c4:	85 d2                	test   %edx,%edx
  8053c6:	0f 84 9b 00 00 00    	je     805467 <tcp_bind+0x16e>
  8053cc:	8b 0a                	mov    (%edx),%ecx
  8053ce:	85 db                	test   %ebx,%ebx
  8053d0:	0f 84 98 00 00 00    	je     80546e <tcp_bind+0x175>
  8053d6:	85 c9                	test   %ecx,%ecx
  8053d8:	0f 84 90 00 00 00    	je     80546e <tcp_bind+0x175>
          ip_addr_isany(ipaddr) ||
  8053de:	8b 3b                	mov    (%ebx),%edi
  8053e0:	39 f9                	cmp    %edi,%ecx
  8053e2:	0f 84 8d 00 00 00    	je     805475 <tcp_bind+0x17c>
  8053e8:	85 ff                	test   %edi,%edi
  8053ea:	0f 84 85 00 00 00    	je     805475 <tcp_bind+0x17c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8053f0:	8b 52 0c             	mov    0xc(%edx),%edx
  8053f3:	85 d2                	test   %edx,%edx
  8053f5:	75 c7                	jne    8053be <tcp_bind+0xc5>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8053f7:	8b 15 50 b2 b3 00    	mov    0xb3b250,%edx
  8053fd:	eb 0f                	jmp    80540e <tcp_bind+0x115>
    if (cpcb->local_port == port) {
  8053ff:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  805403:	75 06                	jne    80540b <tcp_bind+0x112>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  805405:	8b 3b                	mov    (%ebx),%edi
  805407:	39 3a                	cmp    %edi,(%edx)
  805409:	74 71                	je     80547c <tcp_bind+0x183>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80540b:	8b 52 0c             	mov    0xc(%edx),%edx
  80540e:	85 d2                	test   %edx,%edx
  805410:	75 ed                	jne    8053ff <tcp_bind+0x106>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  805412:	85 db                	test   %ebx,%ebx
  805414:	74 09                	je     80541f <tcp_bind+0x126>
  805416:	83 3b 00             	cmpl   $0x0,(%ebx)
  805419:	74 04                	je     80541f <tcp_bind+0x126>
    pcb->local_ip = *ipaddr;
  80541b:	8b 13                	mov    (%ebx),%edx
  80541d:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  80541f:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  805423:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  805428:	89 46 0c             	mov    %eax,0xc(%esi)
  80542b:	89 35 4c b2 b3 00    	mov    %esi,0xb3b24c
  805431:	e8 70 cd ff ff       	call   8021a6 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  805436:	b8 00 00 00 00       	mov    $0x0,%eax
  80543b:	eb 44                	jmp    805481 <tcp_bind+0x188>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80543d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805442:	eb 3d                	jmp    805481 <tcp_bind+0x188>
  805444:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805449:	eb 36                	jmp    805481 <tcp_bind+0x188>
  80544b:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805450:	eb 2f                	jmp    805481 <tcp_bind+0x188>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805452:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805457:	eb 28                	jmp    805481 <tcp_bind+0x188>
  805459:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80545e:	eb 21                	jmp    805481 <tcp_bind+0x188>
  805460:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805465:	eb 1a                	jmp    805481 <tcp_bind+0x188>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805467:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80546c:	eb 13                	jmp    805481 <tcp_bind+0x188>
  80546e:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805473:	eb 0c                	jmp    805481 <tcp_bind+0x188>
  805475:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80547a:	eb 05                	jmp    805481 <tcp_bind+0x188>
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80547c:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
  805481:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805484:	5b                   	pop    %ebx
  805485:	5e                   	pop    %esi
  805486:	5f                   	pop    %edi
  805487:	5d                   	pop    %ebp
  805488:	c3                   	ret    

00805489 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  805489:	55                   	push   %ebp
  80548a:	89 e5                	mov    %esp,%ebp
  80548c:	57                   	push   %edi
  80548d:	56                   	push   %esi
  80548e:	53                   	push   %ebx
  80548f:	83 ec 1c             	sub    $0x1c,%esp
  805492:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805495:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  805499:	74 17                	je     8054b2 <tcp_listen_with_backlog+0x29>
  80549b:	83 ec 04             	sub    $0x4,%esp
  80549e:	68 54 19 81 00       	push   $0x811954
  8054a3:	68 60 01 00 00       	push   $0x160
  8054a8:	68 0a 1b 81 00       	push   $0x811b0a
  8054ad:	e8 dc 8e 00 00       	call   80e38e <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  8054b2:	83 ec 0c             	sub    $0xc,%esp
  8054b5:	6a 03                	push   $0x3
  8054b7:	e8 e2 ee ff ff       	call   80439e <memp_malloc>
  8054bc:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  8054be:	83 c4 10             	add    $0x10,%esp
  8054c1:	85 c0                	test   %eax,%eax
  8054c3:	0f 84 d2 00 00 00    	je     80559b <tcp_listen_with_backlog+0x112>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  8054c9:	8b 43 18             	mov    0x18(%ebx),%eax
  8054cc:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  8054cf:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  8054d3:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  8054d7:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  8054de:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8054e2:	83 c8 02             	or     $0x2,%eax
  8054e5:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  8054e9:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  8054ed:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  8054f0:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  8054f4:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  8054f7:	85 db                	test   %ebx,%ebx
  8054f9:	74 04                	je     8054ff <tcp_listen_with_backlog+0x76>
  8054fb:	8b 03                	mov    (%ebx),%eax
  8054fd:	eb 05                	jmp    805504 <tcp_listen_with_backlog+0x7b>
  8054ff:	b8 00 00 00 00       	mov    $0x0,%eax
  805504:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  805506:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  80550b:	39 c3                	cmp    %eax,%ebx
  80550d:	75 0a                	jne    805519 <tcp_listen_with_backlog+0x90>
  80550f:	8b 43 0c             	mov    0xc(%ebx),%eax
  805512:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805517:	eb 4f                	jmp    805568 <tcp_listen_with_backlog+0xdf>
  805519:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80551e:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  805522:	89 df                	mov    %ebx,%edi
  805524:	eb 2c                	jmp    805552 <tcp_listen_with_backlog+0xc9>
  805526:	8b 50 0c             	mov    0xc(%eax),%edx
  805529:	39 d7                	cmp    %edx,%edi
  80552b:	0f 94 c3             	sete   %bl
  80552e:	85 d2                	test   %edx,%edx
  805530:	0f 95 c1             	setne  %cl
  805533:	84 cb                	test   %cl,%bl
  805535:	74 15                	je     80554c <tcp_listen_with_backlog+0xc3>
  805537:	89 fb                	mov    %edi,%ebx
  805539:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  80553d:	74 05                	je     805544 <tcp_listen_with_backlog+0xbb>
  80553f:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  805544:	8b 53 0c             	mov    0xc(%ebx),%edx
  805547:	89 50 0c             	mov    %edx,0xc(%eax)
  80554a:	eb 1c                	jmp    805568 <tcp_listen_with_backlog+0xdf>
  80554c:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
  805550:	89 d0                	mov    %edx,%eax
  805552:	85 c0                	test   %eax,%eax
  805554:	75 d0                	jne    805526 <tcp_listen_with_backlog+0x9d>
  805556:	89 fb                	mov    %edi,%ebx
  805558:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  80555c:	74 0a                	je     805568 <tcp_listen_with_backlog+0xdf>
  80555e:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805565:	00 00 00 
  805568:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  80556f:	83 ec 08             	sub    $0x8,%esp
  805572:	53                   	push   %ebx
  805573:	6a 02                	push   $0x2
  805575:	e8 7a ee ff ff       	call   8043f4 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  80557a:	c7 46 20 72 52 80 00 	movl   $0x805272,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  805581:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  805586:	89 46 0c             	mov    %eax,0xc(%esi)
  805589:	89 35 44 b2 b3 00    	mov    %esi,0xb3b244
  80558f:	e8 12 cc ff ff       	call   8021a6 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  805594:	83 c4 10             	add    $0x10,%esp
  805597:	89 f0                	mov    %esi,%eax
  805599:	eb 05                	jmp    8055a0 <tcp_listen_with_backlog+0x117>
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  80559b:	b8 00 00 00 00       	mov    $0x0,%eax
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  return (struct tcp_pcb *)lpcb;
}
  8055a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8055a3:	5b                   	pop    %ebx
  8055a4:	5e                   	pop    %esi
  8055a5:	5f                   	pop    %edi
  8055a6:	5d                   	pop    %ebp
  8055a7:	c3                   	ret    

008055a8 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  8055a8:	55                   	push   %ebp
  8055a9:	89 e5                	mov    %esp,%ebp
  8055ab:	56                   	push   %esi
  8055ac:	53                   	push   %ebx
  8055ad:	8b 45 08             	mov    0x8(%ebp),%eax
  8055b0:	8b 55 0c             	mov    0xc(%ebp),%edx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  8055b3:	0f b7 58 28          	movzwl 0x28(%eax),%ebx
  8055b7:	0f b7 f3             	movzwl %bx,%esi
  8055ba:	0f b7 ca             	movzwl %dx,%ecx
  8055bd:	01 f1                	add    %esi,%ecx
  8055bf:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  8055c5:	76 0e                	jbe    8055d5 <tcp_recved+0x2d>
    pcb->rcv_wnd = TCP_WND;
  8055c7:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  8055cd:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  8055d3:	eb 10                	jmp    8055e5 <tcp_recved+0x3d>
  } else {
    pcb->rcv_wnd += len;
  8055d5:	01 da                	add    %ebx,%edx
  8055d7:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  8055db:	66 3b 50 34          	cmp    0x34(%eax),%dx
  8055df:	72 04                	jb     8055e5 <tcp_recved+0x3d>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  8055e1:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  8055e5:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  8055e9:	f6 c2 03             	test   $0x3,%dl
  8055ec:	75 24                	jne    805612 <tcp_recved+0x6a>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  8055ee:	f6 c2 01             	test   $0x1,%dl
  8055f1:	74 17                	je     80560a <tcp_recved+0x62>
  8055f3:	83 e2 fe             	and    $0xfffffffe,%edx
  8055f6:	83 ca 02             	or     $0x2,%edx
  8055f9:	88 50 20             	mov    %dl,0x20(%eax)
  8055fc:	83 ec 0c             	sub    $0xc,%esp
  8055ff:	50                   	push   %eax
  805600:	e8 37 29 00 00       	call   807f3c <tcp_output>
  805605:	83 c4 10             	add    $0x10,%esp
  805608:	eb 27                	jmp    805631 <tcp_recved+0x89>
  80560a:	83 ca 01             	or     $0x1,%edx
  80560d:	88 50 20             	mov    %dl,0x20(%eax)
  805610:	eb 1f                	jmp    805631 <tcp_recved+0x89>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  805612:	f6 c2 01             	test   $0x1,%dl
  805615:	74 1a                	je     805631 <tcp_recved+0x89>
  805617:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  80561d:	76 12                	jbe    805631 <tcp_recved+0x89>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  80561f:	83 ca 02             	or     $0x2,%edx
  805622:	88 50 20             	mov    %dl,0x20(%eax)
  805625:	83 ec 0c             	sub    $0xc,%esp
  805628:	50                   	push   %eax
  805629:	e8 0e 29 00 00       	call   807f3c <tcp_output>
  80562e:	83 c4 10             	add    $0x10,%esp
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  805631:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805634:	5b                   	pop    %ebx
  805635:	5e                   	pop    %esi
  805636:	5d                   	pop    %ebp
  805637:	c3                   	ret    

00805638 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  805638:	55                   	push   %ebp
  805639:	89 e5                	mov    %esp,%ebp
  80563b:	53                   	push   %ebx
  80563c:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80563f:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  805645:	eb 5d                	jmp    8056a4 <tcp_fasttmr+0x6c>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  805647:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80564d:	85 c0                	test   %eax,%eax
  80564f:	74 32                	je     805683 <tcp_fasttmr+0x4b>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805651:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  805657:	85 d2                	test   %edx,%edx
  805659:	74 12                	je     80566d <tcp_fasttmr+0x35>
  80565b:	6a 00                	push   $0x0
  80565d:	50                   	push   %eax
  80565e:	53                   	push   %ebx
  80565f:	ff 73 18             	pushl  0x18(%ebx)
  805662:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  805664:	83 c4 10             	add    $0x10,%esp
  805667:	84 c0                	test   %al,%al
  805669:	75 18                	jne    805683 <tcp_fasttmr+0x4b>
  80566b:	eb 0c                	jmp    805679 <tcp_fasttmr+0x41>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80566d:	83 ec 0c             	sub    $0xc,%esp
  805670:	50                   	push   %eax
  805671:	e8 f1 f0 ff ff       	call   804767 <pbuf_free>
  805676:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  805679:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805680:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  805683:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  805687:	a8 01                	test   $0x1,%al
  805689:	74 16                	je     8056a1 <tcp_fasttmr+0x69>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  80568b:	83 c8 02             	or     $0x2,%eax
  80568e:	88 43 20             	mov    %al,0x20(%ebx)
  805691:	83 ec 0c             	sub    $0xc,%esp
  805694:	53                   	push   %ebx
  805695:	e8 a2 28 00 00       	call   807f3c <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80569a:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  80569e:	83 c4 10             	add    $0x10,%esp
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8056a1:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  8056a4:	85 db                	test   %ebx,%ebx
  8056a6:	75 9f                	jne    805647 <tcp_fasttmr+0xf>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  8056a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8056ab:	c9                   	leave  
  8056ac:	c3                   	ret    

008056ad <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  8056ad:	55                   	push   %ebp
  8056ae:	89 e5                	mov    %esp,%ebp
  8056b0:	56                   	push   %esi
  8056b1:	53                   	push   %ebx
  8056b2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  
  if (seg != NULL) {
  8056b5:	85 db                	test   %ebx,%ebx
  8056b7:	74 2a                	je     8056e3 <tcp_seg_free+0x36>
    if (seg->p != NULL) {
  8056b9:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  8056bc:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
    if (seg->p != NULL) {
  8056c1:	85 c0                	test   %eax,%eax
  8056c3:	74 0e                	je     8056d3 <tcp_seg_free+0x26>
      count = pbuf_free(seg->p);
  8056c5:	83 ec 0c             	sub    $0xc,%esp
  8056c8:	50                   	push   %eax
  8056c9:	e8 99 f0 ff ff       	call   804767 <pbuf_free>
  8056ce:	89 c6                	mov    %eax,%esi
  8056d0:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  8056d3:	83 ec 08             	sub    $0x8,%esp
  8056d6:	53                   	push   %ebx
  8056d7:	6a 04                	push   $0x4
  8056d9:	e8 16 ed ff ff       	call   8043f4 <memp_free>
  8056de:	83 c4 10             	add    $0x10,%esp
  8056e1:	eb 05                	jmp    8056e8 <tcp_seg_free+0x3b>
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  8056e3:	be 00 00 00 00       	mov    $0x0,%esi
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  }
  return count;
}
  8056e8:	89 f0                	mov    %esi,%eax
  8056ea:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8056ed:	5b                   	pop    %ebx
  8056ee:	5e                   	pop    %esi
  8056ef:	5d                   	pop    %ebp
  8056f0:	c3                   	ret    

008056f1 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  8056f1:	55                   	push   %ebp
  8056f2:	89 e5                	mov    %esp,%ebp
  8056f4:	56                   	push   %esi
  8056f5:	53                   	push   %ebx
  8056f6:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  8056f9:	bb 00 00 00 00       	mov    $0x0,%ebx
  struct tcp_seg *next;
  while (seg != NULL) {
  8056fe:	eb 12                	jmp    805712 <tcp_segs_free+0x21>
    next = seg->next;
  805700:	8b 30                	mov    (%eax),%esi
    count += tcp_seg_free(seg);
  805702:	83 ec 0c             	sub    $0xc,%esp
  805705:	50                   	push   %eax
  805706:	e8 a2 ff ff ff       	call   8056ad <tcp_seg_free>
  80570b:	01 c3                	add    %eax,%ebx
  80570d:	83 c4 10             	add    $0x10,%esp
    seg = next;
  805710:	89 f0                	mov    %esi,%eax
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  805712:	85 c0                	test   %eax,%eax
  805714:	75 ea                	jne    805700 <tcp_segs_free+0xf>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  805716:	89 d8                	mov    %ebx,%eax
  805718:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80571b:	5b                   	pop    %ebx
  80571c:	5e                   	pop    %esi
  80571d:	5d                   	pop    %ebp
  80571e:	c3                   	ret    

0080571f <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  80571f:	55                   	push   %ebp
  805720:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  805722:	8b 55 0c             	mov    0xc(%ebp),%edx
  805725:	8b 45 08             	mov    0x8(%ebp),%eax
  805728:	88 50 14             	mov    %dl,0x14(%eax)
}
  80572b:	5d                   	pop    %ebp
  80572c:	c3                   	ret    

0080572d <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  80572d:	55                   	push   %ebp
  80572e:	89 e5                	mov    %esp,%ebp
  805730:	53                   	push   %ebx
  805731:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  805734:	6a 04                	push   $0x4
  805736:	e8 63 ec ff ff       	call   80439e <memp_malloc>
  80573b:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  80573d:	83 c4 10             	add    $0x10,%esp
  805740:	85 c0                	test   %eax,%eax
  805742:	74 1c                	je     805760 <tcp_seg_copy+0x33>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  805744:	83 ec 04             	sub    $0x4,%esp
  805747:	6a 14                	push   $0x14
  805749:	ff 75 08             	pushl  0x8(%ebp)
  80574c:	50                   	push   %eax
  80574d:	e8 94 94 00 00       	call   80ebe6 <memcpy>
  pbuf_ref(cseg->p);
  805752:	83 c4 04             	add    $0x4,%esp
  805755:	ff 73 04             	pushl  0x4(%ebx)
  805758:	e8 81 f4 ff ff       	call   804bde <pbuf_ref>
  return cseg;
  80575d:	83 c4 10             	add    $0x10,%esp
}
  805760:	89 d8                	mov    %ebx,%eax
  805762:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805765:	c9                   	leave  
  805766:	c3                   	ret    

00805767 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  805767:	55                   	push   %ebp
  805768:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  80576a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80576d:	8b 45 08             	mov    0x8(%ebp),%eax
  805770:	89 50 18             	mov    %edx,0x18(%eax)
}
  805773:	5d                   	pop    %ebp
  805774:	c3                   	ret    

00805775 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  805775:	55                   	push   %ebp
  805776:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  805778:	8b 55 0c             	mov    0xc(%ebp),%edx
  80577b:	8b 45 08             	mov    0x8(%ebp),%eax
  80577e:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  805784:	5d                   	pop    %ebp
  805785:	c3                   	ret    

00805786 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805786:	55                   	push   %ebp
  805787:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  805789:	8b 55 0c             	mov    0xc(%ebp),%edx
  80578c:	8b 45 08             	mov    0x8(%ebp),%eax
  80578f:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  805795:	5d                   	pop    %ebp
  805796:	c3                   	ret    

00805797 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  805797:	55                   	push   %ebp
  805798:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  80579a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80579d:	8b 45 08             	mov    0x8(%ebp),%eax
  8057a0:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  8057a6:	5d                   	pop    %ebp
  8057a7:	c3                   	ret    

008057a8 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  8057a8:	55                   	push   %ebp
  8057a9:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  8057ab:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057ae:	8b 45 08             	mov    0x8(%ebp),%eax
  8057b1:	89 50 20             	mov    %edx,0x20(%eax)
}
  8057b4:	5d                   	pop    %ebp
  8057b5:	c3                   	ret    

008057b6 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  8057b6:	55                   	push   %ebp
  8057b7:	89 e5                	mov    %esp,%ebp
  8057b9:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  8057bc:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057bf:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  8057c5:	8b 55 10             	mov    0x10(%ebp),%edx
  8057c8:	88 50 31             	mov    %dl,0x31(%eax)
}
  8057cb:	5d                   	pop    %ebp
  8057cc:	c3                   	ret    

008057cd <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  8057cd:	55                   	push   %ebp
  8057ce:	89 e5                	mov    %esp,%ebp
  8057d0:	53                   	push   %ebx
  8057d1:	83 ec 04             	sub    $0x4,%esp
  8057d4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  8057d7:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  8057da:	83 f8 0a             	cmp    $0xa,%eax
  8057dd:	74 64                	je     805843 <tcp_pcb_purge+0x76>
  8057df:	83 f8 01             	cmp    $0x1,%eax
  8057e2:	76 5f                	jbe    805843 <tcp_pcb_purge+0x76>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  8057e4:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8057ea:	85 c0                	test   %eax,%eax
  8057ec:	74 16                	je     805804 <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  8057ee:	83 ec 0c             	sub    $0xc,%esp
  8057f1:	50                   	push   %eax
  8057f2:	e8 70 ef ff ff       	call   804767 <pbuf_free>
      pcb->refused_data = NULL;
  8057f7:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8057fe:	00 00 00 
  805801:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  805804:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  80580a:	83 ec 0c             	sub    $0xc,%esp
  80580d:	ff 73 7c             	pushl  0x7c(%ebx)
  805810:	e8 dc fe ff ff       	call   8056f1 <tcp_segs_free>
    pcb->ooseq = NULL;
  805815:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  80581c:	83 c4 04             	add    $0x4,%esp
  80581f:	ff 73 74             	pushl  0x74(%ebx)
  805822:	e8 ca fe ff ff       	call   8056f1 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  805827:	83 c4 04             	add    $0x4,%esp
  80582a:	ff 73 78             	pushl  0x78(%ebx)
  80582d:	e8 bf fe ff ff       	call   8056f1 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  805832:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  805839:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  805840:	83 c4 10             	add    $0x10,%esp
  }
}
  805843:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805846:	c9                   	leave  
  805847:	c3                   	ret    

00805848 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805848:	55                   	push   %ebp
  805849:	89 e5                	mov    %esp,%ebp
  80584b:	57                   	push   %edi
  80584c:	56                   	push   %esi
  80584d:	53                   	push   %ebx
  80584e:	83 ec 1c             	sub    $0x1c,%esp
  805851:	8b 45 08             	mov    0x8(%ebp),%eax
  805854:	8b 7d 0c             	mov    0xc(%ebp),%edi
  805857:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  TCP_RMV(pcblist, pcb);
  80585a:	8b 10                	mov    (%eax),%edx
  80585c:	39 fa                	cmp    %edi,%edx
  80585e:	75 07                	jne    805867 <tcp_pcb_remove+0x1f>
  805860:	8b 52 0c             	mov    0xc(%edx),%edx
  805863:	89 10                	mov    %edx,(%eax)
  805865:	eb 55                	jmp    8058bc <tcp_pcb_remove+0x74>
  805867:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80586d:	bf 00 00 00 00       	mov    $0x0,%edi
  805872:	eb 34                	jmp    8058a8 <tcp_pcb_remove+0x60>
  805874:	8b 42 0c             	mov    0xc(%edx),%eax
  805877:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  80587a:	0f 94 c1             	sete   %cl
  80587d:	89 ce                	mov    %ecx,%esi
  80587f:	85 c0                	test   %eax,%eax
  805881:	0f 95 c1             	setne  %cl
  805884:	89 f3                	mov    %esi,%ebx
  805886:	84 cb                	test   %cl,%bl
  805888:	74 17                	je     8058a1 <tcp_pcb_remove+0x59>
  80588a:	89 f8                	mov    %edi,%eax
  80588c:	84 c0                	test   %al,%al
  80588e:	74 06                	je     805896 <tcp_pcb_remove+0x4e>
  805890:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805896:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805899:	8b 40 0c             	mov    0xc(%eax),%eax
  80589c:	89 42 0c             	mov    %eax,0xc(%edx)
  80589f:	eb 1b                	jmp    8058bc <tcp_pcb_remove+0x74>
  8058a1:	bf 01 00 00 00       	mov    $0x1,%edi
  8058a6:	89 c2                	mov    %eax,%edx
  8058a8:	85 d2                	test   %edx,%edx
  8058aa:	75 c8                	jne    805874 <tcp_pcb_remove+0x2c>
  8058ac:	89 f8                	mov    %edi,%eax
  8058ae:	84 c0                	test   %al,%al
  8058b0:	74 0a                	je     8058bc <tcp_pcb_remove+0x74>
  8058b2:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  8058b9:	00 00 00 
  8058bc:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8058bf:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)

  tcp_pcb_purge(pcb);
  8058c6:	83 ec 0c             	sub    $0xc,%esp
  8058c9:	57                   	push   %edi
  8058ca:	e8 fe fe ff ff       	call   8057cd <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  8058cf:	8b 47 10             	mov    0x10(%edi),%eax
  8058d2:	83 c4 10             	add    $0x10,%esp
  8058d5:	83 f8 0a             	cmp    $0xa,%eax
  8058d8:	74 22                	je     8058fc <tcp_pcb_remove+0xb4>
  8058da:	83 f8 01             	cmp    $0x1,%eax
  8058dd:	74 1d                	je     8058fc <tcp_pcb_remove+0xb4>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  8058df:	0f b6 47 20          	movzbl 0x20(%edi),%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  8058e3:	a8 01                	test   $0x1,%al
  8058e5:	74 15                	je     8058fc <tcp_pcb_remove+0xb4>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  8058e7:	83 c8 02             	or     $0x2,%eax
  8058ea:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8058ed:	88 46 20             	mov    %al,0x20(%esi)
    tcp_output(pcb);
  8058f0:	83 ec 0c             	sub    $0xc,%esp
  8058f3:	56                   	push   %esi
  8058f4:	e8 43 26 00 00       	call   807f3c <tcp_output>
  8058f9:	83 c4 10             	add    $0x10,%esp
  }

  if (pcb->state != LISTEN) {
  8058fc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8058ff:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  805903:	74 5d                	je     805962 <tcp_pcb_remove+0x11a>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805905:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
  805909:	74 17                	je     805922 <tcp_pcb_remove+0xda>
  80590b:	83 ec 04             	sub    $0x4,%esp
  80590e:	68 1e 1b 81 00       	push   $0x811b1e
  805913:	68 b4 04 00 00       	push   $0x4b4
  805918:	68 0a 1b 81 00       	push   $0x811b0a
  80591d:	e8 6c 8a 00 00       	call   80e38e <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805922:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805925:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  805929:	74 17                	je     805942 <tcp_pcb_remove+0xfa>
  80592b:	83 ec 04             	sub    $0x4,%esp
  80592e:	68 36 1b 81 00       	push   $0x811b36
  805933:	68 b5 04 00 00       	push   $0x4b5
  805938:	68 0a 1b 81 00       	push   $0x811b0a
  80593d:	e8 4c 8a 00 00       	call   80e38e <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805942:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805945:	83 78 7c 00          	cmpl   $0x0,0x7c(%eax)
  805949:	74 17                	je     805962 <tcp_pcb_remove+0x11a>
  80594b:	83 ec 04             	sub    $0x4,%esp
  80594e:	68 4f 1b 81 00       	push   $0x811b4f
  805953:	68 b7 04 00 00       	push   $0x4b7
  805958:	68 0a 1b 81 00       	push   $0x811b0a
  80595d:	e8 2c 8a 00 00       	call   80e38e <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  805962:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805965:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  80596c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80596f:	5b                   	pop    %ebx
  805970:	5e                   	pop    %esi
  805971:	5f                   	pop    %edi
  805972:	5d                   	pop    %ebp
  805973:	c3                   	ret    

00805974 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  805974:	55                   	push   %ebp
  805975:	89 e5                	mov    %esp,%ebp
  805977:	57                   	push   %edi
  805978:	56                   	push   %esi
  805979:	53                   	push   %ebx
  80597a:	83 ec 1c             	sub    $0x1c,%esp
  80597d:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  805980:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  805984:	0f 87 37 01 00 00    	ja     805ac1 <tcp_close+0x14d>
  80598a:	8b 43 10             	mov    0x10(%ebx),%eax
  80598d:	ff 24 85 68 1b 81 00 	jmp    *0x811b68(,%eax,4)
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805994:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  805999:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80599c:	39 c3                	cmp    %eax,%ebx
  80599e:	75 0a                	jne    8059aa <tcp_close+0x36>
  8059a0:	8b 43 0c             	mov    0xc(%ebx),%eax
  8059a3:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  8059a8:	eb 5e                	jmp    805a08 <tcp_close+0x94>
  8059aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8059ad:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  8059b2:	bf 00 00 00 00       	mov    $0x0,%edi
  8059b7:	eb 39                	jmp    8059f2 <tcp_close+0x7e>
  8059b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8059bc:	8b 40 0c             	mov    0xc(%eax),%eax
  8059bf:	39 c3                	cmp    %eax,%ebx
  8059c1:	0f 94 c1             	sete   %cl
  8059c4:	89 ce                	mov    %ecx,%esi
  8059c6:	85 c0                	test   %eax,%eax
  8059c8:	0f 95 c1             	setne  %cl
  8059cb:	89 f2                	mov    %esi,%edx
  8059cd:	84 ca                	test   %cl,%dl
  8059cf:	74 19                	je     8059ea <tcp_close+0x76>
  8059d1:	89 f8                	mov    %edi,%eax
  8059d3:	84 c0                	test   %al,%al
  8059d5:	74 08                	je     8059df <tcp_close+0x6b>
  8059d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8059da:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  8059df:	8b 43 0c             	mov    0xc(%ebx),%eax
  8059e2:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8059e5:	89 47 0c             	mov    %eax,0xc(%edi)
  8059e8:	eb 1e                	jmp    805a08 <tcp_close+0x94>
  8059ea:	bf 01 00 00 00       	mov    $0x1,%edi
  8059ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8059f2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  8059f6:	75 c1                	jne    8059b9 <tcp_close+0x45>
  8059f8:	89 f8                	mov    %edi,%eax
  8059fa:	84 c0                	test   %al,%al
  8059fc:	74 0a                	je     805a08 <tcp_close+0x94>
  8059fe:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805a05:	00 00 00 
  805a08:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  805a0f:	83 ec 08             	sub    $0x8,%esp
  805a12:	53                   	push   %ebx
  805a13:	6a 02                	push   $0x2
  805a15:	e8 da e9 ff ff       	call   8043f4 <memp_free>
    pcb = NULL;
    break;
  805a1a:	83 c4 10             	add    $0x10,%esp
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  805a1d:	b8 00 00 00 00       	mov    $0x0,%eax
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  805a22:	e9 bb 00 00 00       	jmp    805ae2 <tcp_close+0x16e>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  805a27:	83 ec 08             	sub    $0x8,%esp
  805a2a:	53                   	push   %ebx
  805a2b:	68 44 b2 b3 00       	push   $0xb3b244
  805a30:	e8 13 fe ff ff       	call   805848 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  805a35:	83 c4 08             	add    $0x8,%esp
  805a38:	53                   	push   %ebx
  805a39:	6a 03                	push   $0x3
  805a3b:	e8 b4 e9 ff ff       	call   8043f4 <memp_free>
    pcb = NULL;
    break;
  805a40:	83 c4 10             	add    $0x10,%esp
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
  805a43:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  805a48:	e9 95 00 00 00       	jmp    805ae2 <tcp_close+0x16e>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805a4d:	83 ec 08             	sub    $0x8,%esp
  805a50:	53                   	push   %ebx
  805a51:	68 3c b2 b3 00       	push   $0xb3b23c
  805a56:	e8 ed fd ff ff       	call   805848 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805a5b:	83 c4 08             	add    $0x8,%esp
  805a5e:	53                   	push   %ebx
  805a5f:	6a 02                	push   $0x2
  805a61:	e8 8e e9 ff ff       	call   8043f4 <memp_free>
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  805a66:	83 c4 10             	add    $0x10,%esp
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
  805a69:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  805a6e:	eb 72                	jmp    805ae2 <tcp_close+0x16e>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805a70:	83 ec 08             	sub    $0x8,%esp
  805a73:	6a 01                	push   $0x1
  805a75:	53                   	push   %ebx
  805a76:	e8 4f 24 00 00       	call   807eca <tcp_send_ctrl>
    if (err == ERR_OK) {
  805a7b:	83 c4 10             	add    $0x10,%esp
  805a7e:	84 c0                	test   %al,%al
  805a80:	75 60                	jne    805ae2 <tcp_close+0x16e>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  805a82:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805a89:	eb 3b                	jmp    805ac6 <tcp_close+0x152>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805a8b:	83 ec 08             	sub    $0x8,%esp
  805a8e:	6a 01                	push   $0x1
  805a90:	53                   	push   %ebx
  805a91:	e8 34 24 00 00       	call   807eca <tcp_send_ctrl>
    if (err == ERR_OK) {
  805a96:	83 c4 10             	add    $0x10,%esp
  805a99:	84 c0                	test   %al,%al
  805a9b:	75 45                	jne    805ae2 <tcp_close+0x16e>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  805a9d:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805aa4:	eb 20                	jmp    805ac6 <tcp_close+0x152>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805aa6:	83 ec 08             	sub    $0x8,%esp
  805aa9:	6a 01                	push   $0x1
  805aab:	53                   	push   %ebx
  805aac:	e8 19 24 00 00       	call   807eca <tcp_send_ctrl>
    if (err == ERR_OK) {
  805ab1:	83 c4 10             	add    $0x10,%esp
  805ab4:	84 c0                	test   %al,%al
  805ab6:	75 2a                	jne    805ae2 <tcp_close+0x16e>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  805ab8:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  805abf:	eb 05                	jmp    805ac6 <tcp_close+0x152>
    }
    break;
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
    pcb = NULL;
  805ac1:	bb 00 00 00 00       	mov    $0x0,%ebx
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  805ac6:	85 db                	test   %ebx,%ebx
  805ac8:	74 13                	je     805add <tcp_close+0x169>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  805aca:	83 ec 0c             	sub    $0xc,%esp
  805acd:	53                   	push   %ebx
  805ace:	e8 69 24 00 00       	call   807f3c <tcp_output>
  805ad3:	83 c4 10             	add    $0x10,%esp
  805ad6:	b8 00 00 00 00       	mov    $0x0,%eax
  805adb:	eb 05                	jmp    805ae2 <tcp_close+0x16e>
  805add:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return err;
}
  805ae2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805ae5:	5b                   	pop    %ebx
  805ae6:	5e                   	pop    %esi
  805ae7:	5f                   	pop    %edi
  805ae8:	5d                   	pop    %ebp
  805ae9:	c3                   	ret    

00805aea <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  805aea:	55                   	push   %ebp
  805aeb:	89 e5                	mov    %esp,%ebp
  805aed:	83 ec 08             	sub    $0x8,%esp
  805af0:	8b 45 10             	mov    0x10(%ebp),%eax
  805af3:	8b 55 14             	mov    0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  805af6:	85 c0                	test   %eax,%eax
  805af8:	74 13                	je     805b0d <tcp_recv_null+0x23>
    pbuf_free(p);
  805afa:	83 ec 0c             	sub    $0xc,%esp
  805afd:	50                   	push   %eax
  805afe:	e8 64 ec ff ff       	call   804767 <pbuf_free>
  805b03:	83 c4 10             	add    $0x10,%esp
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
  805b06:	b8 00 00 00 00       	mov    $0x0,%eax
  805b0b:	eb 17                	jmp    805b24 <tcp_recv_null+0x3a>
  805b0d:	b8 00 00 00 00       	mov    $0x0,%eax
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  arg = arg;
  if (p != NULL) {
    pbuf_free(p);
  } else if (err == ERR_OK) {
  805b12:	84 d2                	test   %dl,%dl
  805b14:	75 0e                	jne    805b24 <tcp_recv_null+0x3a>
    return tcp_close(pcb);
  805b16:	83 ec 0c             	sub    $0xc,%esp
  805b19:	ff 75 0c             	pushl  0xc(%ebp)
  805b1c:	e8 53 fe ff ff       	call   805974 <tcp_close>
  805b21:	83 c4 10             	add    $0x10,%esp
  }
  return ERR_OK;
}
  805b24:	c9                   	leave  
  805b25:	c3                   	ret    

00805b26 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  805b26:	55                   	push   %ebp
  805b27:	89 e5                	mov    %esp,%ebp
  805b29:	57                   	push   %edi
  805b2a:	56                   	push   %esi
  805b2b:	53                   	push   %ebx
  805b2c:	83 ec 2c             	sub    $0x2c,%esp
  805b2f:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  805b32:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805b36:	75 21                	jne    805b59 <tcp_abort+0x33>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805b38:	83 ec 08             	sub    $0x8,%esp
  805b3b:	53                   	push   %ebx
  805b3c:	68 50 b2 b3 00       	push   $0xb3b250
  805b41:	e8 02 fd ff ff       	call   805848 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805b46:	83 c4 08             	add    $0x8,%esp
  805b49:	53                   	push   %ebx
  805b4a:	6a 02                	push   $0x2
  805b4c:	e8 a3 e8 ff ff       	call   8043f4 <memp_free>
  805b51:	83 c4 10             	add    $0x10,%esp
  805b54:	e9 d1 00 00 00       	jmp    805c2a <tcp_abort+0x104>
  } else {
    seqno = pcb->snd_nxt;
  805b59:	8b 43 54             	mov    0x54(%ebx),%eax
  805b5c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805b5f:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805b62:	85 db                	test   %ebx,%ebx
  805b64:	74 04                	je     805b6a <tcp_abort+0x44>
  805b66:	8b 03                	mov    (%ebx),%eax
  805b68:	eb 05                	jmp    805b6f <tcp_abort+0x49>
  805b6a:	b8 00 00 00 00       	mov    $0x0,%eax
  805b6f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805b72:	83 fb fc             	cmp    $0xfffffffc,%ebx
  805b75:	74 05                	je     805b7c <tcp_abort+0x56>
  805b77:	8b 43 04             	mov    0x4(%ebx),%eax
  805b7a:	eb 05                	jmp    805b81 <tcp_abort+0x5b>
  805b7c:	b8 00 00 00 00       	mov    $0x0,%eax
  805b81:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805b84:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805b88:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805b8c:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805b90:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  805b94:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  805b9a:	8b 43 18             	mov    0x18(%ebx),%eax
  805b9d:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805ba0:	83 ec 08             	sub    $0x8,%esp
  805ba3:	53                   	push   %ebx
  805ba4:	68 3c b2 b3 00       	push   $0xb3b23c
  805ba9:	e8 9a fc ff ff       	call   805848 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805bae:	8b 43 78             	mov    0x78(%ebx),%eax
  805bb1:	83 c4 10             	add    $0x10,%esp
  805bb4:	85 c0                	test   %eax,%eax
  805bb6:	74 0c                	je     805bc4 <tcp_abort+0x9e>
      tcp_segs_free(pcb->unacked);
  805bb8:	83 ec 0c             	sub    $0xc,%esp
  805bbb:	50                   	push   %eax
  805bbc:	e8 30 fb ff ff       	call   8056f1 <tcp_segs_free>
  805bc1:	83 c4 10             	add    $0x10,%esp
    }
    if (pcb->unsent != NULL) {
  805bc4:	8b 43 74             	mov    0x74(%ebx),%eax
  805bc7:	85 c0                	test   %eax,%eax
  805bc9:	74 0c                	je     805bd7 <tcp_abort+0xb1>
      tcp_segs_free(pcb->unsent);
  805bcb:	83 ec 0c             	sub    $0xc,%esp
  805bce:	50                   	push   %eax
  805bcf:	e8 1d fb ff ff       	call   8056f1 <tcp_segs_free>
  805bd4:	83 c4 10             	add    $0x10,%esp
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  805bd7:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805bda:	85 c0                	test   %eax,%eax
  805bdc:	74 0c                	je     805bea <tcp_abort+0xc4>
      tcp_segs_free(pcb->ooseq);
  805bde:	83 ec 0c             	sub    $0xc,%esp
  805be1:	50                   	push   %eax
  805be2:	e8 0a fb ff ff       	call   8056f1 <tcp_segs_free>
  805be7:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  805bea:	83 ec 08             	sub    $0x8,%esp
  805bed:	53                   	push   %ebx
  805bee:	6a 02                	push   $0x2
  805bf0:	e8 ff e7 ff ff       	call   8043f4 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805bf5:	83 c4 10             	add    $0x10,%esp
  805bf8:	85 f6                	test   %esi,%esi
  805bfa:	74 0d                	je     805c09 <tcp_abort+0xe3>
  805bfc:	83 ec 08             	sub    $0x8,%esp
  805bff:	6a fb                	push   $0xfffffffb
  805c01:	ff 75 cc             	pushl  -0x34(%ebp)
  805c04:	ff d6                	call   *%esi
  805c06:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805c09:	83 ec 08             	sub    $0x8,%esp
  805c0c:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805c10:	50                   	push   %eax
  805c11:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805c15:	50                   	push   %eax
  805c16:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805c19:	50                   	push   %eax
  805c1a:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805c1d:	50                   	push   %eax
  805c1e:	57                   	push   %edi
  805c1f:	ff 75 d4             	pushl  -0x2c(%ebp)
  805c22:	e8 8c 27 00 00       	call   8083b3 <tcp_rst>
  805c27:	83 c4 20             	add    $0x20,%esp
  }
}
  805c2a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805c2d:	5b                   	pop    %ebx
  805c2e:	5e                   	pop    %esi
  805c2f:	5f                   	pop    %edi
  805c30:	5d                   	pop    %ebp
  805c31:	c3                   	ret    

00805c32 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  805c32:	55                   	push   %ebp
  805c33:	89 e5                	mov    %esp,%ebp
  805c35:	57                   	push   %edi
  805c36:	56                   	push   %esi
  805c37:	53                   	push   %ebx
  805c38:	83 ec 1c             	sub    $0x1c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  805c3b:	83 05 40 b2 b3 00 01 	addl   $0x1,0xb3b240

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  805c42:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  805c48:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)

  ++tcp_ticks;

  /* Steps through all of the active PCBs. */
  prev = NULL;
  805c4c:	bf 00 00 00 00       	mov    $0x0,%edi
  805c51:	e9 53 03 00 00       	jmp    805fa9 <tcp_slowtmr+0x377>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805c56:	8b 43 10             	mov    0x10(%ebx),%eax
  805c59:	85 c0                	test   %eax,%eax
  805c5b:	75 17                	jne    805c74 <tcp_slowtmr+0x42>
  805c5d:	83 ec 04             	sub    $0x4,%esp
  805c60:	68 78 19 81 00       	push   $0x811978
  805c65:	68 36 02 00 00       	push   $0x236
  805c6a:	68 0a 1b 81 00       	push   $0x811b0a
  805c6f:	e8 1a 87 00 00       	call   80e38e <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805c74:	83 f8 01             	cmp    $0x1,%eax
  805c77:	75 17                	jne    805c90 <tcp_slowtmr+0x5e>
  805c79:	83 ec 04             	sub    $0x4,%esp
  805c7c:	68 a4 19 81 00       	push   $0x8119a4
  805c81:	68 37 02 00 00       	push   $0x237
  805c86:	68 0a 1b 81 00       	push   $0x811b0a
  805c8b:	e8 fe 86 00 00       	call   80e38e <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805c90:	83 f8 0a             	cmp    $0xa,%eax
  805c93:	75 17                	jne    805cac <tcp_slowtmr+0x7a>
  805c95:	83 ec 04             	sub    $0x4,%esp
  805c98:	68 d0 19 81 00       	push   $0x8119d0
  805c9d:	68 38 02 00 00       	push   $0x238
  805ca2:	68 0a 1b 81 00       	push   $0x811b0a
  805ca7:	e8 e2 86 00 00       	call   80e38e <_panic>

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805cac:	83 f8 02             	cmp    $0x2,%eax
  805caf:	75 12                	jne    805cc3 <tcp_slowtmr+0x91>
  805cb1:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805cb5:	80 fa 06             	cmp    $0x6,%dl
  805cb8:	0f 85 ac 03 00 00    	jne    80606a <tcp_slowtmr+0x438>
  805cbe:	e9 a0 01 00 00       	jmp    805e63 <tcp_slowtmr+0x231>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805cc3:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  805cc7:	be 01 00 00 00       	mov    $0x1,%esi

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805ccc:	80 fa 0c             	cmp    $0xc,%dl
  805ccf:	0f 84 ee 00 00 00    	je     805dc3 <tcp_slowtmr+0x191>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  805cd5:	0f b6 8b a4 00 00 00 	movzbl 0xa4(%ebx),%ecx
  805cdc:	84 c9                	test   %cl,%cl
  805cde:	74 54                	je     805d34 <tcp_slowtmr+0x102>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  805ce0:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  805ce6:	83 c0 01             	add    $0x1,%eax
  805ce9:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805cef:	0f b6 d1             	movzbl %cl,%edx
  805cf2:	0f b6 92 87 1b 81 00 	movzbl 0x811b87(%edx),%edx
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805cf9:	be 00 00 00 00       	mov    $0x0,%esi
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805cfe:	39 d0                	cmp    %edx,%eax
  805d00:	0f 82 bd 00 00 00    	jb     805dc3 <tcp_slowtmr+0x191>
          pcb->persist_cnt = 0;
  805d06:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  805d0d:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  805d10:	80 f9 06             	cmp    $0x6,%cl
  805d13:	77 09                	ja     805d1e <tcp_slowtmr+0xec>
            pcb->persist_backoff++;
  805d15:	83 c1 01             	add    $0x1,%ecx
  805d18:	88 8b a4 00 00 00    	mov    %cl,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  805d1e:	83 ec 0c             	sub    $0xc,%esp
  805d21:	53                   	push   %ebx
  805d22:	e8 79 29 00 00       	call   8086a0 <tcp_zero_window_probe>
  805d27:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805d2a:	be 00 00 00 00       	mov    $0x0,%esi
  805d2f:	e9 8f 00 00 00       	jmp    805dc3 <tcp_slowtmr+0x191>
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  805d34:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805d38:	66 85 c9             	test   %cx,%cx
  805d3b:	78 07                	js     805d44 <tcp_slowtmr+0x112>
          ++pcb->rtime;
  805d3d:	83 c1 01             	add    $0x1,%ecx
  805d40:	66 89 4b 32          	mov    %cx,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805d44:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805d48:	74 74                	je     805dbe <tcp_slowtmr+0x18c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805d4a:	be 00 00 00 00       	mov    $0x0,%esi
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
          ++pcb->rtime;

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805d4f:	0f b7 4b 44          	movzwl 0x44(%ebx),%ecx
  805d53:	66 39 4b 32          	cmp    %cx,0x32(%ebx)
  805d57:	7c 6a                	jl     805dc3 <tcp_slowtmr+0x191>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  805d59:	83 f8 02             	cmp    $0x2,%eax
  805d5c:	74 1f                	je     805d7d <tcp_slowtmr+0x14b>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805d5e:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805d62:	66 c1 f8 03          	sar    $0x3,%ax
  805d66:	98                   	cwtl   
  805d67:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805d6b:	01 c8                	add    %ecx,%eax
  805d6d:	0f b6 d2             	movzbl %dl,%edx
  805d70:	0f b6 8a 90 1b 81 00 	movzbl 0x811b90(%edx),%ecx
  805d77:	d3 e0                	shl    %cl,%eax
  805d79:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  805d7d:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  805d83:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  805d87:	66 39 43 5c          	cmp    %ax,0x5c(%ebx)
  805d8b:	66 0f 46 43 5c       	cmovbe 0x5c(%ebx),%ax
  805d90:	66 d1 e8             	shr    %ax
  805d93:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  805d97:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  805d9b:	66 39 d0             	cmp    %dx,%ax
  805d9e:	73 07                	jae    805da7 <tcp_slowtmr+0x175>
            pcb->ssthresh = pcb->mss * 2;
  805da0:	8d 04 12             	lea    (%edx,%edx,1),%eax
  805da3:	66 89 43 50          	mov    %ax,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  805da7:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  805dab:	83 ec 0c             	sub    $0xc,%esp
  805dae:	53                   	push   %ebx
  805daf:	e8 24 27 00 00       	call   8084d8 <tcp_rexmit_rto>
  805db4:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805db7:	be 00 00 00 00       	mov    $0x0,%esi
  805dbc:	eb 05                	jmp    805dc3 <tcp_slowtmr+0x191>
  805dbe:	be 00 00 00 00       	mov    $0x0,%esi
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  805dc3:	8b 43 10             	mov    0x10(%ebx),%eax
  805dc6:	83 f8 06             	cmp    $0x6,%eax
  805dc9:	75 21                	jne    805dec <tcp_slowtmr+0x1ba>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805dcb:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805dd0:	2b 43 2c             	sub    0x2c(%ebx),%eax
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  805dd3:	83 f8 29             	cmp    $0x29,%eax
  805dd6:	89 f0                	mov    %esi,%eax
  805dd8:	1c ff                	sbb    $0xff,%al
  805dda:	89 c6                	mov    %eax,%esi

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  805ddc:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805ddf:	85 c9                	test   %ecx,%ecx
  805de1:	0f 85 8f 00 00 00    	jne    805e76 <tcp_slowtmr+0x244>
  805de7:	e9 e6 00 00 00       	jmp    805ed2 <tcp_slowtmr+0x2a0>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  805dec:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  805df0:	74 7d                	je     805e6f <tcp_slowtmr+0x23d>
  805df2:	83 f8 04             	cmp    $0x4,%eax
  805df5:	74 05                	je     805dfc <tcp_slowtmr+0x1ca>
  805df7:	83 f8 07             	cmp    $0x7,%eax
  805dfa:	75 73                	jne    805e6f <tcp_slowtmr+0x23d>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805dfc:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805e01:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805e04:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  805e07:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805e0d:	8d 91 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%edx
  805e13:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805e18:	f7 e2                	mul    %edx
  805e1a:	c1 ea 05             	shr    $0x5,%edx
  805e1d:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805e20:	76 0e                	jbe    805e30 <tcp_slowtmr+0x1fe>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  805e22:	83 ec 0c             	sub    $0xc,%esp
  805e25:	53                   	push   %ebx
  805e26:	e8 fb fc ff ff       	call   805b26 <tcp_abort>
  805e2b:	83 c4 10             	add    $0x10,%esp
  805e2e:	eb 3f                	jmp    805e6f <tcp_slowtmr+0x23d>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  805e30:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  805e37:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  805e3d:	01 ca                	add    %ecx,%edx
  805e3f:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805e44:	f7 e2                	mul    %edx
  805e46:	c1 ea 05             	shr    $0x5,%edx
  805e49:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805e4c:	76 21                	jbe    805e6f <tcp_slowtmr+0x23d>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  805e4e:	83 ec 0c             	sub    $0xc,%esp
  805e51:	53                   	push   %ebx
  805e52:	e8 27 27 00 00       	call   80857e <tcp_keepalive>
        pcb->keep_cnt_sent++;
  805e57:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  805e5e:	83 c4 10             	add    $0x10,%esp
  805e61:	eb 0c                	jmp    805e6f <tcp_slowtmr+0x23d>
  805e63:	be 01 00 00 00       	mov    $0x1,%esi
  805e68:	eb 05                	jmp    805e6f <tcp_slowtmr+0x23d>

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805e6a:	be 01 00 00 00       	mov    $0x1,%esi

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  805e6f:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805e72:	85 c9                	test   %ecx,%ecx
  805e74:	74 29                	je     805e9f <tcp_slowtmr+0x26d>
  805e76:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  805e7c:	2b 53 2c             	sub    0x2c(%ebx),%edx
  805e7f:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  805e83:	8d 04 40             	lea    (%eax,%eax,2),%eax
  805e86:	01 c0                	add    %eax,%eax
  805e88:	39 c2                	cmp    %eax,%edx
  805e8a:	72 13                	jb     805e9f <tcp_slowtmr+0x26d>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  805e8c:	83 ec 0c             	sub    $0xc,%esp
  805e8f:	51                   	push   %ecx
  805e90:	e8 5c f8 ff ff       	call   8056f1 <tcp_segs_free>
      pcb->ooseq = NULL;
  805e95:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  805e9c:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  805e9f:	8b 43 10             	mov    0x10(%ebx),%eax
  805ea2:	83 f8 03             	cmp    $0x3,%eax
  805ea5:	75 13                	jne    805eba <tcp_slowtmr+0x288>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805ea7:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805eac:	2b 43 2c             	sub    0x2c(%ebx),%eax
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  805eaf:	83 f8 29             	cmp    $0x29,%eax
  805eb2:	89 f0                	mov    %esi,%eax
  805eb4:	1c ff                	sbb    $0xff,%al
  805eb6:	89 c6                	mov    %eax,%esi
  805eb8:	eb 18                	jmp    805ed2 <tcp_slowtmr+0x2a0>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  805eba:	83 f8 09             	cmp    $0x9,%eax
  805ebd:	75 13                	jne    805ed2 <tcp_slowtmr+0x2a0>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  805ebf:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805ec4:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805ec7:	3d f1 00 00 00       	cmp    $0xf1,%eax
  805ecc:	89 f0                	mov    %esi,%eax
  805ece:	1c ff                	sbb    $0xff,%al
  805ed0:	89 c6                	mov    %eax,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  805ed2:	89 f0                	mov    %esi,%eax
  805ed4:	84 c0                	test   %al,%al
  805ed6:	0f 84 8a 00 00 00    	je     805f66 <tcp_slowtmr+0x334>
      tcp_pcb_purge(pcb);      
  805edc:	83 ec 0c             	sub    $0xc,%esp
  805edf:	53                   	push   %ebx
  805ee0:	e8 e8 f8 ff ff       	call   8057cd <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  805ee5:	83 c4 10             	add    $0x10,%esp
  805ee8:	85 ff                	test   %edi,%edi
  805eea:	74 27                	je     805f13 <tcp_slowtmr+0x2e1>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805eec:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  805ef2:	75 17                	jne    805f0b <tcp_slowtmr+0x2d9>
  805ef4:	83 ec 04             	sub    $0x4,%esp
  805ef7:	68 00 1a 81 00       	push   $0x811a00
  805efc:	68 c1 02 00 00       	push   $0x2c1
  805f01:	68 0a 1b 81 00       	push   $0x811b0a
  805f06:	e8 83 84 00 00       	call   80e38e <_panic>
        prev->next = pcb->next;
  805f0b:	8b 43 0c             	mov    0xc(%ebx),%eax
  805f0e:	89 47 0c             	mov    %eax,0xc(%edi)
  805f11:	eb 27                	jmp    805f3a <tcp_slowtmr+0x308>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  805f13:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  805f19:	74 17                	je     805f32 <tcp_slowtmr+0x300>
  805f1b:	83 ec 04             	sub    $0x4,%esp
  805f1e:	68 2c 1a 81 00       	push   $0x811a2c
  805f23:	68 c5 02 00 00       	push   $0x2c5
  805f28:	68 0a 1b 81 00       	push   $0x811b0a
  805f2d:	e8 5c 84 00 00       	call   80e38e <_panic>
        tcp_active_pcbs = pcb->next;
  805f32:	8b 43 0c             	mov    0xc(%ebx),%eax
  805f35:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  805f3a:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  805f40:	85 c0                	test   %eax,%eax
  805f42:	74 0d                	je     805f51 <tcp_slowtmr+0x31f>
  805f44:	83 ec 08             	sub    $0x8,%esp
  805f47:	6a fb                	push   $0xfffffffb
  805f49:	ff 73 18             	pushl  0x18(%ebx)
  805f4c:	ff d0                	call   *%eax
  805f4e:	83 c4 10             	add    $0x10,%esp

      pcb2 = pcb->next;
  805f51:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  805f54:	83 ec 08             	sub    $0x8,%esp
  805f57:	53                   	push   %ebx
  805f58:	6a 02                	push   $0x2
  805f5a:	e8 95 e4 ff ff       	call   8043f4 <memp_free>
  805f5f:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  805f62:	89 f3                	mov    %esi,%ebx
  805f64:	eb 43                	jmp    805fa9 <tcp_slowtmr+0x377>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  805f66:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  805f6a:	83 c0 01             	add    $0x1,%eax
  805f6d:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  805f70:	3a 43 31             	cmp    0x31(%ebx),%al
  805f73:	72 2f                	jb     805fa4 <tcp_slowtmr+0x372>
        pcb->polltmr = 0;
  805f75:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  805f79:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  805f7f:	85 c0                	test   %eax,%eax
  805f81:	74 0f                	je     805f92 <tcp_slowtmr+0x360>
  805f83:	83 ec 08             	sub    $0x8,%esp
  805f86:	53                   	push   %ebx
  805f87:	ff 73 18             	pushl  0x18(%ebx)
  805f8a:	ff d0                	call   *%eax
  805f8c:	88 45 e3             	mov    %al,-0x1d(%ebp)
  805f8f:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  805f92:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  805f96:	75 0c                	jne    805fa4 <tcp_slowtmr+0x372>
          tcp_output(pcb);
  805f98:	83 ec 0c             	sub    $0xc,%esp
  805f9b:	53                   	push   %ebx
  805f9c:	e8 9b 1f 00 00       	call   807f3c <tcp_output>
  805fa1:	83 c4 10             	add    $0x10,%esp
        }
      }
      
      prev = pcb;
  805fa4:	89 df                	mov    %ebx,%edi
      pcb = pcb->next;
  805fa6:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  805fa9:	85 db                	test   %ebx,%ebx
  805fab:	0f 85 a5 fc ff ff    	jne    805c56 <tcp_slowtmr+0x24>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  805fb1:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
  while (pcb != NULL) {
  805fb7:	e9 a4 00 00 00       	jmp    806060 <tcp_slowtmr+0x42e>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  805fbc:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  805fc0:	74 17                	je     805fd9 <tcp_slowtmr+0x3a7>
  805fc2:	83 ec 04             	sub    $0x4,%esp
  805fc5:	68 58 1a 81 00       	push   $0x811a58
  805fca:	68 e5 02 00 00       	push   $0x2e5
  805fcf:	68 0a 1b 81 00       	push   $0x811b0a
  805fd4:	e8 b5 83 00 00       	call   80e38e <_panic>
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  805fd9:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805fde:	2b 46 2c             	sub    0x2c(%esi),%eax
  805fe1:	3d f0 00 00 00       	cmp    $0xf0,%eax
  805fe6:	76 73                	jbe    80605b <tcp_slowtmr+0x429>
      tcp_pcb_purge(pcb);      
  805fe8:	83 ec 0c             	sub    $0xc,%esp
  805feb:	56                   	push   %esi
  805fec:	e8 dc f7 ff ff       	call   8057cd <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  805ff1:	83 c4 10             	add    $0x10,%esp
  805ff4:	85 db                	test   %ebx,%ebx
  805ff6:	74 27                	je     80601f <tcp_slowtmr+0x3ed>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  805ff8:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  805ffe:	75 17                	jne    806017 <tcp_slowtmr+0x3e5>
  806000:	83 ec 04             	sub    $0x4,%esp
  806003:	68 88 1a 81 00       	push   $0x811a88
  806008:	68 f4 02 00 00       	push   $0x2f4
  80600d:	68 0a 1b 81 00       	push   $0x811b0a
  806012:	e8 77 83 00 00       	call   80e38e <_panic>
        prev->next = pcb->next;
  806017:	8b 46 0c             	mov    0xc(%esi),%eax
  80601a:	89 43 0c             	mov    %eax,0xc(%ebx)
  80601d:	eb 27                	jmp    806046 <tcp_slowtmr+0x414>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80601f:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  806025:	74 17                	je     80603e <tcp_slowtmr+0x40c>
  806027:	83 ec 04             	sub    $0x4,%esp
  80602a:	68 b0 1a 81 00       	push   $0x811ab0
  80602f:	68 f8 02 00 00       	push   $0x2f8
  806034:	68 0a 1b 81 00       	push   $0x811b0a
  806039:	e8 50 83 00 00       	call   80e38e <_panic>
        tcp_tw_pcbs = pcb->next;
  80603e:	8b 46 0c             	mov    0xc(%esi),%eax
  806041:	a3 50 b2 b3 00       	mov    %eax,0xb3b250
      }
      pcb2 = pcb->next;
  806046:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  806049:	83 ec 08             	sub    $0x8,%esp
  80604c:	56                   	push   %esi
  80604d:	6a 02                	push   $0x2
  80604f:	e8 a0 e3 ff ff       	call   8043f4 <memp_free>
  806054:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  806057:	89 fe                	mov    %edi,%esi
  806059:	eb 05                	jmp    806060 <tcp_slowtmr+0x42e>
    } else {
      prev = pcb;
  80605b:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  80605d:	8b 76 0c             	mov    0xc(%esi),%esi

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  806060:	85 f6                	test   %esi,%esi
  806062:	0f 85 54 ff ff ff    	jne    805fbc <tcp_slowtmr+0x38a>
  806068:	eb 0e                	jmp    806078 <tcp_slowtmr+0x446>

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80606a:	80 fa 0c             	cmp    $0xc,%dl
  80606d:	0f 85 62 fc ff ff    	jne    805cd5 <tcp_slowtmr+0xa3>
  806073:	e9 f2 fd ff ff       	jmp    805e6a <tcp_slowtmr+0x238>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  806078:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80607b:	5b                   	pop    %ebx
  80607c:	5e                   	pop    %esi
  80607d:	5f                   	pop    %edi
  80607e:	5d                   	pop    %ebp
  80607f:	c3                   	ret    

00806080 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  806080:	55                   	push   %ebp
  806081:	89 e5                	mov    %esp,%ebp
  806083:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  806086:	e8 ad f5 ff ff       	call   805638 <tcp_fasttmr>

  if (++tcp_timer & 1) {
  80608b:	0f b6 05 f9 43 b3 00 	movzbl 0xb343f9,%eax
  806092:	83 c0 01             	add    $0x1,%eax
  806095:	a2 f9 43 b3 00       	mov    %al,0xb343f9
  80609a:	a8 01                	test   $0x1,%al
  80609c:	74 05                	je     8060a3 <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80609e:	e8 8f fb ff ff       	call   805c32 <tcp_slowtmr>
  }
}
  8060a3:	c9                   	leave  
  8060a4:	c3                   	ret    

008060a5 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  8060a5:	55                   	push   %ebp
  8060a6:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  8060a8:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8060ad:	03 05 08 40 81 00    	add    0x814008,%eax
  8060b3:	a3 08 40 81 00       	mov    %eax,0x814008
  return iss;
}
  8060b8:	5d                   	pop    %ebp
  8060b9:	c3                   	ret    

008060ba <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  8060ba:	55                   	push   %ebp
  8060bb:	89 e5                	mov    %esp,%ebp
  8060bd:	57                   	push   %edi
  8060be:	56                   	push   %esi
  8060bf:	53                   	push   %ebx
  8060c0:	83 ec 28             	sub    $0x28,%esp
  8060c3:	0f b6 5d 08          	movzbl 0x8(%ebp),%ebx
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  8060c7:	6a 02                	push   $0x2
  8060c9:	e8 d0 e2 ff ff       	call   80439e <memp_malloc>
  8060ce:	89 c6                	mov    %eax,%esi
  if (pcb == NULL) {
  8060d0:	83 c4 10             	add    $0x10,%esp
  8060d3:	85 c0                	test   %eax,%eax
  8060d5:	0f 85 bd 00 00 00    	jne    806198 <tcp_alloc+0xde>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8060db:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8060e0:	8b 35 40 b2 b3 00    	mov    0xb3b240,%esi
tcp_kill_timewait(void)
{
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  8060e6:	b9 00 00 00 00       	mov    $0x0,%ecx
  inactive = NULL;
  8060eb:	bf 00 00 00 00       	mov    $0x0,%edi
  8060f0:	eb 10                	jmp    806102 <tcp_alloc+0x48>
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8060f2:	89 f2                	mov    %esi,%edx
  8060f4:	2b 50 2c             	sub    0x2c(%eax),%edx
  8060f7:	39 ca                	cmp    %ecx,%edx
  8060f9:	72 04                	jb     8060ff <tcp_alloc+0x45>
      inactivity = tcp_ticks - pcb->tmr;
  8060fb:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  8060fd:	89 c7                	mov    %eax,%edi
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8060ff:	8b 40 0c             	mov    0xc(%eax),%eax
  806102:	85 c0                	test   %eax,%eax
  806104:	75 ec                	jne    8060f2 <tcp_alloc+0x38>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  806106:	85 ff                	test   %edi,%edi
  806108:	74 0c                	je     806116 <tcp_alloc+0x5c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  80610a:	83 ec 0c             	sub    $0xc,%esp
  80610d:	57                   	push   %edi
  80610e:	e8 13 fa ff ff       	call   805b26 <tcp_abort>
  806113:	83 c4 10             	add    $0x10,%esp
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  806116:	83 ec 0c             	sub    $0xc,%esp
  806119:	6a 02                	push   $0x2
  80611b:	e8 7e e2 ff ff       	call   80439e <memp_malloc>
  806120:	89 c6                	mov    %eax,%esi
    if (pcb == NULL) {
  806122:	83 c4 10             	add    $0x10,%esp
  806125:	85 c0                	test   %eax,%eax
  806127:	75 6f                	jne    806198 <tcp_alloc+0xde>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806129:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80612e:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  806134:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  806139:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  inactive = NULL;
  806140:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806147:	eb 21                	jmp    80616a <tcp_alloc+0xb0>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  806149:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  80614d:	38 d3                	cmp    %dl,%bl
  80614f:	72 16                	jb     806167 <tcp_alloc+0xad>
  806151:	38 ca                	cmp    %cl,%dl
  806153:	77 12                	ja     806167 <tcp_alloc+0xad>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806155:	89 fe                	mov    %edi,%esi
  806157:	2b 70 2c             	sub    0x2c(%eax),%esi
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  80615a:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
  80615d:	72 08                	jb     806167 <tcp_alloc+0xad>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
  80615f:	89 d1                	mov    %edx,%ecx
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  806161:	89 75 e4             	mov    %esi,-0x1c(%ebp)
      inactive = pcb;
  806164:	89 45 e0             	mov    %eax,-0x20(%ebp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806167:	8b 40 0c             	mov    0xc(%eax),%eax
  80616a:	85 c0                	test   %eax,%eax
  80616c:	75 db                	jne    806149 <tcp_alloc+0x8f>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  80616e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806171:	85 c0                	test   %eax,%eax
  806173:	74 0c                	je     806181 <tcp_alloc+0xc7>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  806175:	83 ec 0c             	sub    $0xc,%esp
  806178:	50                   	push   %eax
  806179:	e8 a8 f9 ff ff       	call   805b26 <tcp_abort>
  80617e:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  806181:	83 ec 0c             	sub    $0xc,%esp
  806184:	6a 02                	push   $0x2
  806186:	e8 13 e2 ff ff       	call   80439e <memp_malloc>
  80618b:	89 c6                	mov    %eax,%esi
    }
  }
  if (pcb != NULL) {
  80618d:	83 c4 10             	add    $0x10,%esp
  806190:	85 c0                	test   %eax,%eax
  806192:	0f 84 96 00 00 00    	je     80622e <tcp_alloc+0x174>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  806198:	83 ec 04             	sub    $0x4,%esp
  80619b:	68 a8 00 00 00       	push   $0xa8
  8061a0:	6a 00                	push   $0x0
  8061a2:	56                   	push   %esi
  8061a3:	e8 89 89 00 00       	call   80eb31 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  8061a8:	c6 46 14 40          	movb   $0x40,0x14(%esi)
    pcb->snd_buf = TCP_SND_BUF;
  8061ac:	66 c7 46 6e 40 5b    	movw   $0x5b40,0x6e(%esi)
    pcb->snd_queuelen = 0;
  8061b2:	66 c7 46 70 00 00    	movw   $0x0,0x70(%esi)
    pcb->rcv_wnd = TCP_WND;
  8061b8:	66 c7 46 28 c0 5d    	movw   $0x5dc0,0x28(%esi)
    pcb->rcv_ann_wnd = TCP_WND;
  8061be:	66 c7 46 2a c0 5d    	movw   $0x5dc0,0x2a(%esi)
    pcb->tos = 0;
  8061c4:	c6 46 0a 00          	movb   $0x0,0xa(%esi)
    pcb->ttl = TCP_TTL;
  8061c8:	c6 46 0b ff          	movb   $0xff,0xb(%esi)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8061cc:	66 c7 46 34 18 02    	movw   $0x218,0x34(%esi)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  8061d2:	66 c7 46 44 06 00    	movw   $0x6,0x44(%esi)
    pcb->sa = 0;
  8061d8:	66 c7 46 40 00 00    	movw   $0x0,0x40(%esi)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  8061de:	66 c7 46 42 06 00    	movw   $0x6,0x42(%esi)
    pcb->rtime = -1;
  8061e4:	66 c7 46 32 ff ff    	movw   $0xffff,0x32(%esi)
    pcb->cwnd = 1;
  8061ea:	66 c7 46 4e 01 00    	movw   $0x1,0x4e(%esi)
    iss = tcp_next_iss();
  8061f0:	e8 b0 fe ff ff       	call   8060a5 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  8061f5:	89 46 64             	mov    %eax,0x64(%esi)
    pcb->snd_nxt = iss;
  8061f8:	89 46 54             	mov    %eax,0x54(%esi)
    pcb->snd_max = iss;
  8061fb:	89 46 58             	mov    %eax,0x58(%esi)
    pcb->lastack = iss;
  8061fe:	89 46 48             	mov    %eax,0x48(%esi)
    pcb->snd_lbb = iss;   
  806201:	89 46 68             	mov    %eax,0x68(%esi)
    pcb->tmr = tcp_ticks;
  806204:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806209:	89 46 2c             	mov    %eax,0x2c(%esi)

    pcb->polltmr = 0;
  80620c:	c6 46 30 00          	movb   $0x0,0x30(%esi)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  806210:	c7 86 88 00 00 00 ea 	movl   $0x805aea,0x88(%esi)
  806217:	5a 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  80621a:	c7 86 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%esi)
  806221:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  806224:	c6 86 a5 00 00 00 00 	movb   $0x0,0xa5(%esi)
  80622b:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80622e:	89 f0                	mov    %esi,%eax
  806230:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806233:	5b                   	pop    %ebx
  806234:	5e                   	pop    %esi
  806235:	5f                   	pop    %edi
  806236:	5d                   	pop    %ebp
  806237:	c3                   	ret    

00806238 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  806238:	55                   	push   %ebp
  806239:	89 e5                	mov    %esp,%ebp
  80623b:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  80623e:	6a 40                	push   $0x40
  806240:	e8 75 fe ff ff       	call   8060ba <tcp_alloc>
}
  806245:	c9                   	leave  
  806246:	c3                   	ret    

00806247 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  806247:	55                   	push   %ebp
  806248:	89 e5                	mov    %esp,%ebp
  80624a:	56                   	push   %esi
  80624b:	53                   	push   %ebx
  80624c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80624f:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  806251:	83 ec 0c             	sub    $0xc,%esp
  806254:	ff 75 0c             	pushl  0xc(%ebp)
  806257:	e8 00 02 00 00       	call   80645c <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  80625c:	83 c4 10             	add    $0x10,%esp
  80625f:	85 c0                	test   %eax,%eax
  806261:	74 14                	je     806277 <tcp_eff_send_mss+0x30>
  806263:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806267:	66 85 c0             	test   %ax,%ax
  80626a:	74 0b                	je     806277 <tcp_eff_send_mss+0x30>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  80626c:	83 e8 28             	sub    $0x28,%eax
  80626f:	66 39 c3             	cmp    %ax,%bx
  806272:	0f 46 c3             	cmovbe %ebx,%eax
  806275:	89 c6                	mov    %eax,%esi
  }
  return sendmss;
}
  806277:	89 f0                	mov    %esi,%eax
  806279:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80627c:	5b                   	pop    %ebx
  80627d:	5e                   	pop    %esi
  80627e:	5d                   	pop    %ebp
  80627f:	c3                   	ret    

00806280 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  806280:	55                   	push   %ebp
  806281:	89 e5                	mov    %esp,%ebp
  806283:	57                   	push   %edi
  806284:	56                   	push   %esi
  806285:	53                   	push   %ebx
  806286:	83 ec 1c             	sub    $0x1c,%esp
  806289:	8b 75 0c             	mov    0xc(%ebp),%esi
  80628c:	8b 45 10             	mov    0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80628f:	8b 7d 08             	mov    0x8(%ebp),%edi
  806292:	83 7f 10 00          	cmpl   $0x0,0x10(%edi)
  806296:	74 17                	je     8062af <tcp_connect+0x2f>
  806298:	83 ec 04             	sub    $0x4,%esp
  80629b:	68 d8 1a 81 00       	push   $0x811ad8
  8062a0:	68 ec 01 00 00       	push   $0x1ec
  8062a5:	68 0a 1b 81 00       	push   $0x811b0a
  8062aa:	e8 df 80 00 00       	call   80e38e <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  8062af:	85 f6                	test   %esi,%esi
  8062b1:	0f 84 4c 01 00 00    	je     806403 <tcp_connect+0x183>
    pcb->remote_ip = *ipaddr;
  8062b7:	8b 16                	mov    (%esi),%edx
  8062b9:	8b 7d 08             	mov    0x8(%ebp),%edi
  8062bc:	89 57 04             	mov    %edx,0x4(%edi)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  8062bf:	66 89 47 1e          	mov    %ax,0x1e(%edi)
  if (pcb->local_port == 0) {
  8062c3:	66 83 7f 1c 00       	cmpw   $0x0,0x1c(%edi)
  8062c8:	75 0c                	jne    8062d6 <tcp_connect+0x56>
    pcb->local_port = tcp_new_port();
  8062ca:	e8 ad ef ff ff       	call   80527c <tcp_new_port>
  8062cf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8062d2:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  8062d6:	e8 ca fd ff ff       	call   8060a5 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  8062db:	8b 7d 08             	mov    0x8(%ebp),%edi
  8062de:	c7 47 24 00 00 00 00 	movl   $0x0,0x24(%edi)
  pcb->snd_nxt = iss;
  8062e5:	89 47 54             	mov    %eax,0x54(%edi)
  pcb->lastack = iss - 1;
  8062e8:	83 e8 01             	sub    $0x1,%eax
  8062eb:	89 47 48             	mov    %eax,0x48(%edi)
  pcb->snd_lbb = iss - 1;
  8062ee:	89 47 68             	mov    %eax,0x68(%edi)
  pcb->rcv_wnd = TCP_WND;
  8062f1:	66 c7 47 28 c0 5d    	movw   $0x5dc0,0x28(%edi)
  pcb->rcv_ann_wnd = TCP_WND;
  8062f7:	66 c7 47 2a c0 5d    	movw   $0x5dc0,0x2a(%edi)
  pcb->snd_wnd = TCP_WND;
  8062fd:	66 c7 47 5c c0 5d    	movw   $0x5dc0,0x5c(%edi)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  806303:	66 c7 47 34 18 02    	movw   $0x218,0x34(%edi)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  806309:	83 ec 08             	sub    $0x8,%esp
  80630c:	56                   	push   %esi
  80630d:	68 18 02 00 00       	push   $0x218
  806312:	e8 30 ff ff ff       	call   806247 <tcp_eff_send_mss>
  806317:	8b 7d 08             	mov    0x8(%ebp),%edi
  80631a:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  80631e:	66 c7 47 4e 01 00    	movw   $0x1,0x4e(%edi)
  pcb->ssthresh = pcb->mss * 10;
  806324:	8d 04 80             	lea    (%eax,%eax,4),%eax
  806327:	01 c0                	add    %eax,%eax
  806329:	66 89 47 50          	mov    %ax,0x50(%edi)
  pcb->state = SYN_SENT;
  80632d:	c7 47 10 02 00 00 00 	movl   $0x2,0x10(%edi)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  806334:	8b 45 14             	mov    0x14(%ebp),%eax
  806337:	89 87 8c 00 00 00    	mov    %eax,0x8c(%edi)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80633d:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  806343:	83 c4 10             	add    $0x10,%esp
  806346:	39 d7                	cmp    %edx,%edi
  806348:	75 0a                	jne    806354 <tcp_connect+0xd4>
  80634a:	8b 47 0c             	mov    0xc(%edi),%eax
  80634d:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  806352:	eb 55                	jmp    8063a9 <tcp_connect+0x129>
  806354:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80635a:	bf 00 00 00 00       	mov    $0x0,%edi
  80635f:	eb 34                	jmp    806395 <tcp_connect+0x115>
  806361:	8b 42 0c             	mov    0xc(%edx),%eax
  806364:	39 45 08             	cmp    %eax,0x8(%ebp)
  806367:	0f 94 c1             	sete   %cl
  80636a:	89 ce                	mov    %ecx,%esi
  80636c:	85 c0                	test   %eax,%eax
  80636e:	0f 95 c1             	setne  %cl
  806371:	89 f3                	mov    %esi,%ebx
  806373:	84 cb                	test   %cl,%bl
  806375:	74 17                	je     80638e <tcp_connect+0x10e>
  806377:	89 f8                	mov    %edi,%eax
  806379:	84 c0                	test   %al,%al
  80637b:	74 06                	je     806383 <tcp_connect+0x103>
  80637d:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  806383:	8b 45 08             	mov    0x8(%ebp),%eax
  806386:	8b 40 0c             	mov    0xc(%eax),%eax
  806389:	89 42 0c             	mov    %eax,0xc(%edx)
  80638c:	eb 1b                	jmp    8063a9 <tcp_connect+0x129>
  80638e:	bf 01 00 00 00       	mov    $0x1,%edi
  806393:	89 c2                	mov    %eax,%edx
  806395:	85 d2                	test   %edx,%edx
  806397:	75 c8                	jne    806361 <tcp_connect+0xe1>
  806399:	89 f8                	mov    %edi,%eax
  80639b:	84 c0                	test   %al,%al
  80639d:	74 0a                	je     8063a9 <tcp_connect+0x129>
  80639f:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  8063a6:	00 00 00 
  TCP_REG(&tcp_active_pcbs, pcb);
  8063a9:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  8063ae:	8b 7d 08             	mov    0x8(%ebp),%edi
  8063b1:	89 47 0c             	mov    %eax,0xc(%edi)
  8063b4:	89 3d 3c b2 b3 00    	mov    %edi,0xb3b23c
  8063ba:	e8 e7 bd ff ff       	call   8021a6 <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  8063bf:	83 ec 0c             	sub    $0xc,%esp
  8063c2:	68 b4 05 04 02       	push   $0x20405b4
  8063c7:	e8 66 12 00 00       	call   807632 <htonl>
  8063cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  8063cf:	83 c4 0c             	add    $0xc,%esp
  8063d2:	6a 04                	push   $0x4
  8063d4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8063d7:	50                   	push   %eax
  8063d8:	6a 00                	push   $0x0
  8063da:	6a 02                	push   $0x2
  8063dc:	6a 00                	push   $0x0
  8063de:	6a 00                	push   $0x0
  8063e0:	ff 75 08             	pushl  0x8(%ebp)
  8063e3:	e8 7b 14 00 00       	call   807863 <tcp_enqueue>
  8063e8:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  8063ea:	83 c4 20             	add    $0x20,%esp
  8063ed:	84 c0                	test   %al,%al
  8063ef:	75 17                	jne    806408 <tcp_connect+0x188>
    tcp_output(pcb);
  8063f1:	83 ec 0c             	sub    $0xc,%esp
  8063f4:	ff 75 08             	pushl  0x8(%ebp)
  8063f7:	e8 40 1b 00 00       	call   807f3c <tcp_output>
  8063fc:	83 c4 10             	add    $0x10,%esp
  }
  return ret;
  8063ff:	89 f0                	mov    %esi,%eax
  806401:	eb 05                	jmp    806408 <tcp_connect+0x188>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  806403:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  if (ret == ERR_OK) { 
    tcp_output(pcb);
  }
  return ret;
} 
  806408:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80640b:	5b                   	pop    %ebx
  80640c:	5e                   	pop    %esi
  80640d:	5f                   	pop    %edi
  80640e:	5d                   	pop    %ebp
  80640f:	c3                   	ret    

00806410 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  806410:	55                   	push   %ebp
  806411:	89 e5                	mov    %esp,%ebp
  806413:	53                   	push   %ebx
  806414:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  806417:	8b 45 08             	mov    0x8(%ebp),%eax
  80641a:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  80641c:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  80641f:	b8 01 00 00 00       	mov    $0x1,%eax
{
  u32_t addr2test;

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806424:	83 fb fd             	cmp    $0xfffffffd,%ebx
  806427:	77 30                	ja     806459 <ip_addr_isbroadcast+0x49>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  806429:	0f b6 41 2e          	movzbl 0x2e(%ecx),%eax
  80642d:	83 e0 02             	and    $0x2,%eax
  806430:	74 27                	je     806459 <ip_addr_isbroadcast+0x49>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  806432:	8b 41 04             	mov    0x4(%ecx),%eax
  806435:	39 c2                	cmp    %eax,%edx
  806437:	74 1b                	je     806454 <ip_addr_isbroadcast+0x44>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806439:	8b 59 08             	mov    0x8(%ecx),%ebx
  80643c:	31 d0                	xor    %edx,%eax
  80643e:	89 c1                	mov    %eax,%ecx
          && ((addr2test & ~netif->netmask.addr) ==
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
  806440:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806445:	85 d9                	test   %ebx,%ecx
  806447:	75 10                	jne    806459 <ip_addr_isbroadcast+0x49>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806449:	f7 d3                	not    %ebx

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  80644b:	21 da                	and    %ebx,%edx
  80644d:	39 da                	cmp    %ebx,%edx
  80644f:	0f 94 c0             	sete   %al
  806452:	eb 05                	jmp    806459 <ip_addr_isbroadcast+0x49>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  806454:	b8 00 00 00 00       	mov    $0x0,%eax
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  806459:	5b                   	pop    %ebx
  80645a:	5d                   	pop    %ebp
  80645b:	c3                   	ret    

0080645c <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  80645c:	55                   	push   %ebp
  80645d:	89 e5                	mov    %esp,%ebp
  80645f:	56                   	push   %esi
  806460:	53                   	push   %ebx
  806461:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806464:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  80646a:	eb 1c                	jmp    806488 <ip_route+0x2c>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  80646c:	83 ec 0c             	sub    $0xc,%esp
  80646f:	53                   	push   %ebx
  806470:	e8 11 e2 ff ff       	call   804686 <netif_is_up>
  806475:	83 c4 10             	add    $0x10,%esp
  806478:	84 c0                	test   %al,%al
  80647a:	74 0a                	je     806486 <ip_route+0x2a>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  80647c:	8b 06                	mov    (%esi),%eax
  80647e:	33 43 04             	xor    0x4(%ebx),%eax
  806481:	85 43 08             	test   %eax,0x8(%ebx)
  806484:	74 2b                	je     8064b1 <ip_route+0x55>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806486:	8b 1b                	mov    (%ebx),%ebx
  806488:	85 db                	test   %ebx,%ebx
  80648a:	75 e0                	jne    80646c <ip_route+0x10>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  80648c:	a1 38 b2 b3 00       	mov    0xb3b238,%eax
  806491:	85 c0                	test   %eax,%eax
  806493:	74 1e                	je     8064b3 <ip_route+0x57>
  806495:	83 ec 0c             	sub    $0xc,%esp
  806498:	50                   	push   %eax
  806499:	e8 e8 e1 ff ff       	call   804686 <netif_is_up>
  80649e:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  8064a1:	84 c0                	test   %al,%al
  8064a3:	b8 00 00 00 00       	mov    $0x0,%eax
  8064a8:	0f 45 05 38 b2 b3 00 	cmovne 0xb3b238,%eax
  8064af:	eb 02                	jmp    8064b3 <ip_route+0x57>
  8064b1:	89 d8                	mov    %ebx,%eax
}
  8064b3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8064b6:	5b                   	pop    %ebx
  8064b7:	5e                   	pop    %esi
  8064b8:	5d                   	pop    %ebp
  8064b9:	c3                   	ret    

008064ba <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  8064ba:	55                   	push   %ebp
  8064bb:	89 e5                	mov    %esp,%ebp
  8064bd:	57                   	push   %edi
  8064be:	56                   	push   %esi
  8064bf:	53                   	push   %ebx
  8064c0:	83 ec 28             	sub    $0x28,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  8064c3:	8b 45 08             	mov    0x8(%ebp),%eax
  8064c6:	8b 70 04             	mov    0x4(%eax),%esi
  if (IPH_V(iphdr) != 4) {
  8064c9:	0f b7 06             	movzwl (%esi),%eax
  8064cc:	50                   	push   %eax
  8064cd:	e8 53 11 00 00       	call   807625 <ntohs>
  8064d2:	66 c1 e8 0c          	shr    $0xc,%ax
  8064d6:	83 c4 10             	add    $0x10,%esp
  8064d9:	66 83 f8 04          	cmp    $0x4,%ax
  8064dd:	74 13                	je     8064f2 <ip_input+0x38>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  8064df:	83 ec 0c             	sub    $0xc,%esp
  8064e2:	ff 75 08             	pushl  0x8(%ebp)
  8064e5:	e8 7d e2 ff ff       	call   804767 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  8064ea:	83 c4 10             	add    $0x10,%esp
  8064ed:	e9 bf 02 00 00       	jmp    8067b1 <ip_input+0x2f7>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  8064f2:	83 ec 0c             	sub    $0xc,%esp
  8064f5:	0f b7 06             	movzwl (%esi),%eax
  8064f8:	50                   	push   %eax
  8064f9:	e8 27 11 00 00       	call   807625 <ntohs>
  8064fe:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  806502:	83 e0 3c             	and    $0x3c,%eax
  806505:	89 c7                	mov    %eax,%edi
  806507:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  80650b:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80650f:	89 04 24             	mov    %eax,(%esp)
  806512:	e8 0e 11 00 00       	call   807625 <ntohs>
  806517:	89 c3                	mov    %eax,%ebx

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  806519:	83 c4 10             	add    $0x10,%esp
  80651c:	8b 55 08             	mov    0x8(%ebp),%edx
  80651f:	66 3b 7a 0a          	cmp    0xa(%edx),%di
  806523:	77 06                	ja     80652b <ip_input+0x71>
  806525:	66 3b 5a 08          	cmp    0x8(%edx),%bx
  806529:	76 13                	jbe    80653e <ip_input+0x84>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  80652b:	83 ec 0c             	sub    $0xc,%esp
  80652e:	ff 75 08             	pushl  0x8(%ebp)
  806531:	e8 31 e2 ff ff       	call   804767 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  806536:	83 c4 10             	add    $0x10,%esp
  806539:	e9 73 02 00 00       	jmp    8067b1 <ip_input+0x2f7>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  80653e:	83 ec 08             	sub    $0x8,%esp
  806541:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806545:	50                   	push   %eax
  806546:	56                   	push   %esi
  806547:	e8 a7 0f 00 00       	call   8074f3 <inet_chksum>
  80654c:	83 c4 10             	add    $0x10,%esp
  80654f:	66 85 c0             	test   %ax,%ax
  806552:	74 13                	je     806567 <ip_input+0xad>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  806554:	83 ec 0c             	sub    $0xc,%esp
  806557:	ff 75 08             	pushl  0x8(%ebp)
  80655a:	e8 08 e2 ff ff       	call   804767 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  80655f:	83 c4 10             	add    $0x10,%esp
  806562:	e9 4a 02 00 00       	jmp    8067b1 <ip_input+0x2f7>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  806567:	83 ec 08             	sub    $0x8,%esp
  80656a:	0f b7 db             	movzwl %bx,%ebx
  80656d:	53                   	push   %ebx
  80656e:	ff 75 08             	pushl  0x8(%ebp)
  806571:	e8 3a e5 ff ff       	call   804ab0 <pbuf_realloc>
  806576:	83 c4 10             	add    $0x10,%esp
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    netif = inp;
  806579:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  80657c:	bf 01 00 00 00       	mov    $0x1,%edi
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806581:	8d 46 10             	lea    0x10(%esi),%eax
  806584:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806587:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  80658a:	89 de                	mov    %ebx,%esi
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  80658c:	83 ec 0c             	sub    $0xc,%esp
  80658f:	53                   	push   %ebx
  806590:	e8 f1 e0 ff ff       	call   804686 <netif_is_up>
  806595:	83 c4 10             	add    $0x10,%esp
  806598:	84 c0                	test   %al,%al
  80659a:	74 27                	je     8065c3 <ip_input+0x109>
  80659c:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80659f:	74 22                	je     8065c3 <ip_input+0x109>
  8065a1:	8b 43 04             	mov    0x4(%ebx),%eax
  8065a4:	85 c0                	test   %eax,%eax
  8065a6:	74 1b                	je     8065c3 <ip_input+0x109>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  8065a8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8065ab:	3b 41 10             	cmp    0x10(%ecx),%eax
  8065ae:	74 35                	je     8065e5 <ip_input+0x12b>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  8065b0:	83 ec 08             	sub    $0x8,%esp
  8065b3:	53                   	push   %ebx
  8065b4:	ff 75 dc             	pushl  -0x24(%ebp)
  8065b7:	e8 54 fe ff ff       	call   806410 <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  8065bc:	83 c4 10             	add    $0x10,%esp
  8065bf:	84 c0                	test   %al,%al
  8065c1:	75 22                	jne    8065e5 <ip_input+0x12b>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  8065c3:	85 ff                	test   %edi,%edi
  8065c5:	74 08                	je     8065cf <ip_input+0x115>
        first = 0;
        netif = netif_list;
  8065c7:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  8065cd:	eb 02                	jmp    8065d1 <ip_input+0x117>
      } else {
        netif = netif->next;
  8065cf:	8b 1b                	mov    (%ebx),%ebx
      }
      if (netif == inp) {
  8065d1:	39 f3                	cmp    %esi,%ebx
  8065d3:	75 02                	jne    8065d7 <ip_input+0x11d>
        netif = netif->next;
  8065d5:	8b 1e                	mov    (%esi),%ebx
  8065d7:	bf 00 00 00 00       	mov    $0x0,%edi
      }
    } while(netif != NULL);
  8065dc:	85 db                	test   %ebx,%ebx
  8065de:	75 ac                	jne    80658c <ip_input+0xd2>
  8065e0:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8065e3:	eb 0b                	jmp    8065f0 <ip_input+0x136>
  8065e5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  8065e8:	85 db                	test   %ebx,%ebx
  8065ea:	0f 85 a2 01 00 00    	jne    806792 <ip_input+0x2d8>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  8065f0:	83 ec 0c             	sub    $0xc,%esp
  8065f3:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8065f7:	50                   	push   %eax
  8065f8:	e8 28 10 00 00       	call   807625 <ntohs>
  8065fd:	83 c4 10             	add    $0x10,%esp
  806600:	bb 00 00 00 00       	mov    $0x0,%ebx
  806605:	3c 11                	cmp    $0x11,%al
  806607:	0f 85 85 01 00 00    	jne    806792 <ip_input+0x2d8>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  80660d:	83 ec 0c             	sub    $0xc,%esp
  806610:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806614:	0f b7 44 06 02       	movzwl 0x2(%esi,%eax,1),%eax
  806619:	50                   	push   %eax
  80661a:	e8 06 10 00 00       	call   807625 <ntohs>
  80661f:	83 c4 10             	add    $0x10,%esp
  806622:	66 83 f8 44          	cmp    $0x44,%ax
  806626:	74 3d                	je     806665 <ip_input+0x1ab>
  806628:	e9 65 01 00 00       	jmp    806792 <ip_input+0x2d8>
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
         (ip_addr_ismulticast(&(iphdr->src)))) {
  80662d:	8b 7e 0c             	mov    0xc(%esi),%edi
  806630:	83 ec 0c             	sub    $0xc,%esp
  806633:	68 00 00 00 f0       	push   $0xf0000000
  806638:	e8 16 12 00 00       	call   807853 <ntohl>
  80663d:	21 c7                	and    %eax,%edi
  80663f:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806646:	e8 08 12 00 00       	call   807853 <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  80664b:	83 c4 10             	add    $0x10,%esp
  80664e:	39 c7                	cmp    %eax,%edi
  806650:	75 16                	jne    806668 <ip_input+0x1ae>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  806652:	83 ec 0c             	sub    $0xc,%esp
  806655:	ff 75 08             	pushl  0x8(%ebp)
  806658:	e8 0a e1 ff ff       	call   804767 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  80665d:	83 c4 10             	add    $0x10,%esp
  806660:	e9 4c 01 00 00       	jmp    8067b1 <ip_input+0x2f7>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  806665:	8b 5d 0c             	mov    0xc(%ebp),%ebx
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  806668:	85 db                	test   %ebx,%ebx
  80666a:	75 13                	jne    80667f <ip_input+0x1c5>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  80666c:	83 ec 0c             	sub    $0xc,%esp
  80666f:	ff 75 08             	pushl  0x8(%ebp)
  806672:	e8 f0 e0 ff ff       	call   804767 <pbuf_free>
    return ERR_OK;
  806677:	83 c4 10             	add    $0x10,%esp
  80667a:	e9 32 01 00 00       	jmp    8067b1 <ip_input+0x2f7>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  80667f:	0f b7 5e 06          	movzwl 0x6(%esi),%ebx
  806683:	83 ec 0c             	sub    $0xc,%esp
  806686:	68 ff 3f 00 00       	push   $0x3fff
  80668b:	e8 88 0f 00 00       	call   807618 <htons>
  806690:	83 c4 10             	add    $0x10,%esp
  806693:	66 85 c3             	test   %ax,%bx
  806696:	74 1c                	je     8066b4 <ip_input+0x1fa>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  806698:	83 ec 0c             	sub    $0xc,%esp
  80669b:	ff 75 08             	pushl  0x8(%ebp)
  80669e:	e8 18 05 00 00       	call   806bbb <ip_reass>
  8066a3:	89 45 08             	mov    %eax,0x8(%ebp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  8066a6:	83 c4 10             	add    $0x10,%esp
  8066a9:	85 c0                	test   %eax,%eax
  8066ab:	0f 84 00 01 00 00    	je     8067b1 <ip_input+0x2f7>
      return ERR_OK;
    }
    iphdr = p->payload;
  8066b1:	8b 70 04             	mov    0x4(%eax),%esi
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  8066b4:	83 ec 08             	sub    $0x8,%esp
  8066b7:	ff 75 0c             	pushl  0xc(%ebp)
  8066ba:	ff 75 08             	pushl  0x8(%ebp)
  8066bd:	e8 e0 74 00 00       	call   80dba2 <raw_input>
  8066c2:	83 c4 10             	add    $0x10,%esp
  8066c5:	84 c0                	test   %al,%al
  8066c7:	0f 85 e4 00 00 00    	jne    8067b1 <ip_input+0x2f7>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  8066cd:	83 ec 0c             	sub    $0xc,%esp
  8066d0:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8066d4:	50                   	push   %eax
  8066d5:	e8 4b 0f 00 00       	call   807625 <ntohs>
  8066da:	83 c4 10             	add    $0x10,%esp
  8066dd:	0f b6 c0             	movzbl %al,%eax
  8066e0:	66 83 f8 06          	cmp    $0x6,%ax
  8066e4:	74 24                	je     80670a <ip_input+0x250>
  8066e6:	66 83 f8 11          	cmp    $0x11,%ax
  8066ea:	74 08                	je     8066f4 <ip_input+0x23a>
  8066ec:	66 83 f8 01          	cmp    $0x1,%ax
  8066f0:	75 41                	jne    806733 <ip_input+0x279>
  8066f2:	eb 2c                	jmp    806720 <ip_input+0x266>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  8066f4:	83 ec 08             	sub    $0x8,%esp
  8066f7:	ff 75 0c             	pushl  0xc(%ebp)
  8066fa:	ff 75 08             	pushl  0x8(%ebp)
  8066fd:	e8 e5 20 00 00       	call   8087e7 <udp_input>
      break;
  806702:	83 c4 10             	add    $0x10,%esp
  806705:	e9 a7 00 00 00       	jmp    8067b1 <ip_input+0x2f7>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  80670a:	83 ec 08             	sub    $0x8,%esp
  80670d:	ff 75 0c             	pushl  0xc(%ebp)
  806710:	ff 75 08             	pushl  0x8(%ebp)
  806713:	e8 17 67 00 00       	call   80ce2f <tcp_input>
      break;
  806718:	83 c4 10             	add    $0x10,%esp
  80671b:	e9 91 00 00 00       	jmp    8067b1 <ip_input+0x2f7>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  806720:	83 ec 08             	sub    $0x8,%esp
  806723:	ff 75 0c             	pushl  0xc(%ebp)
  806726:	ff 75 08             	pushl  0x8(%ebp)
  806729:	e8 30 77 00 00       	call   80de5e <icmp_input>
      break;
  80672e:	83 c4 10             	add    $0x10,%esp
  806731:	eb 7e                	jmp    8067b1 <ip_input+0x2f7>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806733:	83 ec 08             	sub    $0x8,%esp
  806736:	ff 75 0c             	pushl  0xc(%ebp)
  806739:	8d 46 10             	lea    0x10(%esi),%eax
  80673c:	50                   	push   %eax
  80673d:	e8 ce fc ff ff       	call   806410 <ip_addr_isbroadcast>
  806742:	83 c4 10             	add    $0x10,%esp
  806745:	84 c0                	test   %al,%al
  806747:	75 39                	jne    806782 <ip_input+0x2c8>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  806749:	8b 5e 10             	mov    0x10(%esi),%ebx
  80674c:	83 ec 0c             	sub    $0xc,%esp
  80674f:	68 00 00 00 f0       	push   $0xf0000000
  806754:	e8 fa 10 00 00       	call   807853 <ntohl>
  806759:	21 c3                	and    %eax,%ebx
  80675b:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806762:	e8 ec 10 00 00       	call   807853 <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806767:	83 c4 10             	add    $0x10,%esp
  80676a:	39 c3                	cmp    %eax,%ebx
  80676c:	74 14                	je     806782 <ip_input+0x2c8>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  80676e:	8b 45 08             	mov    0x8(%ebp),%eax
  806771:	89 70 04             	mov    %esi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  806774:	83 ec 08             	sub    $0x8,%esp
  806777:	6a 02                	push   $0x2
  806779:	50                   	push   %eax
  80677a:	e8 f1 79 00 00       	call   80e170 <icmp_dest_unreach>
  80677f:	83 c4 10             	add    $0x10,%esp
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  806782:	83 ec 0c             	sub    $0xc,%esp
  806785:	ff 75 08             	pushl  0x8(%ebp)
  806788:	e8 da df ff ff       	call   804767 <pbuf_free>
  80678d:	83 c4 10             	add    $0x10,%esp
  806790:	eb 1f                	jmp    8067b1 <ip_input+0x2f7>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806792:	83 ec 08             	sub    $0x8,%esp
  806795:	ff 75 0c             	pushl  0xc(%ebp)
  806798:	8d 46 0c             	lea    0xc(%esi),%eax
  80679b:	50                   	push   %eax
  80679c:	e8 6f fc ff ff       	call   806410 <ip_addr_isbroadcast>
  8067a1:	83 c4 10             	add    $0x10,%esp
  8067a4:	84 c0                	test   %al,%al
  8067a6:	0f 84 81 fe ff ff    	je     80662d <ip_input+0x173>
  8067ac:	e9 a1 fe ff ff       	jmp    806652 <ip_input+0x198>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  8067b1:	b8 00 00 00 00       	mov    $0x0,%eax
  8067b6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8067b9:	5b                   	pop    %ebx
  8067ba:	5e                   	pop    %esi
  8067bb:	5f                   	pop    %edi
  8067bc:	5d                   	pop    %ebp
  8067bd:	c3                   	ret    

008067be <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  8067be:	55                   	push   %ebp
  8067bf:	89 e5                	mov    %esp,%ebp
  8067c1:	57                   	push   %edi
  8067c2:	56                   	push   %esi
  8067c3:	53                   	push   %ebx
  8067c4:	83 ec 1c             	sub    $0x1c,%esp
  8067c7:	8b 75 08             	mov    0x8(%ebp),%esi
  8067ca:	8b 7d 14             	mov    0x14(%ebp),%edi
  8067cd:	8b 45 18             	mov    0x18(%ebp),%eax
  8067d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8067d3:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8067d6:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  8067d9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8067dd:	0f 84 12 01 00 00    	je     8068f5 <ip_output_if+0x137>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  8067e3:	83 ec 08             	sub    $0x8,%esp
  8067e6:	6a 14                	push   $0x14
  8067e8:	56                   	push   %esi
  8067e9:	e8 a7 de ff ff       	call   804695 <pbuf_header>
  8067ee:	83 c4 10             	add    $0x10,%esp
  8067f1:	84 c0                	test   %al,%al
  8067f3:	0f 85 40 01 00 00    	jne    806939 <ip_output_if+0x17b>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  8067f9:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  8067fc:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806801:	77 17                	ja     80681a <ip_output_if+0x5c>
  806803:	83 ec 04             	sub    $0x4,%esp
  806806:	68 a8 1b 81 00       	push   $0x811ba8
  80680b:	68 ee 01 00 00       	push   $0x1ee
  806810:	68 d5 1b 81 00       	push   $0x811bd5
  806815:	e8 74 7b 00 00       	call   80e38e <_panic>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  80681a:	83 ec 0c             	sub    $0xc,%esp
  80681d:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806821:	50                   	push   %eax
  806822:	e8 fe 0d 00 00       	call   807625 <ntohs>
  806827:	0f b6 c0             	movzbl %al,%eax
  80682a:	c1 e7 08             	shl    $0x8,%edi
  80682d:	09 c7                	or     %eax,%edi
  80682f:	0f b7 ff             	movzwl %di,%edi
  806832:	89 3c 24             	mov    %edi,(%esp)
  806835:	e8 de 0d 00 00       	call   807618 <htons>
  80683a:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  80683e:	0f b7 c0             	movzwl %ax,%eax
  806841:	89 04 24             	mov    %eax,(%esp)
  806844:	e8 dc 0d 00 00       	call   807625 <ntohs>
  806849:	25 00 ff 00 00       	and    $0xff00,%eax
  80684e:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  806852:	09 d0                	or     %edx,%eax
  806854:	0f b7 c0             	movzwl %ax,%eax
  806857:	89 04 24             	mov    %eax,(%esp)
  80685a:	e8 b9 0d 00 00       	call   807618 <htons>
  80685f:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806863:	8b 45 10             	mov    0x10(%ebp),%eax
  806866:	8b 00                	mov    (%eax),%eax
  806868:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  80686b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80686f:	80 cc 45             	or     $0x45,%ah
  806872:	89 04 24             	mov    %eax,(%esp)
  806875:	e8 9e 0d 00 00       	call   807618 <htons>
  80687a:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  80687d:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806881:	89 04 24             	mov    %eax,(%esp)
  806884:	e8 8f 0d 00 00       	call   807618 <htons>
  806889:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  80688d:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806893:	0f b7 05 fa 43 b3 00 	movzwl 0xb343fa,%eax
  80689a:	89 04 24             	mov    %eax,(%esp)
  80689d:	e8 76 0d 00 00       	call   807618 <htons>
  8068a2:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  8068a6:	66 83 05 fa 43 b3 00 	addw   $0x1,0xb343fa
  8068ad:	01 

    if (ip_addr_isany(src)) {
  8068ae:	83 c4 10             	add    $0x10,%esp
  8068b1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8068b5:	74 09                	je     8068c0 <ip_output_if+0x102>
  8068b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8068ba:	8b 00                	mov    (%eax),%eax
  8068bc:	85 c0                	test   %eax,%eax
  8068be:	75 18                	jne    8068d8 <ip_output_if+0x11a>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  8068c0:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  8068c4:	74 08                	je     8068ce <ip_output_if+0x110>
  8068c6:	8b 45 20             	mov    0x20(%ebp),%eax
  8068c9:	8b 40 04             	mov    0x4(%eax),%eax
  8068cc:	eb 05                	jmp    8068d3 <ip_output_if+0x115>
  8068ce:	b8 00 00 00 00       	mov    $0x0,%eax
  8068d3:	89 43 0c             	mov    %eax,0xc(%ebx)
  8068d6:	eb 03                	jmp    8068db <ip_output_if+0x11d>
    } else {
      ip_addr_set(&(iphdr->src), src);
  8068d8:	89 43 0c             	mov    %eax,0xc(%ebx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  8068db:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8068e1:	83 ec 08             	sub    $0x8,%esp
  8068e4:	6a 14                	push   $0x14
  8068e6:	53                   	push   %ebx
  8068e7:	e8 07 0c 00 00       	call   8074f3 <inet_chksum>
  8068ec:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  8068f0:	83 c4 10             	add    $0x10,%esp
  8068f3:	eb 09                	jmp    8068fe <ip_output_if+0x140>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  8068f5:	8b 46 04             	mov    0x4(%esi),%eax
  8068f8:	83 c0 10             	add    $0x10,%eax
  8068fb:	89 45 10             	mov    %eax,0x10(%ebp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  8068fe:	8b 45 20             	mov    0x20(%ebp),%eax
  806901:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806905:	66 85 c0             	test   %ax,%ax
  806908:	74 1a                	je     806924 <ip_output_if+0x166>
  80690a:	66 3b 46 08          	cmp    0x8(%esi),%ax
  80690e:	73 14                	jae    806924 <ip_output_if+0x166>
    return ip_frag(p,netif,dest);
  806910:	83 ec 04             	sub    $0x4,%esp
  806913:	ff 75 10             	pushl  0x10(%ebp)
  806916:	ff 75 20             	pushl  0x20(%ebp)
  806919:	56                   	push   %esi
  80691a:	e8 84 07 00 00       	call   8070a3 <ip_frag>
  80691f:	83 c4 10             	add    $0x10,%esp
  806922:	eb 1a                	jmp    80693e <ip_output_if+0x180>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806924:	83 ec 04             	sub    $0x4,%esp
  806927:	ff 75 10             	pushl  0x10(%ebp)
  80692a:	56                   	push   %esi
  80692b:	ff 75 20             	pushl  0x20(%ebp)
  80692e:	8b 45 20             	mov    0x20(%ebp),%eax
  806931:	ff 50 14             	call   *0x14(%eax)
  806934:	83 c4 10             	add    $0x10,%esp
  806937:	eb 05                	jmp    80693e <ip_output_if+0x180>
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  806939:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  }
}
  80693e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806941:	5b                   	pop    %ebx
  806942:	5e                   	pop    %esi
  806943:	5f                   	pop    %edi
  806944:	5d                   	pop    %ebp
  806945:	c3                   	ret    

00806946 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806946:	55                   	push   %ebp
  806947:	89 e5                	mov    %esp,%ebp
  806949:	57                   	push   %edi
  80694a:	56                   	push   %esi
  80694b:	53                   	push   %ebx
  80694c:	83 ec 18             	sub    $0x18,%esp
  80694f:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806952:	8b 75 18             	mov    0x18(%ebp),%esi
  806955:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806958:	ff 75 10             	pushl  0x10(%ebp)
  80695b:	e8 fc fa ff ff       	call   80645c <ip_route>
  806960:	83 c4 10             	add    $0x10,%esp
  806963:	85 c0                	test   %eax,%eax
  806965:	74 27                	je     80698e <ip_output+0x48>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806967:	83 ec 04             	sub    $0x4,%esp
  80696a:	50                   	push   %eax
  80696b:	89 f8                	mov    %edi,%eax
  80696d:	0f b6 f8             	movzbl %al,%edi
  806970:	57                   	push   %edi
  806971:	89 f0                	mov    %esi,%eax
  806973:	0f b6 f0             	movzbl %al,%esi
  806976:	56                   	push   %esi
  806977:	0f b6 db             	movzbl %bl,%ebx
  80697a:	53                   	push   %ebx
  80697b:	ff 75 10             	pushl  0x10(%ebp)
  80697e:	ff 75 0c             	pushl  0xc(%ebp)
  806981:	ff 75 08             	pushl  0x8(%ebp)
  806984:	e8 35 fe ff ff       	call   8067be <ip_output_if>
  806989:	83 c4 20             	add    $0x20,%esp
  80698c:	eb 05                	jmp    806993 <ip_output+0x4d>
          u8_t ttl, u8_t tos, u8_t proto)
{
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
    return ERR_RTE;
  80698e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
}
  806993:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806996:	5b                   	pop    %ebx
  806997:	5e                   	pop    %esi
  806998:	5f                   	pop    %edi
  806999:	5d                   	pop    %ebp
  80699a:	c3                   	ret    

0080699b <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  80699b:	55                   	push   %ebp
  80699c:	89 e5                	mov    %esp,%ebp
  80699e:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  8069a1:	8b 0d e0 49 b3 00    	mov    0xb349e0,%ecx
  8069a7:	39 c1                	cmp    %eax,%ecx
  8069a9:	75 0a                	jne    8069b5 <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  8069ab:	8b 11                	mov    (%ecx),%edx
  8069ad:	89 15 e0 49 b3 00    	mov    %edx,0xb349e0
  8069b3:	eb 1f                	jmp    8069d4 <ip_reass_dequeue_datagram+0x39>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  8069b5:	85 d2                	test   %edx,%edx
  8069b7:	75 17                	jne    8069d0 <ip_reass_dequeue_datagram+0x35>
  8069b9:	83 ec 04             	sub    $0x4,%esp
  8069bc:	68 ed 1b 81 00       	push   $0x811bed
  8069c1:	68 29 01 00 00       	push   $0x129
  8069c6:	68 06 1c 81 00       	push   $0x811c06
  8069cb:	e8 be 79 00 00       	call   80e38e <_panic>
    prev->next = ipr->next;
  8069d0:	8b 08                	mov    (%eax),%ecx
  8069d2:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  8069d4:	83 ec 08             	sub    $0x8,%esp
  8069d7:	50                   	push   %eax
  8069d8:	6a 05                	push   $0x5
  8069da:	e8 15 da ff ff       	call   8043f4 <memp_free>
}
  8069df:	83 c4 10             	add    $0x10,%esp
  8069e2:	c9                   	leave  
  8069e3:	c3                   	ret    

008069e4 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  8069e4:	55                   	push   %ebp
  8069e5:	89 e5                	mov    %esp,%ebp
  8069e7:	57                   	push   %edi
  8069e8:	56                   	push   %esi
  8069e9:	53                   	push   %ebx
  8069ea:	83 ec 1c             	sub    $0x1c,%esp
  8069ed:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8069f0:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  8069f3:	39 c2                	cmp    %eax,%edx
  8069f5:	75 17                	jne    806a0e <ip_reass_free_complete_datagram+0x2a>
  8069f7:	83 ec 04             	sub    $0x4,%esp
  8069fa:	68 23 1c 81 00       	push   $0x811c23
  8069ff:	68 99 00 00 00       	push   $0x99
  806a04:	68 06 1c 81 00       	push   $0x811c06
  806a09:	e8 80 79 00 00       	call   80e38e <_panic>
  if (prev != NULL) {
  806a0e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806a11:	85 c0                	test   %eax,%eax
  806a13:	74 1e                	je     806a33 <ip_reass_free_complete_datagram+0x4f>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806a15:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806a18:	3b 10                	cmp    (%eax),%edx
  806a1a:	74 17                	je     806a33 <ip_reass_free_complete_datagram+0x4f>
  806a1c:	83 ec 04             	sub    $0x4,%esp
  806a1f:	68 2f 1c 81 00       	push   $0x811c2f
  806a24:	68 9b 00 00 00       	push   $0x9b
  806a29:	68 06 1c 81 00       	push   $0x811c06
  806a2e:	e8 5b 79 00 00       	call   80e38e <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806a33:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806a36:	8b 58 04             	mov    0x4(%eax),%ebx
  806a39:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  int pbufs_freed = 0;
  806a3c:	be 00 00 00 00       	mov    $0x0,%esi
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
  806a41:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806a46:	75 3a                	jne    806a82 <ip_reass_free_complete_datagram+0x9e>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  806a48:	8b 00                	mov    (%eax),%eax
  806a4a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806a4d:	89 41 04             	mov    %eax,0x4(%ecx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806a50:	83 ec 04             	sub    $0x4,%esp
  806a53:	6a 14                	push   $0x14
  806a55:	8d 41 08             	lea    0x8(%ecx),%eax
  806a58:	50                   	push   %eax
  806a59:	ff 73 04             	pushl  0x4(%ebx)
  806a5c:	e8 85 81 00 00       	call   80ebe6 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806a61:	83 c4 08             	add    $0x8,%esp
  806a64:	6a 01                	push   $0x1
  806a66:	53                   	push   %ebx
  806a67:	e8 e3 77 00 00       	call   80e24f <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806a6c:	89 1c 24             	mov    %ebx,(%esp)
  806a6f:	e8 52 e1 ff ff       	call   804bc6 <pbuf_clen>
  806a74:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806a77:	89 1c 24             	mov    %ebx,(%esp)
  806a7a:	e8 e8 dc ff ff       	call   804767 <pbuf_free>
  806a7f:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  806a82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806a85:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806a88:	eb 20                	jmp    806aaa <ip_reass_free_complete_datagram+0xc6>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  806a8a:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  806a8d:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806a8f:	83 ec 0c             	sub    $0xc,%esp
  806a92:	53                   	push   %ebx
  806a93:	e8 2e e1 ff ff       	call   804bc6 <pbuf_clen>
  806a98:	0f b6 c0             	movzbl %al,%eax
  806a9b:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806a9d:	89 1c 24             	mov    %ebx,(%esp)
  806aa0:	e8 c2 dc ff ff       	call   804767 <pbuf_free>
  806aa5:	83 c4 10             	add    $0x10,%esp
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  806aa8:	89 fb                	mov    %edi,%ebx
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  806aaa:	85 db                	test   %ebx,%ebx
  806aac:	75 dc                	jne    806a8a <ip_reass_free_complete_datagram+0xa6>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  806aae:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806ab1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806ab4:	e8 e2 fe ff ff       	call   80699b <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806ab9:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806ac0:	0f b7 d0             	movzwl %ax,%edx
  806ac3:	39 d6                	cmp    %edx,%esi
  806ac5:	7e 17                	jle    806ade <ip_reass_free_complete_datagram+0xfa>
  806ac7:	83 ec 04             	sub    $0x4,%esp
  806aca:	68 41 1c 81 00       	push   $0x811c41
  806acf:	68 bc 00 00 00       	push   $0xbc
  806ad4:	68 06 1c 81 00       	push   $0x811c06
  806ad9:	e8 b0 78 00 00       	call   80e38e <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  806ade:	29 f0                	sub    %esi,%eax
  806ae0:	66 a3 dc 49 b3 00    	mov    %ax,0xb349dc

  return pbufs_freed;
}
  806ae6:	89 f0                	mov    %esi,%eax
  806ae8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806aeb:	5b                   	pop    %ebx
  806aec:	5e                   	pop    %esi
  806aed:	5f                   	pop    %edi
  806aee:	5d                   	pop    %ebp
  806aef:	c3                   	ret    

00806af0 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  806af0:	55                   	push   %ebp
  806af1:	89 e5                	mov    %esp,%ebp
  806af3:	57                   	push   %edi
  806af4:	56                   	push   %esi
  806af5:	53                   	push   %ebx
  806af6:	83 ec 1c             	sub    $0x1c,%esp
  806af9:	89 c6                	mov    %eax,%esi
  806afb:	89 55 dc             	mov    %edx,-0x24(%ebp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  806afe:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  806b05:	8b 0d e0 49 b3 00    	mov    0xb349e0,%ecx
  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
  806b0b:	bb 00 00 00 00       	mov    $0x0,%ebx

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
  806b10:	ba 00 00 00 00       	mov    $0x0,%edx
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  806b15:	b8 00 00 00 00       	mov    $0x0,%eax
  806b1a:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  806b1d:	eb 39                	jmp    806b58 <ip_reass_remove_oldest_datagram+0x68>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806b1f:	8b 5e 0c             	mov    0xc(%esi),%ebx
  806b22:	39 59 14             	cmp    %ebx,0x14(%ecx)
  806b25:	75 12                	jne    806b39 <ip_reass_remove_oldest_datagram+0x49>
  806b27:	8b 7e 10             	mov    0x10(%esi),%edi
  806b2a:	39 79 18             	cmp    %edi,0x18(%ecx)
  806b2d:	75 0a                	jne    806b39 <ip_reass_remove_oldest_datagram+0x49>
  806b2f:	0f b7 7e 04          	movzwl 0x4(%esi),%edi
  806b33:	66 39 79 0c          	cmp    %di,0xc(%ecx)
  806b37:	74 16                	je     806b4f <ip_reass_remove_oldest_datagram+0x5f>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  806b39:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (oldest == NULL) {
  806b3d:	85 c0                	test   %eax,%eax
  806b3f:	74 0c                	je     806b4d <ip_reass_remove_oldest_datagram+0x5d>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
  806b41:	0f b6 58 1f          	movzbl 0x1f(%eax),%ebx
  806b45:	38 59 1f             	cmp    %bl,0x1f(%ecx)
  806b48:	0f 46 c1             	cmovbe %ecx,%eax
  806b4b:	eb 02                	jmp    806b4f <ip_reass_remove_oldest_datagram+0x5f>
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
        if (oldest == NULL) {
          oldest = r;
  806b4d:	89 c8                	mov    %ecx,%eax
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  806b4f:	8b 39                	mov    (%ecx),%edi
        prev = r;
  806b51:	85 ff                	test   %edi,%edi
  806b53:	0f 45 d1             	cmovne %ecx,%edx
  806b56:	89 f9                	mov    %edi,%ecx
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  806b58:	85 c9                	test   %ecx,%ecx
  806b5a:	75 c3                	jne    806b1f <ip_reass_remove_oldest_datagram+0x2f>
  806b5c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  806b5f:	85 c0                	test   %eax,%eax
  806b61:	74 08                	je     806b6b <ip_reass_remove_oldest_datagram+0x7b>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806b63:	e8 7c fe ff ff       	call   8069e4 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806b68:	01 45 e0             	add    %eax,-0x20(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806b6b:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806b6e:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  806b71:	7d 05                	jge    806b78 <ip_reass_remove_oldest_datagram+0x88>
  806b73:	83 fb 01             	cmp    $0x1,%ebx
  806b76:	7f 8d                	jg     806b05 <ip_reass_remove_oldest_datagram+0x15>
  return pbufs_freed;
}
  806b78:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806b7b:	83 c4 1c             	add    $0x1c,%esp
  806b7e:	5b                   	pop    %ebx
  806b7f:	5e                   	pop    %esi
  806b80:	5f                   	pop    %edi
  806b81:	5d                   	pop    %ebp
  806b82:	c3                   	ret    

00806b83 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  806b83:	55                   	push   %ebp
  806b84:	89 e5                	mov    %esp,%ebp
  806b86:	56                   	push   %esi
  806b87:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  806b88:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;
  806b8d:	bb 00 00 00 00       	mov    $0x0,%ebx

  r = reassdatagrams;
  while (r != NULL) {
  806b92:	eb 1f                	jmp    806bb3 <ip_reass_tmr+0x30>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  806b94:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  806b98:	84 d2                	test   %dl,%dl
  806b9a:	74 0c                	je     806ba8 <ip_reass_tmr+0x25>
      r->timer--;
  806b9c:	83 ea 01             	sub    $0x1,%edx
  806b9f:	88 50 1f             	mov    %dl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  806ba2:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806ba4:	8b 00                	mov    (%eax),%eax
  806ba6:	eb 0b                	jmp    806bb3 <ip_reass_tmr+0x30>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  806ba8:	8b 30                	mov    (%eax),%esi
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  806baa:	89 da                	mov    %ebx,%edx
  806bac:	e8 33 fe ff ff       	call   8069e4 <ip_reass_free_complete_datagram>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  806bb1:	89 f0                	mov    %esi,%eax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  806bb3:	85 c0                	test   %eax,%eax
  806bb5:	75 dd                	jne    806b94 <ip_reass_tmr+0x11>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  806bb7:	5b                   	pop    %ebx
  806bb8:	5e                   	pop    %esi
  806bb9:	5d                   	pop    %ebp
  806bba:	c3                   	ret    

00806bbb <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806bbb:	55                   	push   %ebp
  806bbc:	89 e5                	mov    %esp,%ebp
  806bbe:	57                   	push   %edi
  806bbf:	56                   	push   %esi
  806bc0:	53                   	push   %ebx
  806bc1:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806bc4:	8b 45 08             	mov    0x8(%ebp),%eax
  806bc7:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806bca:	0f b7 03             	movzwl (%ebx),%eax
  806bcd:	50                   	push   %eax
  806bce:	e8 52 0a 00 00       	call   807625 <ntohs>
  806bd3:	66 c1 e8 08          	shr    $0x8,%ax
  806bd7:	83 e0 0f             	and    $0xf,%eax
  806bda:	83 c4 10             	add    $0x10,%esp
  806bdd:	83 f8 05             	cmp    $0x5,%eax
  806be0:	0f 85 71 04 00 00    	jne    807057 <ip_reass+0x49c>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806be6:	83 ec 0c             	sub    $0xc,%esp
  806be9:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806bed:	50                   	push   %eax
  806bee:	e8 32 0a 00 00       	call   807625 <ntohs>
  806bf3:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806bf7:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806bfb:	89 04 24             	mov    %eax,(%esp)
  806bfe:	e8 22 0a 00 00       	call   807625 <ntohs>
  806c03:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  806c07:	0f b7 03             	movzwl (%ebx),%eax
  806c0a:	89 04 24             	mov    %eax,(%esp)
  806c0d:	e8 13 0a 00 00       	call   807625 <ntohs>
  806c12:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806c16:	83 c4 04             	add    $0x4,%esp
  806c19:	ff 75 08             	pushl  0x8(%ebp)
  806c1c:	e8 a5 df ff ff       	call   804bc6 <pbuf_clen>
  806c21:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806c24:	0f b6 f0             	movzbl %al,%esi
  806c27:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806c2e:	01 f0                	add    %esi,%eax
  806c30:	83 c4 10             	add    $0x10,%esp
  806c33:	83 f8 0a             	cmp    $0xa,%eax
  806c36:	7e 23                	jle    806c5b <ip_reass+0xa0>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806c38:	89 f2                	mov    %esi,%edx
  806c3a:	89 d8                	mov    %ebx,%eax
  806c3c:	e8 af fe ff ff       	call   806af0 <ip_reass_remove_oldest_datagram>
  806c41:	85 c0                	test   %eax,%eax
  806c43:	0f 84 0e 04 00 00    	je     807057 <ip_reass+0x49c>
  806c49:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806c50:	01 f0                	add    %esi,%eax
  806c52:	83 f8 0a             	cmp    $0xa,%eax
  806c55:	0f 8f fc 03 00 00    	jg     807057 <ip_reass+0x49c>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806c5b:	8b 3d e0 49 b3 00    	mov    0xb349e0,%edi
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  806c61:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806c66:	eb 1e                	jmp    806c86 <ip_reass+0xcb>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806c68:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806c6b:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806c6e:	75 12                	jne    806c82 <ip_reass+0xc7>
  806c70:	8b 53 10             	mov    0x10(%ebx),%edx
  806c73:	39 57 18             	cmp    %edx,0x18(%edi)
  806c76:	75 0a                	jne    806c82 <ip_reass+0xc7>
  806c78:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  806c7c:	66 39 4f 0c          	cmp    %cx,0xc(%edi)
  806c80:	74 7f                	je     806d01 <ip_reass+0x146>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806c82:	89 f8                	mov    %edi,%eax
  806c84:	8b 3f                	mov    (%edi),%edi
  806c86:	85 ff                	test   %edi,%edi
  806c88:	75 de                	jne    806c68 <ip_reass+0xad>
  806c8a:	89 45 e0             	mov    %eax,-0x20(%ebp)
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  806c8d:	83 ec 0c             	sub    $0xc,%esp
  806c90:	6a 05                	push   $0x5
  806c92:	e8 07 d7 ff ff       	call   80439e <memp_malloc>
  806c97:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  806c99:	83 c4 10             	add    $0x10,%esp
  806c9c:	85 c0                	test   %eax,%eax
  806c9e:	75 28                	jne    806cc8 <ip_reass+0x10d>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  806ca0:	89 f2                	mov    %esi,%edx
  806ca2:	89 d8                	mov    %ebx,%eax
  806ca4:	e8 47 fe ff ff       	call   806af0 <ip_reass_remove_oldest_datagram>
  806ca9:	39 c6                	cmp    %eax,%esi
  806cab:	0f 8f a6 03 00 00    	jg     807057 <ip_reass+0x49c>
      ipr = memp_malloc(MEMP_REASSDATA);
  806cb1:	83 ec 0c             	sub    $0xc,%esp
  806cb4:	6a 05                	push   $0x5
  806cb6:	e8 e3 d6 ff ff       	call   80439e <memp_malloc>
  806cbb:	89 c7                	mov    %eax,%edi
    }
    if (ipr == NULL)
  806cbd:	83 c4 10             	add    $0x10,%esp
  806cc0:	85 c0                	test   %eax,%eax
  806cc2:	0f 84 8f 03 00 00    	je     807057 <ip_reass+0x49c>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  806cc8:	83 ec 04             	sub    $0x4,%esp
  806ccb:	6a 20                	push   $0x20
  806ccd:	6a 00                	push   $0x0
  806ccf:	57                   	push   %edi
  806cd0:	e8 5c 7e 00 00       	call   80eb31 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  806cd5:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  806cd9:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  806cde:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  806ce0:	89 3d e0 49 b3 00    	mov    %edi,0xb349e0
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  806ce6:	83 c4 0c             	add    $0xc,%esp
  806ce9:	6a 14                	push   $0x14
  806ceb:	53                   	push   %ebx
  806cec:	8d 47 08             	lea    0x8(%edi),%eax
  806cef:	50                   	push   %eax
  806cf0:	e8 f1 7e 00 00       	call   80ebe6 <memcpy>

  if (ipr == NULL) {
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
  806cf5:	83 c4 10             	add    $0x10,%esp
  806cf8:	85 ff                	test   %edi,%edi
  806cfa:	75 46                	jne    806d42 <ip_reass+0x187>
  806cfc:	e9 56 03 00 00       	jmp    807057 <ip_reass+0x49c>
  806d01:	89 45 e0             	mov    %eax,-0x20(%ebp)
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806d04:	83 ec 0c             	sub    $0xc,%esp
  806d07:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d0b:	50                   	push   %eax
  806d0c:	e8 14 09 00 00       	call   807625 <ntohs>
  806d11:	83 c4 10             	add    $0x10,%esp
  806d14:	66 a9 ff 1f          	test   $0x1fff,%ax
  806d18:	75 28                	jne    806d42 <ip_reass+0x187>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  806d1a:	83 ec 0c             	sub    $0xc,%esp
  806d1d:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  806d21:	50                   	push   %eax
  806d22:	e8 fe 08 00 00       	call   807625 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806d27:	83 c4 10             	add    $0x10,%esp
  806d2a:	66 a9 ff 1f          	test   $0x1fff,%ax
  806d2e:	74 12                	je     806d42 <ip_reass+0x187>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  806d30:	83 ec 04             	sub    $0x4,%esp
  806d33:	6a 14                	push   $0x14
  806d35:	53                   	push   %ebx
  806d36:	8d 47 08             	lea    0x8(%edi),%eax
  806d39:	50                   	push   %eax
  806d3a:	e8 a7 7e 00 00       	call   80ebe6 <memcpy>
  806d3f:	83 c4 10             	add    $0x10,%esp
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806d42:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806d46:	66 01 05 dc 49 b3 00 	add    %ax,0xb349dc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806d4d:	83 ec 0c             	sub    $0xc,%esp
  806d50:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d54:	50                   	push   %eax
  806d55:	e8 cb 08 00 00       	call   807625 <ntohs>
  806d5a:	83 c4 10             	add    $0x10,%esp
  806d5d:	f6 c4 20             	test   $0x20,%ah
  806d60:	75 20                	jne    806d82 <ip_reass+0x1c7>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806d62:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    ipr->datagram_len = offset + len;
  806d66:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  806d6a:	0f b7 75 da          	movzwl -0x26(%ebp),%esi
  806d6e:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  806d71:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
  806d75:	66 c1 ea 06          	shr    $0x6,%dx
  806d79:	83 e2 3c             	and    $0x3c,%edx
  806d7c:	29 d0                	sub    %edx,%eax
  806d7e:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806d82:	8b 45 08             	mov    0x8(%ebp),%eax
  806d85:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806d88:	83 ec 0c             	sub    $0xc,%esp
  806d8b:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806d8f:	50                   	push   %eax
  806d90:	e8 90 08 00 00       	call   807625 <ntohs>
  806d95:	89 c6                	mov    %eax,%esi
  806d97:	0f b7 03             	movzwl (%ebx),%eax
  806d9a:	89 04 24             	mov    %eax,(%esp)
  806d9d:	e8 83 08 00 00       	call   807625 <ntohs>
  806da2:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806da6:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806daa:	89 04 24             	mov    %eax,(%esp)
  806dad:	e8 73 08 00 00       	call   807625 <ntohs>
  806db2:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  806db9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806dbc:	8b 51 04             	mov    0x4(%ecx),%edx
  806dbf:	89 55 dc             	mov    %edx,-0x24(%ebp)
  iprh->next_pbuf = NULL;
  806dc2:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  806dc8:	66 89 5a 04          	mov    %bx,0x4(%edx)
  iprh->end = offset + len;
  806dcc:	01 de                	add    %ebx,%esi
  806dce:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806dd2:	66 c1 e8 06          	shr    $0x6,%ax
  806dd6:	83 e0 3c             	and    $0x3c,%eax
  806dd9:	29 c6                	sub    %eax,%esi
  806ddb:	66 89 75 da          	mov    %si,-0x26(%ebp)
  806ddf:	66 89 72 06          	mov    %si,0x6(%edx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  806de3:	8b 47 04             	mov    0x4(%edi),%eax
  806de6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  806de9:	83 c4 10             	add    $0x10,%esp
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  806dec:	b9 01 00 00 00       	mov    $0x1,%ecx
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  806df1:	be 00 00 00 00       	mov    $0x0,%esi
  806df6:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806df9:	89 cf                	mov    %ecx,%edi
  806dfb:	eb 6f                	jmp    806e6c <ip_reass+0x2b1>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806dfd:	8b 50 04             	mov    0x4(%eax),%edx
    if (iprh->start < iprh_tmp->start) {
  806e00:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  806e04:	66 39 cb             	cmp    %cx,%bx
  806e07:	73 3c                	jae    806e45 <ip_reass+0x28a>
  806e09:	89 7d d0             	mov    %edi,-0x30(%ebp)
  806e0c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  806e0f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  806e12:	89 01                	mov    %eax,(%ecx)
      if (iprh_prev != NULL) {
  806e14:	85 f6                	test   %esi,%esi
  806e16:	74 22                	je     806e3a <ip_reass+0x27f>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  806e18:	66 3b 5e 06          	cmp    0x6(%esi),%bx
  806e1c:	0f 82 6c 01 00 00    	jb     806f8e <ip_reass+0x3d3>
  806e22:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  806e26:	66 3b 42 04          	cmp    0x4(%edx),%ax
  806e2a:	0f 87 5e 01 00 00    	ja     806f8e <ip_reass+0x3d3>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  806e30:	8b 45 08             	mov    0x8(%ebp),%eax
  806e33:	89 06                	mov    %eax,(%esi)
  806e35:	e9 92 00 00 00       	jmp    806ecc <ip_reass+0x311>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  806e3a:	8b 45 08             	mov    0x8(%ebp),%eax
  806e3d:	89 47 04             	mov    %eax,0x4(%edi)
  806e40:	e9 87 00 00 00       	jmp    806ecc <ip_reass+0x311>
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  806e45:	66 39 cb             	cmp    %cx,%bx
  806e48:	0f 84 40 01 00 00    	je     806f8e <ip_reass+0x3d3>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  806e4e:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  806e52:	0f 82 36 01 00 00    	jb     806f8e <ip_reass+0x3d3>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  806e58:	85 f6                	test   %esi,%esi
  806e5a:	74 0c                	je     806e68 <ip_reass+0x2ad>
        if (iprh_prev->end != iprh_tmp->start) {
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  806e5c:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  806e60:	b8 00 00 00 00       	mov    $0x0,%eax
  806e65:	0f 45 f8             	cmovne %eax,%edi
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  806e68:	8b 02                	mov    (%edx),%eax
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806e6a:	89 d6                	mov    %edx,%esi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  806e6c:	85 c0                	test   %eax,%eax
  806e6e:	75 8d                	jne    806dfd <ip_reass+0x242>
  806e70:	e9 fe 01 00 00       	jmp    807073 <ip_reass+0x4b8>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  806e75:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  806e79:	66 39 c3             	cmp    %ax,%bx
  806e7c:	73 17                	jae    806e95 <ip_reass+0x2da>
  806e7e:	83 ec 04             	sub    $0x4,%esp
  806e81:	68 5c 1c 81 00       	push   $0x811c5c
  806e86:	68 83 01 00 00       	push   $0x183
  806e8b:	68 06 1c 81 00       	push   $0x811c06
  806e90:	e8 f9 74 00 00       	call   80e38e <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  806e95:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806e98:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  806e9a:	8b 75 dc             	mov    -0x24(%ebp),%esi
  806e9d:	66 3b 46 04          	cmp    0x4(%esi),%ax
  806ea1:	0f 85 ef 01 00 00    	jne    807096 <ip_reass+0x4db>
  806ea7:	eb 23                	jmp    806ecc <ip_reass+0x311>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  806ea9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  806ead:	74 17                	je     806ec6 <ip_reass+0x30b>
  806eaf:	83 ec 04             	sub    $0x4,%esp
  806eb2:	68 88 1c 81 00       	push   $0x811c88
  806eb7:	68 8c 01 00 00       	push   $0x18c
  806ebc:	68 06 1c 81 00       	push   $0x811c06
  806ec1:	e8 c8 74 00 00       	call   80e38e <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  806ec6:	8b 45 08             	mov    0x8(%ebp),%eax
  806ec9:	89 47 04             	mov    %eax,0x4(%edi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  806ecc:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  806ed0:	0f 84 c0 01 00 00    	je     807096 <ip_reass+0x4db>
    /* and had no wholes so far */
    if (valid) {
  806ed6:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  806eda:	0f 84 b6 01 00 00    	je     807096 <ip_reass+0x4db>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  806ee0:	8b 4f 04             	mov    0x4(%edi),%ecx
  806ee3:	8b 59 04             	mov    0x4(%ecx),%ebx
  806ee6:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  806eeb:	0f 85 a5 01 00 00    	jne    807096 <ip_reass+0x4db>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  806ef1:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806ef4:	8b 10                	mov    (%eax),%edx
  806ef6:	89 c6                	mov    %eax,%esi
  806ef8:	eb 15                	jmp    806f0f <ip_reass+0x354>
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  806efa:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  806efd:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  806f01:	66 39 56 06          	cmp    %dx,0x6(%esi)
  806f05:	0f 85 61 01 00 00    	jne    80706c <ip_reass+0x4b1>
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  806f0b:	8b 10                	mov    (%eax),%edx
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  806f0d:	89 c6                	mov    %eax,%esi
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  806f0f:	85 d2                	test   %edx,%edx
  806f11:	75 e7                	jne    806efa <ip_reass+0x33f>
  806f13:	e9 6e 01 00 00       	jmp    807086 <ip_reass+0x4cb>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  806f18:	83 ec 04             	sub    $0x4,%esp
  806f1b:	68 7a 1c 81 00       	push   $0x811c7a
  806f20:	68 ac 01 00 00       	push   $0x1ac
  806f25:	68 06 1c 81 00       	push   $0x811c06
  806f2a:	e8 5f 74 00 00       	call   80e38e <_panic>
          LWIP_ASSERT("sanity check",
  806f2f:	3b 5d dc             	cmp    -0x24(%ebp),%ebx
  806f32:	75 17                	jne    806f4b <ip_reass+0x390>
  806f34:	83 ec 04             	sub    $0x4,%esp
  806f37:	68 7a 1c 81 00       	push   $0x811c7a
  806f3c:	68 ae 01 00 00       	push   $0x1ae
  806f41:	68 06 1c 81 00       	push   $0x811c06
  806f46:	e8 43 74 00 00       	call   80e38e <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  806f4b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806f4e:	83 38 00             	cmpl   $0x0,(%eax)
  806f51:	74 17                	je     806f6a <ip_reass+0x3af>
  806f53:	83 ec 04             	sub    $0x4,%esp
  806f56:	68 c0 1c 81 00       	push   $0x811cc0
  806f5b:	68 b0 01 00 00       	push   $0x1b0
  806f60:	68 06 1c 81 00       	push   $0x811c06
  806f65:	e8 24 74 00 00       	call   80e38e <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  806f6a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806f6d:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  806f71:	66 3b 47 1c          	cmp    0x1c(%edi),%ax
  806f75:	74 3f                	je     806fb6 <ip_reass+0x3fb>
  806f77:	83 ec 04             	sub    $0x4,%esp
  806f7a:	68 e4 1c 81 00       	push   $0x811ce4
  806f7f:	68 b2 01 00 00       	push   $0x1b2
  806f84:	68 06 1c 81 00       	push   $0x811c06
  806f89:	e8 00 74 00 00       	call   80e38e <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  806f8e:	83 ec 0c             	sub    $0xc,%esp
  806f91:	ff 75 08             	pushl  0x8(%ebp)
  806f94:	e8 2d dc ff ff       	call   804bc6 <pbuf_clen>
  806f99:	0f b6 c0             	movzbl %al,%eax
  806f9c:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
  pbuf_free(new_p);
  806fa3:	83 c4 04             	add    $0x4,%esp
  806fa6:	ff 75 08             	pushl  0x8(%ebp)
  806fa9:	e8 b9 d7 ff ff       	call   804767 <pbuf_free>
  806fae:	83 c4 10             	add    $0x10,%esp
  806fb1:	e9 e0 00 00 00       	jmp    807096 <ip_reass+0x4db>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  806fb6:	83 c0 14             	add    $0x14,%eax
  806fb9:	66 89 47 1c          	mov    %ax,0x1c(%edi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  806fbd:	8b 71 04             	mov    0x4(%ecx),%esi
  806fc0:	8b 1e                	mov    (%esi),%ebx

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  806fc2:	83 ec 04             	sub    $0x4,%esp
  806fc5:	6a 14                	push   $0x14
  806fc7:	8d 47 08             	lea    0x8(%edi),%eax
  806fca:	50                   	push   %eax
  806fcb:	56                   	push   %esi
  806fcc:	e8 15 7c 00 00       	call   80ebe6 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  806fd1:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  806fd5:	89 04 24             	mov    %eax,(%esp)
  806fd8:	e8 3b 06 00 00       	call   807618 <htons>
  806fdd:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  806fe1:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  806fe7:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  806fed:	83 c4 08             	add    $0x8,%esp
  806ff0:	6a 14                	push   $0x14
  806ff2:	56                   	push   %esi
  806ff3:	e8 fb 04 00 00       	call   8074f3 <inet_chksum>
  806ff8:	66 89 46 0a          	mov    %ax,0xa(%esi)

    p = ipr->p;
  806ffc:	8b 47 04             	mov    0x4(%edi),%eax
  806fff:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807002:	83 c4 10             	add    $0x10,%esp
  807005:	89 7d dc             	mov    %edi,-0x24(%ebp)
  807008:	89 c7                	mov    %eax,%edi
  80700a:	eb 1d                	jmp    807029 <ip_reass+0x46e>
      iprh = (struct ip_reass_helper*)r->payload;
  80700c:	8b 73 04             	mov    0x4(%ebx),%esi

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  80700f:	83 ec 08             	sub    $0x8,%esp
  807012:	6a ec                	push   $0xffffffec
  807014:	53                   	push   %ebx
  807015:	e8 7b d6 ff ff       	call   804695 <pbuf_header>
      pbuf_cat(p, r);
  80701a:	83 c4 08             	add    $0x8,%esp
  80701d:	53                   	push   %ebx
  80701e:	57                   	push   %edi
  80701f:	e8 cb db ff ff       	call   804bef <pbuf_cat>
      r = iprh->next_pbuf;
  807024:	8b 1e                	mov    (%esi),%ebx
  807026:	83 c4 10             	add    $0x10,%esp
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807029:	85 db                	test   %ebx,%ebx
  80702b:	75 df                	jne    80700c <ip_reass+0x451>
  80702d:	8b 7d dc             	mov    -0x24(%ebp),%edi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  807030:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807033:	89 f8                	mov    %edi,%eax
  807035:	e8 61 f9 ff ff       	call   80699b <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  80703a:	83 ec 0c             	sub    $0xc,%esp
  80703d:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  807040:	56                   	push   %esi
  807041:	e8 80 db ff ff       	call   804bc6 <pbuf_clen>
  807046:	0f b6 c0             	movzbl %al,%eax
  807049:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc

    /* Return the pbuf chain */
    return p;
  807050:	83 c4 10             	add    $0x10,%esp
  807053:	89 f0                	mov    %esi,%eax
  807055:	eb 44                	jmp    80709b <ip_reass+0x4e0>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  807057:	83 ec 0c             	sub    $0xc,%esp
  80705a:	ff 75 08             	pushl  0x8(%ebp)
  80705d:	e8 05 d7 ff ff       	call   804767 <pbuf_free>
  return NULL;
  807062:	83 c4 10             	add    $0x10,%esp
  807065:	b8 00 00 00 00       	mov    $0x0,%eax
  80706a:	eb 2f                	jmp    80709b <ip_reass+0x4e0>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  80706c:	b8 00 00 00 00       	mov    $0x0,%eax
  807071:	eb 28                	jmp    80709b <ip_reass+0x4e0>
  807073:	89 7d d0             	mov    %edi,-0x30(%ebp)
  807076:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  807079:	85 f6                	test   %esi,%esi
  80707b:	0f 85 f4 fd ff ff    	jne    806e75 <ip_reass+0x2ba>
  807081:	e9 23 fe ff ff       	jmp    806ea9 <ip_reass+0x2ee>
  807086:	89 75 dc             	mov    %esi,-0x24(%ebp)
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  807089:	85 c9                	test   %ecx,%ecx
  80708b:	0f 85 9e fe ff ff    	jne    806f2f <ip_reass+0x374>
  807091:	e9 82 fe ff ff       	jmp    806f18 <ip_reass+0x35d>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  807096:	b8 00 00 00 00       	mov    $0x0,%eax
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
  80709b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80709e:	5b                   	pop    %ebx
  80709f:	5e                   	pop    %esi
  8070a0:	5f                   	pop    %edi
  8070a1:	5d                   	pop    %ebp
  8070a2:	c3                   	ret    

008070a3 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  8070a3:	55                   	push   %ebp
  8070a4:	89 e5                	mov    %esp,%ebp
  8070a6:	57                   	push   %edi
  8070a7:	56                   	push   %esi
  8070a8:	53                   	push   %ebx
  8070a9:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  8070ac:	8b 45 0c             	mov    0xc(%ebp),%eax
  8070af:	0f b7 58 2c          	movzwl 0x2c(%eax),%ebx
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  8070b3:	6a 02                	push   $0x2
  8070b5:	6a 00                	push   $0x0
  8070b7:	6a 02                	push   $0x2
  8070b9:	e8 6f d7 ff ff       	call   80482d <pbuf_alloc>
  8070be:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (rambuf == NULL) {
  8070c1:	83 c4 10             	add    $0x10,%esp
  8070c4:	85 c0                	test   %eax,%eax
  8070c6:	0f 84 9f 01 00 00    	je     80726b <ip_frag+0x1c8>
  8070cc:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  8070ce:	66 89 58 0a          	mov    %bx,0xa(%eax)
  8070d2:	66 89 58 08          	mov    %bx,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  8070d6:	b8 03 44 b3 00       	mov    $0xb34403,%eax
  8070db:	83 e0 fc             	and    $0xfffffffc,%eax
  8070de:	89 c7                	mov    %eax,%edi
  8070e0:	89 7e 04             	mov    %edi,0x4(%esi)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8070e3:	83 ec 04             	sub    $0x4,%esp
  8070e6:	6a 14                	push   $0x14
  8070e8:	8b 45 08             	mov    0x8(%ebp),%eax
  8070eb:	ff 70 04             	pushl  0x4(%eax)
  8070ee:	57                   	push   %edi
  8070ef:	e8 f2 7a 00 00       	call   80ebe6 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8070f4:	0f b7 47 06          	movzwl 0x6(%edi),%eax
  8070f8:	89 04 24             	mov    %eax,(%esp)
  8070fb:	e8 25 05 00 00       	call   807625 <ntohs>
  ofo = tmp & IP_OFFMASK;
  807100:	89 c6                	mov    %eax,%esi
  807102:	66 81 e6 ff 1f       	and    $0x1fff,%si
  807107:	66 89 75 de          	mov    %si,-0x22(%ebp)
  omf = tmp & IP_MF;
  80710b:	66 25 00 20          	and    $0x2000,%ax
  80710f:	66 89 45 dc          	mov    %ax,-0x24(%ebp)

  left = p->tot_len - IP_HLEN;
  807113:	8b 45 08             	mov    0x8(%ebp),%eax
  807116:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80711a:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  80711e:	8d 70 ec             	lea    -0x14(%eax),%esi

  nfb = (mtu - IP_HLEN) / 8;
  807121:	0f b7 db             	movzwl %bx,%ebx
  807124:	8d 43 f3             	lea    -0xd(%ebx),%eax
  807127:	83 c4 10             	add    $0x10,%esp
  80712a:	83 eb 14             	sub    $0x14,%ebx
  80712d:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  807130:	0f 49 c3             	cmovns %ebx,%eax
  807133:	c1 f8 03             	sar    $0x3,%eax
  807136:	66 89 45 ce          	mov    %ax,-0x32(%ebp)
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  80713a:	66 c7 45 e4 14 00    	movw   $0x14,-0x1c(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807140:	c1 e0 03             	shl    $0x3,%eax
  807143:	66 89 45 cc          	mov    %ax,-0x34(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807147:	8d 47 14             	lea    0x14(%edi),%eax
  80714a:	89 45 d0             	mov    %eax,-0x30(%ebp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  80714d:	e9 fb 00 00 00       	jmp    80724d <ip_frag+0x1aa>
    last = (left <= mtu - IP_HLEN);
  807152:	0f b7 c6             	movzwl %si,%eax
  807155:	89 45 d8             	mov    %eax,-0x28(%ebp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  807158:	0f b7 5d de          	movzwl -0x22(%ebp),%ebx
  80715c:	66 81 e3 ff 1f       	and    $0x1fff,%bx
  807161:	66 0b 5d dc          	or     -0x24(%ebp),%bx
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807165:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
  while (left) {
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
  807169:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80716c:	7d 0b                	jge    807179 <ip_frag+0xd6>
      tmp = tmp | IP_MF;
  80716e:	80 cf 20             	or     $0x20,%bh

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807171:	0f b7 45 cc          	movzwl -0x34(%ebp),%eax
  807175:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807179:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80717d:	50                   	push   %eax
  80717e:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807182:	50                   	push   %eax
  807183:	ff 75 d0             	pushl  -0x30(%ebp)
  807186:	ff 75 08             	pushl  0x8(%ebp)
  807189:	e8 29 dd ff ff       	call   804eb7 <pbuf_copy_partial>
  80718e:	66 01 45 e4          	add    %ax,-0x1c(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  807192:	0f b7 db             	movzwl %bx,%ebx
  807195:	89 1c 24             	mov    %ebx,(%esp)
  807198:	e8 7b 04 00 00       	call   807618 <htons>
  80719d:	66 89 47 06          	mov    %ax,0x6(%edi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8071a1:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
  8071a5:	8d 41 14             	lea    0x14(%ecx),%eax
  8071a8:	0f b7 c0             	movzwl %ax,%eax
  8071ab:	89 04 24             	mov    %eax,(%esp)
  8071ae:	e8 65 04 00 00       	call   807618 <htons>
  8071b3:	66 89 47 02          	mov    %ax,0x2(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  8071b7:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8071bd:	83 c4 08             	add    $0x8,%esp
  8071c0:	6a 14                	push   $0x14
  8071c2:	57                   	push   %edi
  8071c3:	e8 2b 03 00 00       	call   8074f3 <inet_chksum>
  8071c8:	66 89 47 0a          	mov    %ax,0xa(%edi)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  8071cc:	83 c4 10             	add    $0x10,%esp
  8071cf:	8b 55 d8             	mov    -0x28(%ebp),%edx
  8071d2:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  8071d5:	7c 15                	jl     8071ec <ip_frag+0x149>
      pbuf_realloc(rambuf, left + IP_HLEN);
  8071d7:	83 ec 08             	sub    $0x8,%esp
  8071da:	8d 46 14             	lea    0x14(%esi),%eax
  8071dd:	0f b7 c0             	movzwl %ax,%eax
  8071e0:	50                   	push   %eax
  8071e1:	ff 75 d4             	pushl  -0x2c(%ebp)
  8071e4:	e8 c7 d8 ff ff       	call   804ab0 <pbuf_realloc>
  8071e9:	83 c4 10             	add    $0x10,%esp
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  8071ec:	83 ec 04             	sub    $0x4,%esp
  8071ef:	6a 00                	push   $0x0
  8071f1:	6a 00                	push   $0x0
  8071f3:	6a 02                	push   $0x2
  8071f5:	e8 33 d6 ff ff       	call   80482d <pbuf_alloc>
  8071fa:	89 c3                	mov    %eax,%ebx
    if (header != NULL) {
  8071fc:	83 c4 10             	add    $0x10,%esp
  8071ff:	85 c0                	test   %eax,%eax
  807201:	74 35                	je     807238 <ip_frag+0x195>
      pbuf_chain(header, rambuf);
  807203:	83 ec 08             	sub    $0x8,%esp
  807206:	ff 75 d4             	pushl  -0x2c(%ebp)
  807209:	50                   	push   %eax
  80720a:	e8 4c da ff ff       	call   804c5b <pbuf_chain>
      netif->output(netif, header, dest);
  80720f:	83 c4 0c             	add    $0xc,%esp
  807212:	ff 75 10             	pushl  0x10(%ebp)
  807215:	53                   	push   %ebx
  807216:	ff 75 0c             	pushl  0xc(%ebp)
  807219:	8b 45 0c             	mov    0xc(%ebp),%eax
  80721c:	ff 50 14             	call   *0x14(%eax)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  80721f:	89 1c 24             	mov    %ebx,(%esp)
  807222:	e8 40 d5 ff ff       	call   804767 <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  807227:	66 2b 75 e6          	sub    -0x1a(%ebp),%si
    ofo += nfb;
  80722b:	0f b7 4d ce          	movzwl -0x32(%ebp),%ecx
  80722f:	66 01 4d de          	add    %cx,-0x22(%ebp)
  807233:	83 c4 10             	add    $0x10,%esp
  807236:	eb 15                	jmp    80724d <ip_frag+0x1aa>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  807238:	83 ec 0c             	sub    $0xc,%esp
  80723b:	ff 75 d4             	pushl  -0x2c(%ebp)
  80723e:	e8 24 d5 ff ff       	call   804767 <pbuf_free>
      return ERR_MEM;
  807243:	83 c4 10             	add    $0x10,%esp
  807246:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80724b:	eb 23                	jmp    807270 <ip_frag+0x1cd>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  80724d:	66 85 f6             	test   %si,%si
  807250:	0f 85 fc fe ff ff    	jne    807152 <ip_frag+0xaf>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  807256:	83 ec 0c             	sub    $0xc,%esp
  807259:	ff 75 d4             	pushl  -0x2c(%ebp)
  80725c:	e8 06 d5 ff ff       	call   804767 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  807261:	83 c4 10             	add    $0x10,%esp
  807264:	b8 00 00 00 00       	mov    $0x0,%eax
  807269:	eb 05                	jmp    807270 <ip_frag+0x1cd>
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  80726b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  807270:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807273:	5b                   	pop    %ebx
  807274:	5e                   	pop    %esi
  807275:	5f                   	pop    %edi
  807276:	5d                   	pop    %ebp
  807277:	c3                   	ret    

00807278 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  807278:	55                   	push   %ebp
  807279:	89 e5                	mov    %esp,%ebp
  80727b:	57                   	push   %edi
  80727c:	56                   	push   %esi
  80727d:	53                   	push   %ebx
  80727e:	83 ec 1c             	sub    $0x1c,%esp
  807281:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  807284:	89 c3                	mov    %eax,%ebx
  while (len > 1) {
  807286:	89 d7                	mov    %edx,%edi
{
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  807288:	be 00 00 00 00       	mov    $0x0,%esi
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80728d:	eb 17                	jmp    8072a6 <lwip_standard_chksum+0x2e>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80728f:	0f b6 03             	movzbl (%ebx),%eax
  807292:	c1 e0 08             	shl    $0x8,%eax
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  807295:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  807299:	09 c8                	or     %ecx,%eax
  80729b:	83 c3 02             	add    $0x2,%ebx
    octetptr++;
    acc += src;
  80729e:	0f b7 c0             	movzwl %ax,%eax
  8072a1:	01 c6                	add    %eax,%esi
    len -= 2;
  8072a3:	83 ef 02             	sub    $0x2,%edi
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8072a6:	66 83 ff 01          	cmp    $0x1,%di
  8072aa:	77 e3                	ja     80728f <lwip_standard_chksum+0x17>
  8072ac:	89 d0                	mov    %edx,%eax
  8072ae:	66 d1 e8             	shr    %ax
  8072b1:	0f b7 c8             	movzwl %ax,%ecx
  8072b4:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8072b7:	8d 0c 4f             	lea    (%edi,%ecx,2),%ecx
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  8072ba:	f7 d8                	neg    %eax
  8072bc:	8d 14 42             	lea    (%edx,%eax,2),%edx
  8072bf:	66 85 d2             	test   %dx,%dx
  8072c2:	74 0b                	je     8072cf <lwip_standard_chksum+0x57>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
    acc += src;
  8072c4:	0f b6 01             	movzbl (%ecx),%eax
  8072c7:	c1 e0 08             	shl    $0x8,%eax
  8072ca:	0f b7 c0             	movzwl %ax,%eax
  8072cd:	01 c6                	add    %eax,%esi
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8072cf:	89 f0                	mov    %esi,%eax
  8072d1:	c1 e8 10             	shr    $0x10,%eax
  8072d4:	0f b7 f6             	movzwl %si,%esi
  8072d7:	01 c6                	add    %eax,%esi
  if ((acc & 0xffff0000) != 0) {
  8072d9:	f7 c6 00 00 ff ff    	test   $0xffff0000,%esi
  8072df:	74 0a                	je     8072eb <lwip_standard_chksum+0x73>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8072e1:	89 f0                	mov    %esi,%eax
  8072e3:	c1 e8 10             	shr    $0x10,%eax
  8072e6:	0f b7 f6             	movzwl %si,%esi
  8072e9:	01 c6                	add    %eax,%esi
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  8072eb:	83 ec 0c             	sub    $0xc,%esp
  8072ee:	0f b7 f6             	movzwl %si,%esi
  8072f1:	56                   	push   %esi
  8072f2:	e8 21 03 00 00       	call   807618 <htons>
}
  8072f7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8072fa:	5b                   	pop    %ebx
  8072fb:	5e                   	pop    %esi
  8072fc:	5f                   	pop    %edi
  8072fd:	5d                   	pop    %ebp
  8072fe:	c3                   	ret    

008072ff <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  8072ff:	55                   	push   %ebp
  807300:	89 e5                	mov    %esp,%ebp
  807302:	57                   	push   %edi
  807303:	56                   	push   %esi
  807304:	53                   	push   %ebx
  807305:	83 ec 1c             	sub    $0x1c,%esp
  807308:	8b 75 08             	mov    0x8(%ebp),%esi
  80730b:	8b 45 14             	mov    0x14(%ebp),%eax
  80730e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807311:	8b 45 18             	mov    0x18(%ebp),%eax
  807314:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807317:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  80731c:	bb 00 00 00 00       	mov    $0x0,%ebx
  807321:	89 f8                	mov    %edi,%eax
  807323:	89 df                	mov    %ebx,%edi
  807325:	89 c3                	mov    %eax,%ebx
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807327:	eb 3d                	jmp    807366 <inet_chksum_pseudo+0x67>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  807329:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  80732d:	8b 46 04             	mov    0x4(%esi),%eax
  807330:	e8 43 ff ff ff       	call   807278 <lwip_standard_chksum>
  807335:	0f b7 c0             	movzwl %ax,%eax
  807338:	01 f8                	add    %edi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  80733a:	89 c7                	mov    %eax,%edi
  80733c:	c1 ef 10             	shr    $0x10,%edi
  80733f:	0f b7 c0             	movzwl %ax,%eax
  807342:	01 c7                	add    %eax,%edi
    if (q->len % 2 != 0) {
  807344:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807348:	74 1a                	je     807364 <inet_chksum_pseudo+0x65>
      swapped = 1 - swapped;
  80734a:	b8 01 00 00 00       	mov    $0x1,%eax
  80734f:	29 d8                	sub    %ebx,%eax
  807351:	89 c3                	mov    %eax,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
  807353:	89 fa                	mov    %edi,%edx
  807355:	c1 e2 08             	shl    $0x8,%edx
  807358:	0f b7 d2             	movzwl %dx,%edx
  80735b:	89 f8                	mov    %edi,%eax
  80735d:	0f b6 c4             	movzbl %ah,%eax
  807360:	09 c2                	or     %eax,%edx
  807362:	89 d7                	mov    %edx,%edi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807364:	8b 36                	mov    (%esi),%esi
  807366:	85 f6                	test   %esi,%esi
  807368:	75 bf                	jne    807329 <inet_chksum_pseudo+0x2a>
  80736a:	89 d8                	mov    %ebx,%eax
  80736c:	89 fb                	mov    %edi,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80736e:	84 c0                	test   %al,%al
  807370:	74 0d                	je     80737f <inet_chksum_pseudo+0x80>
    acc = SWAP_BYTES_IN_WORD(acc);
  807372:	89 f8                	mov    %edi,%eax
  807374:	c1 e0 08             	shl    $0x8,%eax
  807377:	0f b7 c0             	movzwl %ax,%eax
  80737a:	0f b6 df             	movzbl %bh,%ebx
  80737d:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  80737f:	8b 45 0c             	mov    0xc(%ebp),%eax
  807382:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807384:	8b 45 10             	mov    0x10(%ebp),%eax
  807387:	8b 00                	mov    (%eax),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  807389:	0f b7 ca             	movzwl %dx,%ecx
  80738c:	c1 ea 10             	shr    $0x10,%edx
  80738f:	01 ca                	add    %ecx,%edx
  807391:	0f b7 c8             	movzwl %ax,%ecx
  807394:	01 ca                	add    %ecx,%edx
  807396:	c1 e8 10             	shr    $0x10,%eax
  807399:	01 d0                	add    %edx,%eax
  80739b:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  80739d:	83 ec 0c             	sub    $0xc,%esp
  8073a0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8073a4:	50                   	push   %eax
  8073a5:	e8 6e 02 00 00       	call   807618 <htons>
  8073aa:	0f b7 c0             	movzwl %ax,%eax
  8073ad:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  8073af:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  8073b3:	89 04 24             	mov    %eax,(%esp)
  8073b6:	e8 5d 02 00 00       	call   807618 <htons>
  8073bb:	0f b7 c0             	movzwl %ax,%eax
  8073be:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  8073c0:	89 d8                	mov    %ebx,%eax
  8073c2:	c1 e8 10             	shr    $0x10,%eax
  8073c5:	0f b7 db             	movzwl %bx,%ebx
  8073c8:	01 d8                	add    %ebx,%eax
  acc = FOLD_U32T(acc);
  8073ca:	89 c2                	mov    %eax,%edx
  8073cc:	c1 ea 10             	shr    $0x10,%edx
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  8073cf:	01 d0                	add    %edx,%eax
  8073d1:	f7 d0                	not    %eax
}
  8073d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8073d6:	5b                   	pop    %ebx
  8073d7:	5e                   	pop    %esi
  8073d8:	5f                   	pop    %edi
  8073d9:	5d                   	pop    %ebp
  8073da:	c3                   	ret    

008073db <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  8073db:	55                   	push   %ebp
  8073dc:	89 e5                	mov    %esp,%ebp
  8073de:	57                   	push   %edi
  8073df:	56                   	push   %esi
  8073e0:	53                   	push   %ebx
  8073e1:	83 ec 1c             	sub    $0x1c,%esp
  8073e4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8073e7:	8b 45 14             	mov    0x14(%ebp),%eax
  8073ea:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8073ed:	8b 45 18             	mov    0x18(%ebp),%eax
  8073f0:	89 45 d8             	mov    %eax,-0x28(%ebp)
  8073f3:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  8073f7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  8073fb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807402:	eb 6d                	jmp    807471 <inet_chksum_pseudo_partial+0x96>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  807404:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  807408:	66 39 fe             	cmp    %di,%si
  80740b:	0f 46 fe             	cmovbe %esi,%edi
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80740e:	0f b7 d7             	movzwl %di,%edx
  807411:	8b 43 04             	mov    0x4(%ebx),%eax
  807414:	e8 5f fe ff ff       	call   807278 <lwip_standard_chksum>
  807419:	0f b7 c0             	movzwl %ax,%eax
  80741c:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  80741f:	29 fe                	sub    %edi,%esi
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807421:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  807426:	76 17                	jbe    80743f <inet_chksum_pseudo_partial+0x64>
  807428:	83 ec 04             	sub    $0x4,%esp
  80742b:	68 11 1d 81 00       	push   $0x811d11
  807430:	68 60 01 00 00       	push   $0x160
  807435:	68 1c 1d 81 00       	push   $0x811d1c
  80743a:	e8 4f 6f 00 00       	call   80e38e <_panic>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  80743f:	89 c2                	mov    %eax,%edx
  807441:	c1 ea 10             	shr    $0x10,%edx
  807444:	0f b7 c0             	movzwl %ax,%eax
  807447:	01 d0                	add    %edx,%eax
  807449:	89 c2                	mov    %eax,%edx
  80744b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  80744e:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807452:	74 1b                	je     80746f <inet_chksum_pseudo_partial+0x94>
      swapped = 1 - swapped;
  807454:	b8 01 00 00 00       	mov    $0x1,%eax
  807459:	2a 45 e3             	sub    -0x1d(%ebp),%al
  80745c:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80745f:	89 d0                	mov    %edx,%eax
  807461:	c1 e2 08             	shl    $0x8,%edx
  807464:	0f b7 d2             	movzwl %dx,%edx
  807467:	0f b6 c4             	movzbl %ah,%eax
  80746a:	09 c2                	or     %eax,%edx
  80746c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80746f:	8b 1b                	mov    (%ebx),%ebx
  807471:	85 db                	test   %ebx,%ebx
  807473:	74 05                	je     80747a <inet_chksum_pseudo_partial+0x9f>
  807475:	66 85 f6             	test   %si,%si
  807478:	75 8a                	jne    807404 <inet_chksum_pseudo_partial+0x29>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80747a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80747e:	74 13                	je     807493 <inet_chksum_pseudo_partial+0xb8>
    acc = SWAP_BYTES_IN_WORD(acc);
  807480:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807483:	89 c8                	mov    %ecx,%eax
  807485:	c1 e0 08             	shl    $0x8,%eax
  807488:	0f b7 c0             	movzwl %ax,%eax
  80748b:	0f b6 d5             	movzbl %ch,%edx
  80748e:	09 d0                	or     %edx,%eax
  807490:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  807493:	8b 45 0c             	mov    0xc(%ebp),%eax
  807496:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807498:	8b 45 10             	mov    0x10(%ebp),%eax
  80749b:	8b 00                	mov    (%eax),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  80749d:	0f b7 ca             	movzwl %dx,%ecx
  8074a0:	c1 ea 10             	shr    $0x10,%edx
  8074a3:	01 ca                	add    %ecx,%edx
  8074a5:	0f b7 d8             	movzwl %ax,%ebx
  8074a8:	01 d3                	add    %edx,%ebx
  8074aa:	c1 e8 10             	shr    $0x10,%eax
  8074ad:	01 c3                	add    %eax,%ebx
  8074af:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8074b2:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons((u16_t)proto);
  8074b4:	83 ec 0c             	sub    $0xc,%esp
  8074b7:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  8074bb:	50                   	push   %eax
  8074bc:	e8 57 01 00 00       	call   807618 <htons>
  8074c1:	0f b7 d0             	movzwl %ax,%edx
  8074c4:	8d 1c 32             	lea    (%edx,%esi,1),%ebx
  acc += (u32_t)htons(proto_len);
  8074c7:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  8074cb:	89 04 24             	mov    %eax,(%esp)
  8074ce:	e8 45 01 00 00       	call   807618 <htons>
  8074d3:	0f b7 d0             	movzwl %ax,%edx
  8074d6:	01 da                	add    %ebx,%edx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  8074d8:	89 d0                	mov    %edx,%eax
  8074da:	c1 e8 10             	shr    $0x10,%eax
  8074dd:	0f b7 d2             	movzwl %dx,%edx
  8074e0:	01 d0                	add    %edx,%eax
  acc = FOLD_U32T(acc);
  8074e2:	89 c2                	mov    %eax,%edx
  8074e4:	c1 ea 10             	shr    $0x10,%edx
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  8074e7:	01 d0                	add    %edx,%eax
  8074e9:	f7 d0                	not    %eax
}
  8074eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8074ee:	5b                   	pop    %ebx
  8074ef:	5e                   	pop    %esi
  8074f0:	5f                   	pop    %edi
  8074f1:	5d                   	pop    %ebp
  8074f2:	c3                   	ret    

008074f3 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  8074f3:	55                   	push   %ebp
  8074f4:	89 e5                	mov    %esp,%ebp
  8074f6:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  8074f9:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  8074fd:	8b 45 08             	mov    0x8(%ebp),%eax
  807500:	e8 73 fd ff ff       	call   807278 <lwip_standard_chksum>
  807505:	f7 d0                	not    %eax
}
  807507:	c9                   	leave  
  807508:	c3                   	ret    

00807509 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  807509:	55                   	push   %ebp
  80750a:	89 e5                	mov    %esp,%ebp
  80750c:	57                   	push   %edi
  80750d:	56                   	push   %esi
  80750e:	53                   	push   %ebx
  80750f:	83 ec 0c             	sub    $0xc,%esp
  807512:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807515:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  80751a:	bb 00 00 00 00       	mov    $0x0,%ebx
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80751f:	eb 3b                	jmp    80755c <inet_chksum_pbuf+0x53>
    acc += LWIP_CHKSUM(q->payload, q->len);
  807521:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  807525:	8b 46 04             	mov    0x4(%esi),%eax
  807528:	e8 4b fd ff ff       	call   807278 <lwip_standard_chksum>
  80752d:	0f b7 c0             	movzwl %ax,%eax
  807530:	01 c3                	add    %eax,%ebx
    acc = FOLD_U32T(acc);
  807532:	89 d8                	mov    %ebx,%eax
  807534:	c1 e8 10             	shr    $0x10,%eax
  807537:	0f b7 db             	movzwl %bx,%ebx
  80753a:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  80753c:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807540:	74 18                	je     80755a <inet_chksum_pbuf+0x51>
      swapped = 1 - swapped;
  807542:	b8 01 00 00 00       	mov    $0x1,%eax
  807547:	89 f9                	mov    %edi,%ecx
  807549:	29 c8                	sub    %ecx,%eax
  80754b:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80754d:	89 da                	mov    %ebx,%edx
  80754f:	c1 e2 08             	shl    $0x8,%edx
  807552:	0f b7 d2             	movzwl %dx,%edx
  807555:	0f b6 df             	movzbl %bh,%ebx
  807558:	09 d3                	or     %edx,%ebx
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80755a:	8b 36                	mov    (%esi),%esi
  80755c:	85 f6                	test   %esi,%esi
  80755e:	75 c1                	jne    807521 <inet_chksum_pbuf+0x18>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  807560:	89 f8                	mov    %edi,%eax
  807562:	84 c0                	test   %al,%al
  807564:	74 0d                	je     807573 <inet_chksum_pbuf+0x6a>
    acc = SWAP_BYTES_IN_WORD(acc);
  807566:	89 da                	mov    %ebx,%edx
  807568:	c1 e2 08             	shl    $0x8,%edx
  80756b:	0f b7 d2             	movzwl %dx,%edx
  80756e:	0f b6 df             	movzbl %bh,%ebx
  807571:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  807573:	89 d8                	mov    %ebx,%eax
  807575:	f7 d0                	not    %eax
}
  807577:	83 c4 0c             	add    $0xc,%esp
  80757a:	5b                   	pop    %ebx
  80757b:	5e                   	pop    %esi
  80757c:	5f                   	pop    %edi
  80757d:	5d                   	pop    %ebp
  80757e:	c3                   	ret    

0080757f <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  80757f:	55                   	push   %ebp
  807580:	89 e5                	mov    %esp,%ebp
  807582:	57                   	push   %edi
  807583:	56                   	push   %esi
  807584:	53                   	push   %ebx
  807585:	83 ec 14             	sub    $0x14,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807588:	8b 45 08             	mov    0x8(%ebp),%eax
  80758b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  80758e:	8d 7d f0             	lea    -0x10(%ebp),%edi
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  807591:	c7 45 e0 e4 49 b3 00 	movl   $0xb349e4,-0x20(%ebp)
  807598:	0f b6 0f             	movzbl (%edi),%ecx
  80759b:	ba 00 00 00 00       	mov    $0x0,%edx
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  8075a0:	0f b6 d9             	movzbl %cl,%ebx
  8075a3:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  8075a6:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
  8075a9:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8075ac:	66 c1 e8 0b          	shr    $0xb,%ax
  8075b0:	89 c3                	mov    %eax,%ebx
  8075b2:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8075b5:	01 c0                	add    %eax,%eax
  8075b7:	29 c1                	sub    %eax,%ecx
  8075b9:	89 c8                	mov    %ecx,%eax
      *ap /= (u8_t)10;
  8075bb:	89 d9                	mov    %ebx,%ecx
      inv[i++] = '0' + rem;
  8075bd:	8d 72 01             	lea    0x1(%edx),%esi
  8075c0:	0f b6 d2             	movzbl %dl,%edx
  8075c3:	83 c0 30             	add    $0x30,%eax
  8075c6:	88 44 15 ed          	mov    %al,-0x13(%ebp,%edx,1)
  8075ca:	89 f2                	mov    %esi,%edx
    } while(*ap);
  8075cc:	84 db                	test   %bl,%bl
  8075ce:	75 d0                	jne    8075a0 <inet_ntoa+0x21>
  8075d0:	c6 07 00             	movb   $0x0,(%edi)
  8075d3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8075d6:	eb 0d                	jmp    8075e5 <inet_ntoa+0x66>
    while(i--)
      *rp++ = inv[i];
  8075d8:	0f b6 c2             	movzbl %dl,%eax
  8075db:	0f b6 44 05 ed       	movzbl -0x13(%ebp,%eax,1),%eax
  8075e0:	88 01                	mov    %al,(%ecx)
  8075e2:	83 c1 01             	add    $0x1,%ecx
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  8075e5:	83 ea 01             	sub    $0x1,%edx
  8075e8:	80 fa ff             	cmp    $0xff,%dl
  8075eb:	75 eb                	jne    8075d8 <inet_ntoa+0x59>
  8075ed:	89 f0                	mov    %esi,%eax
  8075ef:	0f b6 f0             	movzbl %al,%esi
  8075f2:	03 75 e0             	add    -0x20(%ebp),%esi
      *rp++ = inv[i];
    *rp++ = '.';
  8075f5:	8d 46 01             	lea    0x1(%esi),%eax
  8075f8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8075fb:	c6 06 2e             	movb   $0x2e,(%esi)
    ap++;
  8075fe:	83 c7 01             	add    $0x1,%edi
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  807601:	8d 45 f4             	lea    -0xc(%ebp),%eax
  807604:	39 c7                	cmp    %eax,%edi
  807606:	75 90                	jne    807598 <inet_ntoa+0x19>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  807608:	c6 06 00             	movb   $0x0,(%esi)
  return str;
}
  80760b:	b8 e4 49 b3 00       	mov    $0xb349e4,%eax
  807610:	83 c4 14             	add    $0x14,%esp
  807613:	5b                   	pop    %ebx
  807614:	5e                   	pop    %esi
  807615:	5f                   	pop    %edi
  807616:	5d                   	pop    %ebp
  807617:	c3                   	ret    

00807618 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  807618:	55                   	push   %ebp
  807619:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  80761b:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80761f:	66 c1 c0 08          	rol    $0x8,%ax
}
  807623:	5d                   	pop    %ebp
  807624:	c3                   	ret    

00807625 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  807625:	55                   	push   %ebp
  807626:	89 e5                	mov    %esp,%ebp
  return htons(n);
  807628:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80762c:	66 c1 c0 08          	rol    $0x8,%ax
}
  807630:	5d                   	pop    %ebp
  807631:	c3                   	ret    

00807632 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  807632:	55                   	push   %ebp
  807633:	89 e5                	mov    %esp,%ebp
  807635:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
  807638:	89 d1                	mov    %edx,%ecx
  80763a:	c1 e1 18             	shl    $0x18,%ecx
  80763d:	89 d0                	mov    %edx,%eax
  80763f:	c1 e8 18             	shr    $0x18,%eax
  807642:	09 c8                	or     %ecx,%eax
  807644:	89 d1                	mov    %edx,%ecx
  807646:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80764c:	c1 e1 08             	shl    $0x8,%ecx
  80764f:	09 c8                	or     %ecx,%eax
  807651:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  807657:	c1 ea 08             	shr    $0x8,%edx
  80765a:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  80765c:	5d                   	pop    %ebp
  80765d:	c3                   	ret    

0080765e <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  80765e:	55                   	push   %ebp
  80765f:	89 e5                	mov    %esp,%ebp
  807661:	57                   	push   %edi
  807662:	56                   	push   %esi
  807663:	53                   	push   %ebx
  807664:	83 ec 20             	sub    $0x20,%esp
  807667:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  80766a:	0f be 10             	movsbl (%eax),%edx
inet_aton(const char *cp, struct in_addr *addr)
{
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  80766d:	8d 5d e4             	lea    -0x1c(%ebp),%ebx
  807670:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  807673:	0f b6 ca             	movzbl %dl,%ecx
  807676:	83 e9 30             	sub    $0x30,%ecx
  807679:	83 f9 09             	cmp    $0x9,%ecx
  80767c:	0f 87 94 01 00 00    	ja     807816 <inet_aton+0x1b8>
      return (0);
    val = 0;
    base = 10;
  807682:	c7 45 dc 0a 00 00 00 	movl   $0xa,-0x24(%ebp)
    if (c == '0') {
  807689:	83 fa 30             	cmp    $0x30,%edx
  80768c:	75 2b                	jne    8076b9 <inet_aton+0x5b>
      c = *++cp;
  80768e:	0f b6 50 01          	movzbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  807692:	89 d1                	mov    %edx,%ecx
  807694:	83 e1 df             	and    $0xffffffdf,%ecx
  807697:	80 f9 58             	cmp    $0x58,%cl
  80769a:	74 0f                	je     8076ab <inet_aton+0x4d>
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
  80769c:	83 c0 01             	add    $0x1,%eax
  80769f:	0f be d2             	movsbl %dl,%edx
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
      } else
        base = 8;
  8076a2:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  8076a9:	eb 0e                	jmp    8076b9 <inet_aton+0x5b>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
  8076ab:	0f be 50 02          	movsbl 0x2(%eax),%edx
  8076af:	8d 40 02             	lea    0x2(%eax),%eax
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
  8076b2:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
  8076b9:	83 c0 01             	add    $0x1,%eax
  8076bc:	be 00 00 00 00       	mov    $0x0,%esi
  8076c1:	eb 03                	jmp    8076c6 <inet_aton+0x68>
  8076c3:	83 c0 01             	add    $0x1,%eax
  8076c6:	8d 58 ff             	lea    -0x1(%eax),%ebx
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  8076c9:	89 55 e0             	mov    %edx,-0x20(%ebp)
  8076cc:	0f b6 fa             	movzbl %dl,%edi
  8076cf:	8d 4f d0             	lea    -0x30(%edi),%ecx
  8076d2:	83 f9 09             	cmp    $0x9,%ecx
  8076d5:	77 0d                	ja     8076e4 <inet_aton+0x86>
        val = (val * base) + (int)(c - '0');
  8076d7:	0f af 75 dc          	imul   -0x24(%ebp),%esi
  8076db:	8d 74 32 d0          	lea    -0x30(%edx,%esi,1),%esi
        c = *++cp;
  8076df:	0f be 10             	movsbl (%eax),%edx
  8076e2:	eb df                	jmp    8076c3 <inet_aton+0x65>
      } else if (base == 16 && isxdigit(c)) {
  8076e4:	83 7d dc 10          	cmpl   $0x10,-0x24(%ebp)
  8076e8:	75 32                	jne    80771c <inet_aton+0xbe>
  8076ea:	8d 4f 9f             	lea    -0x61(%edi),%ecx
  8076ed:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  8076f0:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8076f3:	81 e1 df 00 00 00    	and    $0xdf,%ecx
  8076f9:	83 e9 41             	sub    $0x41,%ecx
  8076fc:	83 f9 05             	cmp    $0x5,%ecx
  8076ff:	77 1b                	ja     80771c <inet_aton+0xbe>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  807701:	c1 e6 04             	shl    $0x4,%esi
  807704:	83 c2 0a             	add    $0xa,%edx
  807707:	83 7d d8 1a          	cmpl   $0x1a,-0x28(%ebp)
  80770b:	19 c9                	sbb    %ecx,%ecx
  80770d:	83 e1 20             	and    $0x20,%ecx
  807710:	83 c1 41             	add    $0x41,%ecx
  807713:	29 ca                	sub    %ecx,%edx
  807715:	09 d6                	or     %edx,%esi
        c = *++cp;
  807717:	0f be 10             	movsbl (%eax),%edx
  80771a:	eb a7                	jmp    8076c3 <inet_aton+0x65>
      } else
        break;
    }
    if (c == '.') {
  80771c:	83 fa 2e             	cmp    $0x2e,%edx
  80771f:	75 23                	jne    807744 <inet_aton+0xe6>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  807721:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807724:	8d 7d f0             	lea    -0x10(%ebp),%edi
  807727:	39 f8                	cmp    %edi,%eax
  807729:	0f 84 ee 00 00 00    	je     80781d <inet_aton+0x1bf>
        return (0);
      *pp++ = val;
  80772f:	83 c0 04             	add    $0x4,%eax
  807732:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807735:	89 70 fc             	mov    %esi,-0x4(%eax)
      c = *++cp;
  807738:	8d 43 01             	lea    0x1(%ebx),%eax
  80773b:	0f be 53 01          	movsbl 0x1(%ebx),%edx
    } else
      break;
  }
  80773f:	e9 2f ff ff ff       	jmp    807673 <inet_aton+0x15>
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807744:	85 d2                	test   %edx,%edx
  807746:	74 25                	je     80776d <inet_aton+0x10f>
  807748:	8d 4f e0             	lea    -0x20(%edi),%ecx
    return (0);
  80774b:	b8 00 00 00 00       	mov    $0x0,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807750:	83 f9 5f             	cmp    $0x5f,%ecx
  807753:	0f 87 d0 00 00 00    	ja     807829 <inet_aton+0x1cb>
  807759:	83 fa 20             	cmp    $0x20,%edx
  80775c:	74 0f                	je     80776d <inet_aton+0x10f>
  80775e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807761:	83 ea 09             	sub    $0x9,%edx
  807764:	83 fa 04             	cmp    $0x4,%edx
  807767:	0f 87 bc 00 00 00    	ja     807829 <inet_aton+0x1cb>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  80776d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  807770:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807773:	29 c2                	sub    %eax,%edx
  807775:	c1 fa 02             	sar    $0x2,%edx
  807778:	83 c2 01             	add    $0x1,%edx
  80777b:	83 fa 02             	cmp    $0x2,%edx
  80777e:	74 20                	je     8077a0 <inet_aton+0x142>
  807780:	83 fa 02             	cmp    $0x2,%edx
  807783:	7f 0f                	jg     807794 <inet_aton+0x136>

  case 0:
    return (0);       /* initial nondigit */
  807785:	b8 00 00 00 00       	mov    $0x0,%eax
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  80778a:	85 d2                	test   %edx,%edx
  80778c:	0f 84 97 00 00 00    	je     807829 <inet_aton+0x1cb>
  807792:	eb 67                	jmp    8077fb <inet_aton+0x19d>
  807794:	83 fa 03             	cmp    $0x3,%edx
  807797:	74 1e                	je     8077b7 <inet_aton+0x159>
  807799:	83 fa 04             	cmp    $0x4,%edx
  80779c:	74 38                	je     8077d6 <inet_aton+0x178>
  80779e:	eb 5b                	jmp    8077fb <inet_aton+0x19d>
  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
      return (0);
  8077a0:	b8 00 00 00 00       	mov    $0x0,%eax

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  8077a5:	81 fe ff ff ff 00    	cmp    $0xffffff,%esi
  8077ab:	77 7c                	ja     807829 <inet_aton+0x1cb>
      return (0);
    val |= parts[0] << 24;
  8077ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8077b0:	c1 e0 18             	shl    $0x18,%eax
  8077b3:	09 c6                	or     %eax,%esi
    break;
  8077b5:	eb 44                	jmp    8077fb <inet_aton+0x19d>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
      return (0);
  8077b7:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= parts[0] << 24;
    break;

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  8077bc:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  8077c2:	77 65                	ja     807829 <inet_aton+0x1cb>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  8077c4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8077c7:	c1 e2 18             	shl    $0x18,%edx
  8077ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8077cd:	c1 e0 10             	shl    $0x10,%eax
  8077d0:	09 d0                	or     %edx,%eax
  8077d2:	09 c6                	or     %eax,%esi
    break;
  8077d4:	eb 25                	jmp    8077fb <inet_aton+0x19d>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
      return (0);
  8077d6:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
    break;

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  8077db:	81 fe ff 00 00 00    	cmp    $0xff,%esi
  8077e1:	77 46                	ja     807829 <inet_aton+0x1cb>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  8077e3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8077e6:	c1 e2 18             	shl    $0x18,%edx
  8077e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8077ec:	c1 e0 10             	shl    $0x10,%eax
  8077ef:	09 c2                	or     %eax,%edx
  8077f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8077f4:	c1 e0 08             	shl    $0x8,%eax
  8077f7:	09 d0                	or     %edx,%eax
  8077f9:	09 c6                	or     %eax,%esi
    break;
  }
  if (addr)
  8077fb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8077ff:	74 23                	je     807824 <inet_aton+0x1c6>
    addr->s_addr = htonl(val);
  807801:	56                   	push   %esi
  807802:	e8 2b fe ff ff       	call   807632 <htonl>
  807807:	83 c4 04             	add    $0x4,%esp
  80780a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80780d:	89 03                	mov    %eax,(%ebx)
  return (1);
  80780f:	b8 01 00 00 00       	mov    $0x1,%eax
  807814:	eb 13                	jmp    807829 <inet_aton+0x1cb>
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
  807816:	b8 00 00 00 00       	mov    $0x0,%eax
  80781b:	eb 0c                	jmp    807829 <inet_aton+0x1cb>
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
  80781d:	b8 00 00 00 00       	mov    $0x0,%eax
  807822:	eb 05                	jmp    807829 <inet_aton+0x1cb>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
    addr->s_addr = htonl(val);
  return (1);
  807824:	b8 01 00 00 00       	mov    $0x1,%eax
}
  807829:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80782c:	5b                   	pop    %ebx
  80782d:	5e                   	pop    %esi
  80782e:	5f                   	pop    %edi
  80782f:	5d                   	pop    %ebp
  807830:	c3                   	ret    

00807831 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  807831:	55                   	push   %ebp
  807832:	89 e5                	mov    %esp,%ebp
  807834:	83 ec 10             	sub    $0x10,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  807837:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80783a:	50                   	push   %eax
  80783b:	ff 75 08             	pushl  0x8(%ebp)
  80783e:	e8 1b fe ff ff       	call   80765e <inet_aton>
  807843:	83 c4 08             	add    $0x8,%esp
    return (val.s_addr);
  807846:	85 c0                	test   %eax,%eax
  807848:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80784d:	0f 45 45 fc          	cmovne -0x4(%ebp),%eax
  }
  return (INADDR_NONE);
}
  807851:	c9                   	leave  
  807852:	c3                   	ret    

00807853 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807853:	55                   	push   %ebp
  807854:	89 e5                	mov    %esp,%ebp
  return htonl(n);
  807856:	ff 75 08             	pushl  0x8(%ebp)
  807859:	e8 d4 fd ff ff       	call   807632 <htonl>
  80785e:	83 c4 04             	add    $0x4,%esp
}
  807861:	c9                   	leave  
  807862:	c3                   	ret    

00807863 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807863:	55                   	push   %ebp
  807864:	89 e5                	mov    %esp,%ebp
  807866:	57                   	push   %edi
  807867:	56                   	push   %esi
  807868:	53                   	push   %ebx
  807869:	83 ec 3c             	sub    $0x3c,%esp
  80786c:	8b 7d 08             	mov    0x8(%ebp),%edi
  80786f:	8b 45 10             	mov    0x10(%ebp),%eax
  807872:	89 c6                	mov    %eax,%esi
  807874:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  807877:	8b 45 14             	mov    0x14(%ebp),%eax
  80787a:	89 c2                	mov    %eax,%edx
  80787c:	89 45 bc             	mov    %eax,-0x44(%ebp)
  80787f:	8b 45 18             	mov    0x18(%ebp),%eax
  807882:	89 c3                	mov    %eax,%ebx
  807884:	89 45 b8             	mov    %eax,-0x48(%ebp)
  807887:	8b 45 20             	mov    0x20(%ebp),%eax
  80788a:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  80788e:	88 55 dd             	mov    %dl,-0x23(%ebp)
  807891:	89 da                	mov    %ebx,%edx
  807893:	88 45 dc             	mov    %al,-0x24(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807896:	66 85 f6             	test   %si,%si
  807899:	74 1b                	je     8078b6 <tcp_enqueue+0x53>
  80789b:	84 c0                	test   %al,%al
  80789d:	74 17                	je     8078b6 <tcp_enqueue+0x53>
  80789f:	83 ec 04             	sub    $0x4,%esp
  8078a2:	68 40 1d 81 00       	push   $0x811d40
  8078a7:	68 90 00 00 00       	push   $0x90
  8078ac:	68 e2 1e 81 00       	push   $0x811ee2
  8078b1:	e8 d8 6a 00 00       	call   80e38e <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  8078b6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8078ba:	74 1d                	je     8078d9 <tcp_enqueue+0x76>
  8078bc:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8078c0:	74 17                	je     8078d9 <tcp_enqueue+0x76>
  8078c2:	83 ec 04             	sub    $0x4,%esp
  8078c5:	68 80 1d 81 00       	push   $0x811d80
  8078ca:	68 92 00 00 00       	push   $0x92
  8078cf:	68 e2 1e 81 00       	push   $0x811ee2
  8078d4:	e8 b5 6a 00 00       	call   80e38e <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  8078d9:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  8078dd:	66 3b 4f 6e          	cmp    0x6e(%edi),%cx
  8078e1:	76 0e                	jbe    8078f1 <tcp_enqueue+0x8e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  8078e3:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  8078e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8078ec:	e9 d1 05 00 00       	jmp    807ec2 <tcp_enqueue+0x65f>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  8078f1:	8b 4f 68             	mov    0x68(%edi),%ecx
  8078f4:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  8078f7:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  8078fb:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  8078ff:	66 83 f9 1f          	cmp    $0x1f,%cx
  807903:	76 0e                	jbe    807913 <tcp_enqueue+0xb0>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  807905:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807909:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80790e:	e9 af 05 00 00       	jmp    807ec2 <tcp_enqueue+0x65f>
  }
  if (queuelen != 0) {
  807913:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  807918:	74 23                	je     80793d <tcp_enqueue+0xda>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80791a:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80791e:	75 29                	jne    807949 <tcp_enqueue+0xe6>
  807920:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807924:	75 23                	jne    807949 <tcp_enqueue+0xe6>
  807926:	83 ec 04             	sub    $0x4,%esp
  807929:	68 c8 1d 81 00       	push   $0x811dc8
  80792e:	68 ae 00 00 00       	push   $0xae
  807933:	68 e2 1e 81 00       	push   $0x811ee2
  807938:	e8 51 6a 00 00       	call   80e38e <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  80793d:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807941:	75 41                	jne    807984 <tcp_enqueue+0x121>
  807943:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807947:	75 3b                	jne    807984 <tcp_enqueue+0x121>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807949:	c0 e8 02             	shr    $0x2,%al
  80794c:	c1 e0 0c             	shl    $0xc,%eax
  80794f:	66 05 00 50          	add    $0x5000,%ax
  807953:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
  807957:	8b 45 0c             	mov    0xc(%ebp),%eax
  80795a:	89 45 cc             	mov    %eax,-0x34(%ebp)
  80795d:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807961:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  807965:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
  807969:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  807970:	be 00 00 00 00       	mov    $0x0,%esi
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807975:	83 e2 01             	and    $0x1,%edx
  807978:	88 55 c9             	mov    %dl,-0x37(%ebp)
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80797b:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  80797f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807982:	eb 17                	jmp    80799b <tcp_enqueue+0x138>
  }
  if (queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807984:	83 ec 04             	sub    $0x4,%esp
  807987:	68 04 1e 81 00       	push   $0x811e04
  80798c:	68 b1 00 00 00       	push   $0xb1
  807991:	68 e2 1e 81 00       	push   $0x811ee2
  807996:	e8 f3 69 00 00       	call   80e38e <_panic>
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80799b:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  80799f:	66 39 47 34          	cmp    %ax,0x34(%edi)
  8079a3:	66 0f 46 47 34       	cmovbe 0x34(%edi),%ax
  8079a8:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  8079ac:	83 ec 0c             	sub    $0xc,%esp
  8079af:	6a 04                	push   $0x4
  8079b1:	e8 e8 c9 ff ff       	call   80439e <memp_malloc>
  8079b6:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  8079b8:	83 c4 10             	add    $0x10,%esp
  8079bb:	85 c0                	test   %eax,%eax
  8079bd:	0f 84 91 04 00 00    	je     807e54 <tcp_enqueue+0x5f1>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  8079c3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  8079c9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  8079d0:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  8079d4:	75 1f                	jne    8079f5 <tcp_enqueue+0x192>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  8079d6:	85 f6                	test   %esi,%esi
  8079d8:	75 17                	jne    8079f1 <tcp_enqueue+0x18e>
  8079da:	83 ec 04             	sub    $0x4,%esp
  8079dd:	68 fa 1e 81 00       	push   $0x811efa
  8079e2:	68 ce 00 00 00       	push   $0xce
  8079e7:	68 e2 1e 81 00       	push   $0x811ee2
  8079ec:	e8 9d 69 00 00       	call   80e38e <_panic>
      useg->next = seg;
  8079f1:	89 06                	mov    %eax,(%esi)
  8079f3:	eb 03                	jmp    8079f8 <tcp_enqueue+0x195>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  8079f5:	89 45 d0             	mov    %eax,-0x30(%ebp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  8079f8:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8079fc:	74 5f                	je     807a5d <tcp_enqueue+0x1fa>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  8079fe:	83 ec 04             	sub    $0x4,%esp
  807a01:	6a 00                	push   $0x0
  807a03:	ff 75 d4             	pushl  -0x2c(%ebp)
  807a06:	6a 00                	push   $0x0
  807a08:	e8 20 ce ff ff       	call   80482d <pbuf_alloc>
  807a0d:	89 43 04             	mov    %eax,0x4(%ebx)
  807a10:	83 c4 10             	add    $0x10,%esp
  807a13:	85 c0                	test   %eax,%eax
  807a15:	0f 84 39 04 00 00    	je     807e54 <tcp_enqueue+0x5f1>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807a1b:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
  807a1f:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  807a23:	73 17                	jae    807a3c <tcp_enqueue+0x1d9>
  807a25:	83 ec 04             	sub    $0x4,%esp
  807a28:	68 38 1e 81 00       	push   $0x811e38
  807a2d:	68 df 00 00 00       	push   $0xdf
  807a32:	68 e2 1e 81 00       	push   $0x811ee2
  807a37:	e8 52 69 00 00       	call   80e38e <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  807a3c:	83 ec 0c             	sub    $0xc,%esp
  807a3f:	50                   	push   %eax
  807a40:	e8 81 d1 ff ff       	call   804bc6 <pbuf_clen>
  807a45:	0f b6 c0             	movzbl %al,%eax
  807a48:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      seg->dataptr = seg->p->payload;
  807a4c:	8b 43 04             	mov    0x4(%ebx),%eax
  807a4f:	8b 40 04             	mov    0x4(%eax),%eax
  807a52:	89 43 08             	mov    %eax,0x8(%ebx)
  807a55:	83 c4 10             	add    $0x10,%esp
  807a58:	e9 00 01 00 00       	jmp    807b5d <tcp_enqueue+0x2fa>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807a5d:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  807a61:	74 7c                	je     807adf <tcp_enqueue+0x27c>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807a63:	83 ec 04             	sub    $0x4,%esp
  807a66:	6a 00                	push   $0x0
  807a68:	0f b7 75 e2          	movzwl -0x1e(%ebp),%esi
  807a6c:	0f b7 c6             	movzwl %si,%eax
  807a6f:	50                   	push   %eax
  807a70:	6a 00                	push   $0x0
  807a72:	e8 b6 cd ff ff       	call   80482d <pbuf_alloc>
  807a77:	89 43 04             	mov    %eax,0x4(%ebx)
  807a7a:	83 c4 10             	add    $0x10,%esp
  807a7d:	85 c0                	test   %eax,%eax
  807a7f:	0f 84 cf 03 00 00    	je     807e54 <tcp_enqueue+0x5f1>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807a85:	66 3b 70 0a          	cmp    0xa(%eax),%si
  807a89:	76 17                	jbe    807aa2 <tcp_enqueue+0x23f>
  807a8b:	83 ec 04             	sub    $0x4,%esp
  807a8e:	68 60 1e 81 00       	push   $0x811e60
  807a93:	68 ea 00 00 00       	push   $0xea
  807a98:	68 e2 1e 81 00       	push   $0x811ee2
  807a9d:	e8 ec 68 00 00       	call   80e38e <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  807aa2:	83 ec 0c             	sub    $0xc,%esp
  807aa5:	50                   	push   %eax
  807aa6:	e8 1b d1 ff ff       	call   804bc6 <pbuf_clen>
  807aab:	0f b6 c0             	movzbl %al,%eax
  807aae:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      if (arg != NULL) {
  807ab2:	83 c4 10             	add    $0x10,%esp
  807ab5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807ab9:	74 19                	je     807ad4 <tcp_enqueue+0x271>
        MEMCPY(seg->p->payload, ptr, seglen);
  807abb:	83 ec 04             	sub    $0x4,%esp
  807abe:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807ac2:	50                   	push   %eax
  807ac3:	ff 75 cc             	pushl  -0x34(%ebp)
  807ac6:	8b 43 04             	mov    0x4(%ebx),%eax
  807ac9:	ff 70 04             	pushl  0x4(%eax)
  807acc:	e8 15 71 00 00       	call   80ebe6 <memcpy>
  807ad1:	83 c4 10             	add    $0x10,%esp
      }
      seg->dataptr = seg->p->payload;
  807ad4:	8b 43 04             	mov    0x4(%ebx),%eax
  807ad7:	8b 40 04             	mov    0x4(%eax),%eax
  807ada:	89 43 08             	mov    %eax,0x8(%ebx)
  807add:	eb 7e                	jmp    807b5d <tcp_enqueue+0x2fa>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  807adf:	83 ec 04             	sub    $0x4,%esp
  807ae2:	6a 01                	push   $0x1
  807ae4:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807ae8:	50                   	push   %eax
  807ae9:	6a 00                	push   $0x0
  807aeb:	e8 3d cd ff ff       	call   80482d <pbuf_alloc>
  807af0:	89 c6                	mov    %eax,%esi
  807af2:	83 c4 10             	add    $0x10,%esp
  807af5:	85 c0                	test   %eax,%eax
  807af7:	0f 84 57 03 00 00    	je     807e54 <tcp_enqueue+0x5f1>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
  807afd:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807b01:	83 c0 01             	add    $0x1,%eax
  807b04:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  807b08:	8b 45 cc             	mov    -0x34(%ebp),%eax
  807b0b:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  807b0e:	89 43 08             	mov    %eax,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  807b11:	83 ec 04             	sub    $0x4,%esp
  807b14:	6a 00                	push   $0x0
  807b16:	6a 00                	push   $0x0
  807b18:	6a 00                	push   $0x0
  807b1a:	e8 0e cd ff ff       	call   80482d <pbuf_alloc>
  807b1f:	89 43 04             	mov    %eax,0x4(%ebx)
  807b22:	83 c4 10             	add    $0x10,%esp
  807b25:	85 c0                	test   %eax,%eax
  807b27:	75 11                	jne    807b3a <tcp_enqueue+0x2d7>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  807b29:	83 ec 0c             	sub    $0xc,%esp
  807b2c:	56                   	push   %esi
  807b2d:	e8 35 cc ff ff       	call   804767 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  807b32:	83 c4 10             	add    $0x10,%esp
  807b35:	e9 1a 03 00 00       	jmp    807e54 <tcp_enqueue+0x5f1>
      }
      queuelen += pbuf_clen(seg->p);
  807b3a:	83 ec 0c             	sub    $0xc,%esp
  807b3d:	50                   	push   %eax
  807b3e:	e8 83 d0 ff ff       	call   804bc6 <pbuf_clen>
  807b43:	0f b6 c0             	movzbl %al,%eax
  807b46:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  807b4a:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  807b4e:	83 c4 08             	add    $0x8,%esp
  807b51:	56                   	push   %esi
  807b52:	ff 73 04             	pushl  0x4(%ebx)
  807b55:	e8 95 d0 ff ff       	call   804bef <pbuf_cat>
  807b5a:	83 c4 10             	add    $0x10,%esp
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807b5d:	66 83 7d e0 20       	cmpw   $0x20,-0x20(%ebp)
  807b62:	0f 87 ec 02 00 00    	ja     807e54 <tcp_enqueue+0x5f1>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  807b68:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807b6c:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807b70:	83 ec 08             	sub    $0x8,%esp
  807b73:	6a 14                	push   $0x14
  807b75:	ff 73 04             	pushl  0x4(%ebx)
  807b78:	e8 18 cb ff ff       	call   804695 <pbuf_header>
  807b7d:	83 c4 10             	add    $0x10,%esp
  807b80:	84 c0                	test   %al,%al
  807b82:	0f 85 cc 02 00 00    	jne    807e54 <tcp_enqueue+0x5f1>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  807b88:	8b 43 04             	mov    0x4(%ebx),%eax
  807b8b:	8b 70 04             	mov    0x4(%eax),%esi
  807b8e:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807b91:	83 ec 0c             	sub    $0xc,%esp
  807b94:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807b98:	50                   	push   %eax
  807b99:	e8 7a fa ff ff       	call   807618 <htons>
  807b9e:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807ba1:	8b 73 10             	mov    0x10(%ebx),%esi
  807ba4:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807ba8:	89 04 24             	mov    %eax,(%esp)
  807bab:	e8 68 fa ff ff       	call   807618 <htons>
  807bb0:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807bb4:	8b 73 10             	mov    0x10(%ebx),%esi
  807bb7:	83 c4 04             	add    $0x4,%esp
  807bba:	ff 75 d8             	pushl  -0x28(%ebp)
  807bbd:	e8 70 fa ff ff       	call   807632 <htonl>
  807bc2:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807bc5:	8b 43 10             	mov    0x10(%ebx),%eax
  807bc8:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807bce:	8b 73 10             	mov    0x10(%ebx),%esi
  807bd1:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807bd5:	89 04 24             	mov    %eax,(%esp)
  807bd8:	e8 48 fa ff ff       	call   807625 <ntohs>
  807bdd:	83 e0 c0             	and    $0xffffffc0,%eax
  807be0:	0f b6 55 dd          	movzbl -0x23(%ebp),%edx
  807be4:	09 d0                	or     %edx,%eax
  807be6:	0f b7 c0             	movzwl %ax,%eax
  807be9:	89 04 24             	mov    %eax,(%esp)
  807bec:	e8 27 fa ff ff       	call   807618 <htons>
  807bf1:	66 89 46 0c          	mov    %ax,0xc(%esi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  807bf5:	83 c4 10             	add    $0x10,%esp
  807bf8:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807bfc:	75 27                	jne    807c25 <tcp_enqueue+0x3c2>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  807bfe:	8b 73 10             	mov    0x10(%ebx),%esi
  807c01:	83 ec 0c             	sub    $0xc,%esp
  807c04:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807c08:	50                   	push   %eax
  807c09:	e8 17 fa ff ff       	call   807625 <ntohs>
  807c0e:	83 e0 3f             	and    $0x3f,%eax
  807c11:	80 cc 50             	or     $0x50,%ah
  807c14:	89 04 24             	mov    %eax,(%esp)
  807c17:	e8 fc f9 ff ff       	call   807618 <htons>
  807c1c:	66 89 46 0c          	mov    %ax,0xc(%esi)
  807c20:	83 c4 10             	add    $0x10,%esp
  807c23:	eb 3a                	jmp    807c5f <tcp_enqueue+0x3fc>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807c25:	8b 73 10             	mov    0x10(%ebx),%esi
  807c28:	83 ec 0c             	sub    $0xc,%esp
  807c2b:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807c2f:	50                   	push   %eax
  807c30:	e8 f0 f9 ff ff       	call   807625 <ntohs>
  807c35:	83 e0 3f             	and    $0x3f,%eax
  807c38:	66 0b 45 ca          	or     -0x36(%ebp),%ax
  807c3c:	0f b7 c0             	movzwl %ax,%eax
  807c3f:	89 04 24             	mov    %eax,(%esp)
  807c42:	e8 d1 f9 ff ff       	call   807618 <htons>
  807c47:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807c4b:	83 c4 0c             	add    $0xc,%esp
  807c4e:	ff 75 d4             	pushl  -0x2c(%ebp)
  807c51:	ff 75 1c             	pushl  0x1c(%ebp)
  807c54:	ff 73 08             	pushl  0x8(%ebx)
  807c57:	e8 8a 6f 00 00       	call   80ebe6 <memcpy>
  807c5c:	83 c4 10             	add    $0x10,%esp
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  807c5f:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  807c63:	0f b7 c1             	movzwl %cx,%eax
  807c66:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807c69:	01 45 cc             	add    %eax,-0x34(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  807c6c:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  807c70:	0f 94 45 e4          	sete   -0x1c(%ebp)
  807c74:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  807c78:	89 de                	mov    %ebx,%esi

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  807c7a:	66 29 4d de          	sub    %cx,-0x22(%ebp)
  807c7e:	0f 85 17 fd ff ff    	jne    80799b <tcp_enqueue+0x138>
  807c84:	84 c0                	test   %al,%al
  807c86:	0f 85 0f fd ff ff    	jne    80799b <tcp_enqueue+0x138>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807c8c:	8b 77 74             	mov    0x74(%edi),%esi
  807c8f:	85 f6                	test   %esi,%esi
  807c91:	75 07                	jne    807c9a <tcp_enqueue+0x437>
  807c93:	e9 ff 00 00 00       	jmp    807d97 <tcp_enqueue+0x534>
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807c98:	89 c6                	mov    %eax,%esi
  807c9a:	8b 06                	mov    (%esi),%eax
  807c9c:	85 c0                	test   %eax,%eax
  807c9e:	75 f8                	jne    807c98 <tcp_enqueue+0x435>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  807ca0:	85 f6                	test   %esi,%esi
  807ca2:	0f 84 ef 00 00 00    	je     807d97 <tcp_enqueue+0x534>
    TCP_TCPLEN(useg) != 0 &&
  807ca8:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807cac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807caf:	83 ec 0c             	sub    $0xc,%esp
  807cb2:	8b 46 10             	mov    0x10(%esi),%eax
  807cb5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807cb9:	50                   	push   %eax
  807cba:	e8 66 f9 ff ff       	call   807625 <ntohs>
  807cbf:	83 c4 10             	add    $0x10,%esp
  807cc2:	ba 01 00 00 00       	mov    $0x1,%edx
  807cc7:	a8 01                	test   $0x1,%al
  807cc9:	75 1b                	jne    807ce6 <tcp_enqueue+0x483>
  807ccb:	83 ec 0c             	sub    $0xc,%esp
  807cce:	8b 46 10             	mov    0x10(%esi),%eax
  807cd1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807cd5:	50                   	push   %eax
  807cd6:	e8 4a f9 ff ff       	call   807625 <ntohs>
  807cdb:	66 d1 e8             	shr    %ax
  807cde:	89 c2                	mov    %eax,%edx
  807ce0:	83 e2 01             	and    $0x1,%edx
  807ce3:	83 c4 10             	add    $0x10,%esp
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  807ce6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807ce9:	01 d0                	add    %edx,%eax
  807ceb:	0f 84 c7 01 00 00    	je     807eb8 <tcp_enqueue+0x655>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807cf1:	83 ec 0c             	sub    $0xc,%esp
  807cf4:	8b 46 10             	mov    0x10(%esi),%eax
  807cf7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807cfb:	50                   	push   %eax
  807cfc:	e8 24 f9 ff ff       	call   807625 <ntohs>
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  807d01:	83 c4 10             	add    $0x10,%esp
  807d04:	a8 03                	test   $0x3,%al
  807d06:	0f 85 ac 01 00 00    	jne    807eb8 <tcp_enqueue+0x655>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807d0c:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807d10:	0f 85 a2 01 00 00    	jne    807eb8 <tcp_enqueue+0x655>
    !(flags & (TCP_SYN | TCP_FIN)) &&
  807d16:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  807d1a:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807d1d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807d21:	01 d0                	add    %edx,%eax
  807d23:	0f b7 57 34          	movzwl 0x34(%edi),%edx
  807d27:	39 d0                	cmp    %edx,%eax
  807d29:	0f 8f 89 01 00 00    	jg     807eb8 <tcp_enqueue+0x655>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  807d2f:	83 ec 08             	sub    $0x8,%esp
  807d32:	6a ec                	push   $0xffffffec
  807d34:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807d37:	ff 70 04             	pushl  0x4(%eax)
  807d3a:	e8 56 c9 ff ff       	call   804695 <pbuf_header>
  807d3f:	83 c4 10             	add    $0x10,%esp
  807d42:	84 c0                	test   %al,%al
  807d44:	74 17                	je     807d5d <tcp_enqueue+0x4fa>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  807d46:	83 ec 04             	sub    $0x4,%esp
  807d49:	68 07 1f 81 00       	push   $0x811f07
  807d4e:	68 52 01 00 00       	push   $0x152
  807d53:	68 e2 1e 81 00       	push   $0x811ee2
  807d58:	e8 31 66 00 00       	call   80e38e <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  807d5d:	83 ec 08             	sub    $0x8,%esp
  807d60:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807d63:	ff 70 04             	pushl  0x4(%eax)
  807d66:	ff 76 04             	pushl  0x4(%esi)
  807d69:	e8 81 ce ff ff       	call   804bef <pbuf_cat>
    useg->len += queue->len;
  807d6e:	8b 55 d0             	mov    -0x30(%ebp),%edx
  807d71:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807d75:	66 01 46 0c          	add    %ax,0xc(%esi)
    useg->next = queue->next;
  807d79:	8b 02                	mov    (%edx),%eax
  807d7b:	89 06                	mov    %eax,(%esi)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  807d7d:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  807d80:	39 da                	cmp    %ebx,%edx
  807d82:	b8 00 00 00 00       	mov    $0x0,%eax
  807d87:	0f 44 d8             	cmove  %eax,%ebx
    }
    memp_free(MEMP_TCP_SEG, queue);
  807d8a:	52                   	push   %edx
  807d8b:	6a 04                	push   $0x4
  807d8d:	e8 62 c6 ff ff       	call   8043f4 <memp_free>
  807d92:	83 c4 10             	add    $0x10,%esp
  807d95:	eb 1f                	jmp    807db6 <tcp_enqueue+0x553>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  807d97:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807d9a:	89 47 74             	mov    %eax,0x74(%edi)
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  807d9d:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
  807da1:	83 e2 03             	and    $0x3,%edx
    ++len;
  807da4:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807da8:	83 c0 01             	add    $0x1,%eax
  807dab:	84 d2                	test   %dl,%dl
  807dad:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  807db2:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  }
  if (flags & TCP_FIN) {
  807db6:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  807dba:	74 04                	je     807dc0 <tcp_enqueue+0x55d>
    pcb->flags |= TF_FIN;
  807dbc:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  }
  pcb->snd_lbb += len;
  807dc0:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  807dc4:	0f b7 c2             	movzwl %dx,%eax
  807dc7:	01 47 68             	add    %eax,0x68(%edi)

  pcb->snd_buf -= len;
  807dca:	66 29 57 6e          	sub    %dx,0x6e(%edi)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  807dce:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807dd2:	66 89 47 70          	mov    %ax,0x70(%edi)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  807dd6:	66 85 c0             	test   %ax,%ax
  807dd9:	74 23                	je     807dfe <tcp_enqueue+0x59b>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807ddb:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807ddf:	75 1d                	jne    807dfe <tcp_enqueue+0x59b>
  807de1:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807de5:	75 17                	jne    807dfe <tcp_enqueue+0x59b>
  807de7:	83 ec 04             	sub    $0x4,%esp
  807dea:	68 94 1e 81 00       	push   $0x811e94
  807def:	68 7a 01 00 00       	push   $0x17a
  807df4:	68 e2 1e 81 00       	push   $0x811ee2
  807df9:	e8 90 65 00 00       	call   80e38e <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807dfe:	85 db                	test   %ebx,%ebx
  807e00:	0f 84 8f 00 00 00    	je     807e95 <tcp_enqueue+0x632>
  807e06:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  807e0b:	0f 84 84 00 00 00    	je     807e95 <tcp_enqueue+0x632>
  807e11:	8b 5b 10             	mov    0x10(%ebx),%ebx
  807e14:	85 db                	test   %ebx,%ebx
  807e16:	0f 84 80 00 00 00    	je     807e9c <tcp_enqueue+0x639>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  807e1c:	b8 00 00 00 00       	mov    $0x0,%eax
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807e21:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  807e25:	0f 85 97 00 00 00    	jne    807ec2 <tcp_enqueue+0x65f>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  807e2b:	83 ec 0c             	sub    $0xc,%esp
  807e2e:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  807e32:	50                   	push   %eax
  807e33:	e8 ed f7 ff ff       	call   807625 <ntohs>
  807e38:	83 c8 08             	or     $0x8,%eax
  807e3b:	0f b7 c0             	movzwl %ax,%eax
  807e3e:	89 04 24             	mov    %eax,(%esp)
  807e41:	e8 d2 f7 ff ff       	call   807618 <htons>
  807e46:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  807e4a:	83 c4 10             	add    $0x10,%esp
  }

  return ERR_OK;
  807e4d:	b8 00 00 00 00       	mov    $0x0,%eax
  807e52:	eb 6e                	jmp    807ec2 <tcp_enqueue+0x65f>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  807e54:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  807e58:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807e5b:	85 c0                	test   %eax,%eax
  807e5d:	74 0c                	je     807e6b <tcp_enqueue+0x608>
    tcp_segs_free(queue);
  807e5f:	83 ec 0c             	sub    $0xc,%esp
  807e62:	50                   	push   %eax
  807e63:	e8 89 d8 ff ff       	call   8056f1 <tcp_segs_free>
  807e68:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  807e6b:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  807e70:	74 31                	je     807ea3 <tcp_enqueue+0x640>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807e72:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807e76:	75 32                	jne    807eaa <tcp_enqueue+0x647>
  807e78:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807e7c:	75 33                	jne    807eb1 <tcp_enqueue+0x64e>
  807e7e:	83 ec 04             	sub    $0x4,%esp
  807e81:	68 94 1e 81 00       	push   $0x811e94
  807e86:	68 8d 01 00 00       	push   $0x18d
  807e8b:	68 e2 1e 81 00       	push   $0x811ee2
  807e90:	e8 f9 64 00 00       	call   80e38e <_panic>
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  807e95:	b8 00 00 00 00       	mov    $0x0,%eax
  807e9a:	eb 26                	jmp    807ec2 <tcp_enqueue+0x65f>
  807e9c:	b8 00 00 00 00       	mov    $0x0,%eax
  807ea1:	eb 1f                	jmp    807ec2 <tcp_enqueue+0x65f>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  807ea3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807ea8:	eb 18                	jmp    807ec2 <tcp_enqueue+0x65f>
  807eaa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807eaf:	eb 11                	jmp    807ec2 <tcp_enqueue+0x65f>
  807eb1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807eb6:	eb 0a                	jmp    807ec2 <tcp_enqueue+0x65f>
      /* initialize list with this segment */
      pcb->unsent = queue;
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  807eb8:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807ebb:	89 06                	mov    %eax,(%esi)
  807ebd:	e9 db fe ff ff       	jmp    807d9d <tcp_enqueue+0x53a>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  807ec2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807ec5:	5b                   	pop    %ebx
  807ec6:	5e                   	pop    %esi
  807ec7:	5f                   	pop    %edi
  807ec8:	5d                   	pop    %ebp
  807ec9:	c3                   	ret    

00807eca <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  807eca:	55                   	push   %ebp
  807ecb:	89 e5                	mov    %esp,%ebp
  807ecd:	83 ec 0c             	sub    $0xc,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  807ed0:	6a 00                	push   $0x0
  807ed2:	6a 00                	push   $0x0
  807ed4:	6a 01                	push   $0x1
  807ed6:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  807eda:	50                   	push   %eax
  807edb:	6a 00                	push   $0x0
  807edd:	6a 00                	push   $0x0
  807edf:	ff 75 08             	pushl  0x8(%ebp)
  807ee2:	e8 7c f9 ff ff       	call   807863 <tcp_enqueue>
}
  807ee7:	c9                   	leave  
  807ee8:	c3                   	ret    

00807ee9 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  807ee9:	55                   	push   %ebp
  807eea:	89 e5                	mov    %esp,%ebp
  807eec:	56                   	push   %esi
  807eed:	53                   	push   %ebx
  807eee:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807ef1:	8b 55 10             	mov    0x10(%ebp),%edx
  807ef4:	8b 5d 14             	mov    0x14(%ebp),%ebx
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  807ef7:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  807efa:	8d 70 fe             	lea    -0x2(%eax),%esi
  807efd:	83 fe 02             	cmp    $0x2,%esi
  807f00:	76 05                	jbe    807f07 <tcp_write+0x1e>
  807f02:	83 f8 07             	cmp    $0x7,%eax
  807f05:	75 29                	jne    807f30 <tcp_write+0x47>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  807f07:	b8 00 00 00 00       	mov    $0x0,%eax
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  807f0c:	66 85 d2             	test   %dx,%dx
  807f0f:	74 24                	je     807f35 <tcp_write+0x4c>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  807f11:	83 ec 04             	sub    $0x4,%esp
  807f14:	6a 00                	push   $0x0
  807f16:	6a 00                	push   $0x0
  807f18:	0f b6 db             	movzbl %bl,%ebx
  807f1b:	53                   	push   %ebx
  807f1c:	6a 00                	push   $0x0
  807f1e:	0f b7 d2             	movzwl %dx,%edx
  807f21:	52                   	push   %edx
  807f22:	ff 75 0c             	pushl  0xc(%ebp)
  807f25:	51                   	push   %ecx
  807f26:	e8 38 f9 ff ff       	call   807863 <tcp_enqueue>
  807f2b:	83 c4 20             	add    $0x20,%esp
  807f2e:	eb 05                	jmp    807f35 <tcp_write+0x4c>
    }
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  807f30:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  }
}
  807f35:	8d 65 f8             	lea    -0x8(%ebp),%esp
  807f38:	5b                   	pop    %ebx
  807f39:	5e                   	pop    %esi
  807f3a:	5d                   	pop    %ebp
  807f3b:	c3                   	ret    

00807f3c <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  807f3c:	55                   	push   %ebp
  807f3d:	89 e5                	mov    %esp,%ebp
  807f3f:	57                   	push   %edi
  807f40:	56                   	push   %esi
  807f41:	53                   	push   %ebx
  807f42:	83 ec 1c             	sub    $0x1c,%esp
  807f45:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  807f48:	39 3d 58 b2 b3 00    	cmp    %edi,0xb3b258
  807f4e:	0f 84 36 04 00 00    	je     80838a <tcp_output+0x44e>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  807f54:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  807f58:	66 39 47 4e          	cmp    %ax,0x4e(%edi)
  807f5c:	66 0f 46 47 4e       	cmovbe 0x4e(%edi),%ax
  807f61:	0f b7 c0             	movzwl %ax,%eax
  807f64:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  807f67:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  807f6a:	8b 47 78             	mov    0x78(%edi),%eax
  807f6d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807f70:	8b 55 dc             	mov    -0x24(%ebp),%edx
  if (useg != NULL) {
  807f73:	85 c0                	test   %eax,%eax
  807f75:	75 06                	jne    807f7d <tcp_output+0x41>
  807f77:	eb 0d                	jmp    807f86 <tcp_output+0x4a>
    for (; useg->next != NULL; useg = useg->next);
  807f79:	89 c2                	mov    %eax,%edx
  807f7b:	eb 00                	jmp    807f7d <tcp_output+0x41>
  807f7d:	8b 02                	mov    (%edx),%eax
  807f7f:	85 c0                	test   %eax,%eax
  807f81:	75 f6                	jne    807f79 <tcp_output+0x3d>
  807f83:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  807f86:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  807f8a:	75 0b                	jne    807f97 <tcp_output+0x5b>

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  807f8c:	8d 47 04             	lea    0x4(%edi),%eax
  807f8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807f92:	e9 8c 03 00 00       	jmp    808323 <tcp_output+0x3e7>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  807f97:	85 db                	test   %ebx,%ebx
  807f99:	74 1f                	je     807fba <tcp_output+0x7e>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  807f9b:	83 ec 0c             	sub    $0xc,%esp
  807f9e:	8b 43 10             	mov    0x10(%ebx),%eax
  807fa1:	ff 70 04             	pushl  0x4(%eax)
  807fa4:	e8 aa f8 ff ff       	call   807853 <ntohl>
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  807fa9:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  807fad:	2b 57 48             	sub    0x48(%edi),%edx
  807fb0:	01 d0                	add    %edx,%eax
  807fb2:	83 c4 10             	add    $0x10,%esp
  807fb5:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  807fb8:	73 d2                	jae    807f8c <tcp_output+0x50>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  807fba:	83 ec 04             	sub    $0x4,%esp
  807fbd:	6a 00                	push   $0x0
  807fbf:	6a 14                	push   $0x14
  807fc1:	6a 01                	push   $0x1
  807fc3:	e8 65 c8 ff ff       	call   80482d <pbuf_alloc>
  807fc8:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  807fca:	83 c4 10             	add    $0x10,%esp
  807fcd:	85 c0                	test   %eax,%eax
  807fcf:	0f 84 bc 03 00 00    	je     808391 <tcp_output+0x455>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  807fd5:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  807fd9:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  807fdc:	83 ec 0c             	sub    $0xc,%esp
  807fdf:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807fe3:	50                   	push   %eax
  807fe4:	e8 2f f6 ff ff       	call   807618 <htons>
  807fe9:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  807fec:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807ff0:	89 04 24             	mov    %eax,(%esp)
  807ff3:	e8 20 f6 ff ff       	call   807618 <htons>
  807ff8:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  807ffc:	83 c4 04             	add    $0x4,%esp
  807fff:	ff 77 54             	pushl  0x54(%edi)
  808002:	e8 2b f6 ff ff       	call   807632 <htonl>
  808007:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  80800a:	83 c4 04             	add    $0x4,%esp
  80800d:	ff 77 24             	pushl  0x24(%edi)
  808010:	e8 1d f6 ff ff       	call   807632 <htonl>
  808015:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  808018:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80801c:	89 04 24             	mov    %eax,(%esp)
  80801f:	e8 01 f6 ff ff       	call   807625 <ntohs>
  808024:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808029:	83 c8 10             	or     $0x10,%eax
  80802c:	89 04 24             	mov    %eax,(%esp)
  80802f:	e8 e4 f5 ff ff       	call   807618 <htons>
  808034:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808038:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80803c:	89 04 24             	mov    %eax,(%esp)
  80803f:	e8 d4 f5 ff ff       	call   807618 <htons>
  808044:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  808048:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80804e:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808052:	89 04 24             	mov    %eax,(%esp)
  808055:	e8 cb f5 ff ff       	call   807625 <ntohs>
  80805a:	83 e0 3f             	and    $0x3f,%eax
  80805d:	80 cc 50             	or     $0x50,%ah
  808060:	89 04 24             	mov    %eax,(%esp)
  808063:	e8 b0 f5 ff ff       	call   807618 <htons>
  808068:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80806c:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  808072:	8d 47 04             	lea    0x4(%edi),%eax
  808075:	89 c1                	mov    %eax,%ecx
  808077:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80807b:	89 04 24             	mov    %eax,(%esp)
  80807e:	6a 06                	push   $0x6
  808080:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808083:	51                   	push   %ecx
  808084:	57                   	push   %edi
  808085:	56                   	push   %esi
  808086:	e8 74 f2 ff ff       	call   8072ff <inet_chksum_pseudo>
  80808b:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80808f:	83 c4 18             	add    $0x18,%esp
  808092:	6a 06                	push   $0x6
  808094:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808098:	50                   	push   %eax
  808099:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80809d:	50                   	push   %eax
  80809e:	ff 75 e4             	pushl  -0x1c(%ebp)
  8080a1:	57                   	push   %edi
  8080a2:	56                   	push   %esi
  8080a3:	e8 9e e8 ff ff       	call   806946 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  8080a8:	83 c4 14             	add    $0x14,%esp
  8080ab:	56                   	push   %esi
  8080ac:	e8 b6 c6 ff ff       	call   804767 <pbuf_free>

    return ERR_OK;
  8080b1:	83 c4 10             	add    $0x10,%esp
  8080b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8080b9:	e9 ed 02 00 00       	jmp    8083ab <tcp_output+0x46f>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  8080be:	83 ec 0c             	sub    $0xc,%esp
  8080c1:	8b 43 10             	mov    0x10(%ebx),%eax
  8080c4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8080c8:	50                   	push   %eax
  8080c9:	e8 57 f5 ff ff       	call   807625 <ntohs>
  8080ce:	83 c4 10             	add    $0x10,%esp
  8080d1:	a8 04                	test   $0x4,%al
  8080d3:	74 17                	je     8080ec <tcp_output+0x1b0>
  8080d5:	83 ec 04             	sub    $0x4,%esp
  8080d8:	68 1b 1f 81 00       	push   $0x811f1b
  8080dd:	68 05 02 00 00       	push   $0x205
  8080e2:	68 e2 1e 81 00       	push   $0x811ee2
  8080e7:	e8 a2 62 00 00       	call   80e38e <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  8080ec:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8080f0:	74 1c                	je     80810e <tcp_output+0x1d2>
  8080f2:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  8080f6:	a8 40                	test   $0x40,%al
  8080f8:	75 14                	jne    80810e <tcp_output+0x1d2>
  8080fa:	8b 57 74             	mov    0x74(%edi),%edx
  8080fd:	85 d2                	test   %edx,%edx
  8080ff:	0f 84 93 02 00 00    	je     808398 <tcp_output+0x45c>
  808105:	83 3a 00             	cmpl   $0x0,(%edx)
  808108:	0f 84 8a 02 00 00    	je     808398 <tcp_output+0x45c>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  80810e:	8b 03                	mov    (%ebx),%eax
  808110:	89 47 74             	mov    %eax,0x74(%edi)

    if (pcb->state != SYN_SENT) {
  808113:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  808117:	74 29                	je     808142 <tcp_output+0x206>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  808119:	8b 73 10             	mov    0x10(%ebx),%esi
  80811c:	83 ec 0c             	sub    $0xc,%esp
  80811f:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  808123:	50                   	push   %eax
  808124:	e8 fc f4 ff ff       	call   807625 <ntohs>
  808129:	83 c8 10             	or     $0x10,%eax
  80812c:	0f b7 c0             	movzwl %ax,%eax
  80812f:	89 04 24             	mov    %eax,(%esp)
  808132:	e8 e1 f4 ff ff       	call   807618 <htons>
  808137:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80813b:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  80813f:	83 c4 10             	add    $0x10,%esp
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  808142:	8b 73 10             	mov    0x10(%ebx),%esi
  808145:	83 ec 0c             	sub    $0xc,%esp
  808148:	ff 77 24             	pushl  0x24(%edi)
  80814b:	e8 e2 f4 ff ff       	call   807632 <htonl>
  808150:	89 46 08             	mov    %eax,0x8(%esi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808153:	8b 73 10             	mov    0x10(%ebx),%esi
  808156:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80815a:	89 04 24             	mov    %eax,(%esp)
  80815d:	e8 b6 f4 ff ff       	call   807618 <htons>
  808162:	66 89 46 0e          	mov    %ax,0xe(%esi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  808166:	83 c4 10             	add    $0x10,%esp
  808169:	85 ff                	test   %edi,%edi
  80816b:	74 05                	je     808172 <tcp_output+0x236>
  80816d:	83 3f 00             	cmpl   $0x0,(%edi)
  808170:	75 27                	jne    808199 <tcp_output+0x25d>
    netif = ip_route(&(pcb->remote_ip));
  808172:	83 ec 0c             	sub    $0xc,%esp
  808175:	ff 75 e4             	pushl  -0x1c(%ebp)
  808178:	e8 df e2 ff ff       	call   80645c <ip_route>
    if (netif == NULL) {
  80817d:	83 c4 10             	add    $0x10,%esp
  808180:	85 c0                	test   %eax,%eax
  808182:	0f 84 a2 00 00 00    	je     80822a <tcp_output+0x2ee>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  808188:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80818b:	74 05                	je     808192 <tcp_output+0x256>
  80818d:	8b 40 04             	mov    0x4(%eax),%eax
  808190:	eb 05                	jmp    808197 <tcp_output+0x25b>
  808192:	b8 00 00 00 00       	mov    $0x0,%eax
  808197:	89 07                	mov    %eax,(%edi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  808199:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  80819e:	75 06                	jne    8081a6 <tcp_output+0x26a>
    pcb->rtime = 0;
  8081a0:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

  if (pcb->rttest == 0) {
  8081a6:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  8081aa:	75 1c                	jne    8081c8 <tcp_output+0x28c>
    pcb->rttest = tcp_ticks;
  8081ac:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8081b1:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8081b4:	83 ec 0c             	sub    $0xc,%esp
  8081b7:	8b 43 10             	mov    0x10(%ebx),%eax
  8081ba:	ff 70 04             	pushl  0x4(%eax)
  8081bd:	e8 91 f6 ff ff       	call   807853 <ntohl>
  8081c2:	89 47 3c             	mov    %eax,0x3c(%edi)
  8081c5:	83 c4 10             	add    $0x10,%esp
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  8081c8:	8b 53 04             	mov    0x4(%ebx),%edx
  8081cb:	8b 43 10             	mov    0x10(%ebx),%eax
  8081ce:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  8081d1:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  8081d5:	8b 53 04             	mov    0x4(%ebx),%edx
  8081d8:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  8081dc:	8b 43 04             	mov    0x4(%ebx),%eax
  8081df:	8b 53 10             	mov    0x10(%ebx),%edx
  8081e2:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  8081e5:	8b 43 10             	mov    0x10(%ebx),%eax
  8081e8:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8081ee:	8b 73 10             	mov    0x10(%ebx),%esi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  8081f1:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8081f4:	83 ec 0c             	sub    $0xc,%esp
  8081f7:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  8081fb:	52                   	push   %edx
  8081fc:	6a 06                	push   $0x6
  8081fe:	ff 75 e4             	pushl  -0x1c(%ebp)
  808201:	57                   	push   %edi
  808202:	50                   	push   %eax
  808203:	e8 f7 f0 ff ff       	call   8072ff <inet_chksum_pseudo>
  808208:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80820c:	83 c4 18             	add    $0x18,%esp
  80820f:	6a 06                	push   $0x6
  808211:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808215:	50                   	push   %eax
  808216:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80821a:	50                   	push   %eax
  80821b:	ff 75 e4             	pushl  -0x1c(%ebp)
  80821e:	57                   	push   %edi
  80821f:	ff 73 04             	pushl  0x4(%ebx)
  808222:	e8 1f e7 ff ff       	call   806946 <ip_output>
  808227:	83 c4 20             	add    $0x20,%esp
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  80822a:	83 ec 0c             	sub    $0xc,%esp
  80822d:	8b 43 10             	mov    0x10(%ebx),%eax
  808230:	ff 70 04             	pushl  0x4(%eax)
  808233:	e8 1b f6 ff ff       	call   807853 <ntohl>
  808238:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80823b:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80823f:	8b 43 10             	mov    0x10(%ebx),%eax
  808242:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808246:	89 04 24             	mov    %eax,(%esp)
  808249:	e8 d7 f3 ff ff       	call   807625 <ntohs>
  80824e:	83 c4 10             	add    $0x10,%esp
  808251:	ba 01 00 00 00       	mov    $0x1,%edx
  808256:	a8 01                	test   $0x1,%al
  808258:	75 1b                	jne    808275 <tcp_output+0x339>
  80825a:	83 ec 0c             	sub    $0xc,%esp
  80825d:	8b 43 10             	mov    0x10(%ebx),%eax
  808260:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808264:	50                   	push   %eax
  808265:	e8 bb f3 ff ff       	call   807625 <ntohs>
  80826a:	66 d1 e8             	shr    %ax
  80826d:	89 c2                	mov    %eax,%edx
  80826f:	83 e2 01             	and    $0x1,%edx
  808272:	83 c4 10             	add    $0x10,%esp
  808275:	01 d6                	add    %edx,%esi
  808277:	03 75 e0             	add    -0x20(%ebp),%esi
  80827a:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  80827d:	39 77 58             	cmp    %esi,0x58(%edi)
  808280:	79 03                	jns    808285 <tcp_output+0x349>
      pcb->snd_max = pcb->snd_nxt;
  808282:	89 77 58             	mov    %esi,0x58(%edi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  808285:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  808289:	83 ec 0c             	sub    $0xc,%esp
  80828c:	8b 43 10             	mov    0x10(%ebx),%eax
  80828f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808293:	50                   	push   %eax
  808294:	e8 8c f3 ff ff       	call   807625 <ntohs>
  808299:	83 c4 10             	add    $0x10,%esp
  80829c:	ba 01 00 00 00       	mov    $0x1,%edx
  8082a1:	a8 01                	test   $0x1,%al
  8082a3:	75 1b                	jne    8082c0 <tcp_output+0x384>
  8082a5:	83 ec 0c             	sub    $0xc,%esp
  8082a8:	8b 43 10             	mov    0x10(%ebx),%eax
  8082ab:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8082af:	50                   	push   %eax
  8082b0:	e8 70 f3 ff ff       	call   807625 <ntohs>
  8082b5:	66 d1 e8             	shr    %ax
  8082b8:	89 c2                	mov    %eax,%edx
  8082ba:	83 e2 01             	and    $0x1,%edx
  8082bd:	83 c4 10             	add    $0x10,%esp
  8082c0:	01 f2                	add    %esi,%edx
  8082c2:	74 50                	je     808314 <tcp_output+0x3d8>
      seg->next = NULL;
  8082c4:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  8082ca:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8082ce:	75 08                	jne    8082d8 <tcp_output+0x39c>
        pcb->unacked = seg;
  8082d0:	89 5f 78             	mov    %ebx,0x78(%edi)
  8082d3:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  8082d6:	eb 48                	jmp    808320 <tcp_output+0x3e4>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  8082d8:	83 ec 0c             	sub    $0xc,%esp
  8082db:	8b 43 10             	mov    0x10(%ebx),%eax
  8082de:	ff 70 04             	pushl  0x4(%eax)
  8082e1:	e8 6d f5 ff ff       	call   807853 <ntohl>
  8082e6:	89 c6                	mov    %eax,%esi
  8082e8:	83 c4 04             	add    $0x4,%esp
  8082eb:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8082ee:	8b 40 10             	mov    0x10(%eax),%eax
  8082f1:	ff 70 04             	pushl  0x4(%eax)
  8082f4:	e8 5a f5 ff ff       	call   807853 <ntohl>
  8082f9:	83 c4 10             	add    $0x10,%esp
  8082fc:	39 c6                	cmp    %eax,%esi
  8082fe:	79 0a                	jns    80830a <tcp_output+0x3ce>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  808300:	8b 47 78             	mov    0x78(%edi),%eax
  808303:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  808305:	89 5f 78             	mov    %ebx,0x78(%edi)
  808308:	eb 16                	jmp    808320 <tcp_output+0x3e4>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  80830a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80830d:	89 18                	mov    %ebx,(%eax)
  80830f:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808312:	eb 0c                	jmp    808320 <tcp_output+0x3e4>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  808314:	83 ec 0c             	sub    $0xc,%esp
  808317:	53                   	push   %ebx
  808318:	e8 90 d3 ff ff       	call   8056ad <tcp_seg_free>
  80831d:	83 c4 10             	add    $0x10,%esp
    }
    seg = pcb->unsent;
  808320:	8b 5f 74             	mov    0x74(%edi),%ebx
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  808323:	85 db                	test   %ebx,%ebx
  808325:	74 58                	je     80837f <tcp_output+0x443>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  808327:	83 ec 0c             	sub    $0xc,%esp
  80832a:	8b 43 10             	mov    0x10(%ebx),%eax
  80832d:	ff 70 04             	pushl  0x4(%eax)
  808330:	e8 1e f5 ff ff       	call   807853 <ntohl>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  808335:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808339:	2b 57 48             	sub    0x48(%edi),%edx
  80833c:	01 d0                	add    %edx,%eax
  80833e:	83 c4 10             	add    $0x10,%esp
  808341:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  808344:	0f 83 74 fd ff ff    	jae    8080be <tcp_output+0x182>
  80834a:	eb 54                	jmp    8083a0 <tcp_output+0x464>
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  80834c:	83 ec 0c             	sub    $0xc,%esp
  80834f:	8b 43 10             	mov    0x10(%ebx),%eax
  808352:	ff 70 04             	pushl  0x4(%eax)
  808355:	e8 f9 f4 ff ff       	call   807853 <ntohl>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80835a:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80835e:	2b 57 48             	sub    0x48(%edi),%edx
  808361:	01 d0                	add    %edx,%eax
  808363:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  808367:	83 c4 10             	add    $0x10,%esp
  80836a:	39 d0                	cmp    %edx,%eax
  80836c:	76 11                	jbe    80837f <tcp_output+0x443>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  80836e:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  808375:	00 00 00 
    pcb->persist_backoff = 1;
  808378:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  80837f:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  808383:	b8 00 00 00 00       	mov    $0x0,%eax
  808388:	eb 21                	jmp    8083ab <tcp_output+0x46f>
  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  80838a:	b8 00 00 00 00       	mov    $0x0,%eax
  80838f:	eb 1a                	jmp    8083ab <tcp_output+0x46f>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    if (p == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  808391:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808396:	eb 13                	jmp    8083ab <tcp_output+0x46f>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808398:	a8 a0                	test   $0xa0,%al
  80839a:	0f 85 6e fd ff ff    	jne    80810e <tcp_output+0x1d2>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  8083a0:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  8083a7:	75 d6                	jne    80837f <tcp_output+0x443>
  8083a9:	eb a1                	jmp    80834c <tcp_output+0x410>
    pcb->persist_backoff = 1;
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
  8083ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8083ae:	5b                   	pop    %ebx
  8083af:	5e                   	pop    %esi
  8083b0:	5f                   	pop    %edi
  8083b1:	5d                   	pop    %ebp
  8083b2:	c3                   	ret    

008083b3 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  8083b3:	55                   	push   %ebp
  8083b4:	89 e5                	mov    %esp,%ebp
  8083b6:	57                   	push   %edi
  8083b7:	56                   	push   %esi
  8083b8:	53                   	push   %ebx
  8083b9:	83 ec 20             	sub    $0x20,%esp
  8083bc:	8b 7d 18             	mov    0x18(%ebp),%edi
  8083bf:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8083c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8083c5:	6a 00                	push   $0x0
  8083c7:	6a 14                	push   $0x14
  8083c9:	6a 01                	push   $0x1
  8083cb:	e8 5d c4 ff ff       	call   80482d <pbuf_alloc>
  if (p == NULL) {
  8083d0:	83 c4 10             	add    $0x10,%esp
  8083d3:	85 c0                	test   %eax,%eax
  8083d5:	0f 84 f5 00 00 00    	je     8084d0 <tcp_rst+0x11d>
  8083db:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8083dd:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8083e2:	77 17                	ja     8083fb <tcp_rst+0x48>
  8083e4:	83 ec 04             	sub    $0x4,%esp
  8083e7:	68 b4 1e 81 00       	push   $0x811eb4
  8083ec:	68 be 02 00 00       	push   $0x2be
  8083f1:	68 e2 1e 81 00       	push   $0x811ee2
  8083f6:	e8 93 5f 00 00       	call   80e38e <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8083fb:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  8083fe:	83 ec 0c             	sub    $0xc,%esp
  808401:	0f b7 ff             	movzwl %di,%edi
  808404:	57                   	push   %edi
  808405:	e8 0e f2 ff ff       	call   807618 <htons>
  80840a:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  80840d:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808411:	89 04 24             	mov    %eax,(%esp)
  808414:	e8 ff f1 ff ff       	call   807618 <htons>
  808419:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  80841d:	83 c4 04             	add    $0x4,%esp
  808420:	ff 75 08             	pushl  0x8(%ebp)
  808423:	e8 0a f2 ff ff       	call   807632 <htonl>
  808428:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  80842b:	83 c4 04             	add    $0x4,%esp
  80842e:	ff 75 0c             	pushl  0xc(%ebp)
  808431:	e8 fc f1 ff ff       	call   807632 <htonl>
  808436:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  808439:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80843d:	89 04 24             	mov    %eax,(%esp)
  808440:	e8 e0 f1 ff ff       	call   807625 <ntohs>
  808445:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80844a:	83 c8 14             	or     $0x14,%eax
  80844d:	89 04 24             	mov    %eax,(%esp)
  808450:	e8 c3 f1 ff ff       	call   807618 <htons>
  808455:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808459:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  808460:	e8 b3 f1 ff ff       	call   807618 <htons>
  808465:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808469:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80846f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808473:	89 04 24             	mov    %eax,(%esp)
  808476:	e8 aa f1 ff ff       	call   807625 <ntohs>
  80847b:	83 e0 3f             	and    $0x3f,%eax
  80847e:	80 cc 50             	or     $0x50,%ah
  808481:	89 04 24             	mov    %eax,(%esp)
  808484:	e8 8f f1 ff ff       	call   807618 <htons>
  808489:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80848d:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808493:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808497:	89 04 24             	mov    %eax,(%esp)
  80849a:	6a 06                	push   $0x6
  80849c:	ff 75 14             	pushl  0x14(%ebp)
  80849f:	ff 75 10             	pushl  0x10(%ebp)
  8084a2:	56                   	push   %esi
  8084a3:	e8 57 ee ff ff       	call   8072ff <inet_chksum_pseudo>
  8084a8:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  8084ac:	83 c4 18             	add    $0x18,%esp
  8084af:	6a 06                	push   $0x6
  8084b1:	6a 00                	push   $0x0
  8084b3:	68 ff 00 00 00       	push   $0xff
  8084b8:	ff 75 14             	pushl  0x14(%ebp)
  8084bb:	ff 75 10             	pushl  0x10(%ebp)
  8084be:	56                   	push   %esi
  8084bf:	e8 82 e4 ff ff       	call   806946 <ip_output>
  pbuf_free(p);
  8084c4:	83 c4 14             	add    $0x14,%esp
  8084c7:	56                   	push   %esi
  8084c8:	e8 9a c2 ff ff       	call   804767 <pbuf_free>
  8084cd:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  8084d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8084d3:	5b                   	pop    %ebx
  8084d4:	5e                   	pop    %esi
  8084d5:	5f                   	pop    %edi
  8084d6:	5d                   	pop    %ebp
  8084d7:	c3                   	ret    

008084d8 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  8084d8:	55                   	push   %ebp
  8084d9:	89 e5                	mov    %esp,%ebp
  8084db:	53                   	push   %ebx
  8084dc:	83 ec 04             	sub    $0x4,%esp
  8084df:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8084e2:	8b 53 78             	mov    0x78(%ebx),%edx
  8084e5:	85 d2                	test   %edx,%edx
  8084e7:	75 04                	jne    8084ed <tcp_rexmit_rto+0x15>
  8084e9:	eb 41                	jmp    80852c <tcp_rexmit_rto+0x54>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  8084eb:	89 c2                	mov    %eax,%edx
  8084ed:	8b 02                	mov    (%edx),%eax
  8084ef:	85 c0                	test   %eax,%eax
  8084f1:	75 f8                	jne    8084eb <tcp_rexmit_rto+0x13>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  8084f3:	8b 43 74             	mov    0x74(%ebx),%eax
  8084f6:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  8084f8:	8b 43 78             	mov    0x78(%ebx),%eax
  8084fb:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  8084fe:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808505:	83 ec 0c             	sub    $0xc,%esp
  808508:	8b 40 10             	mov    0x10(%eax),%eax
  80850b:	ff 70 04             	pushl  0x4(%eax)
  80850e:	e8 40 f3 ff ff       	call   807853 <ntohl>
  808513:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  808516:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  80851a:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  808521:	89 1c 24             	mov    %ebx,(%esp)
  808524:	e8 13 fa ff ff       	call   807f3c <tcp_output>
  808529:	83 c4 10             	add    $0x10,%esp
}
  80852c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80852f:	c9                   	leave  
  808530:	c3                   	ret    

00808531 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808531:	55                   	push   %ebp
  808532:	89 e5                	mov    %esp,%ebp
  808534:	53                   	push   %ebx
  808535:	83 ec 04             	sub    $0x4,%esp
  808538:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80853b:	8b 43 78             	mov    0x78(%ebx),%eax
  80853e:	85 c0                	test   %eax,%eax
  808540:	74 37                	je     808579 <tcp_rexmit+0x48>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808542:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808544:	8b 4b 74             	mov    0x74(%ebx),%ecx
  808547:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808549:	8b 43 78             	mov    0x78(%ebx),%eax
  80854c:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80854f:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808552:	83 ec 0c             	sub    $0xc,%esp
  808555:	8b 40 10             	mov    0x10(%eax),%eax
  808558:	ff 70 04             	pushl  0x4(%eax)
  80855b:	e8 f3 f2 ff ff       	call   807853 <ntohl>
  808560:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808563:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  808567:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80856e:	89 1c 24             	mov    %ebx,(%esp)
  808571:	e8 c6 f9 ff ff       	call   807f3c <tcp_output>
  808576:	83 c4 10             	add    $0x10,%esp
}
  808579:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80857c:	c9                   	leave  
  80857d:	c3                   	ret    

0080857e <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  80857e:	55                   	push   %ebp
  80857f:	89 e5                	mov    %esp,%ebp
  808581:	57                   	push   %edi
  808582:	56                   	push   %esi
  808583:	53                   	push   %ebx
  808584:	83 ec 20             	sub    $0x20,%esp
  808587:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80858a:	6a 00                	push   $0x0
  80858c:	6a 14                	push   $0x14
  80858e:	6a 01                	push   $0x1
  808590:	e8 98 c2 ff ff       	call   80482d <pbuf_alloc>
   
  if(p == NULL) {
  808595:	83 c4 10             	add    $0x10,%esp
  808598:	85 c0                	test   %eax,%eax
  80859a:	0f 84 f8 00 00 00    	je     808698 <tcp_keepalive+0x11a>
  8085a0:	89 c7                	mov    %eax,%edi
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8085a2:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8085a7:	77 17                	ja     8085c0 <tcp_keepalive+0x42>
  8085a9:	83 ec 04             	sub    $0x4,%esp
  8085ac:	68 b4 1e 81 00       	push   $0x811eb4
  8085b1:	68 3a 03 00 00       	push   $0x33a
  8085b6:	68 e2 1e 81 00       	push   $0x811ee2
  8085bb:	e8 ce 5d 00 00       	call   80e38e <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8085c0:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  8085c3:	83 ec 0c             	sub    $0xc,%esp
  8085c6:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  8085ca:	50                   	push   %eax
  8085cb:	e8 48 f0 ff ff       	call   807618 <htons>
  8085d0:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8085d3:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  8085d7:	89 04 24             	mov    %eax,(%esp)
  8085da:	e8 39 f0 ff ff       	call   807618 <htons>
  8085df:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  8085e3:	8b 46 54             	mov    0x54(%esi),%eax
  8085e6:	83 e8 01             	sub    $0x1,%eax
  8085e9:	89 04 24             	mov    %eax,(%esp)
  8085ec:	e8 41 f0 ff ff       	call   807632 <htonl>
  8085f1:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8085f4:	83 c4 04             	add    $0x4,%esp
  8085f7:	ff 76 24             	pushl  0x24(%esi)
  8085fa:	e8 33 f0 ff ff       	call   807632 <htonl>
  8085ff:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808602:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808606:	89 04 24             	mov    %eax,(%esp)
  808609:	e8 17 f0 ff ff       	call   807625 <ntohs>
  80860e:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808613:	89 04 24             	mov    %eax,(%esp)
  808616:	e8 fd ef ff ff       	call   807618 <htons>
  80861b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80861f:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808623:	89 04 24             	mov    %eax,(%esp)
  808626:	e8 ed ef ff ff       	call   807618 <htons>
  80862b:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80862f:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808635:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808639:	89 04 24             	mov    %eax,(%esp)
  80863c:	e8 e4 ef ff ff       	call   807625 <ntohs>
  808641:	83 e0 3f             	and    $0x3f,%eax
  808644:	80 cc 50             	or     $0x50,%ah
  808647:	89 04 24             	mov    %eax,(%esp)
  80864a:	e8 c9 ef ff ff       	call   807618 <htons>
  80864f:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808653:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808659:	8d 46 04             	lea    0x4(%esi),%eax
  80865c:	89 c2                	mov    %eax,%edx
  80865e:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808662:	89 04 24             	mov    %eax,(%esp)
  808665:	6a 06                	push   $0x6
  808667:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80866a:	52                   	push   %edx
  80866b:	56                   	push   %esi
  80866c:	57                   	push   %edi
  80866d:	e8 8d ec ff ff       	call   8072ff <inet_chksum_pseudo>
  808672:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808676:	83 c4 18             	add    $0x18,%esp
  808679:	6a 06                	push   $0x6
  80867b:	6a 00                	push   $0x0
  80867d:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808681:	50                   	push   %eax
  808682:	ff 75 e4             	pushl  -0x1c(%ebp)
  808685:	56                   	push   %esi
  808686:	57                   	push   %edi
  808687:	e8 ba e2 ff ff       	call   806946 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80868c:	83 c4 14             	add    $0x14,%esp
  80868f:	57                   	push   %edi
  808690:	e8 d2 c0 ff ff       	call   804767 <pbuf_free>
  808695:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808698:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80869b:	5b                   	pop    %ebx
  80869c:	5e                   	pop    %esi
  80869d:	5f                   	pop    %edi
  80869e:	5d                   	pop    %ebp
  80869f:	c3                   	ret    

008086a0 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  8086a0:	55                   	push   %ebp
  8086a1:	89 e5                	mov    %esp,%ebp
  8086a3:	57                   	push   %edi
  8086a4:	56                   	push   %esi
  8086a5:	53                   	push   %ebx
  8086a6:	83 ec 1c             	sub    $0x1c,%esp
  8086a9:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  8086ac:	8b 46 78             	mov    0x78(%esi),%eax
  8086af:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  8086b2:	85 c0                	test   %eax,%eax
  8086b4:	75 0e                	jne    8086c4 <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  8086b6:	8b 46 74             	mov    0x74(%esi),%eax
  8086b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  8086bc:	85 c0                	test   %eax,%eax
  8086be:	0f 84 1b 01 00 00    	je     8087df <tcp_zero_window_probe+0x13f>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  8086c4:	83 ec 04             	sub    $0x4,%esp
  8086c7:	6a 00                	push   $0x0
  8086c9:	6a 15                	push   $0x15
  8086cb:	6a 01                	push   $0x1
  8086cd:	e8 5b c1 ff ff       	call   80482d <pbuf_alloc>
  8086d2:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  8086d4:	83 c4 10             	add    $0x10,%esp
  8086d7:	85 c0                	test   %eax,%eax
  8086d9:	0f 84 00 01 00 00    	je     8087df <tcp_zero_window_probe+0x13f>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8086df:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8086e4:	77 17                	ja     8086fd <tcp_zero_window_probe+0x5d>
  8086e6:	83 ec 04             	sub    $0x4,%esp
  8086e9:	68 b4 1e 81 00       	push   $0x811eb4
  8086ee:	68 8d 03 00 00       	push   $0x38d
  8086f3:	68 e2 1e 81 00       	push   $0x811ee2
  8086f8:	e8 91 5c 00 00       	call   80e38e <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8086fd:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808700:	83 ec 0c             	sub    $0xc,%esp
  808703:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808707:	50                   	push   %eax
  808708:	e8 0b ef ff ff       	call   807618 <htons>
  80870d:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808710:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808714:	89 04 24             	mov    %eax,(%esp)
  808717:	e8 fc ee ff ff       	call   807618 <htons>
  80871c:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  808720:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808723:	8b 40 10             	mov    0x10(%eax),%eax
  808726:	8b 40 04             	mov    0x4(%eax),%eax
  808729:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80872c:	83 c4 04             	add    $0x4,%esp
  80872f:	ff 76 24             	pushl  0x24(%esi)
  808732:	e8 fb ee ff ff       	call   807632 <htonl>
  808737:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80873a:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80873e:	89 04 24             	mov    %eax,(%esp)
  808741:	e8 df ee ff ff       	call   807625 <ntohs>
  808746:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80874b:	89 04 24             	mov    %eax,(%esp)
  80874e:	e8 c5 ee ff ff       	call   807618 <htons>
  808753:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808757:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80875b:	89 04 24             	mov    %eax,(%esp)
  80875e:	e8 b5 ee ff ff       	call   807618 <htons>
  808763:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808767:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80876d:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808771:	89 04 24             	mov    %eax,(%esp)
  808774:	e8 ac ee ff ff       	call   807625 <ntohs>
  808779:	83 e0 3f             	and    $0x3f,%eax
  80877c:	80 cc 50             	or     $0x50,%ah
  80877f:	89 04 24             	mov    %eax,(%esp)
  808782:	e8 91 ee ff ff       	call   807618 <htons>
  808787:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80878b:	8b 47 04             	mov    0x4(%edi),%eax
  80878e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808791:	8b 51 08             	mov    0x8(%ecx),%edx
  808794:	0f b6 12             	movzbl (%edx),%edx
  808797:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  80879a:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  8087a0:	8d 46 04             	lea    0x4(%esi),%eax
  8087a3:	89 c1                	mov    %eax,%ecx
  8087a5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8087a9:	89 04 24             	mov    %eax,(%esp)
  8087ac:	6a 06                	push   $0x6
  8087ae:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8087b1:	51                   	push   %ecx
  8087b2:	56                   	push   %esi
  8087b3:	57                   	push   %edi
  8087b4:	e8 46 eb ff ff       	call   8072ff <inet_chksum_pseudo>
  8087b9:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  8087bd:	83 c4 18             	add    $0x18,%esp
  8087c0:	6a 06                	push   $0x6
  8087c2:	6a 00                	push   $0x0
  8087c4:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  8087c8:	50                   	push   %eax
  8087c9:	ff 75 e4             	pushl  -0x1c(%ebp)
  8087cc:	56                   	push   %esi
  8087cd:	57                   	push   %edi
  8087ce:	e8 73 e1 ff ff       	call   806946 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  8087d3:	83 c4 14             	add    $0x14,%esp
  8087d6:	57                   	push   %edi
  8087d7:	e8 8b bf ff ff       	call   804767 <pbuf_free>
  8087dc:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8087df:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8087e2:	5b                   	pop    %ebx
  8087e3:	5e                   	pop    %esi
  8087e4:	5f                   	pop    %edi
  8087e5:	5d                   	pop    %ebp
  8087e6:	c3                   	ret    

008087e7 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  8087e7:	55                   	push   %ebp
  8087e8:	89 e5                	mov    %esp,%ebp
  8087ea:	57                   	push   %edi
  8087eb:	56                   	push   %esi
  8087ec:	53                   	push   %ebx
  8087ed:	83 ec 38             	sub    $0x38,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  8087f0:	8b 45 08             	mov    0x8(%ebp),%eax
  8087f3:	8b 78 04             	mov    0x4(%eax),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  8087f6:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  8087fa:	0f b7 07             	movzwl (%edi),%eax
  8087fd:	50                   	push   %eax
  8087fe:	e8 22 ee ff ff       	call   807625 <ntohs>
  808803:	66 c1 e8 08          	shr    $0x8,%ax
  808807:	83 e0 0f             	and    $0xf,%eax
  80880a:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808811:	83 c4 10             	add    $0x10,%esp
  808814:	39 c3                	cmp    %eax,%ebx
  808816:	7c 29                	jl     808841 <udp_input+0x5a>
  808818:	83 ec 0c             	sub    $0xc,%esp
  80881b:	0f b7 07             	movzwl (%edi),%eax
  80881e:	50                   	push   %eax
  80881f:	e8 01 ee ff ff       	call   807625 <ntohs>
  808824:	83 c4 08             	add    $0x8,%esp
  808827:	66 c1 e8 06          	shr    $0x6,%ax
  80882b:	83 e0 3c             	and    $0x3c,%eax
  80882e:	f7 d8                	neg    %eax
  808830:	98                   	cwtl   
  808831:	50                   	push   %eax
  808832:	ff 75 08             	pushl  0x8(%ebp)
  808835:	e8 5b be ff ff       	call   804695 <pbuf_header>
  80883a:	83 c4 10             	add    $0x10,%esp
  80883d:	84 c0                	test   %al,%al
  80883f:	74 13                	je     808854 <udp_input+0x6d>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  808841:	83 ec 0c             	sub    $0xc,%esp
  808844:	ff 75 08             	pushl  0x8(%ebp)
  808847:	e8 1b bf ff ff       	call   804767 <pbuf_free>
    goto end;
  80884c:	83 c4 10             	add    $0x10,%esp
  80884f:	e9 ce 02 00 00       	jmp    808b22 <udp_input+0x33b>
  }

  udphdr = (struct udp_hdr *)p->payload;
  808854:	8b 45 08             	mov    0x8(%ebp),%eax
  808857:	8b 40 04             	mov    0x4(%eax),%eax
  80885a:	89 c6                	mov    %eax,%esi
  80885c:	89 45 d0             	mov    %eax,-0x30(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  80885f:	83 ec 0c             	sub    $0xc,%esp
  808862:	0f b7 00             	movzwl (%eax),%eax
  808865:	50                   	push   %eax
  808866:	e8 ba ed ff ff       	call   807625 <ntohs>
  80886b:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  dest = ntohs(udphdr->dest);
  80886f:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  808873:	89 04 24             	mov    %eax,(%esp)
  808876:	e8 aa ed ff ff       	call   807625 <ntohs>
  80887b:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  80887d:	83 c4 10             	add    $0x10,%esp
  808880:	66 83 f8 44          	cmp    $0x44,%ax
  808884:	75 49                	jne    8088cf <udp_input+0xe8>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  808886:	66 83 7d da 43       	cmpw   $0x43,-0x26(%ebp)
  80888b:	0f 85 06 01 00 00    	jne    808997 <udp_input+0x1b0>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  808891:	8b 45 0c             	mov    0xc(%ebp),%eax
  808894:	8b 40 20             	mov    0x20(%eax),%eax
  808897:	85 c0                	test   %eax,%eax
  808899:	0f 84 f8 00 00 00    	je     808997 <udp_input+0x1b0>
  80889f:	8b 40 08             	mov    0x8(%eax),%eax
  8088a2:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8088a5:	85 c0                	test   %eax,%eax
  8088a7:	0f 84 ea 00 00 00    	je     808997 <udp_input+0x1b0>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  8088ad:	83 f8 fc             	cmp    $0xfffffffc,%eax
  8088b0:	0f 84 f7 00 00 00    	je     8089ad <udp_input+0x1c6>
  8088b6:	8b 40 04             	mov    0x4(%eax),%eax
  8088b9:	85 c0                	test   %eax,%eax
  8088bb:	0f 84 ec 00 00 00    	je     8089ad <udp_input+0x1c6>
  8088c1:	3b 47 0c             	cmp    0xc(%edi),%eax
  8088c4:	0f 85 cd 00 00 00    	jne    808997 <udp_input+0x1b0>
  8088ca:	e9 de 00 00 00       	jmp    8089ad <udp_input+0x1c6>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8088cf:	8b 1d 54 b2 b3 00    	mov    0xb3b254,%ebx
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    local_match = 0;
    uncon_pcb = NULL;
  8088d5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  8088dc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8088e3:	8d 47 10             	lea    0x10(%edi),%eax
  8088e6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8088e9:	89 7d dc             	mov    %edi,-0x24(%ebp)
  8088ec:	0f b7 7d da          	movzwl -0x26(%ebp),%edi
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8088f0:	e9 91 00 00 00       	jmp    808986 <udp_input+0x19f>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  8088f5:	66 3b 73 12          	cmp    0x12(%ebx),%si
  8088f9:	0f 85 81 00 00 00    	jne    808980 <udp_input+0x199>
  8088ff:	85 db                	test   %ebx,%ebx
  808901:	74 23                	je     808926 <udp_input+0x13f>
          (ip_addr_isany(&pcb->local_ip) ||
  808903:	8b 03                	mov    (%ebx),%eax
  808905:	85 c0                	test   %eax,%eax
  808907:	74 1d                	je     808926 <udp_input+0x13f>
  808909:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80890c:	3b 42 10             	cmp    0x10(%edx),%eax
  80890f:	74 15                	je     808926 <udp_input+0x13f>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808911:	83 ec 08             	sub    $0x8,%esp
  808914:	ff 75 0c             	pushl  0xc(%ebp)
  808917:	ff 75 d4             	pushl  -0x2c(%ebp)
  80891a:	e8 f1 da ff ff       	call   806410 <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  80891f:	83 c4 10             	add    $0x10,%esp
  808922:	84 c0                	test   %al,%al
  808924:	74 5a                	je     808980 <udp_input+0x199>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  808926:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80892a:	0f 85 db 01 00 00    	jne    808b0b <udp_input+0x324>
  808930:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  808934:	83 e0 04             	and    $0x4,%eax
  808937:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80893a:	0f 44 c3             	cmove  %ebx,%eax
  80893d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808940:	e9 c6 01 00 00       	jmp    808b0b <udp_input+0x324>
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  808945:	83 fb fc             	cmp    $0xfffffffc,%ebx
  808948:	74 0f                	je     808959 <udp_input+0x172>
          (ip_addr_isany(&pcb->remote_ip) ||
  80894a:	8b 43 04             	mov    0x4(%ebx),%eax
  80894d:	85 c0                	test   %eax,%eax
  80894f:	74 08                	je     808959 <udp_input+0x172>
  808951:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  808954:	3b 41 0c             	cmp    0xc(%ecx),%eax
  808957:	75 27                	jne    808980 <udp_input+0x199>
  808959:	8b 7d dc             	mov    -0x24(%ebp),%edi
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  80895c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80895f:	85 d2                	test   %edx,%edx
  808961:	0f 84 b3 01 00 00    	je     808b1a <udp_input+0x333>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  808967:	8b 43 0c             	mov    0xc(%ebx),%eax
  80896a:	89 42 0c             	mov    %eax,0xc(%edx)
          pcb->next = udp_pcbs;
  80896d:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808972:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  808975:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  80897b:	e9 9a 01 00 00       	jmp    808b1a <udp_input+0x333>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808980:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  808983:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808986:	85 db                	test   %ebx,%ebx
  808988:	0f 85 67 ff ff ff    	jne    8088f5 <udp_input+0x10e>
  80898e:	8b 7d dc             	mov    -0x24(%ebp),%edi
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  808991:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  808995:	75 16                	jne    8089ad <udp_input+0x1c6>
  808997:	8b 45 0c             	mov    0xc(%ebp),%eax
  80899a:	8b 57 10             	mov    0x10(%edi),%edx
  80899d:	39 50 04             	cmp    %edx,0x4(%eax)
  8089a0:	0f 85 55 01 00 00    	jne    808afb <udp_input+0x314>
  8089a6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  8089ad:	8b 45 d0             	mov    -0x30(%ebp),%eax
  8089b0:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  8089b5:	74 38                	je     8089ef <udp_input+0x208>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  8089b7:	83 ec 0c             	sub    $0xc,%esp
  8089ba:	8b 45 08             	mov    0x8(%ebp),%eax
  8089bd:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8089c1:	50                   	push   %eax
  8089c2:	6a 11                	push   $0x11
  8089c4:	8d 47 10             	lea    0x10(%edi),%eax
  8089c7:	50                   	push   %eax
  8089c8:	8d 47 0c             	lea    0xc(%edi),%eax
  8089cb:	50                   	push   %eax
  8089cc:	ff 75 08             	pushl  0x8(%ebp)
  8089cf:	e8 2b e9 ff ff       	call   8072ff <inet_chksum_pseudo>
  8089d4:	83 c4 20             	add    $0x20,%esp
  8089d7:	66 85 c0             	test   %ax,%ax
  8089da:	74 13                	je     8089ef <udp_input+0x208>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  8089dc:	83 ec 0c             	sub    $0xc,%esp
  8089df:	ff 75 08             	pushl  0x8(%ebp)
  8089e2:	e8 80 bd ff ff       	call   804767 <pbuf_free>
          goto end;
  8089e7:	83 c4 10             	add    $0x10,%esp
  8089ea:	e9 33 01 00 00       	jmp    808b22 <udp_input+0x33b>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  8089ef:	83 ec 08             	sub    $0x8,%esp
  8089f2:	6a f8                	push   $0xfffffff8
  8089f4:	ff 75 08             	pushl  0x8(%ebp)
  8089f7:	e8 99 bc ff ff       	call   804695 <pbuf_header>
  8089fc:	83 c4 10             	add    $0x10,%esp
  8089ff:	84 c0                	test   %al,%al
  808a01:	74 17                	je     808a1a <udp_input+0x233>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808a03:	83 ec 04             	sub    $0x4,%esp
  808a06:	68 07 1f 81 00       	push   $0x811f07
  808a0b:	68 0a 01 00 00       	push   $0x10a
  808a10:	68 32 1f 81 00       	push   $0x811f32
  808a15:	e8 74 59 00 00       	call   80e38e <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  808a1a:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  808a1d:	85 c9                	test   %ecx,%ecx
  808a1f:	74 37                	je     808a58 <udp_input+0x271>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  808a21:	8b 41 18             	mov    0x18(%ecx),%eax
  808a24:	85 c0                	test   %eax,%eax
  808a26:	74 1d                	je     808a45 <udp_input+0x25e>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  808a28:	83 ec 0c             	sub    $0xc,%esp
  808a2b:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
  808a2f:	52                   	push   %edx
  808a30:	83 c7 0c             	add    $0xc,%edi
  808a33:	57                   	push   %edi
  808a34:	ff 75 08             	pushl  0x8(%ebp)
  808a37:	51                   	push   %ecx
  808a38:	ff 71 1c             	pushl  0x1c(%ecx)
  808a3b:	ff d0                	call   *%eax
  808a3d:	83 c4 20             	add    $0x20,%esp
  808a40:	e9 dd 00 00 00       	jmp    808b22 <udp_input+0x33b>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  808a45:	83 ec 0c             	sub    $0xc,%esp
  808a48:	ff 75 08             	pushl  0x8(%ebp)
  808a4b:	e8 17 bd ff ff       	call   804767 <pbuf_free>
        goto end;
  808a50:	83 c4 10             	add    $0x10,%esp
  808a53:	e9 ca 00 00 00       	jmp    808b22 <udp_input+0x33b>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808a58:	83 ec 08             	sub    $0x8,%esp
  808a5b:	ff 75 0c             	pushl  0xc(%ebp)
  808a5e:	8d 47 10             	lea    0x10(%edi),%eax
  808a61:	50                   	push   %eax
  808a62:	e8 a9 d9 ff ff       	call   806410 <ip_addr_isbroadcast>
  808a67:	83 c4 10             	add    $0x10,%esp
  808a6a:	84 c0                	test   %al,%al
  808a6c:	75 7d                	jne    808aeb <udp_input+0x304>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808a6e:	8b 5f 10             	mov    0x10(%edi),%ebx
  808a71:	83 ec 0c             	sub    $0xc,%esp
  808a74:	68 00 00 00 f0       	push   $0xf0000000
  808a79:	e8 d5 ed ff ff       	call   807853 <ntohl>
  808a7e:	21 c3                	and    %eax,%ebx
  808a80:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808a87:	e8 c7 ed ff ff       	call   807853 <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808a8c:	83 c4 10             	add    $0x10,%esp
  808a8f:	39 c3                	cmp    %eax,%ebx
  808a91:	74 58                	je     808aeb <udp_input+0x304>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808a93:	83 ec 0c             	sub    $0xc,%esp
  808a96:	0f b7 07             	movzwl (%edi),%eax
  808a99:	50                   	push   %eax
  808a9a:	e8 86 eb ff ff       	call   807625 <ntohs>
  808a9f:	83 c4 08             	add    $0x8,%esp
  808aa2:	66 c1 e8 08          	shr    $0x8,%ax
  808aa6:	83 e0 0f             	and    $0xf,%eax
  808aa9:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808ab0:	50                   	push   %eax
  808ab1:	ff 75 08             	pushl  0x8(%ebp)
  808ab4:	e8 dc bb ff ff       	call   804695 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808ab9:	83 c4 10             	add    $0x10,%esp
  808abc:	8b 45 08             	mov    0x8(%ebp),%eax
  808abf:	3b 78 04             	cmp    0x4(%eax),%edi
  808ac2:	74 17                	je     808adb <udp_input+0x2f4>
  808ac4:	83 ec 04             	sub    $0x4,%esp
  808ac7:	68 46 1f 81 00       	push   $0x811f46
  808acc:	68 25 01 00 00       	push   $0x125
  808ad1:	68 32 1f 81 00       	push   $0x811f32
  808ad6:	e8 b3 58 00 00       	call   80e38e <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808adb:	83 ec 08             	sub    $0x8,%esp
  808ade:	6a 03                	push   $0x3
  808ae0:	ff 75 08             	pushl  0x8(%ebp)
  808ae3:	e8 88 56 00 00       	call   80e170 <icmp_dest_unreach>
  808ae8:	83 c4 10             	add    $0x10,%esp
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  808aeb:	83 ec 0c             	sub    $0xc,%esp
  808aee:	ff 75 08             	pushl  0x8(%ebp)
  808af1:	e8 71 bc ff ff       	call   804767 <pbuf_free>
  808af6:	83 c4 10             	add    $0x10,%esp
  808af9:	eb 27                	jmp    808b22 <udp_input+0x33b>
    }
  } else {
    pbuf_free(p);
  808afb:	83 ec 0c             	sub    $0xc,%esp
  808afe:	ff 75 08             	pushl  0x8(%ebp)
  808b01:	e8 61 bc ff ff       	call   804767 <pbuf_free>
  808b06:	83 c4 10             	add    $0x10,%esp
  }
end:
  PERF_STOP("udp_input");
}
  808b09:	eb 17                	jmp    808b22 <udp_input+0x33b>
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  808b0b:	66 3b 7b 14          	cmp    0x14(%ebx),%di
  808b0f:	0f 85 6b fe ff ff    	jne    808980 <udp_input+0x199>
  808b15:	e9 2b fe ff ff       	jmp    808945 <udp_input+0x15e>
  808b1a:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  808b1d:	e9 8b fe ff ff       	jmp    8089ad <udp_input+0x1c6>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  808b22:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808b25:	5b                   	pop    %ebx
  808b26:	5e                   	pop    %esi
  808b27:	5f                   	pop    %edi
  808b28:	5d                   	pop    %ebp
  808b29:	c3                   	ret    

00808b2a <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808b2a:	55                   	push   %ebp
  808b2b:	89 e5                	mov    %esp,%ebp
  808b2d:	57                   	push   %edi
  808b2e:	56                   	push   %esi
  808b2f:	53                   	push   %ebx
  808b30:	83 ec 0c             	sub    $0xc,%esp
  808b33:	8b 55 08             	mov    0x8(%ebp),%edx
  808b36:	8b 7d 0c             	mov    0xc(%ebp),%edi
  808b39:	8b 75 10             	mov    0x10(%ebp),%esi
  808b3c:	89 f1                	mov    %esi,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808b3e:	a1 54 b2 b3 00       	mov    0xb3b254,%eax

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  808b43:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808b48:	eb 27                	jmp    808b71 <udp_bind+0x47>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  808b4a:	39 d0                	cmp    %edx,%eax
  808b4c:	75 20                	jne    808b6e <udp_bind+0x44>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808b4e:	84 db                	test   %bl,%bl
  808b50:	74 17                	je     808b69 <udp_bind+0x3f>
  808b52:	83 ec 04             	sub    $0x4,%esp
  808b55:	68 5a 1f 81 00       	push   $0x811f5a
  808b5a:	68 41 02 00 00       	push   $0x241
  808b5f:	68 32 1f 81 00       	push   $0x811f32
  808b64:	e8 25 58 00 00       	call   80e38e <_panic>
      /* pcb already in list, just rebind */
      rebind = 1;
  808b69:	bb 01 00 00 00       	mov    $0x1,%ebx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808b6e:	8b 40 0c             	mov    0xc(%eax),%eax
  808b71:	85 c0                	test   %eax,%eax
  808b73:	75 d5                	jne    808b4a <udp_bind+0x20>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808b75:	85 ff                	test   %edi,%edi
  808b77:	74 04                	je     808b7d <udp_bind+0x53>
  808b79:	8b 07                	mov    (%edi),%eax
  808b7b:	eb 05                	jmp    808b82 <udp_bind+0x58>
  808b7d:	b8 00 00 00 00       	mov    $0x0,%eax
  808b82:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808b84:	66 85 f6             	test   %si,%si
  808b87:	75 2e                	jne    808bb7 <udp_bind+0x8d>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808b89:	8b 35 54 b2 b3 00    	mov    0xb3b254,%esi
  808b8f:	89 f0                	mov    %esi,%eax
  if (port == 0) {
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  808b91:	b9 00 10 00 00       	mov    $0x1000,%ecx
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808b96:	eb 10                	jmp    808ba8 <udp_bind+0x7e>
      if (ipcb->local_port == port) {
  808b98:	66 3b 48 12          	cmp    0x12(%eax),%cx
  808b9c:	75 07                	jne    808ba5 <udp_bind+0x7b>
        /* port is already used by another udp_pcb */
        port++;
  808b9e:	83 c1 01             	add    $0x1,%ecx
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  808ba1:	89 f0                	mov    %esi,%eax
  808ba3:	eb 03                	jmp    808ba8 <udp_bind+0x7e>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808ba5:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808ba8:	85 c0                	test   %eax,%eax
  808baa:	74 07                	je     808bb3 <udp_bind+0x89>
  808bac:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808bb1:	75 e5                	jne    808b98 <udp_bind+0x6e>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  808bb3:	85 c0                	test   %eax,%eax
  808bb5:	75 22                	jne    808bd9 <udp_bind+0xaf>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808bb7:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808bbb:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }
  pcb->local_port = port;
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  808bc0:	84 db                	test   %bl,%bl
  808bc2:	75 1a                	jne    808bde <udp_bind+0xb4>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  808bc4:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808bc9:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808bcc:	89 15 54 b2 b3 00    	mov    %edx,0xb3b254
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808bd2:	b8 00 00 00 00       	mov    $0x0,%eax
  808bd7:	eb 05                	jmp    808bde <udp_bind+0xb4>
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  808bd9:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  808bde:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808be1:	5b                   	pop    %ebx
  808be2:	5e                   	pop    %esi
  808be3:	5f                   	pop    %edi
  808be4:	5d                   	pop    %ebp
  808be5:	c3                   	ret    

00808be6 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  808be6:	55                   	push   %ebp
  808be7:	89 e5                	mov    %esp,%ebp
  808be9:	57                   	push   %edi
  808bea:	56                   	push   %esi
  808beb:	53                   	push   %ebx
  808bec:	83 ec 1c             	sub    $0x1c,%esp
  808bef:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808bf2:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  808bf5:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808bfa:	75 17                	jne    808c13 <udp_sendto_if+0x2d>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808bfc:	83 ec 04             	sub    $0x4,%esp
  808bff:	6a 00                	push   $0x0
  808c01:	53                   	push   %ebx
  808c02:	53                   	push   %ebx
  808c03:	e8 22 ff ff ff       	call   808b2a <udp_bind>
    if (err != ERR_OK) {
  808c08:	83 c4 10             	add    $0x10,%esp
  808c0b:	84 c0                	test   %al,%al
  808c0d:	0f 85 54 01 00 00    	jne    808d67 <udp_sendto_if+0x181>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  808c13:	83 ec 08             	sub    $0x8,%esp
  808c16:	6a 08                	push   $0x8
  808c18:	ff 75 0c             	pushl  0xc(%ebp)
  808c1b:	e8 75 ba ff ff       	call   804695 <pbuf_header>
  808c20:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  808c23:	8b 75 0c             	mov    0xc(%ebp),%esi
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  808c26:	84 c0                	test   %al,%al
  808c28:	74 2a                	je     808c54 <udp_sendto_if+0x6e>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  808c2a:	83 ec 04             	sub    $0x4,%esp
  808c2d:	6a 00                	push   $0x0
  808c2f:	6a 08                	push   $0x8
  808c31:	6a 01                	push   $0x1
  808c33:	e8 f5 bb ff ff       	call   80482d <pbuf_alloc>
  808c38:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  808c3a:	83 c4 10             	add    $0x10,%esp
  808c3d:	85 c0                	test   %eax,%eax
  808c3f:	0f 84 1d 01 00 00    	je     808d62 <udp_sendto_if+0x17c>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  808c45:	83 ec 08             	sub    $0x8,%esp
  808c48:	ff 75 0c             	pushl  0xc(%ebp)
  808c4b:	50                   	push   %eax
  808c4c:	e8 0a c0 ff ff       	call   804c5b <pbuf_chain>
  808c51:	83 c4 10             	add    $0x10,%esp
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808c54:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  808c59:	77 17                	ja     808c72 <udp_sendto_if+0x8c>
  808c5b:	83 ec 04             	sub    $0x4,%esp
  808c5e:	68 68 1f 81 00       	push   $0x811f68
  808c63:	68 b2 01 00 00       	push   $0x1b2
  808c68:	68 32 1f 81 00       	push   $0x811f32
  808c6d:	e8 1c 57 00 00       	call   80e38e <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  808c72:	8b 46 04             	mov    0x4(%esi),%eax
  808c75:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  udphdr->src = htons(pcb->local_port);
  808c78:	83 ec 0c             	sub    $0xc,%esp
  808c7b:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  808c7f:	50                   	push   %eax
  808c80:	e8 93 e9 ff ff       	call   807618 <htons>
  808c85:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808c88:	66 89 01             	mov    %ax,(%ecx)
  udphdr->dest = htons(dst_port);
  808c8b:	0f b7 ff             	movzwl %di,%edi
  808c8e:	89 3c 24             	mov    %edi,(%esp)
  808c91:	e8 82 e9 ff ff       	call   807618 <htons>
  808c96:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808c99:	66 89 41 02          	mov    %ax,0x2(%ecx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  808c9d:	66 c7 41 06 00 00    	movw   $0x0,0x6(%ecx)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  808ca3:	89 df                	mov    %ebx,%edi
  808ca5:	83 c4 10             	add    $0x10,%esp
  808ca8:	85 db                	test   %ebx,%ebx
  808caa:	74 06                	je     808cb2 <udp_sendto_if+0xcc>
  808cac:	8b 03                	mov    (%ebx),%eax
  808cae:	85 c0                	test   %eax,%eax
  808cb0:	75 08                	jne    808cba <udp_sendto_if+0xd4>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  808cb2:	8b 45 18             	mov    0x18(%ebp),%eax
  808cb5:	8d 78 04             	lea    0x4(%eax),%edi
  808cb8:	eb 2c                	jmp    808ce6 <udp_sendto_if+0x100>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  808cba:	8b 55 18             	mov    0x18(%ebp),%edx
  808cbd:	3b 42 04             	cmp    0x4(%edx),%eax
  808cc0:	74 24                	je     808ce6 <udp_sendto_if+0x100>
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  808cc2:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  808cc7:	3b 75 0c             	cmp    0xc(%ebp),%esi
  808cca:	0f 84 97 00 00 00    	je     808d67 <udp_sendto_if+0x181>
        /* free the header pbuf */
        pbuf_free(q);
  808cd0:	83 ec 0c             	sub    $0xc,%esp
  808cd3:	56                   	push   %esi
  808cd4:	e8 8e ba ff ff       	call   804767 <pbuf_free>
  808cd9:	83 c4 10             	add    $0x10,%esp
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  808cdc:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  808ce1:	e9 81 00 00 00       	jmp    808d67 <udp_sendto_if+0x181>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  808ce6:	83 ec 0c             	sub    $0xc,%esp
  808ce9:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808ced:	50                   	push   %eax
  808cee:	e8 25 e9 ff ff       	call   807618 <htons>
  808cf3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808cf6:	66 89 42 04          	mov    %ax,0x4(%edx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  808cfa:	83 c4 10             	add    $0x10,%esp
  808cfd:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  808d01:	75 29                	jne    808d2c <udp_sendto_if+0x146>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808d03:	83 ec 0c             	sub    $0xc,%esp
  808d06:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808d0a:	50                   	push   %eax
  808d0b:	6a 11                	push   $0x11
  808d0d:	ff 75 10             	pushl  0x10(%ebp)
  808d10:	57                   	push   %edi
  808d11:	56                   	push   %esi
  808d12:	e8 e8 e5 ff ff       	call   8072ff <inet_chksum_pseudo>
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  808d17:	83 c4 20             	add    $0x20,%esp
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808d1a:	66 85 c0             	test   %ax,%ax
  808d1d:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  808d22:	0f 44 c2             	cmove  %edx,%eax
  808d25:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808d28:	66 89 42 06          	mov    %ax,0x6(%edx)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  808d2c:	83 ec 04             	sub    $0x4,%esp
  808d2f:	ff 75 18             	pushl  0x18(%ebp)
  808d32:	6a 11                	push   $0x11
  808d34:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  808d38:	50                   	push   %eax
  808d39:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  808d3d:	50                   	push   %eax
  808d3e:	ff 75 10             	pushl  0x10(%ebp)
  808d41:	57                   	push   %edi
  808d42:	56                   	push   %esi
  808d43:	e8 76 da ff ff       	call   8067be <ip_output_if>
  808d48:	89 c3                	mov    %eax,%ebx
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  808d4a:	83 c4 20             	add    $0x20,%esp
  808d4d:	3b 75 0c             	cmp    0xc(%ebp),%esi
  808d50:	74 15                	je     808d67 <udp_sendto_if+0x181>
    /* free the header pbuf */
    pbuf_free(q);
  808d52:	83 ec 0c             	sub    $0xc,%esp
  808d55:	56                   	push   %esi
  808d56:	e8 0c ba ff ff       	call   804767 <pbuf_free>
  808d5b:	83 c4 10             	add    $0x10,%esp
    q = NULL;
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  808d5e:	89 d8                	mov    %ebx,%eax
  808d60:	eb 05                	jmp    808d67 <udp_sendto_if+0x181>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  808d62:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  808d67:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808d6a:	5b                   	pop    %ebx
  808d6b:	5e                   	pop    %esi
  808d6c:	5f                   	pop    %edi
  808d6d:	5d                   	pop    %ebp
  808d6e:	c3                   	ret    

00808d6f <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  808d6f:	55                   	push   %ebp
  808d70:	89 e5                	mov    %esp,%ebp
  808d72:	56                   	push   %esi
  808d73:	53                   	push   %ebx
  808d74:	8b 75 10             	mov    0x10(%ebp),%esi
  808d77:	8b 5d 14             	mov    0x14(%ebp),%ebx

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  808d7a:	83 ec 0c             	sub    $0xc,%esp
  808d7d:	56                   	push   %esi
  808d7e:	e8 d9 d6 ff ff       	call   80645c <ip_route>
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  808d83:	83 c4 10             	add    $0x10,%esp
  808d86:	85 c0                	test   %eax,%eax
  808d88:	74 19                	je     808da3 <udp_sendto+0x34>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  808d8a:	83 ec 0c             	sub    $0xc,%esp
  808d8d:	50                   	push   %eax
  808d8e:	0f b7 db             	movzwl %bx,%ebx
  808d91:	53                   	push   %ebx
  808d92:	56                   	push   %esi
  808d93:	ff 75 0c             	pushl  0xc(%ebp)
  808d96:	ff 75 08             	pushl  0x8(%ebp)
  808d99:	e8 48 fe ff ff       	call   808be6 <udp_sendto_if>
  808d9e:	83 c4 20             	add    $0x20,%esp
  808da1:	eb 05                	jmp    808da8 <udp_sendto+0x39>

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  808da3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
}
  808da8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808dab:	5b                   	pop    %ebx
  808dac:	5e                   	pop    %esi
  808dad:	5d                   	pop    %ebp
  808dae:	c3                   	ret    

00808daf <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  808daf:	55                   	push   %ebp
  808db0:	89 e5                	mov    %esp,%ebp
  808db2:	83 ec 08             	sub    $0x8,%esp
  808db5:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  808db8:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  808dbc:	52                   	push   %edx
  808dbd:	8d 50 04             	lea    0x4(%eax),%edx
  808dc0:	52                   	push   %edx
  808dc1:	ff 75 0c             	pushl  0xc(%ebp)
  808dc4:	50                   	push   %eax
  808dc5:	e8 a5 ff ff ff       	call   808d6f <udp_sendto>
}
  808dca:	c9                   	leave  
  808dcb:	c3                   	ret    

00808dcc <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808dcc:	55                   	push   %ebp
  808dcd:	89 e5                	mov    %esp,%ebp
  808dcf:	57                   	push   %edi
  808dd0:	56                   	push   %esi
  808dd1:	53                   	push   %ebx
  808dd2:	83 ec 0c             	sub    $0xc,%esp
  808dd5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808dd8:	8b 75 0c             	mov    0xc(%ebp),%esi
  808ddb:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  808dde:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808de3:	75 13                	jne    808df8 <udp_connect+0x2c>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808de5:	83 ec 04             	sub    $0x4,%esp
  808de8:	6a 00                	push   $0x0
  808dea:	53                   	push   %ebx
  808deb:	53                   	push   %ebx
  808dec:	e8 39 fd ff ff       	call   808b2a <udp_bind>
    if (err != ERR_OK)
  808df1:	83 c4 10             	add    $0x10,%esp
  808df4:	84 c0                	test   %al,%al
  808df6:	75 3d                	jne    808e35 <udp_connect+0x69>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  808df8:	85 f6                	test   %esi,%esi
  808dfa:	74 04                	je     808e00 <udp_connect+0x34>
  808dfc:	8b 06                	mov    (%esi),%eax
  808dfe:	eb 05                	jmp    808e05 <udp_connect+0x39>
  808e00:	b8 00 00 00 00       	mov    $0x0,%eax
  808e05:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  808e08:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  808e0c:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808e10:	8b 15 54 b2 b3 00    	mov    0xb3b254,%edx
  808e16:	89 d0                	mov    %edx,%eax
  808e18:	eb 07                	jmp    808e21 <udp_connect+0x55>
    if (pcb == ipcb) {
  808e1a:	39 d8                	cmp    %ebx,%eax
  808e1c:	74 12                	je     808e30 <udp_connect+0x64>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808e1e:	8b 40 0c             	mov    0xc(%eax),%eax
  808e21:	85 c0                	test   %eax,%eax
  808e23:	75 f5                	jne    808e1a <udp_connect+0x4e>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  808e25:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  808e28:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  return ERR_OK;
  808e2e:	eb 05                	jmp    808e35 <udp_connect+0x69>

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
  808e30:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
  808e35:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808e38:	5b                   	pop    %ebx
  808e39:	5e                   	pop    %esi
  808e3a:	5f                   	pop    %edi
  808e3b:	5d                   	pop    %ebp
  808e3c:	c3                   	ret    

00808e3d <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  808e3d:	55                   	push   %ebp
  808e3e:	89 e5                	mov    %esp,%ebp
  808e40:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  808e43:	8b 15 a4 1b 81 00    	mov    0x811ba4,%edx
  808e49:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  808e4c:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  808e52:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  808e56:	5d                   	pop    %ebp
  808e57:	c3                   	ret    

00808e58 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  808e58:	55                   	push   %ebp
  808e59:	89 e5                	mov    %esp,%ebp
  808e5b:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  808e5e:	8b 55 0c             	mov    0xc(%ebp),%edx
  808e61:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  808e64:	8b 55 10             	mov    0x10(%ebp),%edx
  808e67:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  808e6a:	5d                   	pop    %ebp
  808e6b:	c3                   	ret    

00808e6c <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  808e6c:	55                   	push   %ebp
  808e6d:	89 e5                	mov    %esp,%ebp
  808e6f:	83 ec 08             	sub    $0x8,%esp
  808e72:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  808e75:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808e7a:	39 c8                	cmp    %ecx,%eax
  808e7c:	75 1e                	jne    808e9c <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  808e7e:	8b 40 0c             	mov    0xc(%eax),%eax
  808e81:	a3 54 b2 b3 00       	mov    %eax,0xb3b254
  808e86:	eb 18                	jmp    808ea0 <udp_remove+0x34>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  808e88:	8b 50 0c             	mov    0xc(%eax),%edx
  808e8b:	39 d1                	cmp    %edx,%ecx
  808e8d:	75 0a                	jne    808e99 <udp_remove+0x2d>
  808e8f:	85 d2                	test   %edx,%edx
  808e91:	74 06                	je     808e99 <udp_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  808e93:	8b 51 0c             	mov    0xc(%ecx),%edx
  808e96:	89 50 0c             	mov    %edx,0xc(%eax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  808e99:	8b 40 0c             	mov    0xc(%eax),%eax
  808e9c:	85 c0                	test   %eax,%eax
  808e9e:	75 e8                	jne    808e88 <udp_remove+0x1c>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  808ea0:	83 ec 08             	sub    $0x8,%esp
  808ea3:	51                   	push   %ecx
  808ea4:	6a 01                	push   $0x1
  808ea6:	e8 49 b5 ff ff       	call   8043f4 <memp_free>
}
  808eab:	83 c4 10             	add    $0x10,%esp
  808eae:	c9                   	leave  
  808eaf:	c3                   	ret    

00808eb0 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  808eb0:	55                   	push   %ebp
  808eb1:	89 e5                	mov    %esp,%ebp
  808eb3:	53                   	push   %ebx
  808eb4:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  808eb7:	6a 01                	push   $0x1
  808eb9:	e8 e0 b4 ff ff       	call   80439e <memp_malloc>
  808ebe:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  808ec0:	83 c4 10             	add    $0x10,%esp
  808ec3:	85 c0                	test   %eax,%eax
  808ec5:	74 14                	je     808edb <udp_new+0x2b>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  808ec7:	83 ec 04             	sub    $0x4,%esp
  808eca:	6a 20                	push   $0x20
  808ecc:	6a 00                	push   $0x0
  808ece:	50                   	push   %eax
  808ecf:	e8 5d 5c 00 00       	call   80eb31 <memset>
    pcb->ttl = UDP_TTL;
  808ed4:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  808ed8:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  808edb:	89 d8                	mov    %ebx,%eax
  808edd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808ee0:	c9                   	leave  
  808ee1:	c3                   	ret    

00808ee2 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  808ee2:	55                   	push   %ebp
  808ee3:	89 e5                	mov    %esp,%ebp
  808ee5:	56                   	push   %esi
  808ee6:	53                   	push   %ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  808ee7:	85 c0                	test   %eax,%eax
  808ee9:	75 17                	jne    808f02 <free_etharp_q+0x20>
  808eeb:	83 ec 04             	sub    $0x4,%esp
  808eee:	68 a8 16 81 00       	push   $0x8116a8
  808ef3:	68 93 00 00 00       	push   $0x93
  808ef8:	68 96 1f 81 00       	push   $0x811f96
  808efd:	e8 8c 54 00 00       	call   80e38e <_panic>
  808f02:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  808f04:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  808f08:	75 17                	jne    808f21 <free_etharp_q+0x3f>
  808f0a:	83 ec 04             	sub    $0x4,%esp
  808f0d:	68 ae 1f 81 00       	push   $0x811fae
  808f12:	68 94 00 00 00       	push   $0x94
  808f17:	68 96 1f 81 00       	push   $0x811f96
  808f1c:	e8 6d 54 00 00       	call   80e38e <_panic>
  while (q) {
    r = q;
    q = q->next;
  808f21:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  808f23:	8b 43 04             	mov    0x4(%ebx),%eax
  808f26:	85 c0                	test   %eax,%eax
  808f28:	75 17                	jne    808f41 <free_etharp_q+0x5f>
  808f2a:	83 ec 04             	sub    $0x4,%esp
  808f2d:	68 bb 1f 81 00       	push   $0x811fbb
  808f32:	68 98 00 00 00       	push   $0x98
  808f37:	68 96 1f 81 00       	push   $0x811f96
  808f3c:	e8 4d 54 00 00       	call   80e38e <_panic>
    pbuf_free(r->p);
  808f41:	83 ec 0c             	sub    $0xc,%esp
  808f44:	50                   	push   %eax
  808f45:	e8 1d b8 ff ff       	call   804767 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  808f4a:	83 c4 08             	add    $0x8,%esp
  808f4d:	53                   	push   %ebx
  808f4e:	6a 0a                	push   $0xa
  808f50:	e8 9f b4 ff ff       	call   8043f4 <memp_free>
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
    r = q;
    q = q->next;
  808f55:	89 f3                	mov    %esi,%ebx
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  808f57:	83 c4 10             	add    $0x10,%esp
  808f5a:	85 f6                	test   %esi,%esi
  808f5c:	75 c3                	jne    808f21 <free_etharp_q+0x3f>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  808f5e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808f61:	5b                   	pop    %ebx
  808f62:	5e                   	pop    %esi
  808f63:	5d                   	pop    %ebp
  808f64:	c3                   	ret    

00808f65 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  808f65:	55                   	push   %ebp
  808f66:	89 e5                	mov    %esp,%ebp
  808f68:	57                   	push   %edi
  808f69:	56                   	push   %esi
  808f6a:	53                   	push   %ebx
  808f6b:	83 ec 1c             	sub    $0x1c,%esp
  808f6e:	89 d7                	mov    %edx,%edi
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  808f70:	85 c0                	test   %eax,%eax
  808f72:	74 2e                	je     808fa2 <find_entry+0x3d>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  808f74:	0f b6 15 00 4a b3 00 	movzbl 0xb34a00,%edx
  808f7b:	0f b6 ca             	movzbl %dl,%ecx
  808f7e:	6b d9 1c             	imul   $0x1c,%ecx,%ebx
  808f81:	83 bb 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ebx)
  808f88:	75 37                	jne    808fc1 <find_entry+0x5c>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  808f8a:	8b 8b 24 4a b3 00    	mov    0xb34a24(%ebx),%ecx
  808f90:	39 08                	cmp    %ecx,(%eax)
  808f92:	75 4c                	jne    808fe0 <find_entry+0x7b>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  808f94:	89 d0                	mov    %edx,%eax
  808f96:	e9 22 02 00 00       	jmp    8091bd <find_entry+0x258>
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  808f9b:	80 f9 0a             	cmp    $0xa,%cl
  808f9e:	75 78                	jne    809018 <find_entry+0xb3>
  808fa0:	eb 5b                	jmp    808ffd <find_entry+0x98>
  808fa2:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  808fa6:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  808faa:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  808fae:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  808fb2:	ba 00 00 00 00       	mov    $0x0,%edx
  808fb7:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  808fbb:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  808fbf:	eb 3c                	jmp    808ffd <find_entry+0x98>
  808fc1:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  808fc5:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  808fc9:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  808fcd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  808fd1:	ba 00 00 00 00       	mov    $0x0,%edx
  808fd6:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  808fda:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  808fde:	eb 1d                	jmp    808ffd <find_entry+0x98>
  808fe0:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  808fe4:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  808fe8:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  808fec:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  808ff0:	ba 00 00 00 00       	mov    $0x0,%edx
  808ff5:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  808ff9:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  808ffd:	0f b6 ca             	movzbl %dl,%ecx
  809000:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  809003:	83 b9 30 4a b3 00 00 	cmpl   $0x0,0xb34a30(%ecx)
  80900a:	75 07                	jne    809013 <find_entry+0xae>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  80900c:	89 d1                	mov    %edx,%ecx
  80900e:	e9 a3 00 00 00       	jmp    8090b6 <find_entry+0x151>
  809013:	b9 0a 00 00 00       	mov    $0xa,%ecx
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809018:	0f b6 da             	movzbl %dl,%ebx
  80901b:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  80901e:	8b b6 30 4a b3 00    	mov    0xb34a30(%esi),%esi
  809024:	83 fe 01             	cmp    $0x1,%esi
  809027:	75 55                	jne    80907e <find_entry+0x119>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809029:	85 c0                	test   %eax,%eax
  80902b:	74 1a                	je     809047 <find_entry+0xe2>
  80902d:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  809030:	8b b6 24 4a b3 00    	mov    0xb34a24(%esi),%esi
  809036:	39 30                	cmp    %esi,(%eax)
  809038:	75 0d                	jne    809047 <find_entry+0xe2>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80903a:	88 15 00 4a b3 00    	mov    %dl,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  809040:	89 d0                	mov    %edx,%eax
  809042:	e9 76 01 00 00       	jmp    8091bd <find_entry+0x258>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  809047:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  80904a:	83 be 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%esi)
  809051:	74 14                	je     809067 <find_entry+0x102>
        if (arp_table[i].ctime >= age_queue) {
  809053:	0f b6 9e 34 4a b3 00 	movzbl 0xb34a34(%esi),%ebx
  80905a:	3a 5d e7             	cmp    -0x19(%ebp),%bl
  80905d:	72 57                	jb     8090b6 <find_entry+0x151>
          old_queue = i;
  80905f:	88 55 e4             	mov    %dl,-0x1c(%ebp)
          age_queue = arp_table[i].ctime;
  809062:	88 5d e7             	mov    %bl,-0x19(%ebp)
  809065:	eb 4f                	jmp    8090b6 <find_entry+0x151>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  809067:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  80906a:	0f b6 9b 34 4a b3 00 	movzbl 0xb34a34(%ebx),%ebx
  809071:	3a 5d e3             	cmp    -0x1d(%ebp),%bl
  809074:	72 40                	jb     8090b6 <find_entry+0x151>
          old_pending = i;
  809076:	88 55 e2             	mov    %dl,-0x1e(%ebp)
          age_pending = arp_table[i].ctime;
  809079:	88 5d e3             	mov    %bl,-0x1d(%ebp)
  80907c:	eb 38                	jmp    8090b6 <find_entry+0x151>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80907e:	83 fe 02             	cmp    $0x2,%esi
  809081:	75 33                	jne    8090b6 <find_entry+0x151>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809083:	85 c0                	test   %eax,%eax
  809085:	74 1a                	je     8090a1 <find_entry+0x13c>
  809087:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  80908a:	8b b6 24 4a b3 00    	mov    0xb34a24(%esi),%esi
  809090:	39 30                	cmp    %esi,(%eax)
  809092:	75 0d                	jne    8090a1 <find_entry+0x13c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  809094:	88 15 00 4a b3 00    	mov    %dl,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80909a:	89 d0                	mov    %edx,%eax
  80909c:	e9 1c 01 00 00       	jmp    8091bd <find_entry+0x258>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  8090a1:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  8090a4:	0f b6 9b 34 4a b3 00 	movzbl 0xb34a34(%ebx),%ebx
  8090ab:	3a 5d e6             	cmp    -0x1a(%ebp),%bl
  8090ae:	72 06                	jb     8090b6 <find_entry+0x151>
        old_stable = i;
  8090b0:	88 55 e5             	mov    %dl,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  8090b3:	88 5d e6             	mov    %bl,-0x1a(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8090b6:	83 c2 01             	add    $0x1,%edx
  8090b9:	80 fa 09             	cmp    $0x9,%dl
  8090bc:	0f 86 d9 fe ff ff    	jbe    808f9b <find_entry+0x36>
  8090c2:	89 fa                	mov    %edi,%edx
  8090c4:	89 c3                	mov    %eax,%ebx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8090c6:	80 f9 0a             	cmp    $0xa,%cl
  8090c9:	75 0e                	jne    8090d9 <find_entry+0x174>
  8090cb:	f6 c2 01             	test   $0x1,%dl
  8090ce:	0f 85 de 00 00 00    	jne    8091b2 <find_entry+0x24d>
  8090d4:	e9 bd 00 00 00       	jmp    809196 <find_entry+0x231>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  8090d9:	f6 c2 02             	test   $0x2,%dl
  8090dc:	0f 85 bb 00 00 00    	jne    80919d <find_entry+0x238>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  8090e2:	89 ce                	mov    %ecx,%esi
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  8090e4:	80 f9 09             	cmp    $0x9,%cl
  8090e7:	7e 5f                	jle    809148 <find_entry+0x1e3>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  8090e9:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  8090ed:	3c 09                	cmp    $0x9,%al
  8090ef:	7f 28                	jg     809119 <find_entry+0x1b4>
    /* recycle oldest stable*/
    i = old_stable;
  8090f1:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  8090f3:	0f b6 c0             	movzbl %al,%eax
  8090f6:	6b c0 1c             	imul   $0x1c,%eax,%eax
  8090f9:	83 b8 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%eax)
  809100:	74 46                	je     809148 <find_entry+0x1e3>
  809102:	83 ec 04             	sub    $0x4,%esp
  809105:	68 c8 1f 81 00       	push   $0x811fc8
  80910a:	68 75 01 00 00       	push   $0x175
  80910f:	68 96 1f 81 00       	push   $0x811f96
  809114:	e8 75 52 00 00       	call   80e38e <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  809119:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
    /* recycle oldest pending */
    i = old_pending;
  80911d:	89 c6                	mov    %eax,%esi
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  80911f:	3c 09                	cmp    $0x9,%al
  809121:	7e 25                	jle    809148 <find_entry+0x1e3>
    /* recycle oldest pending */
    i = old_pending;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  809123:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  809127:	3c 09                	cmp    $0x9,%al
  809129:	7f 79                	jg     8091a4 <find_entry+0x23f>
    /* recycle oldest pending */
    i = old_queue;
  80912b:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  80912d:	0f b6 f8             	movzbl %al,%edi
  809130:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809133:	8b 87 20 4a b3 00    	mov    0xb34a20(%edi),%eax
  809139:	e8 a4 fd ff ff       	call   808ee2 <free_etharp_q>
    arp_table[i].q = NULL;
  80913e:	c7 87 20 4a b3 00 00 	movl   $0x0,0xb34a20(%edi)
  809145:	00 00 00 
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  809148:	89 f0                	mov    %esi,%eax
  80914a:	3c 09                	cmp    $0x9,%al
  80914c:	76 17                	jbe    809165 <find_entry+0x200>
  80914e:	83 ec 04             	sub    $0x4,%esp
  809151:	68 df 1f 81 00       	push   $0x811fdf
  809156:	68 8b 01 00 00       	push   $0x18b
  80915b:	68 96 1f 81 00       	push   $0x811f96
  809160:	e8 29 52 00 00       	call   80e38e <_panic>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  809165:	89 f0                	mov    %esi,%eax
  809167:	0f b6 c0             	movzbl %al,%eax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  80916a:	6b d0 1c             	imul   $0x1c,%eax,%edx
  80916d:	c7 82 30 4a b3 00 00 	movl   $0x0,0xb34a30(%edx)
  809174:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  809177:	85 db                	test   %ebx,%ebx
  809179:	74 08                	je     809183 <find_entry+0x21e>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  80917b:	8b 0b                	mov    (%ebx),%ecx
  80917d:	89 8a 24 4a b3 00    	mov    %ecx,0xb34a24(%edx)
  }
  arp_table[i].ctime = 0;
  809183:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809186:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  80918d:	89 f0                	mov    %esi,%eax
  80918f:	a2 00 4a b3 00       	mov    %al,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  809194:	eb 27                	jmp    8091bd <find_entry+0x258>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809196:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80919b:	eb 20                	jmp    8091bd <find_entry+0x258>
  80919d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8091a2:	eb 19                	jmp    8091bd <find_entry+0x258>
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  8091a4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8091a9:	eb 12                	jmp    8091bd <find_entry+0x258>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  8091ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8091b0:	eb 0b                	jmp    8091bd <find_entry+0x258>
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  8091b2:	f6 c2 02             	test   $0x2,%dl
  8091b5:	0f 84 2e ff ff ff    	je     8090e9 <find_entry+0x184>
  8091bb:	eb ee                	jmp    8091ab <find_entry+0x246>
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  8091bd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8091c0:	5b                   	pop    %ebx
  8091c1:	5e                   	pop    %esi
  8091c2:	5f                   	pop    %edi
  8091c3:	5d                   	pop    %ebp
  8091c4:	c3                   	ret    

008091c5 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  8091c5:	55                   	push   %ebp
  8091c6:	89 e5                	mov    %esp,%ebp
  8091c8:	57                   	push   %edi
  8091c9:	56                   	push   %esi
  8091ca:	53                   	push   %ebx
  8091cb:	83 ec 1c             	sub    $0x1c,%esp
  8091ce:	89 c6                	mov    %eax,%esi
  8091d0:	89 55 e0             	mov    %edx,-0x20(%ebp)
  8091d3:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  8091d6:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8091d9:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  8091dd:	74 17                	je     8091f6 <etharp_send_ip+0x31>
  8091df:	83 ec 04             	sub    $0x4,%esp
  8091e2:	68 0c 20 81 00       	push   $0x81200c
  8091e7:	68 b3 01 00 00       	push   $0x1b3
  8091ec:	68 96 1f 81 00       	push   $0x811f96
  8091f1:	e8 98 51 00 00       	call   80e38e <_panic>
  8091f6:	ba 06 00 00 00       	mov    $0x6,%edx
  8091fb:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  8091fe:	83 ea 01             	sub    $0x1,%edx
    ethhdr->dest.addr[k] = dst->addr[k];
  809201:	0f b6 c2             	movzbl %dl,%eax
  809204:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  809208:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  80920b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80920e:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  809212:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  809216:	84 d2                	test   %dl,%dl
  809218:	75 e4                	jne    8091fe <etharp_send_ip+0x39>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  80921a:	83 ec 0c             	sub    $0xc,%esp
  80921d:	68 00 08 00 00       	push   $0x800
  809222:	e8 f1 e3 ff ff       	call   807618 <htons>
  809227:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  80922b:	83 c4 08             	add    $0x8,%esp
  80922e:	ff 75 e0             	pushl  -0x20(%ebp)
  809231:	56                   	push   %esi
  809232:	ff 56 18             	call   *0x18(%esi)
}
  809235:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809238:	5b                   	pop    %ebx
  809239:	5e                   	pop    %esi
  80923a:	5f                   	pop    %edi
  80923b:	5d                   	pop    %ebp
  80923c:	c3                   	ret    

0080923d <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80923d:	55                   	push   %ebp
  80923e:	89 e5                	mov    %esp,%ebp
  809240:	57                   	push   %edi
  809241:	56                   	push   %esi
  809242:	53                   	push   %ebx
  809243:	83 ec 1c             	sub    $0x1c,%esp
  809246:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809249:	89 cb                	mov    %ecx,%ebx
  80924b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80924e:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809251:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809255:	74 17                	je     80926e <update_arp_entry+0x31>
  809257:	83 ec 04             	sub    $0x4,%esp
  80925a:	68 50 20 81 00       	push   $0x812050
  80925f:	68 d9 01 00 00       	push   $0x1d9
  809264:	68 96 1f 81 00       	push   $0x811f96
  809269:	e8 20 51 00 00       	call   80e38e <_panic>
  80926e:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809270:	85 d2                	test   %edx,%edx
  809272:	0f 84 ed 00 00 00    	je     809365 <update_arp_entry+0x128>
  809278:	83 3a 00             	cmpl   $0x0,(%edx)
  80927b:	0f 84 eb 00 00 00    	je     80936c <update_arp_entry+0x12f>
      ip_addr_isbroadcast(ipaddr, netif) ||
  809281:	83 ec 08             	sub    $0x8,%esp
  809284:	ff 75 e4             	pushl  -0x1c(%ebp)
  809287:	52                   	push   %edx
  809288:	e8 83 d1 ff ff       	call   806410 <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80928d:	83 c4 10             	add    $0x10,%esp
  809290:	84 c0                	test   %al,%al
  809292:	0f 85 db 00 00 00    	jne    809373 <update_arp_entry+0x136>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  809298:	8b 3e                	mov    (%esi),%edi
  80929a:	83 ec 0c             	sub    $0xc,%esp
  80929d:	68 00 00 00 f0       	push   $0xf0000000
  8092a2:	e8 ac e5 ff ff       	call   807853 <ntohl>
  8092a7:	21 c7                	and    %eax,%edi
  8092a9:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8092b0:	e8 9e e5 ff ff       	call   807853 <ntohl>
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  8092b5:	83 c4 10             	add    $0x10,%esp
  8092b8:	39 c7                	cmp    %eax,%edi
  8092ba:	0f 84 ba 00 00 00    	je     80937a <update_arp_entry+0x13d>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  8092c0:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  8092c4:	89 f0                	mov    %esi,%eax
  8092c6:	e8 9a fc ff ff       	call   808f65 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  8092cb:	84 c0                	test   %al,%al
  8092cd:	0f 88 ac 00 00 00    	js     80937f <update_arp_entry+0x142>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  8092d3:	0f be f0             	movsbl %al,%esi
  8092d6:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8092d9:	c7 80 30 4a b3 00 02 	movl   $0x2,0xb34a30(%eax)
  8092e0:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  8092e3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8092e6:	89 88 38 4a b3 00    	mov    %ecx,0xb34a38(%eax)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  8092ec:	ba 06 00 00 00       	mov    $0x6,%edx
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8092f1:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8092f4:	05 20 4a b3 00       	add    $0xb34a20,%eax
  8092f9:	89 d7                	mov    %edx,%edi

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
  8092fb:	83 ef 01             	sub    $0x1,%edi
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8092fe:	89 f9                	mov    %edi,%ecx
  809300:	0f b6 c9             	movzbl %cl,%ecx
  809303:	0f b6 14 0b          	movzbl (%ebx,%ecx,1),%edx
  809307:	88 54 01 08          	mov    %dl,0x8(%ecx,%eax,1)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  80930b:	89 f9                	mov    %edi,%ecx
  80930d:	84 c9                	test   %cl,%cl
  80930f:	75 ea                	jne    8092fb <update_arp_entry+0xbe>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  809311:	6b c6 1c             	imul   $0x1c,%esi,%eax
  809314:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80931b:	89 c6                	mov    %eax,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80931d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809320:	83 c0 25             	add    $0x25,%eax
  809323:	89 45 e0             	mov    %eax,-0x20(%ebp)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809326:	eb 31                	jmp    809359 <update_arp_entry+0x11c>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  809328:	8b 10                	mov    (%eax),%edx
  80932a:	89 96 20 4a b3 00    	mov    %edx,0xb34a20(%esi)
    /* get the packet pointer */
    p = q->p;
  809330:	8b 78 04             	mov    0x4(%eax),%edi
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  809333:	83 ec 08             	sub    $0x8,%esp
  809336:	50                   	push   %eax
  809337:	6a 0a                	push   $0xa
  809339:	e8 b6 b0 ff ff       	call   8043f4 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80933e:	89 1c 24             	mov    %ebx,(%esp)
  809341:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809344:	89 fa                	mov    %edi,%edx
  809346:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809349:	e8 77 fe ff ff       	call   8091c5 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  80934e:	89 3c 24             	mov    %edi,(%esp)
  809351:	e8 11 b4 ff ff       	call   804767 <pbuf_free>
  809356:	83 c4 10             	add    $0x10,%esp
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809359:	8b 86 20 4a b3 00    	mov    0xb34a20(%esi),%eax
  80935f:	85 c0                	test   %eax,%eax
  809361:	75 c5                	jne    809328 <update_arp_entry+0xeb>
  809363:	eb 1a                	jmp    80937f <update_arp_entry+0x142>
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  809365:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80936a:	eb 13                	jmp    80937f <update_arp_entry+0x142>
  80936c:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809371:	eb 0c                	jmp    80937f <update_arp_entry+0x142>
  809373:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809378:	eb 05                	jmp    80937f <update_arp_entry+0x142>
  80937a:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  80937f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809382:	5b                   	pop    %ebx
  809383:	5e                   	pop    %esi
  809384:	5f                   	pop    %edi
  809385:	5d                   	pop    %ebp
  809386:	c3                   	ret    

00809387 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  809387:	55                   	push   %ebp
  809388:	89 e5                	mov    %esp,%ebp
  80938a:	57                   	push   %edi
  80938b:	56                   	push   %esi
  80938c:	53                   	push   %ebx
  80938d:	83 ec 0c             	sub    $0xc,%esp
  809390:	bb 34 4a b3 00       	mov    $0xb34a34,%ebx
  809395:	bf 4c 4b b3 00       	mov    $0xb34b4c,%edi
  80939a:	89 de                	mov    %ebx,%esi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80939c:	0f b6 03             	movzbl (%ebx),%eax
  80939f:	83 c0 01             	add    $0x1,%eax
  8093a2:	88 03                	mov    %al,(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  8093a4:	8b 53 fc             	mov    -0x4(%ebx),%edx
  8093a7:	3c ef                	cmp    $0xef,%al
  8093a9:	76 05                	jbe    8093b0 <etharp_tmr+0x29>
  8093ab:	83 fa 02             	cmp    $0x2,%edx
  8093ae:	74 09                	je     8093b9 <etharp_tmr+0x32>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  8093b0:	3c 01                	cmp    $0x1,%al
  8093b2:	76 1f                	jbe    8093d3 <etharp_tmr+0x4c>
  8093b4:	83 fa 01             	cmp    $0x1,%edx
  8093b7:	75 1a                	jne    8093d3 <etharp_tmr+0x4c>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  8093b9:	8b 46 ec             	mov    -0x14(%esi),%eax
  8093bc:	85 c0                	test   %eax,%eax
  8093be:	74 0c                	je     8093cc <etharp_tmr+0x45>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  8093c0:	e8 1d fb ff ff       	call   808ee2 <free_etharp_q>
        arp_table[i].q = NULL;
  8093c5:	c7 46 ec 00 00 00 00 	movl   $0x0,-0x14(%esi)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  8093cc:	c7 46 fc 00 00 00 00 	movl   $0x0,-0x4(%esi)
  8093d3:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8093d6:	39 fb                	cmp    %edi,%ebx
  8093d8:	75 c0                	jne    80939a <etharp_tmr+0x13>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  8093da:	83 c4 0c             	add    $0xc,%esp
  8093dd:	5b                   	pop    %ebx
  8093de:	5e                   	pop    %esi
  8093df:	5f                   	pop    %edi
  8093e0:	5d                   	pop    %ebp
  8093e1:	c3                   	ret    

008093e2 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  8093e2:	55                   	push   %ebp
  8093e3:	89 e5                	mov    %esp,%ebp
  8093e5:	53                   	push   %ebx
  8093e6:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  8093e9:	ba 02 00 00 00       	mov    $0x2,%edx
  8093ee:	8b 45 0c             	mov    0xc(%ebp),%eax
  8093f1:	e8 6f fb ff ff       	call   808f65 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  8093f6:	84 c0                	test   %al,%al
  8093f8:	78 29                	js     809423 <etharp_find_addr+0x41>
  8093fa:	0f be d0             	movsbl %al,%edx
  8093fd:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  809400:	83 b9 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ecx)
  809407:	75 21                	jne    80942a <etharp_find_addr+0x48>
      *eth_ret = &arp_table[i].ethaddr;
  809409:	89 ca                	mov    %ecx,%edx
  80940b:	8d 99 28 4a b3 00    	lea    0xb34a28(%ecx),%ebx
  809411:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809414:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  809416:	81 c2 24 4a b3 00    	add    $0xb34a24,%edx
  80941c:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80941f:	89 11                	mov    %edx,(%ecx)
      return i;
  809421:	eb 0c                	jmp    80942f <etharp_find_addr+0x4d>
  }
  return -1;
  809423:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809428:	eb 05                	jmp    80942f <etharp_find_addr+0x4d>
  80942a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80942f:	83 c4 04             	add    $0x4,%esp
  809432:	5b                   	pop    %ebx
  809433:	5d                   	pop    %ebp
  809434:	c3                   	ret    

00809435 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  809435:	55                   	push   %ebp
  809436:	89 e5                	mov    %esp,%ebp
  809438:	83 ec 08             	sub    $0x8,%esp
  80943b:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80943e:	85 c0                	test   %eax,%eax
  809440:	75 17                	jne    809459 <etharp_ip_input+0x24>
  809442:	83 ec 04             	sub    $0x4,%esp
  809445:	68 02 13 81 00       	push   $0x811302
  80944a:	68 48 02 00 00       	push   $0x248
  80944f:	68 96 1f 81 00       	push   $0x811f96
  809454:	e8 35 4f 00 00       	call   80e38e <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  809459:	8b 55 0c             	mov    0xc(%ebp),%edx
  80945c:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80945f:	8b 4a 1c             	mov    0x1c(%edx),%ecx
  809462:	33 48 04             	xor    0x4(%eax),%ecx
  809465:	85 48 08             	test   %ecx,0x8(%eax)
  809468:	75 13                	jne    80947d <etharp_ip_input+0x48>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  80946a:	8d 4a 06             	lea    0x6(%edx),%ecx
  80946d:	83 c2 1c             	add    $0x1c,%edx
  809470:	83 ec 0c             	sub    $0xc,%esp
  809473:	6a 00                	push   $0x0
  809475:	e8 c3 fd ff ff       	call   80923d <update_arp_entry>
  80947a:	83 c4 10             	add    $0x10,%esp
}
  80947d:	c9                   	leave  
  80947e:	c3                   	ret    

0080947f <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  80947f:	55                   	push   %ebp
  809480:	89 e5                	mov    %esp,%ebp
  809482:	57                   	push   %edi
  809483:	56                   	push   %esi
  809484:	53                   	push   %ebx
  809485:	83 ec 1c             	sub    $0x1c,%esp
  809488:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80948b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80948f:	75 17                	jne    8094a8 <etharp_arp_input+0x29>
  809491:	83 ec 04             	sub    $0x4,%esp
  809494:	68 02 13 81 00       	push   $0x811302
  809499:	68 75 02 00 00       	push   $0x275
  80949e:	68 96 1f 81 00       	push   $0x811f96
  8094a3:	e8 e6 4e 00 00       	call   80e38e <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  8094a8:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  8094ad:	77 11                	ja     8094c0 <etharp_arp_input+0x41>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8094af:	83 ec 0c             	sub    $0xc,%esp
  8094b2:	53                   	push   %ebx
  8094b3:	e8 af b2 ff ff       	call   804767 <pbuf_free>
    return;
  8094b8:	83 c4 10             	add    $0x10,%esp
  8094bb:	e9 b4 01 00 00       	jmp    809674 <etharp_arp_input+0x1f5>
  }

  hdr = p->payload;
  8094c0:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8094c3:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  8094c7:	83 ec 0c             	sub    $0xc,%esp
  8094ca:	6a 01                	push   $0x1
  8094cc:	e8 47 e1 ff ff       	call   807618 <htons>
  8094d1:	83 c4 10             	add    $0x10,%esp
  8094d4:	66 39 c7             	cmp    %ax,%di
  8094d7:	75 4b                	jne    809524 <etharp_arp_input+0xa5>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8094d9:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  8094dd:	83 ec 0c             	sub    $0xc,%esp
  8094e0:	68 04 06 00 00       	push   $0x604
  8094e5:	e8 2e e1 ff ff       	call   807618 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8094ea:	83 c4 10             	add    $0x10,%esp
  8094ed:	66 39 c7             	cmp    %ax,%di
  8094f0:	75 32                	jne    809524 <etharp_arp_input+0xa5>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8094f2:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  8094f6:	83 ec 0c             	sub    $0xc,%esp
  8094f9:	68 00 08 00 00       	push   $0x800
  8094fe:	e8 15 e1 ff ff       	call   807618 <htons>

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809503:	83 c4 10             	add    $0x10,%esp
  809506:	66 39 c7             	cmp    %ax,%di
  809509:	75 19                	jne    809524 <etharp_arp_input+0xa5>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  80950b:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  80950f:	83 ec 0c             	sub    $0xc,%esp
  809512:	68 06 08 00 00       	push   $0x806
  809517:	e8 fc e0 ff ff       	call   807618 <htons>
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80951c:	83 c4 10             	add    $0x10,%esp
  80951f:	66 39 c7             	cmp    %ax,%di
  809522:	74 11                	je     809535 <etharp_arp_input+0xb6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809524:	83 ec 0c             	sub    $0xc,%esp
  809527:	53                   	push   %ebx
  809528:	e8 3a b2 ff ff       	call   804767 <pbuf_free>
    return;
  80952d:	83 c4 10             	add    $0x10,%esp
  809530:	e9 3f 01 00 00       	jmp    809674 <etharp_arp_input+0x1f5>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  809535:	83 ec 04             	sub    $0x4,%esp
  809538:	6a 04                	push   $0x4
  80953a:	8d 46 1c             	lea    0x1c(%esi),%eax
  80953d:	50                   	push   %eax
  80953e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809541:	50                   	push   %eax
  809542:	e8 9f 56 00 00       	call   80ebe6 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  809547:	83 c4 0c             	add    $0xc,%esp
  80954a:	6a 04                	push   $0x4
  80954c:	8d 46 26             	lea    0x26(%esi),%eax
  80954f:	50                   	push   %eax
  809550:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809553:	50                   	push   %eax
  809554:	e8 8d 56 00 00       	call   80ebe6 <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  809559:	8b 45 08             	mov    0x8(%ebp),%eax
  80955c:	8b 40 04             	mov    0x4(%eax),%eax
  80955f:	83 c4 10             	add    $0x10,%esp
  809562:	85 c0                	test   %eax,%eax
  809564:	74 3c                	je     8095a2 <etharp_arp_input+0x123>
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  }

  /* ARP message directed to us? */
  if (for_us) {
  809566:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  809569:	75 37                	jne    8095a2 <etharp_arp_input+0x123>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80956b:	8d 4e 16             	lea    0x16(%esi),%ecx
  80956e:	83 ec 0c             	sub    $0xc,%esp
  809571:	6a 01                	push   $0x1
  809573:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809576:	8b 45 08             	mov    0x8(%ebp),%eax
  809579:	e8 bf fc ff ff       	call   80923d <update_arp_entry>
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  80957e:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  809582:	89 04 24             	mov    %eax,(%esp)
  809585:	e8 8e e0 ff ff       	call   807618 <htons>
  80958a:	83 c4 10             	add    $0x10,%esp
  80958d:	66 83 f8 01          	cmp    $0x1,%ax
  809591:	74 40                	je     8095d3 <etharp_arp_input+0x154>
  809593:	66 83 f8 02          	cmp    $0x2,%ax
  809597:	0f 84 b9 00 00 00    	je     809656 <etharp_arp_input+0x1d7>
  80959d:	e9 c6 00 00 00       	jmp    809668 <etharp_arp_input+0x1e9>
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  8095a2:	8d 4e 16             	lea    0x16(%esi),%ecx
  8095a5:	83 ec 0c             	sub    $0xc,%esp
  8095a8:	6a 00                	push   $0x0
  8095aa:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8095ad:	8b 45 08             	mov    0x8(%ebp),%eax
  8095b0:	e8 88 fc ff ff       	call   80923d <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  8095b5:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8095b9:	89 04 24             	mov    %eax,(%esp)
  8095bc:	e8 57 e0 ff ff       	call   807618 <htons>
  8095c1:	83 c4 10             	add    $0x10,%esp
  8095c4:	66 83 f8 02          	cmp    $0x2,%ax
  8095c8:	0f 85 9a 00 00 00    	jne    809668 <etharp_arp_input+0x1e9>
  8095ce:	e9 83 00 00 00       	jmp    809656 <etharp_arp_input+0x1d7>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  8095d3:	83 ec 0c             	sub    $0xc,%esp
  8095d6:	6a 02                	push   $0x2
  8095d8:	e8 3b e0 ff ff       	call   807618 <htons>
  8095dd:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  8095e1:	8b 46 1c             	mov    0x1c(%esi),%eax
  8095e4:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  8095e7:	8b 45 08             	mov    0x8(%ebp),%eax
  8095ea:	8b 40 04             	mov    0x4(%eax),%eax
  8095ed:	89 46 1c             	mov    %eax,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8095f0:	83 c4 10             	add    $0x10,%esp
  8095f3:	ba 06 00 00 00       	mov    $0x6,%edx
  8095f8:	8b 45 08             	mov    0x8(%ebp),%eax
  8095fb:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  8095ff:	74 17                	je     809618 <etharp_arp_input+0x199>
  809601:	83 ec 04             	sub    $0x4,%esp
  809604:	68 0c 20 81 00       	push   $0x81200c
  809609:	68 c7 02 00 00       	push   $0x2c7
  80960e:	68 96 1f 81 00       	push   $0x811f96
  809613:	e8 76 4d 00 00       	call   80e38e <_panic>
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  809618:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  80961b:	0f b6 c2             	movzbl %dl,%eax
  80961e:	0f b6 4c 06 16       	movzbl 0x16(%esi,%eax,1),%ecx
  809623:	88 4c 06 20          	mov    %cl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  809627:	88 0c 06             	mov    %cl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  80962a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80962d:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  809631:	88 4c 06 16          	mov    %cl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  809635:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  809638:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  80963c:	88 4c 06 06          	mov    %cl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  809640:	84 d2                	test   %dl,%dl
  809642:	75 d4                	jne    809618 <etharp_arp_input+0x199>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  809644:	83 ec 08             	sub    $0x8,%esp
  809647:	53                   	push   %ebx
  809648:	ff 75 08             	pushl  0x8(%ebp)
  80964b:	8b 45 08             	mov    0x8(%ebp),%eax
  80964e:	ff 50 18             	call   *0x18(%eax)
  809651:	83 c4 10             	add    $0x10,%esp
  809654:	eb 12                	jmp    809668 <etharp_arp_input+0x1e9>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  809656:	83 ec 08             	sub    $0x8,%esp
  809659:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80965c:	50                   	push   %eax
  80965d:	ff 75 08             	pushl  0x8(%ebp)
  809660:	e8 d6 a1 ff ff       	call   80383b <dhcp_arp_reply>
#endif
    break;
  809665:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  809668:	83 ec 0c             	sub    $0xc,%esp
  80966b:	53                   	push   %ebx
  80966c:	e8 f6 b0 ff ff       	call   804767 <pbuf_free>
  809671:	83 c4 10             	add    $0x10,%esp
}
  809674:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809677:	5b                   	pop    %ebx
  809678:	5e                   	pop    %esi
  809679:	5f                   	pop    %edi
  80967a:	5d                   	pop    %ebp
  80967b:	c3                   	ret    

0080967c <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80967c:	55                   	push   %ebp
  80967d:	89 e5                	mov    %esp,%ebp
  80967f:	57                   	push   %edi
  809680:	56                   	push   %esi
  809681:	53                   	push   %ebx
  809682:	83 ec 10             	sub    $0x10,%esp
  809685:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  809688:	6a 00                	push   $0x0
  80968a:	6a 2a                	push   $0x2a
  80968c:	6a 02                	push   $0x2
  80968e:	e8 9a b1 ff ff       	call   80482d <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  809693:	83 c4 10             	add    $0x10,%esp
  809696:	85 c0                	test   %eax,%eax
  809698:	0f 84 ec 00 00 00    	je     80978a <etharp_request+0x10e>
  80969e:	89 c7                	mov    %eax,%edi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  8096a0:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  8096a5:	77 17                	ja     8096be <etharp_request+0x42>
  8096a7:	83 ec 04             	sub    $0x4,%esp
  8096aa:	68 78 20 81 00       	push   $0x812078
  8096af:	68 1c 04 00 00       	push   $0x41c
  8096b4:	68 96 1f 81 00       	push   $0x811f96
  8096b9:	e8 d0 4c 00 00       	call   80e38e <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  8096be:	8b 58 04             	mov    0x4(%eax),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  8096c1:	83 ec 0c             	sub    $0xc,%esp
  8096c4:	6a 01                	push   $0x1
  8096c6:	e8 4d df ff ff       	call   807618 <htons>
  8096cb:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8096cf:	83 c4 10             	add    $0x10,%esp
  8096d2:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  8096d6:	74 17                	je     8096ef <etharp_request+0x73>
  8096d8:	83 ec 04             	sub    $0x4,%esp
  8096db:	68 0c 20 81 00       	push   $0x81200c
  8096e0:	68 23 04 00 00       	push   $0x423
  8096e5:	68 96 1f 81 00       	push   $0x811f96
  8096ea:	e8 9f 4c 00 00       	call   80e38e <_panic>
  8096ef:	ba 06 00 00 00       	mov    $0x6,%edx
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  8096f4:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  8096f7:	0f b6 c2             	movzbl %dl,%eax
  8096fa:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  8096ff:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  809703:	0f b6 88 f8 20 81 00 	movzbl 0x8120f8(%eax),%ecx
  80970a:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  80970e:	0f b6 88 00 21 81 00 	movzbl 0x812100(%eax),%ecx
  809715:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  809718:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  80971d:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  809721:	84 d2                	test   %dl,%dl
  809723:	75 cf                	jne    8096f4 <etharp_request+0x78>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  809725:	8b 46 04             	mov    0x4(%esi),%eax
  809728:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  80972b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80972e:	8b 00                	mov    (%eax),%eax
  809730:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  809733:	83 ec 0c             	sub    $0xc,%esp
  809736:	6a 01                	push   $0x1
  809738:	e8 db de ff ff       	call   807618 <htons>
  80973d:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  809741:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809748:	e8 cb de ff ff       	call   807618 <htons>
  80974d:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  809751:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809758:	e8 bb de ff ff       	call   807618 <htons>
  80975d:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  809761:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809768:	e8 ab de ff ff       	call   807618 <htons>
  80976d:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  809771:	83 c4 08             	add    $0x8,%esp
  809774:	57                   	push   %edi
  809775:	56                   	push   %esi
  809776:	ff 56 18             	call   *0x18(%esi)
  809779:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  80977b:	89 3c 24             	mov    %edi,(%esp)
  80977e:	e8 e4 af ff ff       	call   804767 <pbuf_free>
  809783:	83 c4 10             	add    $0x10,%esp
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
  809786:	89 d8                	mov    %ebx,%eax
  809788:	eb 05                	jmp    80978f <etharp_request+0x113>
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  80978a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80978f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809792:	5b                   	pop    %ebx
  809793:	5e                   	pop    %esi
  809794:	5f                   	pop    %edi
  809795:	5d                   	pop    %ebp
  809796:	c3                   	ret    

00809797 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  809797:	55                   	push   %ebp
  809798:	89 e5                	mov    %esp,%ebp
  80979a:	57                   	push   %edi
  80979b:	56                   	push   %esi
  80979c:	53                   	push   %ebx
  80979d:	83 ec 24             	sub    $0x24,%esp
  8097a0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8097a3:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  8097a6:	ff 75 08             	pushl  0x8(%ebp)
  8097a9:	53                   	push   %ebx
  8097aa:	e8 61 cc ff ff       	call   806410 <ip_addr_isbroadcast>
  8097af:	83 c4 10             	add    $0x10,%esp
  8097b2:	84 c0                	test   %al,%al
  8097b4:	0f 85 a9 01 00 00    	jne    809963 <etharp_query+0x1cc>
      ip_addr_ismulticast(ipaddr) ||
  8097ba:	8b 33                	mov    (%ebx),%esi
  8097bc:	83 ec 0c             	sub    $0xc,%esp
  8097bf:	68 00 00 00 f0       	push   $0xf0000000
  8097c4:	e8 8a e0 ff ff       	call   807853 <ntohl>
  8097c9:	21 c6                	and    %eax,%esi
  8097cb:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8097d2:	e8 7c e0 ff ff       	call   807853 <ntohl>
  8097d7:	83 c4 10             	add    $0x10,%esp
  8097da:	85 db                	test   %ebx,%ebx
  8097dc:	0f 84 88 01 00 00    	je     80996a <etharp_query+0x1d3>
  8097e2:	39 c6                	cmp    %eax,%esi
  8097e4:	0f 84 80 01 00 00    	je     80996a <etharp_query+0x1d3>
      ip_addr_isany(ipaddr)) {
  8097ea:	83 3b 00             	cmpl   $0x0,(%ebx)
  8097ed:	0f 84 7e 01 00 00    	je     809971 <etharp_query+0x1da>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  8097f3:	ba 01 00 00 00       	mov    $0x1,%edx
  8097f8:	89 d8                	mov    %ebx,%eax
  8097fa:	e8 66 f7 ff ff       	call   808f65 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  8097ff:	84 c0                	test   %al,%al
  809801:	0f 88 c4 01 00 00    	js     8099cb <etharp_query+0x234>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  809807:	0f be f0             	movsbl %al,%esi
  80980a:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80980d:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809813:	85 c0                	test   %eax,%eax
  809815:	75 0f                	jne    809826 <etharp_query+0x8f>
    arp_table[i].state = ETHARP_STATE_PENDING;
  809817:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80981a:	c7 80 30 4a b3 00 01 	movl   $0x1,0xb34a30(%eax)
  809821:	00 00 00 
  809824:	eb 28                	jmp    80984e <etharp_query+0xb7>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809826:	8d 50 ff             	lea    -0x1(%eax),%edx
  809829:	83 fa 01             	cmp    $0x1,%edx
  80982c:	76 17                	jbe    809845 <etharp_query+0xae>
  80982e:	83 ec 04             	sub    $0x4,%esp
  809831:	68 ac 20 81 00       	push   $0x8120ac
  809836:	68 92 03 00 00       	push   $0x392
  80983b:	68 96 1f 81 00       	push   $0x811f96
  809840:	e8 49 4b 00 00       	call   80e38e <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809845:	85 ff                	test   %edi,%edi
  809847:	74 05                	je     80984e <etharp_query+0xb7>
  809849:	83 f8 01             	cmp    $0x1,%eax
  80984c:	75 13                	jne    809861 <etharp_query+0xca>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80984e:	83 ec 08             	sub    $0x8,%esp
  809851:	53                   	push   %ebx
  809852:	ff 75 08             	pushl  0x8(%ebp)
  809855:	e8 22 fe ff ff       	call   80967c <etharp_request>
  80985a:	89 c3                	mov    %eax,%ebx
  80985c:	83 c4 10             	add    $0x10,%esp
  80985f:	eb 05                	jmp    809866 <etharp_query+0xcf>
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  809861:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  809866:	85 ff                	test   %edi,%edi
  809868:	0f 84 0a 01 00 00    	je     809978 <etharp_query+0x1e1>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80986e:	6b c6 1c             	imul   $0x1c,%esi,%eax
  809871:	8b 90 30 4a b3 00    	mov    0xb34a30(%eax),%edx
  809877:	83 fa 02             	cmp    $0x2,%edx
  80987a:	75 24                	jne    8098a0 <etharp_query+0x109>
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  80987c:	8b 45 08             	mov    0x8(%ebp),%eax
  80987f:	8d 48 25             	lea    0x25(%eax),%ecx
  if (q != NULL) {
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  809882:	83 ec 0c             	sub    $0xc,%esp
  809885:	6b c6 1c             	imul   $0x1c,%esi,%eax
  809888:	05 28 4a b3 00       	add    $0xb34a28,%eax
  80988d:	50                   	push   %eax
  80988e:	89 fa                	mov    %edi,%edx
  809890:	8b 45 08             	mov    0x8(%ebp),%eax
  809893:	e8 2d f9 ff ff       	call   8091c5 <etharp_send_ip>
  809898:	83 c4 10             	add    $0x10,%esp
  80989b:	e9 2b 01 00 00       	jmp    8099cb <etharp_query+0x234>
  8098a0:	89 d8                	mov    %ebx,%eax
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  8098a2:	83 fa 01             	cmp    $0x1,%edx
  8098a5:	0f 85 20 01 00 00    	jne    8099cb <etharp_query+0x234>
  8098ab:	89 f8                	mov    %edi,%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  8098ad:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  8098b1:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  8098b5:	75 20                	jne    8098d7 <etharp_query+0x140>
  8098b7:	83 38 00             	cmpl   $0x0,(%eax)
  8098ba:	0f 84 03 01 00 00    	je     8099c3 <etharp_query+0x22c>
  8098c0:	83 ec 04             	sub    $0x4,%esp
  8098c3:	68 f2 1f 81 00       	push   $0x811ff2
  8098c8:	68 b1 03 00 00       	push   $0x3b1
  8098cd:	68 96 1f 81 00       	push   $0x811f96
  8098d2:	e8 b7 4a 00 00       	call   80e38e <_panic>
        if(p->type != PBUF_ROM) {
  8098d7:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  8098db:	0f 85 9b 00 00 00    	jne    80997c <etharp_query+0x1e5>
          copy_needed = 1;
          break;
        }
        p = p->next;
  8098e1:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  8098e3:	85 c0                	test   %eax,%eax
  8098e5:	75 c6                	jne    8098ad <etharp_query+0x116>
  8098e7:	e9 b0 00 00 00       	jmp    80999c <etharp_query+0x205>
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
        if(p != NULL) {
          if (pbuf_copy(p, q) != ERR_OK) {
  8098ec:	83 ec 08             	sub    $0x8,%esp
  8098ef:	57                   	push   %edi
  8098f0:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8098f3:	57                   	push   %edi
  8098f4:	e8 32 b4 ff ff       	call   804d2b <pbuf_copy>
  8098f9:	83 c4 10             	add    $0x10,%esp
  8098fc:	84 c0                	test   %al,%al
  8098fe:	0f 84 a4 00 00 00    	je     8099a8 <etharp_query+0x211>
            pbuf_free(p);
  809904:	83 ec 0c             	sub    $0xc,%esp
  809907:	ff 75 e4             	pushl  -0x1c(%ebp)
  80990a:	e8 58 ae ff ff       	call   804767 <pbuf_free>
  80990f:	83 c4 10             	add    $0x10,%esp
  809912:	e9 a8 00 00 00       	jmp    8099bf <etharp_query+0x228>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
        if (new_entry != NULL) {
          new_entry->next = 0;
  809917:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  80991d:	89 78 04             	mov    %edi,0x4(%eax)
          if(arp_table[i].q != NULL) {
  809920:	6b d6 1c             	imul   $0x1c,%esi,%edx
  809923:	8b 8a 20 4a b3 00    	mov    0xb34a20(%edx),%ecx
  809929:	85 c9                	test   %ecx,%ecx
  80992b:	75 04                	jne    809931 <etharp_query+0x19a>
  80992d:	eb 14                	jmp    809943 <etharp_query+0x1ac>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
              r = r->next;
  80992f:	89 d1                	mov    %edx,%ecx
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  809931:	8b 11                	mov    (%ecx),%edx
  809933:	85 d2                	test   %edx,%edx
  809935:	75 f8                	jne    80992f <etharp_query+0x198>
              r = r->next;
            }
            r->next = new_entry;
  809937:	89 01                	mov    %eax,(%ecx)
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  809939:	b8 00 00 00 00       	mov    $0x0,%eax
  80993e:	e9 88 00 00 00       	jmp    8099cb <etharp_query+0x234>
              r = r->next;
            }
            r->next = new_entry;
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  809943:	6b f6 1c             	imul   $0x1c,%esi,%esi
  809946:	89 86 20 4a b3 00    	mov    %eax,0xb34a20(%esi)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80994c:	b8 00 00 00 00       	mov    $0x0,%eax
  809951:	eb 78                	jmp    8099cb <etharp_query+0x234>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  809953:	83 ec 0c             	sub    $0xc,%esp
  809956:	57                   	push   %edi
  809957:	e8 0b ae ff ff       	call   804767 <pbuf_free>
  80995c:	83 c4 10             	add    $0x10,%esp
  80995f:	89 d8                	mov    %ebx,%eax
  809961:	eb 68                	jmp    8099cb <etharp_query+0x234>
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  809963:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809968:	eb 61                	jmp    8099cb <etharp_query+0x234>
  80996a:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80996f:	eb 5a                	jmp    8099cb <etharp_query+0x234>
  809971:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809976:	eb 53                	jmp    8099cb <etharp_query+0x234>
  809978:	89 d8                	mov    %ebx,%eax
  80997a:	eb 4f                	jmp    8099cb <etharp_query+0x234>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80997c:	83 ec 04             	sub    $0x4,%esp
  80997f:	6a 00                	push   $0x0
  809981:	0f b7 d2             	movzwl %dx,%edx
  809984:	52                   	push   %edx
  809985:	6a 03                	push   $0x3
  809987:	e8 a1 ae ff ff       	call   80482d <pbuf_alloc>
  80998c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(p != NULL) {
  80998f:	83 c4 10             	add    $0x10,%esp
  809992:	85 c0                	test   %eax,%eax
  809994:	0f 85 52 ff ff ff    	jne    8098ec <etharp_query+0x155>
  80999a:	eb 23                	jmp    8099bf <etharp_query+0x228>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  80999c:	83 ec 0c             	sub    $0xc,%esp
  80999f:	57                   	push   %edi
  8099a0:	e8 39 b2 ff ff       	call   804bde <pbuf_ref>
  8099a5:	83 c4 10             	add    $0x10,%esp
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  8099a8:	83 ec 0c             	sub    $0xc,%esp
  8099ab:	6a 0a                	push   $0xa
  8099ad:	e8 ec a9 ff ff       	call   80439e <memp_malloc>
        if (new_entry != NULL) {
  8099b2:	83 c4 10             	add    $0x10,%esp
  8099b5:	85 c0                	test   %eax,%eax
  8099b7:	0f 85 5a ff ff ff    	jne    809917 <etharp_query+0x180>
  8099bd:	eb 94                	jmp    809953 <etharp_query+0x1bc>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  8099bf:	89 d8                	mov    %ebx,%eax
  8099c1:	eb 08                	jmp    8099cb <etharp_query+0x234>
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
        if(p->type != PBUF_ROM) {
  8099c3:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  8099c7:	75 b3                	jne    80997c <etharp_query+0x1e5>
  8099c9:	eb d1                	jmp    80999c <etharp_query+0x205>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  8099cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8099ce:	5b                   	pop    %ebx
  8099cf:	5e                   	pop    %esi
  8099d0:	5f                   	pop    %edi
  8099d1:	5d                   	pop    %ebp
  8099d2:	c3                   	ret    

008099d3 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  8099d3:	55                   	push   %ebp
  8099d4:	89 e5                	mov    %esp,%ebp
  8099d6:	57                   	push   %edi
  8099d7:	56                   	push   %esi
  8099d8:	53                   	push   %ebx
  8099d9:	83 ec 24             	sub    $0x24,%esp
  8099dc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8099df:	8b 75 10             	mov    0x10(%ebp),%esi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  8099e2:	6a 0e                	push   $0xe
  8099e4:	ff 75 0c             	pushl  0xc(%ebp)
  8099e7:	e8 a9 ac ff ff       	call   804695 <pbuf_header>
  8099ec:	83 c4 10             	add    $0x10,%esp
  8099ef:	84 c0                	test   %al,%al
  8099f1:	0f 85 bd 00 00 00    	jne    809ab4 <etharp_output+0xe1>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  8099f7:	83 ec 08             	sub    $0x8,%esp
  8099fa:	53                   	push   %ebx
  8099fb:	56                   	push   %esi
  8099fc:	e8 0f ca ff ff       	call   806410 <ip_addr_isbroadcast>
  809a01:	83 c4 10             	add    $0x10,%esp
  809a04:	84 c0                	test   %al,%al
  809a06:	0f 85 8d 00 00 00    	jne    809a99 <etharp_output+0xc6>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  809a0c:	8b 3e                	mov    (%esi),%edi
  809a0e:	83 ec 0c             	sub    $0xc,%esp
  809a11:	68 00 00 00 f0       	push   $0xf0000000
  809a16:	e8 38 de ff ff       	call   807853 <ntohl>
  809a1b:	21 c7                	and    %eax,%edi
  809a1d:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809a24:	e8 2a de ff ff       	call   807853 <ntohl>
  809a29:	83 c4 10             	add    $0x10,%esp
  809a2c:	39 c7                	cmp    %eax,%edi
  809a2e:	75 44                	jne    809a74 <etharp_output+0xa1>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  809a30:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  809a34:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  809a38:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  809a3c:	83 ec 0c             	sub    $0xc,%esp
  809a3f:	ff 36                	pushl  (%esi)
  809a41:	e8 0d de ff ff       	call   807853 <ntohl>
  809a46:	c1 e8 10             	shr    $0x10,%eax
  809a49:	83 e0 7f             	and    $0x7f,%eax
  809a4c:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809a4f:	83 c4 04             	add    $0x4,%esp
  809a52:	ff 36                	pushl  (%esi)
  809a54:	e8 fa dd ff ff       	call   807853 <ntohl>
  809a59:	c1 e8 08             	shr    $0x8,%eax
  809a5c:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809a5f:	83 c4 04             	add    $0x4,%esp
  809a62:	ff 36                	pushl  (%esi)
  809a64:	e8 ea dd ff ff       	call   807853 <ntohl>
  809a69:	88 45 e7             	mov    %al,-0x19(%ebp)
  809a6c:	83 c4 10             	add    $0x10,%esp
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  809a6f:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809a72:	eb 2a                	jmp    809a9e <etharp_output+0xcb>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809a74:	8b 06                	mov    (%esi),%eax
  809a76:	33 43 04             	xor    0x4(%ebx),%eax
  809a79:	85 43 08             	test   %eax,0x8(%ebx)
  809a7c:	74 09                	je     809a87 <etharp_output+0xb4>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  809a7e:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809a82:	74 37                	je     809abb <etharp_output+0xe8>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  809a84:	8d 73 0c             	lea    0xc(%ebx),%esi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  809a87:	83 ec 04             	sub    $0x4,%esp
  809a8a:	ff 75 0c             	pushl  0xc(%ebp)
  809a8d:	56                   	push   %esi
  809a8e:	53                   	push   %ebx
  809a8f:	e8 03 fd ff ff       	call   809797 <etharp_query>
  809a94:	83 c4 10             	add    $0x10,%esp
  809a97:	eb 27                	jmp    809ac0 <etharp_output+0xed>
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  809a99:	b8 00 21 81 00       	mov    $0x812100,%eax
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809a9e:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809aa1:	83 ec 0c             	sub    $0xc,%esp
  809aa4:	50                   	push   %eax
  809aa5:	8b 55 0c             	mov    0xc(%ebp),%edx
  809aa8:	89 d8                	mov    %ebx,%eax
  809aaa:	e8 16 f7 ff ff       	call   8091c5 <etharp_send_ip>
  809aaf:	83 c4 10             	add    $0x10,%esp
  809ab2:	eb 0c                	jmp    809ac0 <etharp_output+0xed>
  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  809ab4:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809ab9:	eb 05                	jmp    809ac0 <etharp_output+0xed>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  809abb:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
  809ac0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809ac3:	5b                   	pop    %ebx
  809ac4:	5e                   	pop    %esi
  809ac5:	5f                   	pop    %edi
  809ac6:	5d                   	pop    %ebp
  809ac7:	c3                   	ret    

00809ac8 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809ac8:	55                   	push   %ebp
  809ac9:	89 e5                	mov    %esp,%ebp
  809acb:	56                   	push   %esi
  809acc:	53                   	push   %ebx
  809acd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809ad0:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809ad3:	83 ec 0c             	sub    $0xc,%esp
  809ad6:	8b 43 04             	mov    0x4(%ebx),%eax
  809ad9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809add:	50                   	push   %eax
  809ade:	e8 35 db ff ff       	call   807618 <htons>
  809ae3:	83 c4 10             	add    $0x10,%esp
  809ae6:	66 3d 00 08          	cmp    $0x800,%ax
  809aea:	74 08                	je     809af4 <ethernet_input+0x2c>
  809aec:	66 3d 06 08          	cmp    $0x806,%ax
  809af0:	74 44                	je     809b36 <ethernet_input+0x6e>
  809af2:	eb 55                	jmp    809b49 <ethernet_input+0x81>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  809af4:	83 ec 08             	sub    $0x8,%esp
  809af7:	53                   	push   %ebx
  809af8:	56                   	push   %esi
  809af9:	e8 37 f9 ff ff       	call   809435 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809afe:	83 c4 08             	add    $0x8,%esp
  809b01:	6a f2                	push   $0xfffffff2
  809b03:	53                   	push   %ebx
  809b04:	e8 8c ab ff ff       	call   804695 <pbuf_header>
  809b09:	83 c4 10             	add    $0x10,%esp
  809b0c:	84 c0                	test   %al,%al
  809b0e:	74 17                	je     809b27 <ethernet_input+0x5f>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809b10:	83 ec 04             	sub    $0x4,%esp
  809b13:	68 d4 20 81 00       	push   $0x8120d4
  809b18:	68 7e 04 00 00       	push   $0x47e
  809b1d:	68 96 1f 81 00       	push   $0x811f96
  809b22:	e8 67 48 00 00       	call   80e38e <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  809b27:	83 ec 08             	sub    $0x8,%esp
  809b2a:	56                   	push   %esi
  809b2b:	53                   	push   %ebx
  809b2c:	e8 89 c9 ff ff       	call   8064ba <ip_input>
      }
      break;
  809b31:	83 c4 10             	add    $0x10,%esp
  809b34:	eb 1f                	jmp    809b55 <ethernet_input+0x8d>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809b36:	83 ec 04             	sub    $0x4,%esp
  809b39:	53                   	push   %ebx
  809b3a:	8d 46 25             	lea    0x25(%esi),%eax
  809b3d:	50                   	push   %eax
  809b3e:	56                   	push   %esi
  809b3f:	e8 3b f9 ff ff       	call   80947f <etharp_arp_input>
      break;
  809b44:	83 c4 10             	add    $0x10,%esp
  809b47:	eb 0c                	jmp    809b55 <ethernet_input+0x8d>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809b49:	83 ec 0c             	sub    $0xc,%esp
  809b4c:	53                   	push   %ebx
  809b4d:	e8 15 ac ff ff       	call   804767 <pbuf_free>
      p = NULL;
      break;
  809b52:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809b55:	b8 00 00 00 00       	mov    $0x0,%eax
  809b5a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809b5d:	5b                   	pop    %ebx
  809b5e:	5e                   	pop    %esi
  809b5f:	5d                   	pop    %ebp
  809b60:	c3                   	ret    

00809b61 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809b61:	55                   	push   %ebp
  809b62:	89 e5                	mov    %esp,%ebp
  809b64:	53                   	push   %ebx
  809b65:	83 ec 10             	sub    $0x10,%esp
  809b68:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809b6b:	ff 73 04             	pushl  0x4(%ebx)
  809b6e:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809b70:	89 1c 24             	mov    %ebx,(%esp)
  809b73:	e8 b2 64 00 00       	call   81002a <free>
}
  809b78:	83 c4 10             	add    $0x10,%esp
  809b7b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809b7e:	c9                   	leave  
  809b7f:	c3                   	ret    

00809b80 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809b80:	55                   	push   %ebp
  809b81:	89 e5                	mov    %esp,%ebp
  809b83:	83 ec 08             	sub    $0x8,%esp
  809b86:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809b89:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809b8e:	89 c8                	mov    %ecx,%eax
  809b90:	f7 e2                	mul    %edx
  809b92:	c1 ea 08             	shr    $0x8,%edx
  809b95:	89 d0                	mov    %edx,%eax
  809b97:	c1 e0 08             	shl    $0x8,%eax
  809b9a:	01 c2                	add    %eax,%edx
  809b9c:	89 c8                	mov    %ecx,%eax
  809b9e:	29 d0                	sub    %edx,%eax
  809ba0:	8b 04 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%eax
  809ba7:	eb 2a                	jmp    809bd3 <timeout_cleanup+0x53>
	if (t->tid == tid) {
  809ba9:	3b 08                	cmp    (%eax),%ecx
  809bab:	75 23                	jne    809bd0 <timeout_cleanup+0x50>
	    LIST_REMOVE(t, link);
  809bad:	8b 50 08             	mov    0x8(%eax),%edx
  809bb0:	85 d2                	test   %edx,%edx
  809bb2:	74 06                	je     809bba <timeout_cleanup+0x3a>
  809bb4:	8b 48 0c             	mov    0xc(%eax),%ecx
  809bb7:	89 4a 0c             	mov    %ecx,0xc(%edx)
  809bba:	8b 50 0c             	mov    0xc(%eax),%edx
  809bbd:	8b 48 08             	mov    0x8(%eax),%ecx
  809bc0:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  809bc2:	83 ec 0c             	sub    $0xc,%esp
  809bc5:	50                   	push   %eax
  809bc6:	e8 5f 64 00 00       	call   81002a <free>
	    goto done;
  809bcb:	83 c4 10             	add    $0x10,%esp
  809bce:	eb 07                	jmp    809bd7 <timeout_cleanup+0x57>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809bd0:	8b 40 08             	mov    0x8(%eax),%eax
  809bd3:	85 c0                	test   %eax,%eax
  809bd5:	75 d2                	jne    809ba9 <timeout_cleanup+0x29>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  809bd7:	c9                   	leave  
  809bd8:	c3                   	ret    

00809bd9 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  809bd9:	55                   	push   %ebp
  809bda:	89 e5                	mov    %esp,%ebp
  809bdc:	56                   	push   %esi
  809bdd:	53                   	push   %ebx
  809bde:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809be4:	b8 80 9d b3 00       	mov    $0xb39d80,%eax
  809be9:	be 80 b1 b3 00       	mov    $0xb3b180,%esi
  809bee:	89 c1                	mov    %eax,%ecx
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  809bf0:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809bf6:	89 50 0c             	mov    %edx,0xc(%eax)
  809bf9:	85 d2                	test   %edx,%edx
  809bfb:	74 06                	je     809c03 <sys_init+0x2a>
  809bfd:	8d 58 0c             	lea    0xc(%eax),%ebx
  809c00:	89 5a 10             	mov    %ebx,0x10(%edx)
  809c03:	c7 41 10 60 9d b3 00 	movl   $0xb39d60,0x10(%ecx)
  809c0a:	83 c0 14             	add    $0x14,%eax
  809c0d:	89 ca                	mov    %ecx,%edx

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  809c0f:	39 f0                	cmp    %esi,%eax
  809c11:	75 db                	jne    809bee <sys_init+0x15>
  809c13:	c7 05 60 9d b3 00 6c 	movl   $0xb3b16c,0xb39d60
  809c1a:	b1 b3 00 
  809c1d:	8b 15 44 4f b3 00    	mov    0xb34f44,%edx
  809c23:	b8 60 4f b3 00       	mov    $0xb34f60,%eax
  809c28:	be 60 9d b3 00       	mov    $0xb39d60,%esi
  809c2d:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  809c2f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809c35:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  809c3b:	85 d2                	test   %edx,%edx
  809c3d:	74 0c                	je     809c4b <sys_init+0x72>
  809c3f:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  809c45:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  809c4b:	c7 81 98 00 00 00 44 	movl   $0xb34f44,0x98(%ecx)
  809c52:	4f b3 00 
  809c55:	05 9c 00 00 00       	add    $0x9c,%eax
  809c5a:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  809c5c:	39 f0                	cmp    %esi,%eax
  809c5e:	75 cd                	jne    809c2d <sys_init+0x54>
  809c60:	c7 05 44 4f b3 00 c4 	movl   $0xb39cc4,0xb34f44
  809c67:	9c b3 00 
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  809c6a:	5b                   	pop    %ebx
  809c6b:	5e                   	pop    %esi
  809c6c:	5d                   	pop    %ebp
  809c6d:	c3                   	ret    

00809c6e <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  809c6e:	55                   	push   %ebp
  809c6f:	89 e5                	mov    %esp,%ebp
  809c71:	53                   	push   %ebx
  809c72:	83 ec 04             	sub    $0x4,%esp
  809c75:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  809c78:	a1 60 9d b3 00       	mov    0xb39d60,%eax
    if (!se) {
  809c7d:	85 c0                	test   %eax,%eax
  809c7f:	75 17                	jne    809c98 <sys_sem_new+0x2a>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  809c81:	83 ec 0c             	sub    $0xc,%esp
  809c84:	68 08 21 81 00       	push   $0x812108
  809c89:	e8 d9 47 00 00       	call   80e467 <cprintf>
	return SYS_SEM_NULL;
  809c8e:	83 c4 10             	add    $0x10,%esp
  809c91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809c96:	eb 52                	jmp    809cea <sys_sem_new+0x7c>
    }
    LIST_REMOVE(se, link);
  809c98:	8b 48 0c             	mov    0xc(%eax),%ecx
  809c9b:	85 c9                	test   %ecx,%ecx
  809c9d:	74 06                	je     809ca5 <sys_sem_new+0x37>
  809c9f:	8b 58 10             	mov    0x10(%eax),%ebx
  809ca2:	89 59 10             	mov    %ebx,0x10(%ecx)
  809ca5:	8b 48 10             	mov    0x10(%eax),%ecx
  809ca8:	8b 58 0c             	mov    0xc(%eax),%ebx
  809cab:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  809cad:	83 38 00             	cmpl   $0x0,(%eax)
  809cb0:	75 19                	jne    809ccb <sys_sem_new+0x5d>
  809cb2:	68 7d 22 81 00       	push   $0x81227d
  809cb7:	68 87 22 81 00       	push   $0x812287
  809cbc:	68 8d 00 00 00       	push   $0x8d
  809cc1:	68 9c 22 81 00       	push   $0x81229c
  809cc6:	e8 c3 46 00 00       	call   80e38e <_panic>
    se->freed = 0;
  809ccb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  809cd1:	0f b6 d2             	movzbl %dl,%edx
  809cd4:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  809cd8:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  809cdc:	2d 80 9d b3 00       	sub    $0xb39d80,%eax
  809ce1:	c1 f8 02             	sar    $0x2,%eax
  809ce4:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  809cea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809ced:	c9                   	leave  
  809cee:	c3                   	ret    

00809cef <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  809cef:	55                   	push   %ebp
  809cf0:	89 e5                	mov    %esp,%ebp
  809cf2:	83 ec 08             	sub    $0x8,%esp
  809cf5:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809cf8:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809cfb:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  809d02:	00 
  809d03:	74 19                	je     809d1e <sys_sem_free+0x2f>
  809d05:	68 b9 22 81 00       	push   $0x8122b9
  809d0a:	68 87 22 81 00       	push   $0x812287
  809d0f:	68 98 00 00 00       	push   $0x98
  809d14:	68 9c 22 81 00       	push   $0x81229c
  809d19:	e8 70 46 00 00       	call   80e38e <_panic>
    sems[sem].freed = 1;
  809d1e:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809d21:	c1 e2 02             	shl    $0x2,%edx
  809d24:	8d 8a 80 9d b3 00    	lea    0xb39d80(%edx),%ecx
  809d2a:	c7 82 80 9d b3 00 01 	movl   $0x1,0xb39d80(%edx)
  809d31:	00 00 00 
    sems[sem].gen++;
  809d34:	83 41 04 01          	addl   $0x1,0x4(%ecx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  809d38:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809d3e:	89 51 0c             	mov    %edx,0xc(%ecx)
  809d41:	85 d2                	test   %edx,%edx
  809d43:	74 0d                	je     809d52 <sys_sem_free+0x63>
  809d45:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  809d48:	8d 0c 8d 8c 9d b3 00 	lea    0xb39d8c(,%ecx,4),%ecx
  809d4f:	89 4a 10             	mov    %ecx,0x10(%edx)
  809d52:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809d59:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  809d5c:	8d 0c 8d 80 9d b3 00 	lea    0xb39d80(,%ecx,4),%ecx
  809d63:	89 0d 60 9d b3 00    	mov    %ecx,0xb39d60
  809d69:	01 d0                	add    %edx,%eax
  809d6b:	c7 04 85 90 9d b3 00 	movl   $0xb39d60,0xb39d90(,%eax,4)
  809d72:	60 9d b3 00 
}
  809d76:	c9                   	leave  
  809d77:	c3                   	ret    

00809d78 <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  809d78:	55                   	push   %ebp
  809d79:	89 e5                	mov    %esp,%ebp
  809d7b:	56                   	push   %esi
  809d7c:	53                   	push   %ebx
  809d7d:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  809d80:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  809d86:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  809d8d:	74 16                	je     809da5 <sys_mbox_free+0x2d>
  809d8f:	68 ca 22 81 00       	push   $0x8122ca
  809d94:	68 87 22 81 00       	push   $0x812287
  809d99:	6a 62                	push   $0x62
  809d9b:	68 9c 22 81 00       	push   $0x81229c
  809da0:	e8 e9 45 00 00       	call   80e38e <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  809da5:	83 ec 0c             	sub    $0xc,%esp
  809da8:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  809dae:	ff b6 ec 4f b3 00    	pushl  0xb34fec(%esi)
  809db4:	e8 36 ff ff ff       	call   809cef <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  809db9:	83 c4 04             	add    $0x4,%esp
  809dbc:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  809dc2:	e8 28 ff ff ff       	call   809cef <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  809dc7:	a1 44 4f b3 00       	mov    0xb34f44,%eax
  809dcc:	89 86 f4 4f b3 00    	mov    %eax,0xb34ff4(%esi)
  809dd2:	83 c4 10             	add    $0x10,%esp
  809dd5:	85 c0                	test   %eax,%eax
  809dd7:	74 12                	je     809deb <sys_mbox_free+0x73>
  809dd9:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  809ddf:	81 c2 f4 4f b3 00    	add    $0xb34ff4,%edx
  809de5:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809deb:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  809df1:	8d 83 60 4f b3 00    	lea    0xb34f60(%ebx),%eax
  809df7:	a3 44 4f b3 00       	mov    %eax,0xb34f44
  809dfc:	c7 83 f8 4f b3 00 44 	movl   $0xb34f44,0xb34ff8(%ebx)
  809e03:	4f b3 00 
    mboxes[mbox].freed = 1;
  809e06:	c7 83 60 4f b3 00 01 	movl   $0x1,0xb34f60(%ebx)
  809e0d:	00 00 00 
}
  809e10:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809e13:	5b                   	pop    %ebx
  809e14:	5e                   	pop    %esi
  809e15:	5d                   	pop    %ebp
  809e16:	c3                   	ret    

00809e17 <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  809e17:	55                   	push   %ebp
  809e18:	89 e5                	mov    %esp,%ebp
  809e1a:	56                   	push   %esi
  809e1b:	53                   	push   %ebx
    assert(size < MBOXSLOTS);
  809e1c:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  809e20:	7e 16                	jle    809e38 <sys_mbox_new+0x21>
  809e22:	68 de 22 81 00       	push   $0x8122de
  809e27:	68 87 22 81 00       	push   $0x812287
  809e2c:	6a 45                	push   $0x45
  809e2e:	68 9c 22 81 00       	push   $0x81229c
  809e33:	e8 56 45 00 00       	call   80e38e <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  809e38:	8b 1d 44 4f b3 00    	mov    0xb34f44,%ebx
    if (!mbe) {
  809e3e:	85 db                	test   %ebx,%ebx
  809e40:	75 1a                	jne    809e5c <sys_mbox_new+0x45>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  809e42:	83 ec 0c             	sub    $0xc,%esp
  809e45:	68 30 21 81 00       	push   $0x812130
  809e4a:	e8 18 46 00 00       	call   80e467 <cprintf>
	return SYS_MBOX_NULL;
  809e4f:	83 c4 10             	add    $0x10,%esp
  809e52:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809e57:	e9 b7 00 00 00       	jmp    809f13 <sys_mbox_new+0xfc>
    }
    LIST_REMOVE(mbe, link);
  809e5c:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  809e62:	85 c0                	test   %eax,%eax
  809e64:	74 0c                	je     809e72 <sys_mbox_new+0x5b>
  809e66:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  809e6c:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809e72:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  809e78:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  809e7e:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  809e80:	83 3b 00             	cmpl   $0x0,(%ebx)
  809e83:	75 16                	jne    809e9b <sys_mbox_new+0x84>
  809e85:	68 ef 22 81 00       	push   $0x8122ef
  809e8a:	68 87 22 81 00       	push   $0x812287
  809e8f:	6a 4c                	push   $0x4c
  809e91:	68 9c 22 81 00       	push   $0x81229c
  809e96:	e8 f3 44 00 00       	call   80e38e <_panic>
    mbe->freed = 0;
  809e9b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  809ea1:	89 d8                	mov    %ebx,%eax
  809ea3:	2d 60 4f b3 00       	sub    $0xb34f60,%eax
  809ea8:	c1 f8 02             	sar    $0x2,%eax
  809eab:	69 f0 97 6f f9 96    	imul   $0x96f96f97,%eax,%esi
    mbe->head = -1;
  809eb1:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  809eb8:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  809ebf:	83 ec 0c             	sub    $0xc,%esp
  809ec2:	6a 00                	push   $0x0
  809ec4:	e8 a5 fd ff ff       	call   809c6e <sys_sem_new>
  809ec9:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  809ecf:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  809ed6:	e8 93 fd ff ff       	call   809c6e <sys_sem_new>
  809edb:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  809ee1:	83 c4 10             	add    $0x10,%esp
  809ee4:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  809eeb:	74 05                	je     809ef2 <sys_mbox_new+0xdb>
  809eed:	83 f8 ff             	cmp    $0xffffffff,%eax
  809ef0:	75 1f                	jne    809f11 <sys_mbox_new+0xfa>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  809ef2:	83 ec 0c             	sub    $0xc,%esp
  809ef5:	56                   	push   %esi
  809ef6:	e8 7d fe ff ff       	call   809d78 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  809efb:	c7 04 24 58 21 81 00 	movl   $0x812158,(%esp)
  809f02:	e8 60 45 00 00       	call   80e467 <cprintf>
	return SYS_MBOX_NULL;
  809f07:	83 c4 10             	add    $0x10,%esp
  809f0a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809f0f:	eb 02                	jmp    809f13 <sys_mbox_new+0xfc>
    }
    return i;
  809f11:	89 f0                	mov    %esi,%eax
}
  809f13:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809f16:	5b                   	pop    %ebx
  809f17:	5e                   	pop    %esi
  809f18:	5d                   	pop    %ebp
  809f19:	c3                   	ret    

00809f1a <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  809f1a:	55                   	push   %ebp
  809f1b:	89 e5                	mov    %esp,%ebp
  809f1d:	83 ec 08             	sub    $0x8,%esp
  809f20:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809f23:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809f26:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  809f2d:	00 
  809f2e:	74 19                	je     809f49 <sys_sem_signal+0x2f>
  809f30:	68 b9 22 81 00       	push   $0x8122b9
  809f35:	68 87 22 81 00       	push   $0x812287
  809f3a:	68 a1 00 00 00       	push   $0xa1
  809f3f:	68 9c 22 81 00       	push   $0x81229c
  809f44:	e8 45 44 00 00       	call   80e38e <_panic>
    sems[sem].counter++;
  809f49:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809f4c:	8d 14 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%edx
  809f53:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  809f58:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  809f5d:	74 27                	je     809f86 <sys_sem_signal+0x6c>
	sems[sem].waiters = 0;
  809f5f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809f66:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  809f69:	66 c7 04 8d 8a 9d b3 	movw   $0x0,0xb39d8a(,%ecx,4)
  809f70:	00 00 00 
	thread_wakeup(&sems[sem].v);
  809f73:	83 ec 0c             	sub    $0xc,%esp
  809f76:	8d 04 8d 88 9d b3 00 	lea    0xb39d88(,%ecx,4),%eax
  809f7d:	50                   	push   %eax
  809f7e:	e8 b9 04 00 00       	call   80a43c <thread_wakeup>
  809f83:	83 c4 10             	add    $0x10,%esp
    }
}
  809f86:	c9                   	leave  
  809f87:	c3                   	ret    

00809f88 <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  809f88:	55                   	push   %ebp
  809f89:	89 e5                	mov    %esp,%ebp
  809f8b:	57                   	push   %edi
  809f8c:	56                   	push   %esi
  809f8d:	53                   	push   %ebx
  809f8e:	83 ec 1c             	sub    $0x1c,%esp
  809f91:	8b 75 0c             	mov    0xc(%ebp),%esi
    assert(!sems[sem].freed);
  809f94:	8b 45 08             	mov    0x8(%ebp),%eax
  809f97:	8d 04 80             	lea    (%eax,%eax,4),%eax
  809f9a:	83 3c 85 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%eax,4)
  809fa1:	00 
  809fa2:	74 19                	je     809fbd <sys_arch_sem_wait+0x35>
  809fa4:	68 b9 22 81 00       	push   $0x8122b9
  809fa9:	68 87 22 81 00       	push   $0x812287
  809fae:	68 ac 00 00 00       	push   $0xac
  809fb3:	68 9c 22 81 00       	push   $0x81229c
  809fb8:	e8 d1 43 00 00       	call   80e38e <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  809fbd:	8b 45 08             	mov    0x8(%ebp),%eax
  809fc0:	8d 04 80             	lea    (%eax,%eax,4),%eax
  809fc3:	8b 04 85 84 9d b3 00 	mov    0xb39d84(,%eax,4),%eax
  809fca:	89 45 dc             	mov    %eax,-0x24(%ebp)

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
    assert(!sems[sem].freed);
    u32_t waited = 0;
  809fcd:	bf 00 00 00 00       	mov    $0x0,%edi

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  809fd2:	8b 45 08             	mov    0x8(%ebp),%eax
  809fd5:	8d 04 80             	lea    (%eax,%eax,4),%eax
  809fd8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  809fdb:	e9 92 00 00 00       	jmp    80a072 <sys_arch_sem_wait+0xea>
	if (sems[sem].counter > 0) {
  809fe0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809fe3:	0f b7 04 85 88 9d b3 	movzwl 0xb39d88(,%eax,4),%eax
  809fea:	00 
  809feb:	66 85 c0             	test   %ax,%ax
  809fee:	74 18                	je     80a008 <sys_arch_sem_wait+0x80>
	    sems[sem].counter--;
  809ff0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809ff3:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  809ff6:	83 e8 01             	sub    $0x1,%eax
  809ff9:	66 89 04 95 88 9d b3 	mov    %ax,0xb39d88(,%edx,4)
  80a000:	00 
	    return waited;
  80a001:	89 f8                	mov    %edi,%eax
  80a003:	e9 86 00 00 00       	jmp    80a08e <sys_arch_sem_wait+0x106>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a008:	83 fe fe             	cmp    $0xfffffffe,%esi
  80a00b:	74 7c                	je     80a089 <sys_arch_sem_wait+0x101>
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80a00d:	e8 ce 4f 00 00       	call   80efe0 <sys_time_msec>
  80a012:	89 c1                	mov    %eax,%ecx
  80a014:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a017:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a01c:	85 f6                	test   %esi,%esi
  80a01e:	74 06                	je     80a026 <sys_arch_sem_wait+0x9e>
  80a020:	89 f0                	mov    %esi,%eax
  80a022:	29 f8                	sub    %edi,%eax
  80a024:	01 c8                	add    %ecx,%eax
	    sems[sem].waiters = 1;
  80a026:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a029:	8d 1c 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%ebx
  80a030:	66 c7 43 0a 01 00    	movw   $0x1,0xa(%ebx)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a036:	83 ec 04             	sub    $0x4,%esp
  80a039:	50                   	push   %eax
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
	    uint32_t cur_v = sems[sem].v;
  80a03a:	8d 43 08             	lea    0x8(%ebx),%eax
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a03d:	ff 73 08             	pushl  0x8(%ebx)
  80a040:	50                   	push   %eax
  80a041:	e8 0d 06 00 00       	call   80a653 <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80a046:	83 c4 10             	add    $0x10,%esp
  80a049:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80a04c:	3b 43 04             	cmp    0x4(%ebx),%eax
  80a04f:	74 17                	je     80a068 <sys_arch_sem_wait+0xe0>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a051:	83 ec 0c             	sub    $0xc,%esp
  80a054:	68 84 21 81 00       	push   $0x812184
  80a059:	e8 09 44 00 00       	call   80e467 <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a05e:	83 c4 10             	add    $0x10,%esp
  80a061:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a066:	eb 26                	jmp    80a08e <sys_arch_sem_wait+0x106>
	    }
	    uint32_t b = sys_time_msec();
  80a068:	e8 73 4f 00 00       	call   80efe0 <sys_time_msec>
	    waited += (b - a);
  80a06d:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a070:	01 c7                	add    %eax,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80a072:	85 f6                	test   %esi,%esi
  80a074:	0f 84 66 ff ff ff    	je     809fe0 <sys_arch_sem_wait+0x58>
  80a07a:	39 f7                	cmp    %esi,%edi
  80a07c:	0f 82 5e ff ff ff    	jb     809fe0 <sys_arch_sem_wait+0x58>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  80a082:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a087:	eb 05                	jmp    80a08e <sys_arch_sem_wait+0x106>
    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
  80a089:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80a08e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a091:	5b                   	pop    %ebx
  80a092:	5e                   	pop    %esi
  80a093:	5f                   	pop    %edi
  80a094:	5d                   	pop    %ebp
  80a095:	c3                   	ret    

0080a096 <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80a096:	55                   	push   %ebp
  80a097:	89 e5                	mov    %esp,%ebp
  80a099:	57                   	push   %edi
  80a09a:	56                   	push   %esi
  80a09b:	53                   	push   %ebx
  80a09c:	83 ec 0c             	sub    $0xc,%esp
  80a09f:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a0a2:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a0a8:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a0af:	74 16                	je     80a0c7 <sys_mbox_trypost+0x31>
  80a0b1:	68 ca 22 81 00       	push   $0x8122ca
  80a0b6:	68 87 22 81 00       	push   $0x812287
  80a0bb:	6a 72                	push   $0x72
  80a0bd:	68 9c 22 81 00       	push   $0x81229c
  80a0c2:	e8 c7 42 00 00       	call   80e38e <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a0c7:	83 ec 08             	sub    $0x8,%esp
  80a0ca:	6a 00                	push   $0x0
  80a0cc:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a0d2:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  80a0d8:	e8 ab fe ff ff       	call   809f88 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a0dd:	8b 96 68 4f b3 00    	mov    0xb34f68(%esi),%edx
  80a0e3:	8b 8e 64 4f b3 00    	mov    0xb34f64(%esi),%ecx
  80a0e9:	83 c4 10             	add    $0x10,%esp
  80a0ec:	39 ca                	cmp    %ecx,%edx
  80a0ee:	74 5c                	je     80a14c <sys_mbox_trypost+0xb6>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a0f0:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a0f6:	8d 42 01             	lea    0x1(%edx),%eax
  80a0f9:	89 c7                	mov    %eax,%edi
  80a0fb:	c1 ff 1f             	sar    $0x1f,%edi
  80a0fe:	c1 ef 1b             	shr    $0x1b,%edi
  80a101:	01 f8                	add    %edi,%eax
  80a103:	83 e0 1f             	and    $0x1f,%eax
  80a106:	29 f8                	sub    %edi,%eax
  80a108:	89 86 68 4f b3 00    	mov    %eax,0xb34f68(%esi)
    mboxes[mbox].msg[slot] = msg;
  80a10e:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a111:	01 d0                	add    %edx,%eax
  80a113:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a116:	89 34 85 6c 4f b3 00 	mov    %esi,0xb34f6c(,%eax,4)

    if (mboxes[mbox].head == -1)
  80a11d:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80a120:	75 0c                	jne    80a12e <sys_mbox_trypost+0x98>
	mboxes[mbox].head = slot;
  80a122:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a128:	89 90 64 4f b3 00    	mov    %edx,0xb34f64(%eax)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80a12e:	83 ec 0c             	sub    $0xc,%esp
  80a131:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a137:	ff b3 ec 4f b3 00    	pushl  0xb34fec(%ebx)
  80a13d:	e8 d8 fd ff ff       	call   809f1a <sys_sem_signal>

    return ERR_OK;
  80a142:	83 c4 10             	add    $0x10,%esp
  80a145:	b8 00 00 00 00       	mov    $0x0,%eax
  80a14a:	eb 05                	jmp    80a151 <sys_mbox_trypost+0xbb>
{
    assert(!mboxes[mbox].freed);

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
    if (mboxes[mbox].nextq == mboxes[mbox].head)
	return ERR_MEM;
  80a14c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	mboxes[mbox].head = slot;

    sys_sem_signal(mboxes[mbox].queued_msg);

    return ERR_OK;
}
  80a151:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a154:	5b                   	pop    %ebx
  80a155:	5e                   	pop    %esi
  80a156:	5f                   	pop    %edi
  80a157:	5d                   	pop    %ebp
  80a158:	c3                   	ret    

0080a159 <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80a159:	55                   	push   %ebp
  80a15a:	89 e5                	mov    %esp,%ebp
  80a15c:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a15f:	ff 75 0c             	pushl  0xc(%ebp)
  80a162:	ff 75 08             	pushl  0x8(%ebp)
  80a165:	e8 2c ff ff ff       	call   80a096 <sys_mbox_trypost>
  80a16a:	83 c4 10             	add    $0x10,%esp
  80a16d:	84 c0                	test   %al,%al
  80a16f:	74 16                	je     80a187 <sys_mbox_post+0x2e>
  80a171:	68 b0 21 81 00       	push   $0x8121b0
  80a176:	68 87 22 81 00       	push   $0x812287
  80a17b:	6a 6c                	push   $0x6c
  80a17d:	68 9c 22 81 00       	push   $0x81229c
  80a182:	e8 07 42 00 00       	call   80e38e <_panic>
}
  80a187:	c9                   	leave  
  80a188:	c3                   	ret    

0080a189 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80a189:	55                   	push   %ebp
  80a18a:	89 e5                	mov    %esp,%ebp
  80a18c:	57                   	push   %edi
  80a18d:	56                   	push   %esi
  80a18e:	53                   	push   %ebx
  80a18f:	83 ec 0c             	sub    $0xc,%esp
  80a192:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a195:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a198:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a19e:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a1a5:	74 19                	je     80a1c0 <sys_arch_mbox_fetch+0x37>
  80a1a7:	68 ca 22 81 00       	push   $0x8122ca
  80a1ac:	68 87 22 81 00       	push   $0x812287
  80a1b1:	68 ce 00 00 00       	push   $0xce
  80a1b6:	68 9c 22 81 00       	push   $0x81229c
  80a1bb:	e8 ce 41 00 00       	call   80e38e <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a1c0:	83 ec 08             	sub    $0x8,%esp
  80a1c3:	ff 75 10             	pushl  0x10(%ebp)
  80a1c6:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a1cc:	ff b0 ec 4f b3 00    	pushl  0xb34fec(%eax)
  80a1d2:	e8 b1 fd ff ff       	call   809f88 <sys_arch_sem_wait>
  80a1d7:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a1d9:	83 c4 10             	add    $0x10,%esp
  80a1dc:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a1df:	0f 84 86 00 00 00    	je     80a26b <sys_arch_mbox_fetch+0xe2>
	return waited;

    int slot = mboxes[mbox].head;
  80a1e5:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a1eb:	8b 80 64 4f b3 00    	mov    0xb34f64(%eax),%eax
    if (slot == -1)
  80a1f1:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a1f4:	75 17                	jne    80a20d <sys_arch_mbox_fetch+0x84>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a1f6:	83 ec 04             	sub    $0x4,%esp
  80a1f9:	68 d8 21 81 00       	push   $0x8121d8
  80a1fe:	68 d6 00 00 00       	push   $0xd6
  80a203:	68 9c 22 81 00       	push   $0x81229c
  80a208:	e8 81 41 00 00       	call   80e38e <_panic>
    if (msg)
  80a20d:	85 ff                	test   %edi,%edi
  80a20f:	74 0e                	je     80a21f <sys_arch_mbox_fetch+0x96>
	*msg = mboxes[mbox].msg[slot];
  80a211:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a214:	01 c2                	add    %eax,%edx
  80a216:	8b 14 95 6c 4f b3 00 	mov    0xb34f6c(,%edx,4),%edx
  80a21d:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a21f:	83 c0 01             	add    $0x1,%eax
  80a222:	99                   	cltd   
  80a223:	c1 ea 1b             	shr    $0x1b,%edx
  80a226:	01 d0                	add    %edx,%eax
  80a228:	83 e0 1f             	and    $0x1f,%eax
  80a22b:	29 d0                	sub    %edx,%eax
  80a22d:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a233:	89 82 64 4f b3 00    	mov    %eax,0xb34f64(%edx)
  80a239:	81 c2 60 4f b3 00    	add    $0xb34f60,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a23f:	3b 42 08             	cmp    0x8(%edx),%eax
  80a242:	75 10                	jne    80a254 <sys_arch_mbox_fetch+0xcb>
	mboxes[mbox].head = -1;
  80a244:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a24a:	c7 80 64 4f b3 00 ff 	movl   $0xffffffff,0xb34f64(%eax)
  80a251:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80a254:	83 ec 0c             	sub    $0xc,%esp
  80a257:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a25d:	ff b3 f0 4f b3 00    	pushl  0xb34ff0(%ebx)
  80a263:	e8 b2 fc ff ff       	call   809f1a <sys_sem_signal>
    return waited;
  80a268:	83 c4 10             	add    $0x10,%esp
}
  80a26b:	89 f0                	mov    %esi,%eax
  80a26d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a270:	5b                   	pop    %ebx
  80a271:	5e                   	pop    %esi
  80a272:	5f                   	pop    %edi
  80a273:	5d                   	pop    %ebp
  80a274:	c3                   	ret    

0080a275 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80a275:	55                   	push   %ebp
  80a276:	89 e5                	mov    %esp,%ebp
  80a278:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a27b:	6a fe                	push   $0xfffffffe
  80a27d:	ff 75 0c             	pushl  0xc(%ebp)
  80a280:	ff 75 08             	pushl  0x8(%ebp)
  80a283:	e8 01 ff ff ff       	call   80a189 <sys_arch_mbox_fetch>
}
  80a288:	c9                   	leave  
  80a289:	c3                   	ret    

0080a28a <sys_thread_new>:
}

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80a28a:	55                   	push   %ebp
  80a28b:	89 e5                	mov    %esp,%ebp
  80a28d:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a290:	6a 08                	push   $0x8
  80a292:	e8 41 5e 00 00       	call   8100d8 <malloc>
    if (lt == 0)
  80a297:	83 c4 10             	add    $0x10,%esp
  80a29a:	85 c0                	test   %eax,%eax
  80a29c:	75 17                	jne    80a2b5 <sys_thread_new+0x2b>
	panic("sys_thread_new: cannot allocate thread struct");
  80a29e:	83 ec 04             	sub    $0x4,%esp
  80a2a1:	68 00 22 81 00       	push   $0x812200
  80a2a6:	68 fd 00 00 00       	push   $0xfd
  80a2ab:	68 9c 22 81 00       	push   $0x81229c
  80a2b0:	e8 d9 40 00 00       	call   80e38e <_panic>

    if (stacksize > PGSIZE)
  80a2b5:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a2bc:	7e 17                	jle    80a2d5 <sys_thread_new+0x4b>
	panic("large stack %d", stacksize);
  80a2be:	ff 75 14             	pushl  0x14(%ebp)
  80a2c1:	68 fa 22 81 00       	push   $0x8122fa
  80a2c6:	68 00 01 00 00       	push   $0x100
  80a2cb:	68 9c 22 81 00       	push   $0x81229c
  80a2d0:	e8 b9 40 00 00       	call   80e38e <_panic>

    lt->func = thread;
  80a2d5:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a2d8:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a2da:	8b 55 10             	mov    0x10(%ebp),%edx
  80a2dd:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a2e0:	50                   	push   %eax
  80a2e1:	68 61 9b 80 00       	push   $0x809b61
  80a2e6:	ff 75 08             	pushl  0x8(%ebp)
  80a2e9:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a2ec:	50                   	push   %eax
  80a2ed:	e8 b8 01 00 00       	call   80a4aa <thread_create>

    if (r < 0)
  80a2f2:	83 c4 10             	add    $0x10,%esp
  80a2f5:	85 c0                	test   %eax,%eax
  80a2f7:	79 1e                	jns    80a317 <sys_thread_new+0x8d>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a2f9:	83 ec 0c             	sub    $0xc,%esp
  80a2fc:	50                   	push   %eax
  80a2fd:	e8 d7 04 00 00       	call   80a7d9 <e2s>
  80a302:	50                   	push   %eax
  80a303:	68 30 22 81 00       	push   $0x812230
  80a308:	68 09 01 00 00       	push   $0x109
  80a30d:	68 9c 22 81 00       	push   $0x81229c
  80a312:	e8 77 40 00 00       	call   80e38e <_panic>

    return tid;
}
  80a317:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a31a:	c9                   	leave  
  80a31b:	c3                   	ret    

0080a31c <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a31c:	55                   	push   %ebp
  80a31d:	89 e5                	mov    %esp,%ebp
  80a31f:	57                   	push   %edi
  80a320:	56                   	push   %esi
  80a321:	53                   	push   %ebx
  80a322:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a325:	e8 06 01 00 00       	call   80a430 <thread_id>
  80a32a:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a32c:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a331:	f7 e2                	mul    %edx
  80a333:	c1 ea 08             	shr    $0x8,%edx
  80a336:	89 d7                	mov    %edx,%edi
  80a338:	c1 e2 08             	shl    $0x8,%edx
  80a33b:	01 d7                	add    %edx,%edi
  80a33d:	89 f0                	mov    %esi,%eax
  80a33f:	29 f8                	sub    %edi,%eax
  80a341:	89 c7                	mov    %eax,%edi
  80a343:	8b 1c 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%ebx
  80a34a:	eb 0b                	jmp    80a357 <sys_arch_timeouts+0x3b>
	if (t->tid == tid)
  80a34c:	3b 33                	cmp    (%ebx),%esi
  80a34e:	0f 84 a4 00 00 00    	je     80a3f8 <sys_arch_timeouts+0xdc>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a354:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a357:	85 db                	test   %ebx,%ebx
  80a359:	75 f1                	jne    80a34c <sys_arch_timeouts+0x30>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80a35b:	83 ec 0c             	sub    $0xc,%esp
  80a35e:	6a 10                	push   $0x10
  80a360:	e8 73 5d 00 00       	call   8100d8 <malloc>
  80a365:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a367:	83 c4 10             	add    $0x10,%esp
  80a36a:	85 c0                	test   %eax,%eax
  80a36c:	75 17                	jne    80a385 <sys_arch_timeouts+0x69>
	panic("sys_arch_timeouts: cannot malloc");
  80a36e:	83 ec 04             	sub    $0x4,%esp
  80a371:	68 5c 22 81 00       	push   $0x81225c
  80a376:	68 2c 01 00 00       	push   $0x12c
  80a37b:	68 9c 22 81 00       	push   $0x81229c
  80a380:	e8 09 40 00 00       	call   80e38e <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80a385:	83 ec 0c             	sub    $0xc,%esp
  80a388:	68 80 9b 80 00       	push   $0x809b80
  80a38d:	e8 ec 00 00 00       	call   80a47e <thread_onhalt>
    if (r < 0)
  80a392:	83 c4 10             	add    $0x10,%esp
  80a395:	85 c0                	test   %eax,%eax
  80a397:	79 1e                	jns    80a3b7 <sys_arch_timeouts+0x9b>
	panic("thread_onhalt failed: %s", e2s(r));
  80a399:	83 ec 0c             	sub    $0xc,%esp
  80a39c:	50                   	push   %eax
  80a39d:	e8 37 04 00 00       	call   80a7d9 <e2s>
  80a3a2:	50                   	push   %eax
  80a3a3:	68 09 23 81 00       	push   $0x812309
  80a3a8:	68 30 01 00 00       	push   $0x130
  80a3ad:	68 9c 22 81 00       	push   $0x81229c
  80a3b2:	e8 d7 3f 00 00       	call   80e38e <_panic>

    t->tid = tid;
  80a3b7:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a3b9:	83 ec 04             	sub    $0x4,%esp
  80a3bc:	6a 04                	push   $0x4
  80a3be:	6a 00                	push   $0x0
  80a3c0:	8d 43 04             	lea    0x4(%ebx),%eax
  80a3c3:	50                   	push   %eax
  80a3c4:	e8 68 47 00 00       	call   80eb31 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a3c9:	8b 04 bd 40 4b b3 00 	mov    0xb34b40(,%edi,4),%eax
  80a3d0:	89 43 08             	mov    %eax,0x8(%ebx)
  80a3d3:	83 c4 10             	add    $0x10,%esp
  80a3d6:	85 c0                	test   %eax,%eax
  80a3d8:	74 0d                	je     80a3e7 <sys_arch_timeouts+0xcb>
  80a3da:	8b 04 bd 40 4b b3 00 	mov    0xb34b40(,%edi,4),%eax
  80a3e1:	8d 53 08             	lea    0x8(%ebx),%edx
  80a3e4:	89 50 0c             	mov    %edx,0xc(%eax)
  80a3e7:	89 1c bd 40 4b b3 00 	mov    %ebx,0xb34b40(,%edi,4)
  80a3ee:	8d 04 bd 40 4b b3 00 	lea    0xb34b40(,%edi,4),%eax
  80a3f5:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a3f8:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a3fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a3fe:	5b                   	pop    %ebx
  80a3ff:	5e                   	pop    %esi
  80a400:	5f                   	pop    %edi
  80a401:	5d                   	pop    %ebp
  80a402:	c3                   	ret    

0080a403 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80a403:	55                   	push   %ebp
  80a404:	89 e5                	mov    %esp,%ebp
}
  80a406:	5d                   	pop    %ebp
  80a407:	c3                   	ret    

0080a408 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80a408:	55                   	push   %ebp
  80a409:	89 e5                	mov    %esp,%ebp
}
  80a40b:	5d                   	pop    %ebp
  80a40c:	c3                   	ret    

0080a40d <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80a40d:	55                   	push   %ebp
  80a40e:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a410:	c7 05 88 b1 b3 00 00 	movl   $0x0,0xb3b188
  80a417:	00 00 00 
    tq->tq_last = 0;
  80a41a:	c7 05 8c b1 b3 00 00 	movl   $0x0,0xb3b18c
  80a421:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80a424:	c7 05 94 b1 b3 00 00 	movl   $0x0,0xb3b194
  80a42b:	00 00 00 
}
  80a42e:	5d                   	pop    %ebp
  80a42f:	c3                   	ret    

0080a430 <thread_id>:

uint32_t
thread_id(void) {
  80a430:	55                   	push   %ebp
  80a431:	89 e5                	mov    %esp,%ebp
    return cur_tc->tc_tid;
  80a433:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a438:	8b 00                	mov    (%eax),%eax
}
  80a43a:	5d                   	pop    %ebp
  80a43b:	c3                   	ret    

0080a43c <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a43c:	55                   	push   %ebp
  80a43d:	89 e5                	mov    %esp,%ebp
  80a43f:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a442:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
    while (tc) {
  80a447:	eb 0c                	jmp    80a455 <thread_wakeup+0x19>
	if (tc->tc_wait_addr == addr)
  80a449:	39 50 48             	cmp    %edx,0x48(%eax)
  80a44c:	75 04                	jne    80a452 <thread_wakeup+0x16>
	    tc->tc_wakeup = 1;
  80a44e:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80a452:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80a455:	85 c0                	test   %eax,%eax
  80a457:	75 f0                	jne    80a449 <thread_wakeup+0xd>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80a459:	5d                   	pop    %ebp
  80a45a:	c3                   	ret    

0080a45b <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80a45b:	55                   	push   %ebp
  80a45c:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80a45e:	8b 15 88 b1 b3 00    	mov    0xb3b188,%edx
    int n = 0;
  80a464:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80a469:	eb 0d                	jmp    80a478 <thread_wakeups_pending+0x1d>
	if (tc->tc_wakeup)
  80a46b:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80a46f:	80 f9 01             	cmp    $0x1,%cl
  80a472:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80a475:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80a478:	85 d2                	test   %edx,%edx
  80a47a:	75 ef                	jne    80a46b <thread_wakeups_pending+0x10>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80a47c:	5d                   	pop    %ebp
  80a47d:	c3                   	ret    

0080a47e <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a47e:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a483:	8b 50 60             	mov    0x60(%eax),%edx
  80a486:	83 fa 03             	cmp    $0x3,%edx
  80a489:	7f 17                	jg     80a4a2 <thread_onhalt+0x24>
    }
    return n;
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80a48b:	55                   	push   %ebp
  80a48c:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a48e:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a491:	89 48 60             	mov    %ecx,0x60(%eax)
  80a494:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a497:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a49b:	b8 00 00 00 00       	mov    $0x0,%eax
  80a4a0:	eb 06                	jmp    80a4a8 <thread_onhalt+0x2a>
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;
  80a4a2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a4a7:	c3                   	ret    

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
    return 0;
}
  80a4a8:	5d                   	pop    %ebp
  80a4a9:	c3                   	ret    

0080a4aa <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a4aa:	55                   	push   %ebp
  80a4ab:	89 e5                	mov    %esp,%ebp
  80a4ad:	57                   	push   %edi
  80a4ae:	56                   	push   %esi
  80a4af:	53                   	push   %ebx
  80a4b0:	83 ec 18             	sub    $0x18,%esp
  80a4b3:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a4b6:	6a 68                	push   $0x68
  80a4b8:	e8 1b 5c 00 00       	call   8100d8 <malloc>
    if (!tc)
  80a4bd:	83 c4 10             	add    $0x10,%esp
  80a4c0:	85 c0                	test   %eax,%eax
  80a4c2:	0f 84 f4 00 00 00    	je     80a5bc <thread_create+0x112>
  80a4c8:	89 c3                	mov    %eax,%ebx
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a4ca:	83 ec 04             	sub    $0x4,%esp
  80a4cd:	6a 68                	push   $0x68
  80a4cf:	6a 00                	push   $0x0
  80a4d1:	50                   	push   %eax
  80a4d2:	e8 5a 46 00 00       	call   80eb31 <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80a4d7:	83 c4 0c             	add    $0xc,%esp
  80a4da:	6a 1f                	push   $0x1f
  80a4dc:	ff 75 0c             	pushl  0xc(%ebp)
  80a4df:	8d 43 08             	lea    0x8(%ebx),%eax
  80a4e2:	50                   	push   %eax
  80a4e3:	e8 46 45 00 00       	call   80ea2e <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a4e8:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80a4ec:	8b 15 94 b1 b3 00    	mov    0xb3b194,%edx
  80a4f2:	8d 42 01             	lea    0x1(%edx),%eax
  80a4f5:	a3 94 b1 b3 00       	mov    %eax,0xb3b194
    if (max_tid == (uint32_t)~0)
  80a4fa:	83 c4 10             	add    $0x10,%esp
  80a4fd:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a500:	75 14                	jne    80a516 <thread_create+0x6c>
	panic("alloc_tid: no more thread ids");
  80a502:	83 ec 04             	sub    $0x4,%esp
  80a505:	68 22 23 81 00       	push   $0x812322
  80a50a:	6a 54                	push   $0x54
  80a50c:	68 40 23 81 00       	push   $0x812340
  80a511:	e8 78 3e 00 00       	call   80e38e <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a516:	89 13                	mov    %edx,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a518:	83 ec 0c             	sub    $0xc,%esp
  80a51b:	68 00 10 00 00       	push   $0x1000
  80a520:	e8 b3 5b 00 00       	call   8100d8 <malloc>
  80a525:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a528:	83 c4 10             	add    $0x10,%esp
  80a52b:	85 c0                	test   %eax,%eax
  80a52d:	75 16                	jne    80a545 <thread_create+0x9b>
	free(tc);
  80a52f:	83 ec 0c             	sub    $0xc,%esp
  80a532:	53                   	push   %ebx
  80a533:	e8 f2 5a 00 00       	call   81002a <free>
	return -E_NO_MEM;
  80a538:	83 c4 10             	add    $0x10,%esp
  80a53b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a540:	e9 83 00 00 00       	jmp    80a5c8 <thread_create+0x11e>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a545:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a54b:	83 ec 04             	sub    $0x4,%esp
  80a54e:	6a 04                	push   $0x4
  80a550:	6a 00                	push   $0x0
  80a552:	57                   	push   %edi
  80a553:	e8 d9 45 00 00       	call   80eb31 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a558:	83 c4 0c             	add    $0xc,%esp
  80a55b:	6a 18                	push   $0x18
  80a55d:	6a 00                	push   $0x0
  80a55f:	8d 43 30             	lea    0x30(%ebx),%eax
  80a562:	50                   	push   %eax
  80a563:	e8 c9 45 00 00       	call   80eb31 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a568:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a56b:	c7 43 30 54 a7 80 00 	movl   $0x80a754,0x30(%ebx)
    tc->tc_entry = entry;
  80a572:	8b 45 10             	mov    0x10(%ebp),%eax
  80a575:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a578:	8b 45 14             	mov    0x14(%ebp),%eax
  80a57b:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a57e:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a585:	83 c4 10             	add    $0x10,%esp
  80a588:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a58f:	75 0e                	jne    80a59f <thread_create+0xf5>
	tq->tq_first = tc;
  80a591:	89 1d 88 b1 b3 00    	mov    %ebx,0xb3b188
	tq->tq_last = tc;
  80a597:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c
  80a59d:	eb 0e                	jmp    80a5ad <thread_create+0x103>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a59f:	a1 8c b1 b3 00       	mov    0xb3b18c,%eax
  80a5a4:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a5a7:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c

    threadq_push(&thread_queue, tc);

    if (tid)
  80a5ad:	85 f6                	test   %esi,%esi
  80a5af:	74 12                	je     80a5c3 <thread_create+0x119>
	*tid = tc->tc_tid;
  80a5b1:	8b 03                	mov    (%ebx),%eax
  80a5b3:	89 06                	mov    %eax,(%esi)
    return 0;
  80a5b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80a5ba:	eb 0c                	jmp    80a5c8 <thread_create+0x11e>
int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
    struct thread_context *tc = malloc(sizeof(struct thread_context));
    if (!tc)
	return -E_NO_MEM;
  80a5bc:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a5c1:	eb 05                	jmp    80a5c8 <thread_create+0x11e>

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a5c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a5c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a5cb:	5b                   	pop    %ebx
  80a5cc:	5e                   	pop    %esi
  80a5cd:	5f                   	pop    %edi
  80a5ce:	5d                   	pop    %ebp
  80a5cf:	c3                   	ret    

0080a5d0 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80a5d0:	55                   	push   %ebp
  80a5d1:	89 e5                	mov    %esp,%ebp
  80a5d3:	53                   	push   %ebx
  80a5d4:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a5d7:	8b 1d 88 b1 b3 00    	mov    0xb3b188,%ebx
  80a5dd:	85 db                	test   %ebx,%ebx
  80a5df:	74 6d                	je     80a64e <thread_yield+0x7e>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a5e1:	8b 43 64             	mov    0x64(%ebx),%eax
  80a5e4:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
    tc->tc_queue_link = 0;
  80a5e9:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80a5f0:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a5f5:	85 c0                	test   %eax,%eax
  80a5f7:	74 42                	je     80a63b <thread_yield+0x6b>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80a5f9:	83 ec 0c             	sub    $0xc,%esp
  80a5fc:	83 c0 30             	add    $0x30,%eax
  80a5ff:	50                   	push   %eax
  80a600:	e8 6b 01 00 00       	call   80a770 <jos_setjmp>
  80a605:	83 c4 10             	add    $0x10,%esp
  80a608:	85 c0                	test   %eax,%eax
  80a60a:	75 42                	jne    80a64e <thread_yield+0x7e>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80a60c:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a611:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a618:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a61f:	75 0c                	jne    80a62d <thread_yield+0x5d>
	tq->tq_first = tc;
  80a621:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
	tq->tq_last = tc;
  80a626:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
  80a62b:	eb 0e                	jmp    80a63b <thread_yield+0x6b>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a62d:	8b 15 8c b1 b3 00    	mov    0xb3b18c,%edx
  80a633:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a636:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
    }

    cur_tc = next_tc;
  80a63b:	89 1d 90 b1 b3 00    	mov    %ebx,0xb3b190
    jos_longjmp(&cur_tc->tc_jb, 1);
  80a641:	8d 43 30             	lea    0x30(%ebx),%eax
  80a644:	ba 01 00 00 00       	mov    $0x1,%edx
  80a649:	e8 52 01 00 00       	call   80a7a0 <jos_longjmp>
}
  80a64e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a651:	c9                   	leave  
  80a652:	c3                   	ret    

0080a653 <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80a653:	55                   	push   %ebp
  80a654:	89 e5                	mov    %esp,%ebp
  80a656:	57                   	push   %edi
  80a657:	56                   	push   %esi
  80a658:	53                   	push   %ebx
  80a659:	83 ec 0c             	sub    $0xc,%esp
  80a65c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a65f:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80a662:	e8 79 49 00 00       	call   80efe0 <sys_time_msec>
  80a667:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80a669:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a66e:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a671:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
    uint32_t s = sys_time_msec();
    uint32_t p = s;
  80a675:	89 f0                	mov    %esi,%eax

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80a677:	eb 22                	jmp    80a69b <thread_wait+0x48>
	if (p < s)
	    break;
	if (addr && *addr != val)
  80a679:	85 db                	test   %ebx,%ebx
  80a67b:	74 07                	je     80a684 <thread_wait+0x31>
  80a67d:	8b 03                	mov    (%ebx),%eax
  80a67f:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80a682:	75 1f                	jne    80a6a3 <thread_wait+0x50>
	    break;
	if (cur_tc->tc_wakeup)
  80a684:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a689:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80a68d:	84 c0                	test   %al,%al
  80a68f:	75 12                	jne    80a6a3 <thread_wait+0x50>
	    break;

	thread_yield();
  80a691:	e8 3a ff ff ff       	call   80a5d0 <thread_yield>
	p = sys_time_msec();
  80a696:	e8 45 49 00 00       	call   80efe0 <sys_time_msec>

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
	if (p < s)
  80a69b:	39 f0                	cmp    %esi,%eax
  80a69d:	72 04                	jb     80a6a3 <thread_wait+0x50>
  80a69f:	39 f8                	cmp    %edi,%eax
  80a6a1:	72 d6                	jb     80a679 <thread_wait+0x26>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80a6a3:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a6a8:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a6af:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80a6b3:	83 c4 0c             	add    $0xc,%esp
  80a6b6:	5b                   	pop    %ebx
  80a6b7:	5e                   	pop    %esi
  80a6b8:	5f                   	pop    %edi
  80a6b9:	5d                   	pop    %ebp
  80a6ba:	c3                   	ret    

0080a6bb <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80a6bb:	55                   	push   %ebp
  80a6bc:	89 e5                	mov    %esp,%ebp
  80a6be:	56                   	push   %esi
  80a6bf:	53                   	push   %ebx
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a6c0:	8b 1d 80 b1 b3 00    	mov    0xb3b180,%ebx
  80a6c6:	85 db                	test   %ebx,%ebx
  80a6c8:	74 40                	je     80a70a <thread_halt+0x4f>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a6ca:	8b 43 64             	mov    0x64(%ebx),%eax
  80a6cd:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
    tc->tc_queue_link = 0;
  80a6d2:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80a6d9:	be 00 00 00 00       	mov    $0x0,%esi
  80a6de:	eb 0f                	jmp    80a6ef <thread_halt+0x34>
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
  80a6e0:	83 ec 0c             	sub    $0xc,%esp
  80a6e3:	ff 33                	pushl  (%ebx)
  80a6e5:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a6e9:	83 c6 01             	add    $0x1,%esi
  80a6ec:	83 c4 10             	add    $0x10,%esp
  80a6ef:	3b 73 60             	cmp    0x60(%ebx),%esi
  80a6f2:	7c ec                	jl     80a6e0 <thread_halt+0x25>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80a6f4:	83 ec 0c             	sub    $0xc,%esp
  80a6f7:	ff 73 04             	pushl  0x4(%ebx)
  80a6fa:	e8 2b 59 00 00       	call   81002a <free>
    free(tc);
  80a6ff:	89 1c 24             	mov    %ebx,(%esp)
  80a702:	e8 23 59 00 00       	call   81002a <free>
  80a707:	83 c4 10             	add    $0x10,%esp
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80a70a:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a70f:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a716:	83 3d 80 b1 b3 00 00 	cmpl   $0x0,0xb3b180
  80a71d:	75 0c                	jne    80a72b <thread_halt+0x70>
	tq->tq_first = tc;
  80a71f:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
	tq->tq_last = tc;
  80a724:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
  80a729:	eb 0e                	jmp    80a739 <thread_halt+0x7e>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a72b:	8b 15 84 b1 b3 00    	mov    0xb3b184,%edx
  80a731:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a734:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
    cur_tc = NULL;
  80a739:	c7 05 90 b1 b3 00 00 	movl   $0x0,0xb3b190
  80a740:	00 00 00 
    thread_yield();
  80a743:	e8 88 fe ff ff       	call   80a5d0 <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80a748:	e8 27 3c 00 00       	call   80e374 <exit>
}
  80a74d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a750:	5b                   	pop    %ebx
  80a751:	5e                   	pop    %esi
  80a752:	5d                   	pop    %ebp
  80a753:	c3                   	ret    

0080a754 <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80a754:	55                   	push   %ebp
  80a755:	89 e5                	mov    %esp,%ebp
  80a757:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80a75a:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a75f:	ff 70 2c             	pushl  0x2c(%eax)
  80a762:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80a765:	e8 51 ff ff ff       	call   80a6bb <thread_halt>
}
  80a76a:	83 c4 10             	add    $0x10,%esp
  80a76d:	c9                   	leave  
  80a76e:	c3                   	ret    
  80a76f:	90                   	nop

0080a770 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80a770:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80a774:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80a777:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80a779:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80a77d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80a780:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80a783:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80a786:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80a789:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80a78c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80a791:	c3                   	ret    
  80a792:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80a799:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080a7a0 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80a7a0:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80a7a2:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80a7a5:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80a7a8:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80a7ab:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80a7ae:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80a7b1:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80a7b3:	ff e1                	jmp    *%ecx

0080a7b5 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80a7b5:	55                   	push   %ebp
  80a7b6:	89 e5                	mov    %esp,%ebp
  80a7b8:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80a7bb:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
};

void
perror(const char *s) {
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80a7c0:	ff 34 85 20 40 81 00 	pushl  0x814020(,%eax,4)
  80a7c7:	ff 75 08             	pushl  0x8(%ebp)
  80a7ca:	68 5b 23 81 00       	push   $0x81235b
  80a7cf:	e8 93 3c 00 00       	call   80e467 <cprintf>
}
  80a7d4:	83 c4 10             	add    $0x10,%esp
  80a7d7:	c9                   	leave  
  80a7d8:	c3                   	ret    

0080a7d9 <e2s>:

const char *
e2s(int err) {
  80a7d9:	55                   	push   %ebp
  80a7da:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80a7dc:	8b 45 08             	mov    0x8(%ebp),%eax
  80a7df:	8b 04 85 20 40 81 00 	mov    0x814020(,%eax,4),%eax
}
  80a7e6:	5d                   	pop    %ebp
  80a7e7:	c3                   	ret    

0080a7e8 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80a7e8:	55                   	push   %ebp
  80a7e9:	89 e5                	mov    %esp,%ebp
  80a7eb:	57                   	push   %edi
  80a7ec:	56                   	push   %esi
  80a7ed:	53                   	push   %ebx
  80a7ee:	83 ec 20             	sub    $0x20,%esp
  80a7f1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80a7f4:	6a 07                	push   $0x7
  80a7f6:	68 00 00 00 10       	push   $0x10000000
  80a7fb:	6a 00                	push   $0x0
  80a7fd:	e8 ed 45 00 00       	call   80edef <sys_page_alloc>
    if (r < 0)
  80a802:	83 c4 10             	add    $0x10,%esp
  80a805:	85 c0                	test   %eax,%eax
  80a807:	79 14                	jns    80a81d <low_level_output+0x35>
	panic("jif: could not allocate page of memory");
  80a809:	83 ec 04             	sub    $0x4,%esp
  80a80c:	68 40 28 81 00       	push   $0x812840
  80a811:	6a 55                	push   $0x55
  80a813:	68 91 28 81 00       	push   $0x812891
  80a818:	e8 71 3b 00 00       	call   80e38e <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80a81d:	8b 45 08             	mov    0x8(%ebp),%eax
  80a820:	8b 40 1c             	mov    0x1c(%eax),%eax
  80a823:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80a826:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80a82b:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a830:	eb 46                	jmp    80a878 <low_level_output+0x90>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80a832:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a836:	0f b7 d0             	movzwl %ax,%edx
  80a839:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
  80a83c:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80a842:	7e 16                	jle    80a85a <low_level_output+0x72>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80a844:	83 ec 0c             	sub    $0xc,%esp
  80a847:	56                   	push   %esi
  80a848:	52                   	push   %edx
  80a849:	68 68 28 81 00       	push   $0x812868
  80a84e:	6a 64                	push   $0x64
  80a850:	68 91 28 81 00       	push   $0x812891
  80a855:	e8 34 3b 00 00       	call   80e38e <_panic>
	memcpy(&txbuf[txsize], q->payload, q->len);
  80a85a:	83 ec 04             	sub    $0x4,%esp
  80a85d:	0f b7 c0             	movzwl %ax,%eax
  80a860:	50                   	push   %eax
  80a861:	ff 73 04             	pushl  0x4(%ebx)
  80a864:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80a867:	50                   	push   %eax
  80a868:	e8 79 43 00 00       	call   80ebe6 <memcpy>
	txsize += q->len;
  80a86d:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a871:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a873:	8b 1b                	mov    (%ebx),%ebx
  80a875:	83 c4 10             	add    $0x10,%esp
  80a878:	85 db                	test   %ebx,%ebx
  80a87a:	75 b6                	jne    80a832 <low_level_output+0x4a>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80a87c:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80a882:	6a 07                	push   $0x7
  80a884:	68 00 00 00 10       	push   $0x10000000
  80a889:	6a 0b                	push   $0xb
  80a88b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a88e:	ff 70 04             	pushl  0x4(%eax)
  80a891:	e8 a2 4a 00 00       	call   80f338 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80a896:	83 c4 08             	add    $0x8,%esp
  80a899:	68 00 00 00 10       	push   $0x10000000
  80a89e:	6a 00                	push   $0x0
  80a8a0:	e8 cf 45 00 00       	call   80ee74 <sys_page_unmap>

    return ERR_OK;
}
  80a8a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80a8aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a8ad:	5b                   	pop    %ebx
  80a8ae:	5e                   	pop    %esi
  80a8af:	5f                   	pop    %edi
  80a8b0:	5d                   	pop    %ebp
  80a8b1:	c3                   	ret    

0080a8b2 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80a8b2:	55                   	push   %ebp
  80a8b3:	89 e5                	mov    %esp,%ebp
  80a8b5:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80a8b8:	ff 75 10             	pushl  0x10(%ebp)
  80a8bb:	ff 75 0c             	pushl  0xc(%ebp)
  80a8be:	ff 75 08             	pushl  0x8(%ebp)
  80a8c1:	e8 0d f1 ff ff       	call   8099d3 <etharp_output>
}
  80a8c6:	c9                   	leave  
  80a8c7:	c3                   	ret    

0080a8c8 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80a8c8:	55                   	push   %ebp
  80a8c9:	89 e5                	mov    %esp,%ebp
  80a8cb:	57                   	push   %edi
  80a8cc:	56                   	push   %esi
  80a8cd:	53                   	push   %ebx
  80a8ce:	83 ec 20             	sub    $0x20,%esp
  80a8d1:	8b 75 0c             	mov    0xc(%ebp),%esi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80a8d4:	8b 45 08             	mov    0x8(%ebp),%eax
  80a8d7:	8b 40 1c             	mov    0x1c(%eax),%eax
  80a8da:	89 45 d8             	mov    %eax,-0x28(%ebp)
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
    s16_t len = pkt->jp_len;
  80a8dd:	8b 06                	mov    (%esi),%eax
  80a8df:	89 c3                	mov    %eax,%ebx

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80a8e1:	6a 03                	push   $0x3
  80a8e3:	0f b7 c0             	movzwl %ax,%eax
  80a8e6:	50                   	push   %eax
  80a8e7:	6a 03                	push   $0x3
  80a8e9:	e8 3f 9f ff ff       	call   80482d <pbuf_alloc>
  80a8ee:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80a8f1:	83 c4 10             	add    $0x10,%esp
  80a8f4:	85 c0                	test   %eax,%eax
  80a8f6:	0f 84 b8 00 00 00    	je     80a9b4 <jif_input+0xec>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80a8fc:	8d 56 04             	lea    0x4(%esi),%edx
  80a8ff:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a902:	89 c6                	mov    %eax,%esi
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
  80a904:	bf 00 00 00 00       	mov    $0x0,%edi
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
	if (bytes > (len - copied))
  80a909:	0f bf c3             	movswl %bx,%eax
  80a90c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80a90f:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
	if (bytes > (len - copied))
  80a913:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a916:	29 f8                	sub    %edi,%eax
  80a918:	39 c3                	cmp    %eax,%ebx
  80a91a:	0f 4f d8             	cmovg  %eax,%ebx
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80a91d:	83 ec 04             	sub    $0x4,%esp
  80a920:	53                   	push   %ebx
  80a921:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a924:	01 f8                	add    %edi,%eax
  80a926:	50                   	push   %eax
  80a927:	ff 76 04             	pushl  0x4(%esi)
  80a92a:	e8 b7 42 00 00       	call   80ebe6 <memcpy>
	copied += bytes;
  80a92f:	01 df                	add    %ebx,%edi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a931:	8b 36                	mov    (%esi),%esi
  80a933:	83 c4 10             	add    $0x10,%esp
  80a936:	85 f6                	test   %esi,%esi
  80a938:	75 d5                	jne    80a90f <jif_input+0x47>
  80a93a:	eb 54                	jmp    80a990 <jif_input+0xc8>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80a93c:	83 ec 08             	sub    $0x8,%esp
  80a93f:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80a942:	57                   	push   %edi
  80a943:	ff 75 08             	pushl  0x8(%ebp)
  80a946:	e8 ea ea ff ff       	call   809435 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80a94b:	83 c4 08             	add    $0x8,%esp
  80a94e:	6a f2                	push   $0xfffffff2
  80a950:	57                   	push   %edi
  80a951:	e8 3f 9d ff ff       	call   804695 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80a956:	83 c4 08             	add    $0x8,%esp
  80a959:	ff 75 08             	pushl  0x8(%ebp)
  80a95c:	57                   	push   %edi
  80a95d:	8b 45 08             	mov    0x8(%ebp),%eax
  80a960:	ff 50 10             	call   *0x10(%eax)
	break;
  80a963:	83 c4 10             	add    $0x10,%esp
  80a966:	eb 4c                	jmp    80a9b4 <jif_input+0xec>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80a968:	83 ec 04             	sub    $0x4,%esp
  80a96b:	ff 75 dc             	pushl  -0x24(%ebp)
  80a96e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a971:	ff 30                	pushl  (%eax)
  80a973:	ff 75 08             	pushl  0x8(%ebp)
  80a976:	e8 04 eb ff ff       	call   80947f <etharp_arp_input>
	break;
  80a97b:	83 c4 10             	add    $0x10,%esp
  80a97e:	eb 34                	jmp    80a9b4 <jif_input+0xec>

    default:
	pbuf_free(p);
  80a980:	83 ec 0c             	sub    $0xc,%esp
  80a983:	ff 75 dc             	pushl  -0x24(%ebp)
  80a986:	e8 dc 9d ff ff       	call   804767 <pbuf_free>
  80a98b:	83 c4 10             	add    $0x10,%esp
  80a98e:	eb 24                	jmp    80a9b4 <jif_input+0xec>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80a990:	83 ec 0c             	sub    $0xc,%esp
  80a993:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80a996:	8b 40 04             	mov    0x4(%eax),%eax
  80a999:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80a99d:	50                   	push   %eax
  80a99e:	e8 75 cc ff ff       	call   807618 <htons>
  80a9a3:	83 c4 10             	add    $0x10,%esp
  80a9a6:	66 3d 00 08          	cmp    $0x800,%ax
  80a9aa:	74 90                	je     80a93c <jif_input+0x74>
  80a9ac:	66 3d 06 08          	cmp    $0x806,%ax
  80a9b0:	74 b6                	je     80a968 <jif_input+0xa0>
  80a9b2:	eb cc                	jmp    80a980 <jif_input+0xb8>
	break;

    default:
	pbuf_free(p);
    }
}
  80a9b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a9b7:	5b                   	pop    %ebx
  80a9b8:	5e                   	pop    %esi
  80a9b9:	5f                   	pop    %edi
  80a9ba:	5d                   	pop    %ebp
  80a9bb:	c3                   	ret    

0080a9bc <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80a9bc:	55                   	push   %ebp
  80a9bd:	89 e5                	mov    %esp,%ebp
  80a9bf:	57                   	push   %edi
  80a9c0:	56                   	push   %esi
  80a9c1:	53                   	push   %ebx
  80a9c2:	83 ec 28             	sub    $0x28,%esp
  80a9c5:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80a9c8:	6a 08                	push   $0x8
  80a9ca:	e8 a8 97 ff ff       	call   804177 <mem_malloc>

    if (jif == NULL) {
  80a9cf:	83 c4 10             	add    $0x10,%esp
  80a9d2:	85 c0                	test   %eax,%eax
  80a9d4:	0f 84 81 00 00 00    	je     80aa5b <jif_init+0x9f>
  80a9da:	89 c6                	mov    %eax,%esi
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80a9dc:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80a9df:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80a9e2:	c7 43 14 b2 a8 80 00 	movl   $0x80a8b2,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80a9e9:	c7 43 18 e8 a7 80 00 	movl   $0x80a7e8,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80a9f0:	83 ec 04             	sub    $0x4,%esp
  80a9f3:	6a 02                	push   $0x2
  80a9f5:	68 84 35 81 00       	push   $0x813584
  80a9fa:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80a9fd:	50                   	push   %eax
  80a9fe:	e8 e3 41 00 00       	call   80ebe6 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80aa03:	8d 43 25             	lea    0x25(%ebx),%eax
  80aa06:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80aa08:	8b 07                	mov    (%edi),%eax
  80aa0a:	89 46 04             	mov    %eax,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80aa0d:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80aa11:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80aa17:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  80aa1b:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80aa1f:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80aa23:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80aa27:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80aa2b:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80aa2f:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80aa33:	c7 04 24 8b 0c 81 00 	movl   $0x810c8b,(%esp)
  80aa3a:	e8 f2 cd ff ff       	call   807831 <inet_addr>
  80aa3f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80aa42:	83 c4 0c             	add    $0xc,%esp
  80aa45:	6a 00                	push   $0x0
  80aa47:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80aa4a:	50                   	push   %eax
  80aa4b:	53                   	push   %ebx
  80aa4c:	e8 46 ed ff ff       	call   809797 <etharp_query>

    return ERR_OK;
  80aa51:	83 c4 10             	add    $0x10,%esp
  80aa54:	b8 00 00 00 00       	mov    $0x0,%eax
  80aa59:	eb 05                	jmp    80aa60 <jif_init+0xa4>

    jif = mem_malloc(sizeof(struct jif));

    if (jif == NULL) {
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  80aa5b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);

    return ERR_OK;
}
  80aa60:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aa63:	5b                   	pop    %ebx
  80aa64:	5e                   	pop    %esi
  80aa65:	5f                   	pop    %edi
  80aa66:	5d                   	pop    %ebp
  80aa67:	c3                   	ret    

0080aa68 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80aa68:	55                   	push   %ebp
  80aa69:	89 e5                	mov    %esp,%ebp
  80aa6b:	56                   	push   %esi
  80aa6c:	53                   	push   %ebx
  80aa6d:	83 ec 28             	sub    $0x28,%esp
  80aa70:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80aa73:	ff 75 10             	pushl  0x10(%ebp)
  80aa76:	ff 75 08             	pushl  0x8(%ebp)
  80aa79:	e8 02 0f 00 00       	call   80b980 <netconn_alloc>
  
  if (conn != NULL ) {
  80aa7e:	83 c4 10             	add    $0x10,%esp
  80aa81:	85 c0                	test   %eax,%eax
  80aa83:	0f 84 bd 00 00 00    	je     80ab46 <netconn_new_with_proto_and_callback+0xde>
  80aa89:	89 c3                	mov    %eax,%ebx
    msg.function = do_newconn;
  80aa8b:	c7 45 e4 87 b8 80 00 	movl   $0x80b887,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80aa92:	89 f0                	mov    %esi,%eax
  80aa94:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80aa97:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80aa9a:	83 ec 0c             	sub    $0xc,%esp
  80aa9d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80aaa0:	50                   	push   %eax
  80aaa1:	e8 9f 78 ff ff       	call   802345 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80aaa6:	83 c4 10             	add    $0x10,%esp
  80aaa9:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80aaad:	0f 84 9a 00 00 00    	je     80ab4d <netconn_new_with_proto_and_callback+0xe5>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80aab3:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80aab7:	74 14                	je     80aacd <netconn_new_with_proto_and_callback+0x65>
  80aab9:	83 ec 04             	sub    $0x4,%esp
  80aabc:	68 a8 28 81 00       	push   $0x8128a8
  80aac1:	6a 52                	push   $0x52
  80aac3:	68 5a 29 81 00       	push   $0x81295a
  80aac8:	e8 c1 38 00 00       	call   80e38e <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80aacd:	8b 43 10             	mov    0x10(%ebx),%eax
  80aad0:	83 f8 ff             	cmp    $0xffffffff,%eax
  80aad3:	75 14                	jne    80aae9 <netconn_new_with_proto_and_callback+0x81>
  80aad5:	83 ec 04             	sub    $0x4,%esp
  80aad8:	68 71 29 81 00       	push   $0x812971
  80aadd:	6a 53                	push   $0x53
  80aadf:	68 5a 29 81 00       	push   $0x81295a
  80aae4:	e8 a5 38 00 00       	call   80e38e <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80aae9:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80aaed:	75 14                	jne    80ab03 <netconn_new_with_proto_and_callback+0x9b>
  80aaef:	83 ec 04             	sub    $0x4,%esp
  80aaf2:	68 8a 29 81 00       	push   $0x81298a
  80aaf7:	6a 54                	push   $0x54
  80aaf9:	68 5a 29 81 00       	push   $0x81295a
  80aafe:	e8 8b 38 00 00       	call   80e38e <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80ab03:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80ab07:	74 14                	je     80ab1d <netconn_new_with_proto_and_callback+0xb5>
  80ab09:	83 ec 04             	sub    $0x4,%esp
  80ab0c:	68 cc 28 81 00       	push   $0x8128cc
  80ab11:	6a 55                	push   $0x55
  80ab13:	68 5a 29 81 00       	push   $0x81295a
  80ab18:	e8 71 38 00 00       	call   80e38e <_panic>
      sys_sem_free(conn->op_completed);
  80ab1d:	83 ec 0c             	sub    $0xc,%esp
  80ab20:	50                   	push   %eax
  80ab21:	e8 c9 f1 ff ff       	call   809cef <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80ab26:	83 c4 04             	add    $0x4,%esp
  80ab29:	ff 73 14             	pushl  0x14(%ebx)
  80ab2c:	e8 47 f2 ff ff       	call   809d78 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80ab31:	83 c4 08             	add    $0x8,%esp
  80ab34:	53                   	push   %ebx
  80ab35:	6a 07                	push   $0x7
  80ab37:	e8 b8 98 ff ff       	call   8043f4 <memp_free>
      return NULL;
  80ab3c:	83 c4 10             	add    $0x10,%esp
  80ab3f:	b8 00 00 00 00       	mov    $0x0,%eax
  80ab44:	eb 09                	jmp    80ab4f <netconn_new_with_proto_and_callback+0xe7>
    }
  }
  return conn;
  80ab46:	b8 00 00 00 00       	mov    $0x0,%eax
  80ab4b:	eb 02                	jmp    80ab4f <netconn_new_with_proto_and_callback+0xe7>
  80ab4d:	89 d8                	mov    %ebx,%eax
}
  80ab4f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ab52:	5b                   	pop    %ebx
  80ab53:	5e                   	pop    %esi
  80ab54:	5d                   	pop    %ebp
  80ab55:	c3                   	ret    

0080ab56 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80ab56:	55                   	push   %ebp
  80ab57:	89 e5                	mov    %esp,%ebp
  80ab59:	53                   	push   %ebx
  80ab5a:	83 ec 24             	sub    $0x24,%esp
  80ab5d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80ab60:	85 db                	test   %ebx,%ebx
  80ab62:	74 28                	je     80ab8c <netconn_delete+0x36>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80ab64:	c7 45 e4 c8 bb 80 00 	movl   $0x80bbc8,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ab6b:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80ab6e:	83 ec 0c             	sub    $0xc,%esp
  80ab71:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ab74:	50                   	push   %eax
  80ab75:	e8 cb 77 ff ff       	call   802345 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80ab7a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80ab81:	89 1c 24             	mov    %ebx,(%esp)
  80ab84:	e8 b0 0e 00 00       	call   80ba39 <netconn_free>

  return ERR_OK;
  80ab89:	83 c4 10             	add    $0x10,%esp
}
  80ab8c:	b8 00 00 00 00       	mov    $0x0,%eax
  80ab91:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ab94:	c9                   	leave  
  80ab95:	c3                   	ret    

0080ab96 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80ab96:	55                   	push   %ebp
  80ab97:	89 e5                	mov    %esp,%ebp
  80ab99:	83 ec 08             	sub    $0x8,%esp
  80ab9c:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80ab9f:	85 c0                	test   %eax,%eax
  80aba1:	75 17                	jne    80abba <netconn_type+0x24>
  80aba3:	83 ec 04             	sub    $0x4,%esp
  80aba6:	68 9f 29 81 00       	push   $0x81299f
  80abab:	68 84 00 00 00       	push   $0x84
  80abb0:	68 5a 29 81 00       	push   $0x81295a
  80abb5:	e8 d4 37 00 00       	call   80e38e <_panic>
  80abba:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80abbc:	c9                   	leave  
  80abbd:	c3                   	ret    

0080abbe <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80abbe:	55                   	push   %ebp
  80abbf:	89 e5                	mov    %esp,%ebp
  80abc1:	53                   	push   %ebx
  80abc2:	83 ec 24             	sub    $0x24,%esp
  80abc5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80abc8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80abcb:	8b 45 10             	mov    0x10(%ebp),%eax
  80abce:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80abd1:	85 db                	test   %ebx,%ebx
  80abd3:	75 17                	jne    80abec <netconn_getaddr+0x2e>
  80abd5:	83 ec 04             	sub    $0x4,%esp
  80abd8:	68 ba 29 81 00       	push   $0x8129ba
  80abdd:	68 98 00 00 00       	push   $0x98
  80abe2:	68 5a 29 81 00       	push   $0x81295a
  80abe7:	e8 a2 37 00 00       	call   80e38e <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80abec:	85 d2                	test   %edx,%edx
  80abee:	75 17                	jne    80ac07 <netconn_getaddr+0x49>
  80abf0:	83 ec 04             	sub    $0x4,%esp
  80abf3:	68 d8 29 81 00       	push   $0x8129d8
  80abf8:	68 99 00 00 00       	push   $0x99
  80abfd:	68 5a 29 81 00       	push   $0x81295a
  80ac02:	e8 87 37 00 00       	call   80e38e <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80ac07:	85 c0                	test   %eax,%eax
  80ac09:	75 17                	jne    80ac22 <netconn_getaddr+0x64>
  80ac0b:	83 ec 04             	sub    $0x4,%esp
  80ac0e:	68 f6 29 81 00       	push   $0x8129f6
  80ac13:	68 9a 00 00 00       	push   $0x9a
  80ac18:	68 5a 29 81 00       	push   $0x81295a
  80ac1d:	e8 6c 37 00 00       	call   80e38e <_panic>

  msg.function = do_getaddr;
  80ac22:	c7 45 e4 17 c0 80 00 	movl   $0x80c017,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ac29:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80ac2c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80ac2f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80ac32:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80ac35:	83 ec 0c             	sub    $0xc,%esp
  80ac38:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ac3b:	50                   	push   %eax
  80ac3c:	e8 04 77 ff ff       	call   802345 <tcpip_apimsg>

  return conn->err;
  80ac41:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ac45:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ac48:	c9                   	leave  
  80ac49:	c3                   	ret    

0080ac4a <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ac4a:	55                   	push   %ebp
  80ac4b:	89 e5                	mov    %esp,%ebp
  80ac4d:	53                   	push   %ebx
  80ac4e:	83 ec 24             	sub    $0x24,%esp
  80ac51:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ac54:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80ac57:	85 db                	test   %ebx,%ebx
  80ac59:	75 17                	jne    80ac72 <netconn_bind+0x28>
  80ac5b:	83 ec 04             	sub    $0x4,%esp
  80ac5e:	68 14 2a 81 00       	push   $0x812a14
  80ac63:	68 b5 00 00 00       	push   $0xb5
  80ac68:	68 5a 29 81 00       	push   $0x81295a
  80ac6d:	e8 1c 37 00 00       	call   80e38e <_panic>

  msg.function = do_bind;
  80ac72:	c7 45 e4 71 bc 80 00 	movl   $0x80bc71,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ac79:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ac7c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ac7f:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80ac82:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80ac86:	83 ec 0c             	sub    $0xc,%esp
  80ac89:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ac8c:	50                   	push   %eax
  80ac8d:	e8 b3 76 ff ff       	call   802345 <tcpip_apimsg>
  return conn->err;
  80ac92:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ac96:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ac99:	c9                   	leave  
  80ac9a:	c3                   	ret    

0080ac9b <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ac9b:	55                   	push   %ebp
  80ac9c:	89 e5                	mov    %esp,%ebp
  80ac9e:	53                   	push   %ebx
  80ac9f:	83 ec 24             	sub    $0x24,%esp
  80aca2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80aca5:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80aca8:	85 db                	test   %ebx,%ebx
  80acaa:	75 17                	jne    80acc3 <netconn_connect+0x28>
  80acac:	83 ec 04             	sub    $0x4,%esp
  80acaf:	68 2f 2a 81 00       	push   $0x812a2f
  80acb4:	68 cc 00 00 00       	push   $0xcc
  80acb9:	68 5a 29 81 00       	push   $0x81295a
  80acbe:	e8 cb 36 00 00       	call   80e38e <_panic>

  msg.function = do_connect;
  80acc3:	c7 45 e4 01 bd 80 00 	movl   $0x80bd01,-0x1c(%ebp)
  msg.msg.conn = conn;
  80acca:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80accd:	8b 55 0c             	mov    0xc(%ebp),%edx
  80acd0:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80acd3:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80acd7:	83 ec 0c             	sub    $0xc,%esp
  80acda:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80acdd:	50                   	push   %eax
  80acde:	e8 62 76 ff ff       	call   802345 <tcpip_apimsg>
  return conn->err;
  80ace3:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ace7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80acea:	c9                   	leave  
  80aceb:	c3                   	ret    

0080acec <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80acec:	55                   	push   %ebp
  80aced:	89 e5                	mov    %esp,%ebp
  80acef:	53                   	push   %ebx
  80acf0:	83 ec 24             	sub    $0x24,%esp
  80acf3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80acf6:	85 db                	test   %ebx,%ebx
  80acf8:	75 17                	jne    80ad11 <netconn_disconnect+0x25>
  80acfa:	83 ec 04             	sub    $0x4,%esp
  80acfd:	68 f0 28 81 00       	push   $0x8128f0
  80ad02:	68 e2 00 00 00       	push   $0xe2
  80ad07:	68 5a 29 81 00       	push   $0x81295a
  80ad0c:	e8 7d 36 00 00       	call   80e38e <_panic>

  msg.function = do_disconnect;
  80ad11:	c7 45 e4 b6 bd 80 00 	movl   $0x80bdb6,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad18:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80ad1b:	83 ec 0c             	sub    $0xc,%esp
  80ad1e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad21:	50                   	push   %eax
  80ad22:	e8 1e 76 ff ff       	call   802345 <tcpip_apimsg>
  return conn->err;
  80ad27:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ad2b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad2e:	c9                   	leave  
  80ad2f:	c3                   	ret    

0080ad30 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80ad30:	55                   	push   %ebp
  80ad31:	89 e5                	mov    %esp,%ebp
  80ad33:	53                   	push   %ebx
  80ad34:	83 ec 24             	sub    $0x24,%esp
  80ad37:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad3a:	85 db                	test   %ebx,%ebx
  80ad3c:	75 17                	jne    80ad55 <netconn_listen_with_backlog+0x25>
  80ad3e:	83 ec 04             	sub    $0x4,%esp
  80ad41:	68 4d 2a 81 00       	push   $0x812a4d
  80ad46:	68 fa 00 00 00       	push   $0xfa
  80ad4b:	68 5a 29 81 00       	push   $0x81295a
  80ad50:	e8 39 36 00 00       	call   80e38e <_panic>

  msg.function = do_listen;
  80ad55:	c7 45 e4 f1 bd 80 00 	movl   $0x80bdf1,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad5c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80ad5f:	83 ec 0c             	sub    $0xc,%esp
  80ad62:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad65:	50                   	push   %eax
  80ad66:	e8 da 75 ff ff       	call   802345 <tcpip_apimsg>
  return conn->err;
  80ad6b:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ad6f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad72:	c9                   	leave  
  80ad73:	c3                   	ret    

0080ad74 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80ad74:	55                   	push   %ebp
  80ad75:	89 e5                	mov    %esp,%ebp
  80ad77:	53                   	push   %ebx
  80ad78:	83 ec 14             	sub    $0x14,%esp
  80ad7b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80ad7e:	85 db                	test   %ebx,%ebx
  80ad80:	75 17                	jne    80ad99 <netconn_accept+0x25>
  80ad82:	83 ec 04             	sub    $0x4,%esp
  80ad85:	68 6a 2a 81 00       	push   $0x812a6a
  80ad8a:	68 10 01 00 00       	push   $0x110
  80ad8f:	68 5a 29 81 00       	push   $0x81295a
  80ad94:	e8 f5 35 00 00       	call   80e38e <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80ad99:	8b 43 18             	mov    0x18(%ebx),%eax
  80ad9c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ad9f:	75 17                	jne    80adb8 <netconn_accept+0x44>
  80ada1:	83 ec 04             	sub    $0x4,%esp
  80ada4:	68 14 29 81 00       	push   $0x812914
  80ada9:	68 11 01 00 00       	push   $0x111
  80adae:	68 5a 29 81 00       	push   $0x81295a
  80adb3:	e8 d6 35 00 00       	call   80e38e <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80adb8:	83 ec 04             	sub    $0x4,%esp
  80adbb:	6a 00                	push   $0x0
  80adbd:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80adc0:	52                   	push   %edx
  80adc1:	50                   	push   %eax
  80adc2:	e8 c2 f3 ff ff       	call   80a189 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80adc7:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80adca:	83 c4 10             	add    $0x10,%esp
  80adcd:	85 c0                	test   %eax,%eax
  80adcf:	74 0d                	je     80adde <netconn_accept+0x6a>
  80add1:	83 ec 04             	sub    $0x4,%esp
  80add4:	6a 00                	push   $0x0
  80add6:	6a 01                	push   $0x1
  80add8:	53                   	push   %ebx
  80add9:	ff d0                	call   *%eax
  80addb:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80adde:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ade1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ade4:	c9                   	leave  
  80ade5:	c3                   	ret    

0080ade6 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80ade6:	55                   	push   %ebp
  80ade7:	89 e5                	mov    %esp,%ebp
  80ade9:	53                   	push   %ebx
  80adea:	83 ec 24             	sub    $0x24,%esp
  80aded:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80adf0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80adf7:	85 db                	test   %ebx,%ebx
  80adf9:	75 17                	jne    80ae12 <netconn_recv+0x2c>
  80adfb:	83 ec 04             	sub    $0x4,%esp
  80adfe:	68 87 2a 81 00       	push   $0x812a87
  80ae03:	68 3a 01 00 00       	push   $0x13a
  80ae08:	68 5a 29 81 00       	push   $0x81295a
  80ae0d:	e8 7c 35 00 00       	call   80e38e <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80ae12:	8b 43 14             	mov    0x14(%ebx),%eax
  80ae15:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ae18:	75 0e                	jne    80ae28 <netconn_recv+0x42>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80ae1a:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80ae1e:	b8 00 00 00 00       	mov    $0x0,%eax
  80ae23:	e9 5b 01 00 00       	jmp    80af83 <netconn_recv+0x19d>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80ae28:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80ae2c:	0f 8c 3a 01 00 00    	jl     80af6c <netconn_recv+0x186>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80ae32:	83 3b 10             	cmpl   $0x10,(%ebx)
  80ae35:	0f 85 f0 00 00 00    	jne    80af2b <netconn_recv+0x145>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80ae3b:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80ae3f:	75 0e                	jne    80ae4f <netconn_recv+0x69>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80ae41:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80ae45:	b8 00 00 00 00       	mov    $0x0,%eax
  80ae4a:	e9 34 01 00 00       	jmp    80af83 <netconn_recv+0x19d>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80ae4f:	83 ec 0c             	sub    $0xc,%esp
  80ae52:	6a 06                	push   $0x6
  80ae54:	e8 45 95 ff ff       	call   80439e <memp_malloc>
  80ae59:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80ae5c:	83 c4 10             	add    $0x10,%esp
  80ae5f:	85 c0                	test   %eax,%eax
  80ae61:	75 09                	jne    80ae6c <netconn_recv+0x86>
      conn->err = ERR_MEM;
  80ae63:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80ae67:	e9 17 01 00 00       	jmp    80af83 <netconn_recv+0x19d>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80ae6c:	83 ec 04             	sub    $0x4,%esp
  80ae6f:	6a 00                	push   $0x0
  80ae71:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80ae74:	50                   	push   %eax
  80ae75:	ff 73 14             	pushl  0x14(%ebx)
  80ae78:	e8 0c f3 ff ff       	call   80a189 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80ae7d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ae80:	83 c4 10             	add    $0x10,%esp
  80ae83:	85 c0                	test   %eax,%eax
  80ae85:	0f 84 e8 00 00 00    	je     80af73 <netconn_recv+0x18d>
      len = p->tot_len;
  80ae8b:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80ae8f:	66 29 53 20          	sub    %dx,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80ae93:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80ae96:	85 c9                	test   %ecx,%ecx
  80ae98:	75 07                	jne    80aea1 <netconn_recv+0xbb>
  80ae9a:	eb 43                	jmp    80aedf <netconn_recv+0xf9>

    if (p != NULL) {
      len = p->tot_len;
      SYS_ARCH_DEC(conn->recv_avail, len);
    } else {
      len = 0;
  80ae9c:	ba 00 00 00 00       	mov    $0x0,%edx
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80aea1:	83 ec 04             	sub    $0x4,%esp
  80aea4:	0f b7 d2             	movzwl %dx,%edx
  80aea7:	52                   	push   %edx
  80aea8:	6a 01                	push   $0x1
  80aeaa:	53                   	push   %ebx
  80aeab:	ff d1                	call   *%ecx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80aead:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80aeb0:	83 c4 10             	add    $0x10,%esp
  80aeb3:	85 c0                	test   %eax,%eax
  80aeb5:	75 28                	jne    80aedf <netconn_recv+0xf9>
      memp_free(MEMP_NETBUF, buf);
  80aeb7:	83 ec 08             	sub    $0x8,%esp
  80aeba:	ff 75 e0             	pushl  -0x20(%ebp)
  80aebd:	6a 06                	push   $0x6
  80aebf:	e8 30 95 ff ff       	call   8043f4 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80aec4:	83 c4 10             	add    $0x10,%esp
        conn->err = ERR_CLSD;
      }
      return NULL;
  80aec7:	b8 00 00 00 00       	mov    $0x0,%eax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
      memp_free(MEMP_NETBUF, buf);
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80aecc:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80aed0:	0f 85 ad 00 00 00    	jne    80af83 <netconn_recv+0x19d>
        conn->err = ERR_CLSD;
  80aed6:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80aeda:	e9 a4 00 00 00       	jmp    80af83 <netconn_recv+0x19d>
      }
      return NULL;
    }

    buf->p = p;
  80aedf:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80aee2:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80aee4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80aee7:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80aeea:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80aeed:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80aef3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80aefa:	c7 45 e4 83 bf 80 00 	movl   $0x80bf83,-0x1c(%ebp)
    msg.msg.conn = conn;
  80af01:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80af04:	85 c0                	test   %eax,%eax
  80af06:	74 0c                	je     80af14 <netconn_recv+0x12e>
      msg.msg.msg.r.len = buf->p->tot_len;
  80af08:	8b 00                	mov    (%eax),%eax
  80af0a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80af0e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80af12:	eb 06                	jmp    80af1a <netconn_recv+0x134>
    } else {
      msg.msg.msg.r.len = 1;
  80af14:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80af1a:	83 ec 0c             	sub    $0xc,%esp
  80af1d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80af20:	50                   	push   %eax
  80af21:	e8 1f 74 ff ff       	call   802345 <tcpip_apimsg>
  80af26:	83 c4 10             	add    $0x10,%esp
  80af29:	eb 3c                	jmp    80af67 <netconn_recv+0x181>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80af2b:	83 ec 04             	sub    $0x4,%esp
  80af2e:	6a 00                	push   $0x0
  80af30:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80af33:	52                   	push   %edx
  80af34:	50                   	push   %eax
  80af35:	e8 4f f2 ff ff       	call   80a189 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80af3a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80af3d:	83 c4 10             	add    $0x10,%esp
  80af40:	85 c0                	test   %eax,%eax
  80af42:	74 23                	je     80af67 <netconn_recv+0x181>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80af44:	8b 10                	mov    (%eax),%edx
  80af46:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80af4a:	66 29 53 20          	sub    %dx,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80af4e:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80af51:	85 d2                	test   %edx,%edx
  80af53:	74 12                	je     80af67 <netconn_recv+0x181>
  80af55:	83 ec 04             	sub    $0x4,%esp
  80af58:	8b 00                	mov    (%eax),%eax
  80af5a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80af5e:	50                   	push   %eax
  80af5f:	6a 01                	push   $0x1
  80af61:	53                   	push   %ebx
  80af62:	ff d2                	call   *%edx
  80af64:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80af67:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80af6a:	eb 17                	jmp    80af83 <netconn_recv+0x19d>
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
    return NULL;
  80af6c:	b8 00 00 00 00       	mov    $0x0,%eax
  80af71:	eb 10                	jmp    80af83 <netconn_recv+0x19d>
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80af73:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80af76:	85 c9                	test   %ecx,%ecx
  80af78:	0f 85 1e ff ff ff    	jne    80ae9c <netconn_recv+0xb6>
  80af7e:	e9 34 ff ff ff       	jmp    80aeb7 <netconn_recv+0xd1>
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
}
  80af83:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80af86:	c9                   	leave  
  80af87:	c3                   	ret    

0080af88 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80af88:	55                   	push   %ebp
  80af89:	89 e5                	mov    %esp,%ebp
  80af8b:	53                   	push   %ebx
  80af8c:	83 ec 24             	sub    $0x24,%esp
  80af8f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80af92:	85 db                	test   %ebx,%ebx
  80af94:	75 17                	jne    80afad <netconn_send+0x25>
  80af96:	83 ec 04             	sub    $0x4,%esp
  80af99:	68 a2 2a 81 00       	push   $0x812aa2
  80af9e:	68 b9 01 00 00       	push   $0x1b9
  80afa3:	68 5a 29 81 00       	push   $0x81295a
  80afa8:	e8 e1 33 00 00       	call   80e38e <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80afad:	c7 45 e4 dd be 80 00 	movl   $0x80bedd,-0x1c(%ebp)
  msg.msg.conn = conn;
  80afb4:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80afb7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80afba:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80afbd:	83 ec 0c             	sub    $0xc,%esp
  80afc0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80afc3:	50                   	push   %eax
  80afc4:	e8 7c 73 ff ff       	call   802345 <tcpip_apimsg>
  return conn->err;
  80afc9:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80afcd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80afd0:	c9                   	leave  
  80afd1:	c3                   	ret    

0080afd2 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80afd2:	55                   	push   %ebp
  80afd3:	89 e5                	mov    %esp,%ebp
  80afd5:	83 ec 08             	sub    $0x8,%esp
  80afd8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80afdb:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80afde:	85 c0                	test   %eax,%eax
  80afe0:	74 1b                	je     80affd <netconn_sendto+0x2b>
    buf->addr = addr;
  80afe2:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80afe5:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80afe8:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80afec:	83 ec 08             	sub    $0x8,%esp
  80afef:	50                   	push   %eax
  80aff0:	ff 75 08             	pushl  0x8(%ebp)
  80aff3:	e8 90 ff ff ff       	call   80af88 <netconn_send>
  80aff8:	83 c4 10             	add    $0x10,%esp
  80affb:	eb 05                	jmp    80b002 <netconn_sendto+0x30>
  }
  return ERR_VAL;
  80affd:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80b002:	c9                   	leave  
  80b003:	c3                   	ret    

0080b004 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b004:	55                   	push   %ebp
  80b005:	89 e5                	mov    %esp,%ebp
  80b007:	53                   	push   %ebx
  80b008:	83 ec 24             	sub    $0x24,%esp
  80b00b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b00e:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b011:	85 db                	test   %ebx,%ebx
  80b013:	75 17                	jne    80b02c <netconn_write+0x28>
  80b015:	83 ec 04             	sub    $0x4,%esp
  80b018:	68 bd 2a 81 00       	push   $0x812abd
  80b01d:	68 d3 01 00 00       	push   $0x1d3
  80b022:	68 5a 29 81 00       	push   $0x81295a
  80b027:	e8 62 33 00 00       	call   80e38e <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b02c:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b02f:	74 17                	je     80b048 <netconn_write+0x44>
  80b031:	83 ec 04             	sub    $0x4,%esp
  80b034:	68 38 29 81 00       	push   $0x812938
  80b039:	68 d4 01 00 00       	push   $0x1d4
  80b03e:	68 5a 29 81 00       	push   $0x81295a
  80b043:	e8 46 33 00 00       	call   80e38e <_panic>

  msg.function = do_write;
  80b048:	c7 45 e4 c7 bf 80 00 	movl   $0x80bfc7,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b04f:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b052:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b055:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b058:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b05b:	8b 45 10             	mov    0x10(%ebp),%eax
  80b05e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b061:	83 ec 0c             	sub    $0xc,%esp
  80b064:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b067:	50                   	push   %eax
  80b068:	e8 d8 72 ff ff       	call   802345 <tcpip_apimsg>
  return conn->err;
  80b06d:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b071:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b074:	c9                   	leave  
  80b075:	c3                   	ret    

0080b076 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b076:	55                   	push   %ebp
  80b077:	89 e5                	mov    %esp,%ebp
  80b079:	53                   	push   %ebx
  80b07a:	83 ec 24             	sub    $0x24,%esp
  80b07d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b080:	85 db                	test   %ebx,%ebx
  80b082:	75 17                	jne    80b09b <netconn_close+0x25>
  80b084:	83 ec 04             	sub    $0x4,%esp
  80b087:	68 d9 2a 81 00       	push   $0x812ad9
  80b08c:	68 ed 01 00 00       	push   $0x1ed
  80b091:	68 5a 29 81 00       	push   $0x81295a
  80b096:	e8 f3 32 00 00       	call   80e38e <_panic>

  msg.function = do_close;
  80b09b:	c7 45 e4 db c0 80 00 	movl   $0x80c0db,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b0a2:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b0a5:	83 ec 0c             	sub    $0xc,%esp
  80b0a8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b0ab:	50                   	push   %eax
  80b0ac:	e8 94 72 ff ff       	call   802345 <tcpip_apimsg>
  return conn->err;
  80b0b1:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b0b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b0b8:	c9                   	leave  
  80b0b9:	c3                   	ret    

0080b0ba <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b0ba:	55                   	push   %ebp
  80b0bb:	89 e5                	mov    %esp,%ebp
  80b0bd:	56                   	push   %esi
  80b0be:	53                   	push   %ebx
  80b0bf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b0c2:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b0c5:	8b 75 10             	mov    0x10(%ebp),%esi
  80b0c8:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b0cb:	85 c0                	test   %eax,%eax
  80b0cd:	75 17                	jne    80b0e6 <recv_tcp+0x2c>
  80b0cf:	83 ec 04             	sub    $0x4,%esp
  80b0d2:	68 f8 2a 81 00       	push   $0x812af8
  80b0d7:	68 c1 00 00 00       	push   $0xc1
  80b0dc:	68 42 2c 81 00       	push   $0x812c42
  80b0e1:	e8 a8 32 00 00       	call   80e38e <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b0e6:	85 db                	test   %ebx,%ebx
  80b0e8:	75 17                	jne    80b101 <recv_tcp+0x47>
  80b0ea:	83 ec 04             	sub    $0x4,%esp
  80b0ed:	68 1c 2b 81 00       	push   $0x812b1c
  80b0f2:	68 c2 00 00 00       	push   $0xc2
  80b0f7:	68 42 2c 81 00       	push   $0x812c42
  80b0fc:	e8 8d 32 00 00       	call   80e38e <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b101:	3b 43 08             	cmp    0x8(%ebx),%eax
  80b104:	74 17                	je     80b11d <recv_tcp+0x63>
  80b106:	83 ec 04             	sub    $0x4,%esp
  80b109:	68 59 2c 81 00       	push   $0x812c59
  80b10e:	68 c4 00 00 00       	push   $0xc4
  80b113:	68 42 2c 81 00       	push   $0x812c42
  80b118:	e8 71 32 00 00       	call   80e38e <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b11d:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b121:	74 44                	je     80b167 <recv_tcp+0xad>
    return ERR_VAL;
  }

  conn->err = err;
  80b123:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80b126:	85 f6                	test   %esi,%esi
  80b128:	74 0a                	je     80b134 <recv_tcp+0x7a>
    len = p->tot_len;
  80b12a:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b12e:	66 01 43 20          	add    %ax,0x20(%ebx)
  80b132:	eb 05                	jmp    80b139 <recv_tcp+0x7f>
  } else {
    len = 0;
  80b134:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b139:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b13c:	85 d2                	test   %edx,%edx
  80b13e:	74 0f                	je     80b14f <recv_tcp+0x95>
  80b140:	83 ec 04             	sub    $0x4,%esp
  80b143:	0f b7 c0             	movzwl %ax,%eax
  80b146:	50                   	push   %eax
  80b147:	6a 00                	push   $0x0
  80b149:	53                   	push   %ebx
  80b14a:	ff d2                	call   *%edx
  80b14c:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b14f:	83 ec 08             	sub    $0x8,%esp
  80b152:	56                   	push   %esi
  80b153:	ff 73 14             	pushl  0x14(%ebx)
  80b156:	e8 3b ef ff ff       	call   80a096 <sys_mbox_trypost>
  80b15b:	83 c4 10             	add    $0x10,%esp
  80b15e:	84 c0                	test   %al,%al
  80b160:	0f 95 c0             	setne  %al
  80b163:	f7 d8                	neg    %eax
  80b165:	eb 05                	jmp    80b16c <recv_tcp+0xb2>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
    return ERR_VAL;
  80b167:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b16c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b16f:	5b                   	pop    %ebx
  80b170:	5e                   	pop    %esi
  80b171:	5d                   	pop    %ebp
  80b172:	c3                   	ret    

0080b173 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80b173:	55                   	push   %ebp
  80b174:	89 e5                	mov    %esp,%ebp
  80b176:	57                   	push   %edi
  80b177:	56                   	push   %esi
  80b178:	53                   	push   %ebx
  80b179:	83 ec 1c             	sub    $0x1c,%esp
  80b17c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b17f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b182:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b185:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b188:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b18b:	85 c0                	test   %eax,%eax
  80b18d:	75 17                	jne    80b1a6 <recv_udp+0x33>
  80b18f:	83 ec 04             	sub    $0x4,%esp
  80b192:	68 3c 2b 81 00       	push   $0x812b3c
  80b197:	68 8e 00 00 00       	push   $0x8e
  80b19c:	68 42 2c 81 00       	push   $0x812c42
  80b1a1:	e8 e8 31 00 00       	call   80e38e <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b1a6:	85 db                	test   %ebx,%ebx
  80b1a8:	75 17                	jne    80b1c1 <recv_udp+0x4e>
  80b1aa:	83 ec 04             	sub    $0x4,%esp
  80b1ad:	68 60 2b 81 00       	push   $0x812b60
  80b1b2:	68 8f 00 00 00       	push   $0x8f
  80b1b7:	68 42 2c 81 00       	push   $0x812c42
  80b1bc:	e8 cd 31 00 00       	call   80e38e <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b1c1:	3b 43 08             	cmp    0x8(%ebx),%eax
  80b1c4:	74 17                	je     80b1dd <recv_udp+0x6a>
  80b1c6:	83 ec 04             	sub    $0x4,%esp
  80b1c9:	68 77 2c 81 00       	push   $0x812c77
  80b1ce:	68 91 00 00 00       	push   $0x91
  80b1d3:	68 42 2c 81 00       	push   $0x812c42
  80b1d8:	e8 b1 31 00 00       	call   80e38e <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b1dd:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b1e1:	75 0e                	jne    80b1f1 <recv_udp+0x7e>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80b1e3:	83 ec 0c             	sub    $0xc,%esp
  80b1e6:	57                   	push   %edi
  80b1e7:	e8 7b 95 ff ff       	call   804767 <pbuf_free>
    return;
  80b1ec:	83 c4 10             	add    $0x10,%esp
  80b1ef:	eb 72                	jmp    80b263 <recv_udp+0xf0>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80b1f1:	83 ec 0c             	sub    $0xc,%esp
  80b1f4:	6a 06                	push   $0x6
  80b1f6:	e8 a3 91 ff ff       	call   80439e <memp_malloc>
  80b1fb:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b1fd:	83 c4 10             	add    $0x10,%esp
  80b200:	85 c0                	test   %eax,%eax
  80b202:	75 0e                	jne    80b212 <recv_udp+0x9f>
    pbuf_free(p);
  80b204:	83 ec 0c             	sub    $0xc,%esp
  80b207:	57                   	push   %edi
  80b208:	e8 5a 95 ff ff       	call   804767 <pbuf_free>
    return;
  80b20d:	83 c4 10             	add    $0x10,%esp
  80b210:	eb 51                	jmp    80b263 <recv_udp+0xf0>
  } else {
    buf->p = p;
  80b212:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b214:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b217:	8b 45 14             	mov    0x14(%ebp),%eax
  80b21a:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b21d:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b221:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b225:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b229:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b22d:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b230:	85 c0                	test   %eax,%eax
  80b232:	74 10                	je     80b244 <recv_udp+0xd1>
  80b234:	83 ec 04             	sub    $0x4,%esp
  80b237:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b23b:	52                   	push   %edx
  80b23c:	6a 00                	push   $0x0
  80b23e:	53                   	push   %ebx
  80b23f:	ff d0                	call   *%eax
  80b241:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b244:	83 ec 08             	sub    $0x8,%esp
  80b247:	56                   	push   %esi
  80b248:	ff 73 14             	pushl  0x14(%ebx)
  80b24b:	e8 46 ee ff ff       	call   80a096 <sys_mbox_trypost>
  80b250:	83 c4 10             	add    $0x10,%esp
  80b253:	84 c0                	test   %al,%al
  80b255:	74 0c                	je     80b263 <recv_udp+0xf0>
    netbuf_delete(buf);
  80b257:	83 ec 0c             	sub    $0xc,%esp
  80b25a:	56                   	push   %esi
  80b25b:	e8 d5 71 ff ff       	call   802435 <netbuf_delete>
    return;
  80b260:	83 c4 10             	add    $0x10,%esp
  }
}
  80b263:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b266:	5b                   	pop    %ebx
  80b267:	5e                   	pop    %esi
  80b268:	5f                   	pop    %edi
  80b269:	5d                   	pop    %ebp
  80b26a:	c3                   	ret    

0080b26b <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80b26b:	55                   	push   %ebp
  80b26c:	89 e5                	mov    %esp,%ebp
  80b26e:	57                   	push   %edi
  80b26f:	56                   	push   %esi
  80b270:	53                   	push   %ebx
  80b271:	83 ec 0c             	sub    $0xc,%esp
  80b274:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b277:	85 db                	test   %ebx,%ebx
  80b279:	0f 84 c8 00 00 00    	je     80b347 <recv_raw+0xdc>
  80b27f:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b283:	0f 84 be 00 00 00    	je     80b347 <recv_raw+0xdc>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b289:	83 ec 04             	sub    $0x4,%esp
  80b28c:	6a 00                	push   $0x0
  80b28e:	8b 45 10             	mov    0x10(%ebp),%eax
  80b291:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b295:	50                   	push   %eax
  80b296:	6a 03                	push   $0x3
  80b298:	e8 90 95 ff ff       	call   80482d <pbuf_alloc>
  80b29d:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b29f:	83 c4 10             	add    $0x10,%esp
  80b2a2:	85 c0                	test   %eax,%eax
  80b2a4:	0f 84 9d 00 00 00    	je     80b347 <recv_raw+0xdc>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b2aa:	83 ec 08             	sub    $0x8,%esp
  80b2ad:	ff 75 10             	pushl  0x10(%ebp)
  80b2b0:	50                   	push   %eax
  80b2b1:	e8 75 9a ff ff       	call   804d2b <pbuf_copy>
  80b2b6:	83 c4 10             	add    $0x10,%esp
  80b2b9:	84 c0                	test   %al,%al
  80b2bb:	74 75                	je     80b332 <recv_raw+0xc7>
        pbuf_free(q);
  80b2bd:	83 ec 0c             	sub    $0xc,%esp
  80b2c0:	56                   	push   %esi
  80b2c1:	e8 a1 94 ff ff       	call   804767 <pbuf_free>
  80b2c6:	83 c4 10             	add    $0x10,%esp
  80b2c9:	eb 7c                	jmp    80b347 <recv_raw+0xdc>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80b2cb:	83 ec 0c             	sub    $0xc,%esp
  80b2ce:	56                   	push   %esi
  80b2cf:	e8 93 94 ff ff       	call   804767 <pbuf_free>
        return 0;
  80b2d4:	83 c4 10             	add    $0x10,%esp
  80b2d7:	eb 6e                	jmp    80b347 <recv_raw+0xdc>
      }

      buf->p = q;
  80b2d9:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b2db:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b2de:	8b 46 04             	mov    0x4(%esi),%eax
  80b2e1:	83 c0 0c             	add    $0xc,%eax
  80b2e4:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b2e7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b2ea:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b2ee:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b2f2:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b2f6:	66 01 43 20          	add    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b2fa:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b2fd:	85 c0                	test   %eax,%eax
  80b2ff:	74 10                	je     80b311 <recv_raw+0xa6>
  80b301:	83 ec 04             	sub    $0x4,%esp
  80b304:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b308:	52                   	push   %edx
  80b309:	6a 00                	push   $0x0
  80b30b:	53                   	push   %ebx
  80b30c:	ff d0                	call   *%eax
  80b30e:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b311:	83 ec 08             	sub    $0x8,%esp
  80b314:	57                   	push   %edi
  80b315:	ff 73 14             	pushl  0x14(%ebx)
  80b318:	e8 79 ed ff ff       	call   80a096 <sys_mbox_trypost>
  80b31d:	83 c4 10             	add    $0x10,%esp
  80b320:	84 c0                	test   %al,%al
  80b322:	74 23                	je     80b347 <recv_raw+0xdc>
        netbuf_delete(buf);
  80b324:	83 ec 0c             	sub    $0xc,%esp
  80b327:	57                   	push   %edi
  80b328:	e8 08 71 ff ff       	call   802435 <netbuf_delete>
  80b32d:	83 c4 10             	add    $0x10,%esp
  80b330:	eb 15                	jmp    80b347 <recv_raw+0xdc>
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80b332:	83 ec 0c             	sub    $0xc,%esp
  80b335:	6a 06                	push   $0x6
  80b337:	e8 62 90 ff ff       	call   80439e <memp_malloc>
  80b33c:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b33e:	83 c4 10             	add    $0x10,%esp
  80b341:	85 c0                	test   %eax,%eax
  80b343:	75 94                	jne    80b2d9 <recv_raw+0x6e>
  80b345:	eb 84                	jmp    80b2cb <recv_raw+0x60>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80b347:	b8 00 00 00 00       	mov    $0x0,%eax
  80b34c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b34f:	5b                   	pop    %ebx
  80b350:	5e                   	pop    %esi
  80b351:	5f                   	pop    %edi
  80b352:	5d                   	pop    %ebp
  80b353:	c3                   	ret    

0080b354 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b354:	55                   	push   %ebp
  80b355:	89 e5                	mov    %esp,%ebp
  80b357:	53                   	push   %ebx
  80b358:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b35b:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b35e:	50                   	push   %eax
  80b35f:	53                   	push   %ebx
  80b360:	e8 02 a4 ff ff       	call   805767 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b365:	83 c4 08             	add    $0x8,%esp
  80b368:	68 ba b0 80 00       	push   $0x80b0ba
  80b36d:	53                   	push   %ebx
  80b36e:	e8 02 a4 ff ff       	call   805775 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b373:	83 c4 08             	add    $0x8,%esp
  80b376:	68 f2 b7 80 00       	push   $0x80b7f2
  80b37b:	53                   	push   %ebx
  80b37c:	e8 05 a4 ff ff       	call   805786 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b381:	83 c4 0c             	add    $0xc,%esp
  80b384:	6a 04                	push   $0x4
  80b386:	68 ae b7 80 00       	push   $0x80b7ae
  80b38b:	53                   	push   %ebx
  80b38c:	e8 25 a4 ff ff       	call   8057b6 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b391:	83 c4 08             	add    $0x8,%esp
  80b394:	68 f1 b3 80 00       	push   $0x80b3f1
  80b399:	53                   	push   %ebx
  80b39a:	e8 f8 a3 ff ff       	call   805797 <tcp_err>
}
  80b39f:	83 c4 10             	add    $0x10,%esp
  80b3a2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b3a5:	c9                   	leave  
  80b3a6:	c3                   	ret    

0080b3a7 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b3a7:	55                   	push   %ebp
  80b3a8:	89 e5                	mov    %esp,%ebp
  80b3aa:	53                   	push   %ebx
  80b3ab:	83 ec 04             	sub    $0x4,%esp
  80b3ae:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b3b1:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b3b4:	85 db                	test   %ebx,%ebx
  80b3b6:	74 2f                	je     80b3e7 <do_connected+0x40>
    return ERR_VAL;
  }

  conn->err = err;
  80b3b8:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b3bb:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b3be:	75 0b                	jne    80b3cb <do_connected+0x24>
  80b3c0:	84 c0                	test   %al,%al
  80b3c2:	75 07                	jne    80b3cb <do_connected+0x24>
    setup_tcp(conn);
  80b3c4:	89 d8                	mov    %ebx,%eax
  80b3c6:	e8 89 ff ff ff       	call   80b354 <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80b3cb:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b3d2:	83 ec 0c             	sub    $0xc,%esp
  80b3d5:	ff 73 10             	pushl  0x10(%ebx)
  80b3d8:	e8 3d eb ff ff       	call   809f1a <sys_sem_signal>
  return ERR_OK;
  80b3dd:	83 c4 10             	add    $0x10,%esp
  80b3e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3e5:	eb 05                	jmp    80b3ec <do_connected+0x45>
  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
    return ERR_VAL;
  80b3e7:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  sys_sem_signal(conn->op_completed);
  return ERR_OK;
}
  80b3ec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b3ef:	c9                   	leave  
  80b3f0:	c3                   	ret    

0080b3f1 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80b3f1:	55                   	push   %ebp
  80b3f2:	89 e5                	mov    %esp,%ebp
  80b3f4:	53                   	push   %ebx
  80b3f5:	83 ec 04             	sub    $0x4,%esp
  80b3f8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b3fb:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b3fe:	85 db                	test   %ebx,%ebx
  80b400:	75 17                	jne    80b419 <err_tcp+0x28>
  80b402:	83 ec 04             	sub    $0x4,%esp
  80b405:	68 95 2c 81 00       	push   $0x812c95
  80b40a:	68 22 01 00 00       	push   $0x122
  80b40f:	68 42 2c 81 00       	push   $0x812c42
  80b414:	e8 75 2f 00 00       	call   80e38e <_panic>

  conn->pcb.tcp = NULL;
  80b419:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80b420:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b423:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b427:	74 24                	je     80b44d <err_tcp+0x5c>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b429:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b42c:	85 c0                	test   %eax,%eax
  80b42e:	74 0d                	je     80b43d <err_tcp+0x4c>
  80b430:	83 ec 04             	sub    $0x4,%esp
  80b433:	6a 00                	push   $0x0
  80b435:	6a 00                	push   $0x0
  80b437:	53                   	push   %ebx
  80b438:	ff d0                	call   *%eax
  80b43a:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b43d:	83 ec 08             	sub    $0x8,%esp
  80b440:	6a 00                	push   $0x0
  80b442:	ff 73 14             	pushl  0x14(%ebx)
  80b445:	e8 0f ed ff ff       	call   80a159 <sys_mbox_post>
  80b44a:	83 c4 10             	add    $0x10,%esp
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b44d:	8b 43 10             	mov    0x10(%ebx),%eax
  80b450:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b453:	74 19                	je     80b46e <err_tcp+0x7d>
  80b455:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b459:	75 13                	jne    80b46e <err_tcp+0x7d>
    conn->state = NETCONN_NONE;
  80b45b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b462:	83 ec 0c             	sub    $0xc,%esp
  80b465:	50                   	push   %eax
  80b466:	e8 af ea ff ff       	call   809f1a <sys_sem_signal>
  80b46b:	83 c4 10             	add    $0x10,%esp
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b46e:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b472:	74 24                	je     80b498 <err_tcp+0xa7>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b474:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b477:	85 c0                	test   %eax,%eax
  80b479:	74 0d                	je     80b488 <err_tcp+0x97>
  80b47b:	83 ec 04             	sub    $0x4,%esp
  80b47e:	6a 00                	push   $0x0
  80b480:	6a 00                	push   $0x0
  80b482:	53                   	push   %ebx
  80b483:	ff d0                	call   *%eax
  80b485:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b488:	83 ec 08             	sub    $0x8,%esp
  80b48b:	6a 00                	push   $0x0
  80b48d:	ff 73 18             	pushl  0x18(%ebx)
  80b490:	e8 c4 ec ff ff       	call   80a159 <sys_mbox_post>
  80b495:	83 c4 10             	add    $0x10,%esp
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b498:	8b 43 04             	mov    0x4(%ebx),%eax
  80b49b:	83 f8 01             	cmp    $0x1,%eax
  80b49e:	74 05                	je     80b4a5 <err_tcp+0xb4>
  80b4a0:	83 f8 04             	cmp    $0x4,%eax
  80b4a3:	75 15                	jne    80b4ba <err_tcp+0xc9>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80b4a5:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80b4ac:	83 ec 0c             	sub    $0xc,%esp
  80b4af:	ff 73 10             	pushl  0x10(%ebx)
  80b4b2:	e8 63 ea ff ff       	call   809f1a <sys_sem_signal>
  80b4b7:	83 c4 10             	add    $0x10,%esp
  }
}
  80b4ba:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b4bd:	c9                   	leave  
  80b4be:	c3                   	ret    

0080b4bf <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b4bf:	55                   	push   %ebp
  80b4c0:	89 e5                	mov    %esp,%ebp
  80b4c2:	57                   	push   %edi
  80b4c3:	56                   	push   %esi
  80b4c4:	53                   	push   %ebx
  80b4c5:	83 ec 0c             	sub    $0xc,%esp
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b4c8:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b4cc:	74 17                	je     80b4e5 <do_writemore+0x26>
  80b4ce:	83 ec 04             	sub    $0x4,%esp
  80b4d1:	68 a2 2c 81 00       	push   $0x812ca2
  80b4d6:	68 b8 03 00 00       	push   $0x3b8
  80b4db:	68 42 2c 81 00       	push   $0x812c42
  80b4e0:	e8 a9 2e 00 00       	call   80e38e <_panic>
  80b4e5:	89 c6                	mov    %eax,%esi

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b4e7:	8b 50 24             	mov    0x24(%eax),%edx
  80b4ea:	8b 78 28             	mov    0x28(%eax),%edi
  80b4ed:	89 f9                	mov    %edi,%ecx
  80b4ef:	03 4a 04             	add    0x4(%edx),%ecx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b4f2:	8b 42 08             	mov    0x8(%edx),%eax
  80b4f5:	89 c3                	mov    %eax,%ebx
  80b4f7:	29 fb                	sub    %edi,%ebx
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b4f9:	29 f8                	sub    %edi,%eax
  80b4fb:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  80b501:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80b506:	0f 4f c3             	cmovg  %ebx,%eax
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b509:	8b 7e 08             	mov    0x8(%esi),%edi
  80b50c:	0f b7 5f 6e          	movzwl 0x6e(%edi),%ebx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b510:	66 39 d8             	cmp    %bx,%ax
  80b513:	0f 46 d8             	cmovbe %eax,%ebx
  80b516:	0f b7 db             	movzwl %bx,%ebx
  80b519:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  80b51d:	50                   	push   %eax
  80b51e:	53                   	push   %ebx
  80b51f:	51                   	push   %ecx
  80b520:	57                   	push   %edi
  80b521:	e8 c3 c9 ff ff       	call   807ee9 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b526:	89 da                	mov    %ebx,%edx
  80b528:	03 56 28             	add    0x28(%esi),%edx
  80b52b:	8b 4e 24             	mov    0x24(%esi),%ecx
  80b52e:	83 c4 10             	add    $0x10,%esp
  80b531:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b534:	7e 17                	jle    80b54d <do_writemore+0x8e>
  80b536:	83 ec 04             	sub    $0x4,%esp
  80b539:	68 bf 2c 81 00       	push   $0x812cbf
  80b53e:	68 cd 03 00 00       	push   $0x3cd
  80b543:	68 42 2c 81 00       	push   $0x812c42
  80b548:	e8 41 2e 00 00       	call   80e38e <_panic>
  if (err == ERR_OK) {
  80b54d:	84 c0                	test   %al,%al
  80b54f:	75 6e                	jne    80b5bf <do_writemore+0x100>
    conn->write_offset += len;
  80b551:	89 56 28             	mov    %edx,0x28(%esi)
do_writemore(struct netconn *conn)
{
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  80b554:	bf 00 00 00 00       	mov    $0x0,%edi

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80b559:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b55c:	75 13                	jne    80b571 <do_writemore+0xb2>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80b55e:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
      conn->write_offset = 0;
  80b565:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
      /* everything was written */
      write_finished = 1;
  80b56c:	bf 01 00 00 00       	mov    $0x1,%edi
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80b571:	8b 46 08             	mov    0x8(%esi),%eax
  80b574:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80b578:	74 12                	je     80b58c <do_writemore+0xcd>
  80b57a:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80b57e:	75 0c                	jne    80b58c <do_writemore+0xcd>
  80b580:	8b 50 74             	mov    0x74(%eax),%edx
  80b583:	85 d2                	test   %edx,%edx
  80b585:	74 6e                	je     80b5f5 <do_writemore+0x136>
  80b587:	83 3a 00             	cmpl   $0x0,(%edx)
  80b58a:	74 69                	je     80b5f5 <do_writemore+0x136>
  80b58c:	83 ec 0c             	sub    $0xc,%esp
  80b58f:	50                   	push   %eax
  80b590:	e8 a7 c9 ff ff       	call   807f3c <tcp_output>
    conn->err = err;
  80b595:	88 46 0c             	mov    %al,0xc(%esi)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80b598:	83 c4 10             	add    $0x10,%esp
  80b59b:	84 c0                	test   %al,%al
  80b59d:	75 39                	jne    80b5d8 <do_writemore+0x119>
  80b59f:	8b 46 08             	mov    0x8(%esi),%eax
  80b5a2:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b5a8:	77 2e                	ja     80b5d8 <do_writemore+0x119>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80b5aa:	8b 46 2c             	mov    0x2c(%esi),%eax
  80b5ad:	85 c0                	test   %eax,%eax
  80b5af:	74 27                	je     80b5d8 <do_writemore+0x119>
  80b5b1:	83 ec 04             	sub    $0x4,%esp
  80b5b4:	53                   	push   %ebx
  80b5b5:	6a 03                	push   $0x3
  80b5b7:	56                   	push   %esi
  80b5b8:	ff d0                	call   *%eax
  80b5ba:	83 c4 10             	add    $0x10,%esp
  80b5bd:	eb 19                	jmp    80b5d8 <do_writemore+0x119>
    }
  } else if (err == ERR_MEM) {
  80b5bf:	3c ff                	cmp    $0xff,%al
  80b5c1:	75 10                	jne    80b5d3 <do_writemore+0x114>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80b5c3:	83 ec 0c             	sub    $0xc,%esp
  80b5c6:	ff 76 08             	pushl  0x8(%esi)
  80b5c9:	e8 6e c9 ff ff       	call   807f3c <tcp_output>
  80b5ce:	83 c4 10             	add    $0x10,%esp
  80b5d1:	eb 28                	jmp    80b5fb <do_writemore+0x13c>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80b5d3:	88 46 0c             	mov    %al,0xc(%esi)
  80b5d6:	eb 06                	jmp    80b5de <do_writemore+0x11f>
    write_finished = 1;
  }

  if (write_finished) {
  80b5d8:	89 f8                	mov    %edi,%eax
  80b5da:	84 c0                	test   %al,%al
  80b5dc:	74 1d                	je     80b5fb <do_writemore+0x13c>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80b5de:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80b5e5:	83 ec 0c             	sub    $0xc,%esp
  80b5e8:	ff 76 10             	pushl  0x10(%esi)
  80b5eb:	e8 2a e9 ff ff       	call   809f1a <sys_sem_signal>
  80b5f0:	83 c4 10             	add    $0x10,%esp
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
  80b5f3:	eb 06                	jmp    80b5fb <do_writemore+0x13c>
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80b5f5:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b5f9:	eb a4                	jmp    80b59f <do_writemore+0xe0>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80b5fb:	b8 00 00 00 00       	mov    $0x0,%eax
  80b600:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b603:	5b                   	pop    %ebx
  80b604:	5e                   	pop    %esi
  80b605:	5f                   	pop    %edi
  80b606:	5d                   	pop    %ebp
  80b607:	c3                   	ret    

0080b608 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80b608:	55                   	push   %ebp
  80b609:	89 e5                	mov    %esp,%ebp
  80b60b:	53                   	push   %ebx
  80b60c:	83 ec 04             	sub    $0x4,%esp
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b60f:	85 c0                	test   %eax,%eax
  80b611:	75 17                	jne    80b62a <do_close_internal+0x22>
  80b613:	83 ec 04             	sub    $0x4,%esp
  80b616:	68 b0 2a 81 00       	push   $0x812ab0
  80b61b:	68 53 02 00 00       	push   $0x253
  80b620:	68 42 2c 81 00       	push   $0x812c42
  80b625:	e8 64 2d 00 00       	call   80e38e <_panic>
  80b62a:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b62c:	83 38 10             	cmpl   $0x10,(%eax)
  80b62f:	74 17                	je     80b648 <do_close_internal+0x40>
  80b631:	83 ec 04             	sub    $0x4,%esp
  80b634:	68 dd 2c 81 00       	push   $0x812cdd
  80b639:	68 54 02 00 00       	push   $0x254
  80b63e:	68 42 2c 81 00       	push   $0x812c42
  80b643:	e8 46 2d 00 00       	call   80e38e <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b648:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80b64c:	74 17                	je     80b665 <do_close_internal+0x5d>
  80b64e:	83 ec 04             	sub    $0x4,%esp
  80b651:	68 80 2b 81 00       	push   $0x812b80
  80b656:	68 55 02 00 00       	push   $0x255
  80b65b:	68 42 2c 81 00       	push   $0x812c42
  80b660:	e8 29 2d 00 00       	call   80e38e <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b665:	8b 40 08             	mov    0x8(%eax),%eax
  80b668:	85 c0                	test   %eax,%eax
  80b66a:	75 17                	jne    80b683 <do_close_internal+0x7b>
  80b66c:	83 ec 04             	sub    $0x4,%esp
  80b66f:	68 fb 2c 81 00       	push   $0x812cfb
  80b674:	68 56 02 00 00       	push   $0x256
  80b679:	68 42 2c 81 00       	push   $0x812c42
  80b67e:	e8 0b 2d 00 00       	call   80e38e <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80b683:	83 ec 08             	sub    $0x8,%esp
  80b686:	6a 00                	push   $0x0
  80b688:	50                   	push   %eax
  80b689:	e8 d9 a0 ff ff       	call   805767 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80b68e:	8b 43 08             	mov    0x8(%ebx),%eax
  80b691:	83 c4 10             	add    $0x10,%esp
  80b694:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b698:	75 10                	jne    80b6aa <do_close_internal+0xa2>
    tcp_accept(conn->pcb.tcp, NULL);
  80b69a:	83 ec 08             	sub    $0x8,%esp
  80b69d:	6a 00                	push   $0x0
  80b69f:	50                   	push   %eax
  80b6a0:	e8 03 a1 ff ff       	call   8057a8 <tcp_accept>
  80b6a5:	83 c4 10             	add    $0x10,%esp
  80b6a8:	eb 44                	jmp    80b6ee <do_close_internal+0xe6>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80b6aa:	83 ec 08             	sub    $0x8,%esp
  80b6ad:	6a 00                	push   $0x0
  80b6af:	50                   	push   %eax
  80b6b0:	e8 c0 a0 ff ff       	call   805775 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80b6b5:	83 c4 08             	add    $0x8,%esp
  80b6b8:	6a 00                	push   $0x0
  80b6ba:	ff 73 08             	pushl  0x8(%ebx)
  80b6bd:	e8 e6 a0 ff ff       	call   8057a8 <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80b6c2:	83 c4 08             	add    $0x8,%esp
  80b6c5:	6a 00                	push   $0x0
  80b6c7:	ff 73 08             	pushl  0x8(%ebx)
  80b6ca:	e8 b7 a0 ff ff       	call   805786 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80b6cf:	83 c4 0c             	add    $0xc,%esp
  80b6d2:	6a 04                	push   $0x4
  80b6d4:	6a 00                	push   $0x0
  80b6d6:	ff 73 08             	pushl  0x8(%ebx)
  80b6d9:	e8 d8 a0 ff ff       	call   8057b6 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80b6de:	83 c4 08             	add    $0x8,%esp
  80b6e1:	6a 00                	push   $0x0
  80b6e3:	ff 73 08             	pushl  0x8(%ebx)
  80b6e6:	e8 ac a0 ff ff       	call   805797 <tcp_err>
  80b6eb:	83 c4 10             	add    $0x10,%esp
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80b6ee:	83 ec 0c             	sub    $0xc,%esp
  80b6f1:	ff 73 08             	pushl  0x8(%ebx)
  80b6f4:	e8 7b a2 ff ff       	call   805974 <tcp_close>
  if (err == ERR_OK) {
  80b6f9:	83 c4 10             	add    $0x10,%esp
  80b6fc:	84 c0                	test   %al,%al
  80b6fe:	75 4a                	jne    80b74a <do_close_internal+0x142>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80b700:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80b707:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80b70e:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b712:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b715:	85 c0                	test   %eax,%eax
  80b717:	74 21                	je     80b73a <do_close_internal+0x132>
  80b719:	83 ec 04             	sub    $0x4,%esp
  80b71c:	6a 00                	push   $0x0
  80b71e:	6a 00                	push   $0x0
  80b720:	53                   	push   %ebx
  80b721:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80b723:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b726:	83 c4 10             	add    $0x10,%esp
  80b729:	85 c0                	test   %eax,%eax
  80b72b:	74 0d                	je     80b73a <do_close_internal+0x132>
  80b72d:	83 ec 04             	sub    $0x4,%esp
  80b730:	6a 00                	push   $0x0
  80b732:	6a 02                	push   $0x2
  80b734:	53                   	push   %ebx
  80b735:	ff d0                	call   *%eax
  80b737:	83 c4 10             	add    $0x10,%esp
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80b73a:	83 ec 0c             	sub    $0xc,%esp
  80b73d:	ff 73 10             	pushl  0x10(%ebx)
  80b740:	e8 d5 e7 ff ff       	call   809f1a <sys_sem_signal>
  80b745:	83 c4 10             	add    $0x10,%esp
  80b748:	eb 5f                	jmp    80b7a9 <do_close_internal+0x1a1>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b74a:	8b 43 08             	mov    0x8(%ebx),%eax
  80b74d:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b751:	75 17                	jne    80b76a <do_close_internal+0x162>
  80b753:	83 ec 04             	sub    $0x4,%esp
  80b756:	68 a4 2b 81 00       	push   $0x812ba4
  80b75b:	68 75 02 00 00       	push   $0x275
  80b760:	68 42 2c 81 00       	push   $0x812c42
  80b765:	e8 24 2c 00 00       	call   80e38e <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80b76a:	83 ec 08             	sub    $0x8,%esp
  80b76d:	68 f2 b7 80 00       	push   $0x80b7f2
  80b772:	50                   	push   %eax
  80b773:	e8 0e a0 ff ff       	call   805786 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80b778:	83 c4 0c             	add    $0xc,%esp
  80b77b:	6a 04                	push   $0x4
  80b77d:	68 ae b7 80 00       	push   $0x80b7ae
  80b782:	ff 73 08             	pushl  0x8(%ebx)
  80b785:	e8 2c a0 ff ff       	call   8057b6 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80b78a:	83 c4 08             	add    $0x8,%esp
  80b78d:	68 f1 b3 80 00       	push   $0x80b3f1
  80b792:	ff 73 08             	pushl  0x8(%ebx)
  80b795:	e8 fd 9f ff ff       	call   805797 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80b79a:	83 c4 08             	add    $0x8,%esp
  80b79d:	53                   	push   %ebx
  80b79e:	ff 73 08             	pushl  0x8(%ebx)
  80b7a1:	e8 c1 9f ff ff       	call   805767 <tcp_arg>
  80b7a6:	83 c4 10             	add    $0x10,%esp
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80b7a9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b7ac:	c9                   	leave  
  80b7ad:	c3                   	ret    

0080b7ae <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80b7ae:	55                   	push   %ebp
  80b7af:	89 e5                	mov    %esp,%ebp
  80b7b1:	83 ec 08             	sub    $0x8,%esp
  80b7b4:	8b 45 08             	mov    0x8(%ebp),%eax
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b7b7:	85 c0                	test   %eax,%eax
  80b7b9:	75 17                	jne    80b7d2 <poll_tcp+0x24>
  80b7bb:	83 ec 04             	sub    $0x4,%esp
  80b7be:	68 95 2c 81 00       	push   $0x812c95
  80b7c3:	68 eb 00 00 00       	push   $0xeb
  80b7c8:	68 42 2c 81 00       	push   $0x812c42
  80b7cd:	e8 bc 2b 00 00       	call   80e38e <_panic>

  if (conn->state == NETCONN_WRITE) {
  80b7d2:	8b 50 04             	mov    0x4(%eax),%edx
  80b7d5:	83 fa 01             	cmp    $0x1,%edx
  80b7d8:	75 07                	jne    80b7e1 <poll_tcp+0x33>
    do_writemore(conn);
  80b7da:	e8 e0 fc ff ff       	call   80b4bf <do_writemore>
  80b7df:	eb 0a                	jmp    80b7eb <poll_tcp+0x3d>
  } else if (conn->state == NETCONN_CLOSE) {
  80b7e1:	83 fa 04             	cmp    $0x4,%edx
  80b7e4:	75 05                	jne    80b7eb <poll_tcp+0x3d>
    do_close_internal(conn);
  80b7e6:	e8 1d fe ff ff       	call   80b608 <do_close_internal>
  }

  return ERR_OK;
}
  80b7eb:	b8 00 00 00 00       	mov    $0x0,%eax
  80b7f0:	c9                   	leave  
  80b7f1:	c3                   	ret    

0080b7f2 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80b7f2:	55                   	push   %ebp
  80b7f3:	89 e5                	mov    %esp,%ebp
  80b7f5:	56                   	push   %esi
  80b7f6:	53                   	push   %ebx
  80b7f7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b7fa:	8b 75 10             	mov    0x10(%ebp),%esi
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b7fd:	85 db                	test   %ebx,%ebx
  80b7ff:	75 17                	jne    80b818 <sent_tcp+0x26>
  80b801:	83 ec 04             	sub    $0x4,%esp
  80b804:	68 95 2c 81 00       	push   $0x812c95
  80b809:	68 03 01 00 00       	push   $0x103
  80b80e:	68 42 2c 81 00       	push   $0x812c42
  80b813:	e8 76 2b 00 00       	call   80e38e <_panic>

  if (conn->state == NETCONN_WRITE) {
  80b818:	8b 43 04             	mov    0x4(%ebx),%eax
  80b81b:	83 f8 01             	cmp    $0x1,%eax
  80b81e:	75 26                	jne    80b846 <sent_tcp+0x54>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80b820:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80b824:	75 17                	jne    80b83d <sent_tcp+0x4b>
  80b826:	83 ec 04             	sub    $0x4,%esp
  80b829:	68 0e 2d 81 00       	push   $0x812d0e
  80b82e:	68 06 01 00 00       	push   $0x106
  80b833:	68 42 2c 81 00       	push   $0x812c42
  80b838:	e8 51 2b 00 00       	call   80e38e <_panic>
    do_writemore(conn);
  80b83d:	89 d8                	mov    %ebx,%eax
  80b83f:	e8 7b fc ff ff       	call   80b4bf <do_writemore>
  80b844:	eb 2e                	jmp    80b874 <sent_tcp+0x82>
  } else if (conn->state == NETCONN_CLOSE) {
  80b846:	83 f8 04             	cmp    $0x4,%eax
  80b849:	75 29                	jne    80b874 <sent_tcp+0x82>
    do_close_internal(conn);
  80b84b:	89 d8                	mov    %ebx,%eax
  80b84d:	e8 b6 fd ff ff       	call   80b608 <do_close_internal>
  80b852:	eb 20                	jmp    80b874 <sent_tcp+0x82>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80b854:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b85a:	76 1f                	jbe    80b87b <sent_tcp+0x89>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80b85c:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b85f:	85 c0                	test   %eax,%eax
  80b861:	74 18                	je     80b87b <sent_tcp+0x89>
  80b863:	83 ec 04             	sub    $0x4,%esp
  80b866:	0f b7 f6             	movzwl %si,%esi
  80b869:	56                   	push   %esi
  80b86a:	6a 02                	push   $0x2
  80b86c:	53                   	push   %ebx
  80b86d:	ff d0                	call   *%eax
  80b86f:	83 c4 10             	add    $0x10,%esp
  80b872:	eb 07                	jmp    80b87b <sent_tcp+0x89>
  } else if (conn->state == NETCONN_CLOSE) {
    do_close_internal(conn);
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80b874:	8b 43 08             	mov    0x8(%ebx),%eax
  80b877:	85 c0                	test   %eax,%eax
  80b879:	75 d9                	jne    80b854 <sent_tcp+0x62>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
    }
  }
  
  return ERR_OK;
}
  80b87b:	b8 00 00 00 00       	mov    $0x0,%eax
  80b880:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b883:	5b                   	pop    %ebx
  80b884:	5e                   	pop    %esi
  80b885:	5d                   	pop    %ebp
  80b886:	c3                   	ret    

0080b887 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80b887:	55                   	push   %ebp
  80b888:	89 e5                	mov    %esp,%ebp
  80b88a:	56                   	push   %esi
  80b88b:	53                   	push   %ebx
  80b88c:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80b88f:	8b 03                	mov    (%ebx),%eax
  80b891:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80b895:	0f 85 ce 00 00 00    	jne    80b969 <do_newconn+0xe2>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80b89b:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80b89f:	8b 33                	mov    (%ebx),%esi
  80b8a1:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80b8a5:	74 17                	je     80b8be <do_newconn+0x37>
  80b8a7:	83 ec 04             	sub    $0x4,%esp
  80b8aa:	68 c8 2b 81 00       	push   $0x812bc8
  80b8af:	68 8a 01 00 00       	push   $0x18a
  80b8b4:	68 42 2c 81 00       	push   $0x812c42
  80b8b9:	e8 d0 2a 00 00       	call   80e38e <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80b8be:	8b 06                	mov    (%esi),%eax
  80b8c0:	25 f0 00 00 00       	and    $0xf0,%eax
  80b8c5:	83 f8 20             	cmp    $0x20,%eax
  80b8c8:	74 46                	je     80b910 <do_newconn+0x89>
  80b8ca:	83 f8 40             	cmp    $0x40,%eax
  80b8cd:	74 0b                	je     80b8da <do_newconn+0x53>
  80b8cf:	83 f8 10             	cmp    $0x10,%eax
  80b8d2:	0f 85 8d 00 00 00    	jne    80b965 <do_newconn+0xde>
  80b8d8:	eb 6e                	jmp    80b948 <do_newconn+0xc1>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80b8da:	83 ec 0c             	sub    $0xc,%esp
  80b8dd:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80b8e1:	50                   	push   %eax
  80b8e2:	e8 2c 25 00 00       	call   80de13 <raw_new>
  80b8e7:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80b8ea:	8b 03                	mov    (%ebx),%eax
  80b8ec:	8b 50 08             	mov    0x8(%eax),%edx
  80b8ef:	83 c4 10             	add    $0x10,%esp
  80b8f2:	85 d2                	test   %edx,%edx
  80b8f4:	75 06                	jne    80b8fc <do_newconn+0x75>
       msg->conn->err = ERR_MEM;
  80b8f6:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80b8fa:	eb 6d                	jmp    80b969 <do_newconn+0xe2>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80b8fc:	83 ec 04             	sub    $0x4,%esp
  80b8ff:	50                   	push   %eax
  80b900:	68 6b b2 80 00       	push   $0x80b26b
  80b905:	52                   	push   %edx
  80b906:	e8 86 23 00 00       	call   80dc91 <raw_recv>
  80b90b:	83 c4 10             	add    $0x10,%esp
  80b90e:	eb 59                	jmp    80b969 <do_newconn+0xe2>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80b910:	e8 9b d5 ff ff       	call   808eb0 <udp_new>
  80b915:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80b918:	8b 03                	mov    (%ebx),%eax
  80b91a:	8b 50 08             	mov    0x8(%eax),%edx
  80b91d:	85 d2                	test   %edx,%edx
  80b91f:	75 06                	jne    80b927 <do_newconn+0xa0>
       msg->conn->err = ERR_MEM;
  80b921:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80b925:	eb 42                	jmp    80b969 <do_newconn+0xe2>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80b927:	83 38 22             	cmpl   $0x22,(%eax)
  80b92a:	75 04                	jne    80b930 <do_newconn+0xa9>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80b92c:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80b930:	8b 03                	mov    (%ebx),%eax
  80b932:	83 ec 04             	sub    $0x4,%esp
  80b935:	50                   	push   %eax
  80b936:	68 73 b1 80 00       	push   $0x80b173
  80b93b:	ff 70 08             	pushl  0x8(%eax)
  80b93e:	e8 15 d5 ff ff       	call   808e58 <udp_recv>
  80b943:	83 c4 10             	add    $0x10,%esp
  80b946:	eb 21                	jmp    80b969 <do_newconn+0xe2>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80b948:	e8 eb a8 ff ff       	call   806238 <tcp_new>
  80b94d:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80b950:	8b 03                	mov    (%ebx),%eax
  80b952:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80b956:	75 06                	jne    80b95e <do_newconn+0xd7>
       msg->conn->err = ERR_MEM;
  80b958:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80b95c:	eb 0b                	jmp    80b969 <do_newconn+0xe2>
       break;
     }
     setup_tcp(msg->conn);
  80b95e:	e8 f1 f9 ff ff       	call   80b354 <setup_tcp>
  80b963:	eb 04                	jmp    80b969 <do_newconn+0xe2>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80b965:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80b969:	83 ec 0c             	sub    $0xc,%esp
  80b96c:	8b 03                	mov    (%ebx),%eax
  80b96e:	ff 70 10             	pushl  0x10(%eax)
  80b971:	e8 a4 e5 ff ff       	call   809f1a <sys_sem_signal>
}
  80b976:	83 c4 10             	add    $0x10,%esp
  80b979:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b97c:	5b                   	pop    %ebx
  80b97d:	5e                   	pop    %esi
  80b97e:	5d                   	pop    %ebp
  80b97f:	c3                   	ret    

0080b980 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80b980:	55                   	push   %ebp
  80b981:	89 e5                	mov    %esp,%ebp
  80b983:	53                   	push   %ebx
  80b984:	83 ec 10             	sub    $0x10,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80b987:	6a 07                	push   $0x7
  80b989:	e8 10 8a ff ff       	call   80439e <memp_malloc>
  if (conn == NULL) {
  80b98e:	83 c4 10             	add    $0x10,%esp
  80b991:	85 c0                	test   %eax,%eax
  80b993:	0f 84 96 00 00 00    	je     80ba2f <netconn_alloc+0xaf>
  80b999:	89 c3                	mov    %eax,%ebx
    return NULL;
  }

  conn->err = ERR_OK;
  80b99b:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80b99f:	8b 45 08             	mov    0x8(%ebp),%eax
  80b9a2:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80b9a4:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80b9ab:	83 ec 0c             	sub    $0xc,%esp
  80b9ae:	6a 00                	push   $0x0
  80b9b0:	e8 b9 e2 ff ff       	call   809c6e <sys_sem_new>
  80b9b5:	89 43 10             	mov    %eax,0x10(%ebx)
  80b9b8:	83 c4 10             	add    $0x10,%esp
  80b9bb:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b9be:	75 15                	jne    80b9d5 <netconn_alloc+0x55>
    memp_free(MEMP_NETCONN, conn);
  80b9c0:	83 ec 08             	sub    $0x8,%esp
  80b9c3:	53                   	push   %ebx
  80b9c4:	6a 07                	push   $0x7
  80b9c6:	e8 29 8a ff ff       	call   8043f4 <memp_free>
    return NULL;
  80b9cb:	83 c4 10             	add    $0x10,%esp
  80b9ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9d3:	eb 5f                	jmp    80ba34 <netconn_alloc+0xb4>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80b9d5:	83 ec 0c             	sub    $0xc,%esp
  80b9d8:	6a 00                	push   $0x0
  80b9da:	e8 38 e4 ff ff       	call   809e17 <sys_mbox_new>
  80b9df:	89 43 14             	mov    %eax,0x14(%ebx)
  80b9e2:	83 c4 10             	add    $0x10,%esp
  80b9e5:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b9e8:	75 20                	jne    80ba0a <netconn_alloc+0x8a>
    sys_sem_free(conn->op_completed);
  80b9ea:	83 ec 0c             	sub    $0xc,%esp
  80b9ed:	ff 73 10             	pushl  0x10(%ebx)
  80b9f0:	e8 fa e2 ff ff       	call   809cef <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80b9f5:	83 c4 08             	add    $0x8,%esp
  80b9f8:	53                   	push   %ebx
  80b9f9:	6a 07                	push   $0x7
  80b9fb:	e8 f4 89 ff ff       	call   8043f4 <memp_free>
    return NULL;
  80ba00:	83 c4 10             	add    $0x10,%esp
  80ba03:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba08:	eb 2a                	jmp    80ba34 <netconn_alloc+0xb4>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80ba0a:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80ba11:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80ba18:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80ba1f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ba22:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80ba25:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  80ba2b:	89 d8                	mov    %ebx,%eax
  80ba2d:	eb 05                	jmp    80ba34 <netconn_alloc+0xb4>
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  if (conn == NULL) {
    return NULL;
  80ba2f:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80ba34:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ba37:	c9                   	leave  
  80ba38:	c3                   	ret    

0080ba39 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80ba39:	55                   	push   %ebp
  80ba3a:	89 e5                	mov    %esp,%ebp
  80ba3c:	56                   	push   %esi
  80ba3d:	53                   	push   %ebx
  80ba3e:	83 ec 10             	sub    $0x10,%esp
  80ba41:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80ba44:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80ba48:	74 17                	je     80ba61 <netconn_free+0x28>
  80ba4a:	83 ec 04             	sub    $0x4,%esp
  80ba4d:	68 e8 2b 81 00       	push   $0x812be8
  80ba52:	68 26 02 00 00       	push   $0x226
  80ba57:	68 42 2c 81 00       	push   $0x812c42
  80ba5c:	e8 2d 29 00 00       	call   80e38e <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80ba61:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80ba64:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80ba68:	75 2a                	jne    80ba94 <netconn_free+0x5b>
  80ba6a:	eb 51                	jmp    80babd <netconn_free+0x84>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80ba6c:	83 3b 10             	cmpl   $0x10,(%ebx)
  80ba6f:	75 15                	jne    80ba86 <netconn_free+0x4d>
        if(mem != NULL) {
  80ba71:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ba74:	85 c0                	test   %eax,%eax
  80ba76:	74 1c                	je     80ba94 <netconn_free+0x5b>
          pbuf_free((struct pbuf *)mem);
  80ba78:	83 ec 0c             	sub    $0xc,%esp
  80ba7b:	50                   	push   %eax
  80ba7c:	e8 e6 8c ff ff       	call   804767 <pbuf_free>
  80ba81:	83 c4 10             	add    $0x10,%esp
  80ba84:	eb 0e                	jmp    80ba94 <netconn_free+0x5b>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80ba86:	83 ec 0c             	sub    $0xc,%esp
  80ba89:	ff 75 f4             	pushl  -0xc(%ebp)
  80ba8c:	e8 a4 69 ff ff       	call   802435 <netbuf_delete>
  80ba91:	83 c4 10             	add    $0x10,%esp
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80ba94:	83 ec 08             	sub    $0x8,%esp
  80ba97:	56                   	push   %esi
  80ba98:	ff 73 14             	pushl  0x14(%ebx)
  80ba9b:	e8 d5 e7 ff ff       	call   80a275 <sys_arch_mbox_tryfetch>
  80baa0:	83 c4 10             	add    $0x10,%esp
  80baa3:	83 f8 ff             	cmp    $0xffffffff,%eax
  80baa6:	75 c4                	jne    80ba6c <netconn_free+0x33>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80baa8:	83 ec 0c             	sub    $0xc,%esp
  80baab:	ff 73 14             	pushl  0x14(%ebx)
  80baae:	e8 c5 e2 ff ff       	call   809d78 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80bab3:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80baba:	83 c4 10             	add    $0x10,%esp
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80babd:	8d 75 f4             	lea    -0xc(%ebp),%esi
    sys_mbox_free(conn->recvmbox);
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80bac0:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bac4:	75 10                	jne    80bad6 <netconn_free+0x9d>
  80bac6:	eb 37                	jmp    80baff <netconn_free+0xc6>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80bac8:	83 ec 0c             	sub    $0xc,%esp
  80bacb:	ff 75 f4             	pushl  -0xc(%ebp)
  80bace:	e8 83 f0 ff ff       	call   80ab56 <netconn_delete>
  80bad3:	83 c4 10             	add    $0x10,%esp
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bad6:	83 ec 08             	sub    $0x8,%esp
  80bad9:	56                   	push   %esi
  80bada:	ff 73 18             	pushl  0x18(%ebx)
  80badd:	e8 93 e7 ff ff       	call   80a275 <sys_arch_mbox_tryfetch>
  80bae2:	83 c4 10             	add    $0x10,%esp
  80bae5:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bae8:	75 de                	jne    80bac8 <netconn_free+0x8f>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80baea:	83 ec 0c             	sub    $0xc,%esp
  80baed:	ff 73 18             	pushl  0x18(%ebx)
  80baf0:	e8 83 e2 ff ff       	call   809d78 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80baf5:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80bafc:	83 c4 10             	add    $0x10,%esp
  }

  sys_sem_free(conn->op_completed);
  80baff:	83 ec 0c             	sub    $0xc,%esp
  80bb02:	ff 73 10             	pushl  0x10(%ebx)
  80bb05:	e8 e5 e1 ff ff       	call   809cef <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80bb0a:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80bb11:	83 c4 08             	add    $0x8,%esp
  80bb14:	53                   	push   %ebx
  80bb15:	6a 07                	push   $0x7
  80bb17:	e8 d8 88 ff ff       	call   8043f4 <memp_free>
}
  80bb1c:	83 c4 10             	add    $0x10,%esp
  80bb1f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bb22:	5b                   	pop    %ebx
  80bb23:	5e                   	pop    %esi
  80bb24:	5d                   	pop    %ebp
  80bb25:	c3                   	ret    

0080bb26 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80bb26:	55                   	push   %ebp
  80bb27:	89 e5                	mov    %esp,%ebp
  80bb29:	57                   	push   %edi
  80bb2a:	56                   	push   %esi
  80bb2b:	53                   	push   %ebx
  80bb2c:	83 ec 0c             	sub    $0xc,%esp
  80bb2f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bb32:	8b 7d 10             	mov    0x10(%ebp),%edi
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bb35:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bb39:	75 17                	jne    80bb52 <accept_function+0x2c>
  80bb3b:	83 ec 04             	sub    $0x4,%esp
  80bb3e:	68 18 2c 81 00       	push   $0x812c18
  80bb43:	68 65 01 00 00       	push   $0x165
  80bb48:	68 42 2c 81 00       	push   $0x812c42
  80bb4d:	e8 3c 28 00 00       	call   80e38e <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80bb52:	83 ec 08             	sub    $0x8,%esp
  80bb55:	ff 73 2c             	pushl  0x2c(%ebx)
  80bb58:	ff 33                	pushl  (%ebx)
  80bb5a:	e8 21 fe ff ff       	call   80b980 <netconn_alloc>
  80bb5f:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80bb61:	83 c4 10             	add    $0x10,%esp
  80bb64:	85 c0                	test   %eax,%eax
  80bb66:	74 53                	je     80bbbb <accept_function+0x95>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80bb68:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bb6b:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80bb6e:	89 f0                	mov    %esi,%eax
  80bb70:	e8 df f7 ff ff       	call   80b354 <setup_tcp>
  newconn->err = err;
  80bb75:	89 f8                	mov    %edi,%eax
  80bb77:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bb7a:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bb7d:	85 c0                	test   %eax,%eax
  80bb7f:	74 0d                	je     80bb8e <accept_function+0x68>
  80bb81:	83 ec 04             	sub    $0x4,%esp
  80bb84:	6a 00                	push   $0x0
  80bb86:	6a 00                	push   $0x0
  80bb88:	53                   	push   %ebx
  80bb89:	ff d0                	call   *%eax
  80bb8b:	83 c4 10             	add    $0x10,%esp

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80bb8e:	83 ec 08             	sub    $0x8,%esp
  80bb91:	56                   	push   %esi
  80bb92:	ff 73 18             	pushl  0x18(%ebx)
  80bb95:	e8 fc e4 ff ff       	call   80a096 <sys_mbox_trypost>
  80bb9a:	83 c4 10             	add    $0x10,%esp
  80bb9d:	84 c0                	test   %al,%al
  80bb9f:	74 1f                	je     80bbc0 <accept_function+0x9a>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80bba1:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80bba8:	83 ec 0c             	sub    $0xc,%esp
  80bbab:	56                   	push   %esi
  80bbac:	e8 88 fe ff ff       	call   80ba39 <netconn_free>
    return ERR_MEM;
  80bbb1:	83 c4 10             	add    $0x10,%esp
  80bbb4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bbb9:	eb 05                	jmp    80bbc0 <accept_function+0x9a>

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  if (newconn == NULL) {
    return ERR_MEM;
  80bbbb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    newconn->pcb.tcp = NULL;
    netconn_free(newconn);
    return ERR_MEM;
  }
  return ERR_OK;
}
  80bbc0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bbc3:	5b                   	pop    %ebx
  80bbc4:	5e                   	pop    %esi
  80bbc5:	5f                   	pop    %edi
  80bbc6:	5d                   	pop    %ebp
  80bbc7:	c3                   	ret    

0080bbc8 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80bbc8:	55                   	push   %ebp
  80bbc9:	89 e5                	mov    %esp,%ebp
  80bbcb:	53                   	push   %ebx
  80bbcc:	83 ec 04             	sub    $0x4,%esp
  80bbcf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80bbd2:	8b 13                	mov    (%ebx),%edx
  80bbd4:	8b 4a 08             	mov    0x8(%edx),%ecx
  80bbd7:	85 c9                	test   %ecx,%ecx
  80bbd9:	74 4f                	je     80bc2a <do_delconn+0x62>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bbdb:	8b 02                	mov    (%edx),%eax
  80bbdd:	25 f0 00 00 00       	and    $0xf0,%eax
  80bbe2:	83 f8 20             	cmp    $0x20,%eax
  80bbe5:	74 1a                	je     80bc01 <do_delconn+0x39>
  80bbe7:	83 f8 40             	cmp    $0x40,%eax
  80bbea:	74 07                	je     80bbf3 <do_delconn+0x2b>
  80bbec:	83 f8 10             	cmp    $0x10,%eax
  80bbef:	75 39                	jne    80bc2a <do_delconn+0x62>
  80bbf1:	eb 27                	jmp    80bc1a <do_delconn+0x52>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80bbf3:	83 ec 0c             	sub    $0xc,%esp
  80bbf6:	51                   	push   %ecx
  80bbf7:	e8 d3 21 00 00       	call   80ddcf <raw_remove>
      break;
  80bbfc:	83 c4 10             	add    $0x10,%esp
  80bbff:	eb 29                	jmp    80bc2a <do_delconn+0x62>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80bc01:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80bc08:	83 ec 0c             	sub    $0xc,%esp
  80bc0b:	8b 03                	mov    (%ebx),%eax
  80bc0d:	ff 70 08             	pushl  0x8(%eax)
  80bc10:	e8 57 d2 ff ff       	call   808e6c <udp_remove>
      break;
  80bc15:	83 c4 10             	add    $0x10,%esp
  80bc18:	eb 10                	jmp    80bc2a <do_delconn+0x62>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80bc1a:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80bc21:	8b 03                	mov    (%ebx),%eax
  80bc23:	e8 e0 f9 ff ff       	call   80b608 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80bc28:	eb 42                	jmp    80bc6c <do_delconn+0xa4>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80bc2a:	8b 13                	mov    (%ebx),%edx
  80bc2c:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bc2f:	85 c0                	test   %eax,%eax
  80bc31:	74 23                	je     80bc56 <do_delconn+0x8e>
  80bc33:	83 ec 04             	sub    $0x4,%esp
  80bc36:	6a 00                	push   $0x0
  80bc38:	6a 00                	push   $0x0
  80bc3a:	52                   	push   %edx
  80bc3b:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80bc3d:	8b 13                	mov    (%ebx),%edx
  80bc3f:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bc42:	83 c4 10             	add    $0x10,%esp
  80bc45:	85 c0                	test   %eax,%eax
  80bc47:	74 0d                	je     80bc56 <do_delconn+0x8e>
  80bc49:	83 ec 04             	sub    $0x4,%esp
  80bc4c:	6a 00                	push   $0x0
  80bc4e:	6a 02                	push   $0x2
  80bc50:	52                   	push   %edx
  80bc51:	ff d0                	call   *%eax
  80bc53:	83 c4 10             	add    $0x10,%esp

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80bc56:	8b 03                	mov    (%ebx),%eax
  80bc58:	8b 40 10             	mov    0x10(%eax),%eax
  80bc5b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bc5e:	74 0c                	je     80bc6c <do_delconn+0xa4>
    sys_sem_signal(msg->conn->op_completed);
  80bc60:	83 ec 0c             	sub    $0xc,%esp
  80bc63:	50                   	push   %eax
  80bc64:	e8 b1 e2 ff ff       	call   809f1a <sys_sem_signal>
  80bc69:	83 c4 10             	add    $0x10,%esp
  }
}
  80bc6c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bc6f:	c9                   	leave  
  80bc70:	c3                   	ret    

0080bc71 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80bc71:	55                   	push   %ebp
  80bc72:	89 e5                	mov    %esp,%ebp
  80bc74:	56                   	push   %esi
  80bc75:	53                   	push   %ebx
  80bc76:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bc79:	8b 33                	mov    (%ebx),%esi
  80bc7b:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80bc7f:	7c 69                	jl     80bcea <do_bind+0x79>
    if (msg->conn->pcb.tcp != NULL) {
  80bc81:	8b 56 08             	mov    0x8(%esi),%edx
  80bc84:	85 d2                	test   %edx,%edx
  80bc86:	74 5e                	je     80bce6 <do_bind+0x75>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bc88:	8b 06                	mov    (%esi),%eax
  80bc8a:	25 f0 00 00 00       	and    $0xf0,%eax
  80bc8f:	83 f8 20             	cmp    $0x20,%eax
  80bc92:	74 20                	je     80bcb4 <do_bind+0x43>
  80bc94:	83 f8 40             	cmp    $0x40,%eax
  80bc97:	74 07                	je     80bca0 <do_bind+0x2f>
  80bc99:	83 f8 10             	cmp    $0x10,%eax
  80bc9c:	75 4c                	jne    80bcea <do_bind+0x79>
  80bc9e:	eb 2d                	jmp    80bccd <do_bind+0x5c>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bca0:	83 ec 08             	sub    $0x8,%esp
  80bca3:	ff 73 04             	pushl  0x4(%ebx)
  80bca6:	52                   	push   %edx
  80bca7:	e8 a6 1f 00 00       	call   80dc52 <raw_bind>
  80bcac:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bcaf:	83 c4 10             	add    $0x10,%esp
  80bcb2:	eb 36                	jmp    80bcea <do_bind+0x79>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bcb4:	83 ec 04             	sub    $0x4,%esp
  80bcb7:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bcbb:	50                   	push   %eax
  80bcbc:	ff 73 04             	pushl  0x4(%ebx)
  80bcbf:	52                   	push   %edx
  80bcc0:	e8 65 ce ff ff       	call   808b2a <udp_bind>
  80bcc5:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bcc8:	83 c4 10             	add    $0x10,%esp
  80bccb:	eb 1d                	jmp    80bcea <do_bind+0x79>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bccd:	83 ec 04             	sub    $0x4,%esp
  80bcd0:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bcd4:	50                   	push   %eax
  80bcd5:	ff 73 04             	pushl  0x4(%ebx)
  80bcd8:	52                   	push   %edx
  80bcd9:	e8 1b 96 ff ff       	call   8052f9 <tcp_bind>
  80bcde:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bce1:	83 c4 10             	add    $0x10,%esp
  80bce4:	eb 04                	jmp    80bcea <do_bind+0x79>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80bce6:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80bcea:	83 ec 0c             	sub    $0xc,%esp
  80bced:	8b 03                	mov    (%ebx),%eax
  80bcef:	ff 70 10             	pushl  0x10(%eax)
  80bcf2:	e8 23 e2 ff ff       	call   809f1a <sys_sem_signal>
}
  80bcf7:	83 c4 10             	add    $0x10,%esp
  80bcfa:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bcfd:	5b                   	pop    %ebx
  80bcfe:	5e                   	pop    %esi
  80bcff:	5d                   	pop    %ebp
  80bd00:	c3                   	ret    

0080bd01 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80bd01:	55                   	push   %ebp
  80bd02:	89 e5                	mov    %esp,%ebp
  80bd04:	56                   	push   %esi
  80bd05:	53                   	push   %ebx
  80bd06:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80bd09:	8b 33                	mov    (%ebx),%esi
  80bd0b:	8b 56 08             	mov    0x8(%esi),%edx
  80bd0e:	85 d2                	test   %edx,%edx
  80bd10:	75 13                	jne    80bd25 <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80bd12:	83 ec 0c             	sub    $0xc,%esp
  80bd15:	ff 76 10             	pushl  0x10(%esi)
  80bd18:	e8 fd e1 ff ff       	call   809f1a <sys_sem_signal>
    return;
  80bd1d:	83 c4 10             	add    $0x10,%esp
  80bd20:	e9 8a 00 00 00       	jmp    80bdaf <do_connect+0xae>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bd25:	8b 06                	mov    (%esi),%eax
  80bd27:	25 f0 00 00 00       	and    $0xf0,%eax
  80bd2c:	83 f8 20             	cmp    $0x20,%eax
  80bd2f:	74 2d                	je     80bd5e <do_connect+0x5d>
  80bd31:	83 f8 40             	cmp    $0x40,%eax
  80bd34:	74 07                	je     80bd3d <do_connect+0x3c>
  80bd36:	83 f8 10             	cmp    $0x10,%eax
  80bd39:	75 74                	jne    80bdaf <do_connect+0xae>
  80bd3b:	eb 47                	jmp    80bd84 <do_connect+0x83>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bd3d:	83 ec 08             	sub    $0x8,%esp
  80bd40:	ff 73 04             	pushl  0x4(%ebx)
  80bd43:	52                   	push   %edx
  80bd44:	e8 28 1f 00 00       	call   80dc71 <raw_connect>
  80bd49:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80bd4c:	83 c4 04             	add    $0x4,%esp
  80bd4f:	8b 03                	mov    (%ebx),%eax
  80bd51:	ff 70 10             	pushl  0x10(%eax)
  80bd54:	e8 c1 e1 ff ff       	call   809f1a <sys_sem_signal>
    break;
  80bd59:	83 c4 10             	add    $0x10,%esp
  80bd5c:	eb 51                	jmp    80bdaf <do_connect+0xae>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bd5e:	83 ec 04             	sub    $0x4,%esp
  80bd61:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bd65:	50                   	push   %eax
  80bd66:	ff 73 04             	pushl  0x4(%ebx)
  80bd69:	52                   	push   %edx
  80bd6a:	e8 5d d0 ff ff       	call   808dcc <udp_connect>
  80bd6f:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80bd72:	83 c4 04             	add    $0x4,%esp
  80bd75:	8b 03                	mov    (%ebx),%eax
  80bd77:	ff 70 10             	pushl  0x10(%eax)
  80bd7a:	e8 9b e1 ff ff       	call   809f1a <sys_sem_signal>
    break;
  80bd7f:	83 c4 10             	add    $0x10,%esp
  80bd82:	eb 2b                	jmp    80bdaf <do_connect+0xae>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80bd84:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80bd8b:	8b 03                	mov    (%ebx),%eax
  80bd8d:	e8 c2 f5 ff ff       	call   80b354 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80bd92:	8b 33                	mov    (%ebx),%esi
  80bd94:	68 a7 b3 80 00       	push   $0x80b3a7
  80bd99:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bd9d:	50                   	push   %eax
  80bd9e:	ff 73 04             	pushl  0x4(%ebx)
  80bda1:	ff 76 08             	pushl  0x8(%esi)
  80bda4:	e8 d7 a4 ff ff       	call   806280 <tcp_connect>
  80bda9:	88 46 0c             	mov    %al,0xc(%esi)
                                 do_connected);
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
  80bdac:	83 c4 10             	add    $0x10,%esp
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80bdaf:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bdb2:	5b                   	pop    %ebx
  80bdb3:	5e                   	pop    %esi
  80bdb4:	5d                   	pop    %ebp
  80bdb5:	c3                   	ret    

0080bdb6 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80bdb6:	55                   	push   %ebp
  80bdb7:	89 e5                	mov    %esp,%ebp
  80bdb9:	53                   	push   %ebx
  80bdba:	83 ec 04             	sub    $0x4,%esp
  80bdbd:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80bdc0:	8b 13                	mov    (%ebx),%edx
  80bdc2:	8b 02                	mov    (%edx),%eax
  80bdc4:	25 f0 00 00 00       	and    $0xf0,%eax
  80bdc9:	83 f8 20             	cmp    $0x20,%eax
  80bdcc:	75 0e                	jne    80bddc <do_disconnect+0x26>
    udp_disconnect(msg->conn->pcb.udp);
  80bdce:	83 ec 0c             	sub    $0xc,%esp
  80bdd1:	ff 72 08             	pushl  0x8(%edx)
  80bdd4:	e8 64 d0 ff ff       	call   808e3d <udp_disconnect>
  80bdd9:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80bddc:	83 ec 0c             	sub    $0xc,%esp
  80bddf:	8b 03                	mov    (%ebx),%eax
  80bde1:	ff 70 10             	pushl  0x10(%eax)
  80bde4:	e8 31 e1 ff ff       	call   809f1a <sys_sem_signal>
}
  80bde9:	83 c4 10             	add    $0x10,%esp
  80bdec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bdef:	c9                   	leave  
  80bdf0:	c3                   	ret    

0080bdf1 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80bdf1:	55                   	push   %ebp
  80bdf2:	89 e5                	mov    %esp,%ebp
  80bdf4:	57                   	push   %edi
  80bdf5:	56                   	push   %esi
  80bdf6:	53                   	push   %ebx
  80bdf7:	83 ec 0c             	sub    $0xc,%esp
  80bdfa:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bdfd:	8b 03                	mov    (%ebx),%eax
  80bdff:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80be03:	0f 8c bc 00 00 00    	jl     80bec5 <do_listen+0xd4>
    if (msg->conn->pcb.tcp != NULL) {
  80be09:	8b 50 08             	mov    0x8(%eax),%edx
  80be0c:	85 d2                	test   %edx,%edx
  80be0e:	0f 84 b1 00 00 00    	je     80bec5 <do_listen+0xd4>
      if (msg->conn->type == NETCONN_TCP) {
  80be14:	83 38 10             	cmpl   $0x10,(%eax)
  80be17:	0f 85 a8 00 00 00    	jne    80bec5 <do_listen+0xd4>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80be1d:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80be21:	0f 85 9a 00 00 00    	jne    80bec1 <do_listen+0xd0>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80be27:	83 ec 08             	sub    $0x8,%esp
  80be2a:	68 ff 00 00 00       	push   $0xff
  80be2f:	52                   	push   %edx
  80be30:	e8 54 96 ff ff       	call   805489 <tcp_listen_with_backlog>
  80be35:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80be37:	83 c4 10             	add    $0x10,%esp
  80be3a:	85 c0                	test   %eax,%eax
  80be3c:	75 08                	jne    80be46 <do_listen+0x55>
            msg->conn->err = ERR_MEM;
  80be3e:	8b 03                	mov    (%ebx),%eax
  80be40:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80be44:	eb 7f                	jmp    80bec5 <do_listen+0xd4>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80be46:	8b 03                	mov    (%ebx),%eax
  80be48:	8b 40 14             	mov    0x14(%eax),%eax
  80be4b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80be4e:	74 15                	je     80be65 <do_listen+0x74>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80be50:	83 ec 0c             	sub    $0xc,%esp
  80be53:	50                   	push   %eax
  80be54:	e8 1f df ff ff       	call   809d78 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80be59:	8b 03                	mov    (%ebx),%eax
  80be5b:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80be62:	83 c4 10             	add    $0x10,%esp
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80be65:	8b 3b                	mov    (%ebx),%edi
  80be67:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80be6b:	75 1b                	jne    80be88 <do_listen+0x97>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80be6d:	83 ec 0c             	sub    $0xc,%esp
  80be70:	6a 00                	push   $0x0
  80be72:	e8 a0 df ff ff       	call   809e17 <sys_mbox_new>
  80be77:	89 47 18             	mov    %eax,0x18(%edi)
  80be7a:	83 c4 10             	add    $0x10,%esp
  80be7d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80be80:	75 06                	jne    80be88 <do_listen+0x97>
                msg->conn->err = ERR_MEM;
  80be82:	8b 03                	mov    (%ebx),%eax
  80be84:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80be88:	8b 03                	mov    (%ebx),%eax
  80be8a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80be8e:	75 35                	jne    80bec5 <do_listen+0xd4>
              msg->conn->state = NETCONN_LISTEN;
  80be90:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80be97:	8b 03                	mov    (%ebx),%eax
  80be99:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80be9c:	8b 03                	mov    (%ebx),%eax
  80be9e:	83 ec 08             	sub    $0x8,%esp
  80bea1:	50                   	push   %eax
  80bea2:	ff 70 08             	pushl  0x8(%eax)
  80bea5:	e8 bd 98 ff ff       	call   805767 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80beaa:	83 c4 08             	add    $0x8,%esp
  80bead:	68 26 bb 80 00       	push   $0x80bb26
  80beb2:	8b 03                	mov    (%ebx),%eax
  80beb4:	ff 70 08             	pushl  0x8(%eax)
  80beb7:	e8 ec 98 ff ff       	call   8057a8 <tcp_accept>
  80bebc:	83 c4 10             	add    $0x10,%esp
  80bebf:	eb 04                	jmp    80bec5 <do_listen+0xd4>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80bec1:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80bec5:	83 ec 0c             	sub    $0xc,%esp
  80bec8:	8b 03                	mov    (%ebx),%eax
  80beca:	ff 70 10             	pushl  0x10(%eax)
  80becd:	e8 48 e0 ff ff       	call   809f1a <sys_sem_signal>
}
  80bed2:	83 c4 10             	add    $0x10,%esp
  80bed5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bed8:	5b                   	pop    %ebx
  80bed9:	5e                   	pop    %esi
  80beda:	5f                   	pop    %edi
  80bedb:	5d                   	pop    %ebp
  80bedc:	c3                   	ret    

0080bedd <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80bedd:	55                   	push   %ebp
  80bede:	89 e5                	mov    %esp,%ebp
  80bee0:	57                   	push   %edi
  80bee1:	56                   	push   %esi
  80bee2:	53                   	push   %ebx
  80bee3:	83 ec 0c             	sub    $0xc,%esp
  80bee6:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bee9:	8b 1e                	mov    (%esi),%ebx
  80beeb:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80beef:	7c 7a                	jl     80bf6b <do_send+0x8e>
    if (msg->conn->pcb.tcp != NULL) {
  80bef1:	8b 53 08             	mov    0x8(%ebx),%edx
  80bef4:	85 d2                	test   %edx,%edx
  80bef6:	74 73                	je     80bf6b <do_send+0x8e>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bef8:	8b 03                	mov    (%ebx),%eax
  80befa:	25 f0 00 00 00       	and    $0xf0,%eax
  80beff:	83 f8 20             	cmp    $0x20,%eax
  80bf02:	74 36                	je     80bf3a <do_send+0x5d>
  80bf04:	83 f8 40             	cmp    $0x40,%eax
  80bf07:	75 62                	jne    80bf6b <do_send+0x8e>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80bf09:	8b 46 04             	mov    0x4(%esi),%eax
  80bf0c:	8b 48 08             	mov    0x8(%eax),%ecx
  80bf0f:	85 c9                	test   %ecx,%ecx
  80bf11:	75 13                	jne    80bf26 <do_send+0x49>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80bf13:	83 ec 08             	sub    $0x8,%esp
  80bf16:	ff 30                	pushl  (%eax)
  80bf18:	52                   	push   %edx
  80bf19:	e8 99 1e 00 00       	call   80ddb7 <raw_send>
  80bf1e:	88 43 0c             	mov    %al,0xc(%ebx)
  80bf21:	83 c4 10             	add    $0x10,%esp
  80bf24:	eb 45                	jmp    80bf6b <do_send+0x8e>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80bf26:	83 ec 04             	sub    $0x4,%esp
  80bf29:	51                   	push   %ecx
  80bf2a:	ff 30                	pushl  (%eax)
  80bf2c:	52                   	push   %edx
  80bf2d:	e8 73 1d 00 00       	call   80dca5 <raw_sendto>
  80bf32:	88 43 0c             	mov    %al,0xc(%ebx)
  80bf35:	83 c4 10             	add    $0x10,%esp
  80bf38:	eb 31                	jmp    80bf6b <do_send+0x8e>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80bf3a:	8b 46 04             	mov    0x4(%esi),%eax
  80bf3d:	8b 48 08             	mov    0x8(%eax),%ecx
  80bf40:	85 c9                	test   %ecx,%ecx
  80bf42:	75 13                	jne    80bf57 <do_send+0x7a>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80bf44:	83 ec 08             	sub    $0x8,%esp
  80bf47:	ff 30                	pushl  (%eax)
  80bf49:	52                   	push   %edx
  80bf4a:	e8 60 ce ff ff       	call   808daf <udp_send>
  80bf4f:	88 43 0c             	mov    %al,0xc(%ebx)
  80bf52:	83 c4 10             	add    $0x10,%esp
  80bf55:	eb 14                	jmp    80bf6b <do_send+0x8e>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80bf57:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80bf5b:	57                   	push   %edi
  80bf5c:	51                   	push   %ecx
  80bf5d:	ff 30                	pushl  (%eax)
  80bf5f:	52                   	push   %edx
  80bf60:	e8 0a ce ff ff       	call   808d6f <udp_sendto>
  80bf65:	88 43 0c             	mov    %al,0xc(%ebx)
  80bf68:	83 c4 10             	add    $0x10,%esp
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80bf6b:	83 ec 0c             	sub    $0xc,%esp
  80bf6e:	8b 06                	mov    (%esi),%eax
  80bf70:	ff 70 10             	pushl  0x10(%eax)
  80bf73:	e8 a2 df ff ff       	call   809f1a <sys_sem_signal>
}
  80bf78:	83 c4 10             	add    $0x10,%esp
  80bf7b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bf7e:	5b                   	pop    %ebx
  80bf7f:	5e                   	pop    %esi
  80bf80:	5f                   	pop    %edi
  80bf81:	5d                   	pop    %ebp
  80bf82:	c3                   	ret    

0080bf83 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80bf83:	55                   	push   %ebp
  80bf84:	89 e5                	mov    %esp,%ebp
  80bf86:	53                   	push   %ebx
  80bf87:	83 ec 04             	sub    $0x4,%esp
  80bf8a:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bf8d:	8b 03                	mov    (%ebx),%eax
  80bf8f:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80bf93:	7c 1d                	jl     80bfb2 <do_recv+0x2f>
    if (msg->conn->pcb.tcp != NULL) {
  80bf95:	8b 50 08             	mov    0x8(%eax),%edx
  80bf98:	85 d2                	test   %edx,%edx
  80bf9a:	74 16                	je     80bfb2 <do_recv+0x2f>
      if (msg->conn->type == NETCONN_TCP) {
  80bf9c:	83 38 10             	cmpl   $0x10,(%eax)
  80bf9f:	75 11                	jne    80bfb2 <do_recv+0x2f>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80bfa1:	83 ec 08             	sub    $0x8,%esp
  80bfa4:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80bfa8:	50                   	push   %eax
  80bfa9:	52                   	push   %edx
  80bfaa:	e8 f9 95 ff ff       	call   8055a8 <tcp_recved>
  80bfaf:	83 c4 10             	add    $0x10,%esp
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80bfb2:	83 ec 0c             	sub    $0xc,%esp
  80bfb5:	8b 03                	mov    (%ebx),%eax
  80bfb7:	ff 70 10             	pushl  0x10(%eax)
  80bfba:	e8 5b df ff ff       	call   809f1a <sys_sem_signal>
}
  80bfbf:	83 c4 10             	add    $0x10,%esp
  80bfc2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bfc5:	c9                   	leave  
  80bfc6:	c3                   	ret    

0080bfc7 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80bfc7:	55                   	push   %ebp
  80bfc8:	89 e5                	mov    %esp,%ebp
  80bfca:	83 ec 08             	sub    $0x8,%esp
  80bfcd:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bfd0:	8b 02                	mov    (%edx),%eax
  80bfd2:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80bfd6:	7c 2d                	jl     80c005 <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80bfd8:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bfdc:	74 23                	je     80c001 <do_write+0x3a>
  80bfde:	83 38 10             	cmpl   $0x10,(%eax)
  80bfe1:	75 1e                	jne    80c001 <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80bfe3:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80bfea:	8b 02                	mov    (%edx),%eax
  80bfec:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80bfef:	8b 02                	mov    (%edx),%eax
  80bff1:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80bff8:	8b 02                	mov    (%edx),%eax
  80bffa:	e8 c0 f4 ff ff       	call   80b4bf <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80bfff:	eb 14                	jmp    80c015 <do_write+0x4e>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c001:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c005:	83 ec 0c             	sub    $0xc,%esp
  80c008:	8b 02                	mov    (%edx),%eax
  80c00a:	ff 70 10             	pushl  0x10(%eax)
  80c00d:	e8 08 df ff ff       	call   809f1a <sys_sem_signal>
  80c012:	83 c4 10             	add    $0x10,%esp
}
  80c015:	c9                   	leave  
  80c016:	c3                   	ret    

0080c017 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80c017:	55                   	push   %ebp
  80c018:	89 e5                	mov    %esp,%ebp
  80c01a:	83 ec 08             	sub    $0x8,%esp
  80c01d:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80c020:	8b 08                	mov    (%eax),%ecx
  80c022:	8b 51 08             	mov    0x8(%ecx),%edx
  80c025:	85 d2                	test   %edx,%edx
  80c027:	0f 84 98 00 00 00    	je     80c0c5 <do_getaddr+0xae>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c02d:	8b 48 04             	mov    0x4(%eax),%ecx
  80c030:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c034:	74 06                	je     80c03c <do_getaddr+0x25>
  80c036:	8b 12                	mov    (%edx),%edx
  80c038:	89 11                	mov    %edx,(%ecx)
  80c03a:	eb 05                	jmp    80c041 <do_getaddr+0x2a>
  80c03c:	8b 52 04             	mov    0x4(%edx),%edx
  80c03f:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c041:	8b 08                	mov    (%eax),%ecx
  80c043:	8b 11                	mov    (%ecx),%edx
  80c045:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c04b:	83 fa 20             	cmp    $0x20,%edx
  80c04e:	74 27                	je     80c077 <do_getaddr+0x60>
  80c050:	83 fa 40             	cmp    $0x40,%edx
  80c053:	74 07                	je     80c05c <do_getaddr+0x45>
  80c055:	83 fa 10             	cmp    $0x10,%edx
  80c058:	75 6f                	jne    80c0c9 <do_getaddr+0xb2>
  80c05a:	eb 4b                	jmp    80c0a7 <do_getaddr+0x90>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80c05c:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c060:	74 0f                	je     80c071 <do_getaddr+0x5a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c062:	8b 50 08             	mov    0x8(%eax),%edx
  80c065:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c068:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c06c:	66 89 0a             	mov    %cx,(%edx)
  80c06f:	eb 58                	jmp    80c0c9 <do_getaddr+0xb2>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80c071:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c075:	eb 52                	jmp    80c0c9 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80c077:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c07b:	74 0f                	je     80c08c <do_getaddr+0x75>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c07d:	8b 50 08             	mov    0x8(%eax),%edx
  80c080:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c083:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c087:	66 89 0a             	mov    %cx,(%edx)
  80c08a:	eb 3d                	jmp    80c0c9 <do_getaddr+0xb2>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c08c:	8b 51 08             	mov    0x8(%ecx),%edx
  80c08f:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c093:	75 06                	jne    80c09b <do_getaddr+0x84>
          msg->conn->err = ERR_CONN;
  80c095:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c099:	eb 2e                	jmp    80c0c9 <do_getaddr+0xb2>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c09b:	8b 48 08             	mov    0x8(%eax),%ecx
  80c09e:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c0a2:	66 89 11             	mov    %dx,(%ecx)
  80c0a5:	eb 22                	jmp    80c0c9 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c0a7:	8b 50 08             	mov    0x8(%eax),%edx
  80c0aa:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c0ae:	74 09                	je     80c0b9 <do_getaddr+0xa2>
  80c0b0:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c0b3:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  80c0b7:	eb 07                	jmp    80c0c0 <do_getaddr+0xa9>
  80c0b9:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c0bc:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  80c0c0:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c0c3:	eb 04                	jmp    80c0c9 <do_getaddr+0xb2>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80c0c5:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80c0c9:	83 ec 0c             	sub    $0xc,%esp
  80c0cc:	8b 00                	mov    (%eax),%eax
  80c0ce:	ff 70 10             	pushl  0x10(%eax)
  80c0d1:	e8 44 de ff ff       	call   809f1a <sys_sem_signal>
}
  80c0d6:	83 c4 10             	add    $0x10,%esp
  80c0d9:	c9                   	leave  
  80c0da:	c3                   	ret    

0080c0db <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c0db:	55                   	push   %ebp
  80c0dc:	89 e5                	mov    %esp,%ebp
  80c0de:	83 ec 08             	sub    $0x8,%esp
  80c0e1:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c0e4:	8b 02                	mov    (%edx),%eax
  80c0e6:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c0ea:	74 15                	je     80c101 <do_close+0x26>
  80c0ec:	83 38 10             	cmpl   $0x10,(%eax)
  80c0ef:	75 10                	jne    80c101 <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80c0f1:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c0f8:	8b 02                	mov    (%edx),%eax
  80c0fa:	e8 09 f5 ff ff       	call   80b608 <do_close_internal>
  80c0ff:	eb 14                	jmp    80c115 <do_close+0x3a>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c101:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c105:	83 ec 0c             	sub    $0xc,%esp
  80c108:	8b 02                	mov    (%edx),%eax
  80c10a:	ff 70 10             	pushl  0x10(%eax)
  80c10d:	e8 08 de ff ff       	call   809f1a <sys_sem_signal>
  80c112:	83 c4 10             	add    $0x10,%esp
  }
}
  80c115:	c9                   	leave  
  80c116:	c3                   	ret    

0080c117 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c117:	55                   	push   %ebp
  80c118:	89 e5                	mov    %esp,%ebp
  80c11a:	57                   	push   %edi
  80c11b:	56                   	push   %esi
  80c11c:	53                   	push   %ebx
  80c11d:	83 ec 18             	sub    $0x18,%esp
  80c120:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c122:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c128:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c12c:	50                   	push   %eax
  80c12d:	e8 f3 b4 ff ff       	call   807625 <ntohs>
  80c132:	83 c4 10             	add    $0x10,%esp
  80c135:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c139:	0f 86 83 00 00 00    	jbe    80c1c2 <tcp_parseopt+0xab>
{
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c13f:	83 c6 14             	add    $0x14,%esi
  80c142:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c147:	eb 4f                	jmp    80c198 <tcp_parseopt+0x81>

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80c149:	0f b6 d3             	movzbl %bl,%edx
  80c14c:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c150:	84 c0                	test   %al,%al
  80c152:	74 6e                	je     80c1c2 <tcp_parseopt+0xab>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80c154:	3c 01                	cmp    $0x1,%al
  80c156:	75 05                	jne    80c15d <tcp_parseopt+0x46>
        ++c;
  80c158:	83 c3 01             	add    $0x1,%ebx
  80c15b:	eb 3b                	jmp    80c198 <tcp_parseopt+0x81>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80c15d:	3c 02                	cmp    $0x2,%al
  80c15f:	75 2c                	jne    80c18d <tcp_parseopt+0x76>
  80c161:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c166:	75 25                	jne    80c18d <tcp_parseopt+0x76>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c168:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80c16d:	c1 e0 08             	shl    $0x8,%eax
  80c170:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80c175:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c177:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c17a:	66 81 fa b3 05       	cmp    $0x5b3,%dx
  80c17f:	ba b4 05 00 00       	mov    $0x5b4,%edx
  80c184:	0f 47 c2             	cmova  %edx,%eax
  80c187:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80c18b:	eb 35                	jmp    80c1c2 <tcp_parseopt+0xab>
      } else {
        if (opts[c + 1] == 0) {
  80c18d:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c192:	84 c0                	test   %al,%al
  80c194:	74 2c                	je     80c1c2 <tcp_parseopt+0xab>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c196:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c198:	83 ec 0c             	sub    $0xc,%esp
  80c19b:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80c1a0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c1a4:	50                   	push   %eax
  80c1a5:	e8 7b b4 ff ff       	call   807625 <ntohs>
  80c1aa:	0f b6 d3             	movzbl %bl,%edx
  80c1ad:	66 c1 e8 0c          	shr    $0xc,%ax
  80c1b1:	0f b7 c0             	movzwl %ax,%eax
  80c1b4:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c1bb:	83 c4 10             	add    $0x10,%esp
  80c1be:	39 c2                	cmp    %eax,%edx
  80c1c0:	7c 87                	jl     80c149 <tcp_parseopt+0x32>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80c1c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c1c5:	5b                   	pop    %ebx
  80c1c6:	5e                   	pop    %esi
  80c1c7:	5f                   	pop    %edi
  80c1c8:	5d                   	pop    %ebp
  80c1c9:	c3                   	ret    

0080c1ca <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80c1ca:	55                   	push   %ebp
  80c1cb:	89 e5                	mov    %esp,%ebp
  80c1cd:	57                   	push   %edi
  80c1ce:	56                   	push   %esi
  80c1cf:	53                   	push   %ebx
  80c1d0:	83 ec 1c             	sub    $0x1c,%esp
  80c1d3:	89 c7                	mov    %eax,%edi
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80c1d5:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80c1dc:	0f 84 46 04 00 00    	je     80c628 <tcp_receive+0x45e>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c1e2:	0f b7 58 5c          	movzwl 0x5c(%eax),%ebx
  80c1e6:	8b 40 60             	mov    0x60(%eax),%eax

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c1e9:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c1ef:	39 d0                	cmp    %edx,%eax
  80c1f1:	78 26                	js     80c219 <tcp_receive+0x4f>
  80c1f3:	39 d0                	cmp    %edx,%eax
  80c1f5:	75 0b                	jne    80c202 <tcp_receive+0x38>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c1f7:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c1fd:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80c200:	78 17                	js     80c219 <tcp_receive+0x4f>
  80c202:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c208:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80c20b:	75 3b                	jne    80c248 <tcp_receive+0x7e>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c20d:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
  80c213:	66 3b 59 0e          	cmp    0xe(%ecx),%bx
  80c217:	73 2f                	jae    80c248 <tcp_receive+0x7e>
      pcb->snd_wnd = tcphdr->wnd;
  80c219:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
  80c21f:	0f b7 49 0e          	movzwl 0xe(%ecx),%ecx
  80c223:	66 89 4f 5c          	mov    %cx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c227:	89 57 60             	mov    %edx,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c22a:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80c230:	89 57 64             	mov    %edx,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c233:	66 85 c9             	test   %cx,%cx
  80c236:	74 10                	je     80c248 <tcp_receive+0x7e>
  80c238:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c23f:	74 07                	je     80c248 <tcp_receive+0x7e>
          pcb->persist_backoff = 0;
  80c241:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80c248:	8b 4f 48             	mov    0x48(%edi),%ecx
  80c24b:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80c251:	39 d1                	cmp    %edx,%ecx
  80c253:	0f 85 ad 00 00 00    	jne    80c306 <tcp_receive+0x13c>
      pcb->acked = 0;
  80c259:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c25f:	0f b7 db             	movzwl %bx,%ebx
  80c262:	01 d8                	add    %ebx,%eax
  80c264:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80c268:	03 57 60             	add    0x60(%edi),%edx
  80c26b:	39 d0                	cmp    %edx,%eax
  80c26d:	0f 85 e2 02 00 00    	jne    80c555 <tcp_receive+0x38b>
        ++pcb->dupacks;
  80c273:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c277:	83 c0 01             	add    $0x1,%eax
  80c27a:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c27d:	3c 02                	cmp    $0x2,%al
  80c27f:	0f 86 d0 02 00 00    	jbe    80c555 <tcp_receive+0x38b>
  80c285:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c289:	0f 84 c6 02 00 00    	je     80c555 <tcp_receive+0x38b>
          if (!(pcb->flags & TF_INFR)) {
  80c28f:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c293:	75 55                	jne    80c2ea <tcp_receive+0x120>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80c295:	83 ec 0c             	sub    $0xc,%esp
  80c298:	57                   	push   %edi
  80c299:	e8 93 c2 ff ff       	call   808531 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80c29e:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  80c2a2:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80c2a6:	83 c4 10             	add    $0x10,%esp
  80c2a9:	66 39 d0             	cmp    %dx,%ax
  80c2ac:	76 09                	jbe    80c2b7 <tcp_receive+0xed>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c2ae:	66 d1 ea             	shr    %dx
  80c2b1:	66 89 57 50          	mov    %dx,0x50(%edi)
  80c2b5:	eb 07                	jmp    80c2be <tcp_receive+0xf4>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80c2b7:	66 d1 e8             	shr    %ax
  80c2ba:	66 89 47 50          	mov    %ax,0x50(%edi)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80c2be:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c2c2:	0f b7 4f 50          	movzwl 0x50(%edi),%ecx
  80c2c6:	0f b7 d0             	movzwl %ax,%edx
  80c2c9:	01 d2                	add    %edx,%edx
  80c2cb:	39 d1                	cmp    %edx,%ecx
  80c2cd:	7d 07                	jge    80c2d6 <tcp_receive+0x10c>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80c2cf:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c2d2:	66 89 57 50          	mov    %dx,0x50(%edi)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c2d6:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c2d9:	66 03 47 50          	add    0x50(%edi),%ax
  80c2dd:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c2e1:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c2e5:	e9 6b 02 00 00       	jmp    80c555 <tcp_receive+0x38b>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c2ea:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c2ee:	89 d0                	mov    %edx,%eax
  80c2f0:	66 03 47 34          	add    0x34(%edi),%ax
  80c2f4:	66 39 c2             	cmp    %ax,%dx
  80c2f7:	0f 83 58 02 00 00    	jae    80c555 <tcp_receive+0x38b>
              pcb->cwnd += pcb->mss;
  80c2fd:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c301:	e9 4f 02 00 00       	jmp    80c555 <tcp_receive+0x38b>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c306:	8d 42 ff             	lea    -0x1(%edx),%eax
  80c309:	39 c8                	cmp    %ecx,%eax
  80c30b:	0f 88 9d 01 00 00    	js     80c4ae <tcp_receive+0x2e4>
  80c311:	89 d0                	mov    %edx,%eax
  80c313:	2b 47 58             	sub    0x58(%edi),%eax
  80c316:	85 c0                	test   %eax,%eax
  80c318:	0f 8f 90 01 00 00    	jg     80c4ae <tcp_receive+0x2e4>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80c31e:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80c322:	a8 04                	test   $0x4,%al
  80c324:	74 0e                	je     80c334 <tcp_receive+0x16a>
        pcb->flags &= ~TF_INFR;
  80c326:	83 e0 fb             	and    $0xfffffffb,%eax
  80c329:	88 47 20             	mov    %al,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c32c:	0f b7 47 50          	movzwl 0x50(%edi),%eax
  80c330:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  80c334:	c6 47 46 00          	movb   $0x0,0x46(%edi)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c338:	0f b7 47 40          	movzwl 0x40(%edi),%eax
  80c33c:	66 c1 f8 03          	sar    $0x3,%ax
  80c340:	66 03 47 42          	add    0x42(%edi),%ax
  80c344:	66 89 47 44          	mov    %ax,0x44(%edi)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c348:	89 d0                	mov    %edx,%eax
  80c34a:	29 c8                	sub    %ecx,%eax
  80c34c:	66 89 47 6c          	mov    %ax,0x6c(%edi)

      pcb->snd_buf += pcb->acked;
  80c350:	66 01 47 6e          	add    %ax,0x6e(%edi)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  80c354:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c358:	89 57 48             	mov    %edx,0x48(%edi)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  80c35b:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c35f:	0f 86 c3 00 00 00    	jbe    80c428 <tcp_receive+0x25e>
        if (pcb->cwnd < pcb->ssthresh) {
  80c365:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c369:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c36d:	73 18                	jae    80c387 <tcp_receive+0x1bd>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c36f:	89 c8                	mov    %ecx,%eax
  80c371:	66 03 47 34          	add    0x34(%edi),%ax
  80c375:	66 39 c1             	cmp    %ax,%cx
  80c378:	0f 83 aa 00 00 00    	jae    80c428 <tcp_receive+0x25e>
            pcb->cwnd += pcb->mss;
  80c37e:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c382:	e9 a1 00 00 00       	jmp    80c428 <tcp_receive+0x25e>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c387:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c38b:	0f af c0             	imul   %eax,%eax
  80c38e:	0f b7 d9             	movzwl %cx,%ebx
  80c391:	99                   	cltd   
  80c392:	f7 fb                	idiv   %ebx
  80c394:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c396:	66 39 c1             	cmp    %ax,%cx
  80c399:	0f 83 89 00 00 00    	jae    80c428 <tcp_receive+0x25e>
            pcb->cwnd = new_cwnd;
  80c39f:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c3a3:	e9 80 00 00 00       	jmp    80c428 <tcp_receive+0x25e>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  80c3a8:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c3ab:	8b 03                	mov    (%ebx),%eax
  80c3ad:	89 47 78             	mov    %eax,0x78(%edi)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c3b0:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c3b4:	83 ec 0c             	sub    $0xc,%esp
  80c3b7:	ff 73 04             	pushl  0x4(%ebx)
  80c3ba:	e8 07 88 ff ff       	call   804bc6 <pbuf_clen>
  80c3bf:	0f b6 c0             	movzbl %al,%eax
  80c3c2:	83 c4 10             	add    $0x10,%esp
  80c3c5:	66 39 c6             	cmp    %ax,%si
  80c3c8:	73 17                	jae    80c3e1 <tcp_receive+0x217>
  80c3ca:	83 ec 04             	sub    $0x4,%esp
  80c3cd:	68 24 2d 81 00       	push   $0x812d24
  80c3d2:	68 55 03 00 00       	push   $0x355
  80c3d7:	68 90 2e 81 00       	push   $0x812e90
  80c3dc:	e8 ad 1f 00 00       	call   80e38e <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c3e1:	83 ec 0c             	sub    $0xc,%esp
  80c3e4:	ff 73 04             	pushl  0x4(%ebx)
  80c3e7:	e8 da 87 ff ff       	call   804bc6 <pbuf_clen>
  80c3ec:	0f b6 c0             	movzbl %al,%eax
  80c3ef:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c3f3:	89 1c 24             	mov    %ebx,(%esp)
  80c3f6:	e8 b2 92 ff ff       	call   8056ad <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  80c3fb:	83 c4 10             	add    $0x10,%esp
  80c3fe:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c403:	74 23                	je     80c428 <tcp_receive+0x25e>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c405:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c409:	75 1d                	jne    80c428 <tcp_receive+0x25e>
  80c40b:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c40f:	75 17                	jne    80c428 <tcp_receive+0x25e>
  80c411:	83 ec 04             	sub    $0x4,%esp
  80c414:	68 4c 2d 81 00       	push   $0x812d4c
  80c419:	68 5c 03 00 00       	push   $0x35c
  80c41e:	68 90 2e 81 00       	push   $0x812e90
  80c423:	e8 66 1f 00 00       	call   80e38e <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80c428:	8b 47 78             	mov    0x78(%edi),%eax
  80c42b:	85 c0                	test   %eax,%eax
  80c42d:	74 68                	je     80c497 <tcp_receive+0x2cd>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c42f:	83 ec 0c             	sub    $0xc,%esp
  80c432:	8b 40 10             	mov    0x10(%eax),%eax
  80c435:	ff 70 04             	pushl  0x4(%eax)
  80c438:	e8 16 b4 ff ff       	call   807853 <ntohl>
  80c43d:	89 c6                	mov    %eax,%esi
  80c43f:	8b 47 78             	mov    0x78(%edi),%eax
  80c442:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80c446:	8b 40 10             	mov    0x10(%eax),%eax
  80c449:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c44d:	89 04 24             	mov    %eax,(%esp)
  80c450:	e8 d0 b1 ff ff       	call   807625 <ntohs>
  80c455:	83 c4 10             	add    $0x10,%esp
  80c458:	ba 01 00 00 00       	mov    $0x1,%edx
  80c45d:	a8 01                	test   $0x1,%al
  80c45f:	75 1e                	jne    80c47f <tcp_receive+0x2b5>
  80c461:	83 ec 0c             	sub    $0xc,%esp
  80c464:	8b 47 78             	mov    0x78(%edi),%eax
  80c467:	8b 40 10             	mov    0x10(%eax),%eax
  80c46a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c46e:	50                   	push   %eax
  80c46f:	e8 b1 b1 ff ff       	call   807625 <ntohs>
  80c474:	66 d1 e8             	shr    %ax
  80c477:	89 c2                	mov    %eax,%edx
  80c479:	83 e2 01             	and    $0x1,%edx
  80c47c:	83 c4 10             	add    $0x10,%esp
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80c47f:	2b 35 a4 b1 b3 00    	sub    0xb3b1a4,%esi
  80c485:	01 d3                	add    %edx,%ebx
  80c487:	01 f3                	add    %esi,%ebx
  80c489:	85 db                	test   %ebx,%ebx
  80c48b:	0f 8e 17 ff ff ff    	jle    80c3a8 <tcp_receive+0x1de>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80c491:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c495:	75 08                	jne    80c49f <tcp_receive+0x2d5>
        pcb->rtime = -1;
  80c497:	66 c7 47 32 ff ff    	movw   $0xffff,0x32(%edi)
  80c49d:	eb 06                	jmp    80c4a5 <tcp_receive+0x2db>
      else
        pcb->rtime = 0;
  80c49f:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

      pcb->polltmr = 0;
  80c4a5:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80c4a9:	e9 a7 00 00 00       	jmp    80c555 <tcp_receive+0x38b>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  80c4ae:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c4b4:	e9 9c 00 00 00       	jmp    80c555 <tcp_receive+0x38b>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  80c4b9:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80c4bc:	8b 03                	mov    (%ebx),%eax
  80c4be:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c4c1:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c4c5:	83 ec 0c             	sub    $0xc,%esp
  80c4c8:	ff 73 04             	pushl  0x4(%ebx)
  80c4cb:	e8 f6 86 ff ff       	call   804bc6 <pbuf_clen>
  80c4d0:	0f b6 c0             	movzbl %al,%eax
  80c4d3:	83 c4 10             	add    $0x10,%esp
  80c4d6:	66 39 c6             	cmp    %ax,%si
  80c4d9:	73 17                	jae    80c4f2 <tcp_receive+0x328>
  80c4db:	83 ec 04             	sub    $0x4,%esp
  80c4de:	68 24 2d 81 00       	push   $0x812d24
  80c4e3:	68 7f 03 00 00       	push   $0x37f
  80c4e8:	68 90 2e 81 00       	push   $0x812e90
  80c4ed:	e8 9c 1e 00 00       	call   80e38e <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80c4f2:	83 ec 0c             	sub    $0xc,%esp
  80c4f5:	ff 73 04             	pushl  0x4(%ebx)
  80c4f8:	e8 c9 86 ff ff       	call   804bc6 <pbuf_clen>
  80c4fd:	0f b6 c0             	movzbl %al,%eax
  80c500:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80c504:	89 1c 24             	mov    %ebx,(%esp)
  80c507:	e8 a1 91 ff ff       	call   8056ad <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  80c50c:	83 c4 10             	add    $0x10,%esp
  80c50f:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c514:	74 24                	je     80c53a <tcp_receive+0x370>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c516:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c51a:	75 1e                	jne    80c53a <tcp_receive+0x370>
  80c51c:	8b 47 74             	mov    0x74(%edi),%eax
  80c51f:	85 c0                	test   %eax,%eax
  80c521:	75 1e                	jne    80c541 <tcp_receive+0x377>
  80c523:	83 ec 04             	sub    $0x4,%esp
  80c526:	68 4c 2d 81 00       	push   $0x812d4c
  80c52b:	68 85 03 00 00       	push   $0x385
  80c530:	68 90 2e 81 00       	push   $0x812e90
  80c535:	e8 54 1e 00 00       	call   80e38e <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  80c53a:	8b 47 74             	mov    0x74(%edi),%eax
  80c53d:	85 c0                	test   %eax,%eax
  80c53f:	74 14                	je     80c555 <tcp_receive+0x38b>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80c541:	83 ec 0c             	sub    $0xc,%esp
  80c544:	8b 40 10             	mov    0x10(%eax),%eax
  80c547:	ff 70 04             	pushl  0x4(%eax)
  80c54a:	e8 e3 b0 ff ff       	call   807632 <htonl>
  80c54f:	89 47 54             	mov    %eax,0x54(%edi)
  80c552:	83 c4 10             	add    $0x10,%esp
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80c555:	8b 47 74             	mov    0x74(%edi),%eax
  80c558:	85 c0                	test   %eax,%eax
  80c55a:	74 70                	je     80c5cc <tcp_receive+0x402>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c55c:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c562:	83 ec 0c             	sub    $0xc,%esp
  80c565:	8b 40 10             	mov    0x10(%eax),%eax
  80c568:	ff 70 04             	pushl  0x4(%eax)
  80c56b:	e8 e3 b2 ff ff       	call   807853 <ntohl>
  80c570:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c573:	8b 47 74             	mov    0x74(%edi),%eax
  80c576:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80c57a:	8b 40 10             	mov    0x10(%eax),%eax
  80c57d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c581:	89 04 24             	mov    %eax,(%esp)
  80c584:	e8 9c b0 ff ff       	call   807625 <ntohs>
  80c589:	83 c4 10             	add    $0x10,%esp
  80c58c:	ba 01 00 00 00       	mov    $0x1,%edx
  80c591:	a8 01                	test   $0x1,%al
  80c593:	75 1e                	jne    80c5b3 <tcp_receive+0x3e9>
  80c595:	83 ec 0c             	sub    $0xc,%esp
  80c598:	8b 47 74             	mov    0x74(%edi),%eax
  80c59b:	8b 40 10             	mov    0x10(%eax),%eax
  80c59e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c5a2:	50                   	push   %eax
  80c5a3:	e8 7d b0 ff ff       	call   807625 <ntohs>
  80c5a8:	66 d1 e8             	shr    %ax
  80c5ab:	89 c2                	mov    %eax,%edx
  80c5ad:	83 e2 01             	and    $0x1,%edx
  80c5b0:	83 c4 10             	add    $0x10,%esp
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80c5b3:	2b 75 e4             	sub    -0x1c(%ebp),%esi
  80c5b6:	01 d3                	add    %edx,%ebx
  80c5b8:	39 de                	cmp    %ebx,%esi
  80c5ba:	78 10                	js     80c5cc <tcp_receive+0x402>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c5bc:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c5c1:	2b 47 58             	sub    0x58(%edi),%eax
  80c5c4:	85 c0                	test   %eax,%eax
  80c5c6:	0f 8e ed fe ff ff    	jle    80c4b9 <tcp_receive+0x2ef>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80c5cc:	8b 47 38             	mov    0x38(%edi),%eax
  80c5cf:	85 c0                	test   %eax,%eax
  80c5d1:	74 55                	je     80c628 <tcp_receive+0x45e>
  80c5d3:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c5d9:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80c5dc:	79 4a                	jns    80c628 <tcp_receive+0x45e>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80c5de:	0f b7 5f 40          	movzwl 0x40(%edi),%ebx
  80c5e2:	0f b7 15 40 b2 b3 00 	movzwl 0xb3b240,%edx
  80c5e9:	29 c2                	sub    %eax,%edx
  80c5eb:	89 d8                	mov    %ebx,%eax
  80c5ed:	66 c1 f8 03          	sar    $0x3,%ax
  80c5f1:	89 d1                	mov    %edx,%ecx
  80c5f3:	29 c1                	sub    %eax,%ecx
      pcb->sa += m;
  80c5f5:	01 cb                	add    %ecx,%ebx
  80c5f7:	66 89 5f 40          	mov    %bx,0x40(%edi)
      if (m < 0) {
        m = -m;
  80c5fb:	89 ca                	mov    %ecx,%edx
  80c5fd:	f7 da                	neg    %edx
  80c5ff:	66 85 c9             	test   %cx,%cx
  80c602:	0f 49 d1             	cmovns %ecx,%edx
      }
      m = m - (pcb->sv >> 2);
  80c605:	0f b7 47 42          	movzwl 0x42(%edi),%eax
      pcb->sv += m;
  80c609:	89 c1                	mov    %eax,%ecx
  80c60b:	66 c1 f9 02          	sar    $0x2,%cx
  80c60f:	29 c8                	sub    %ecx,%eax
  80c611:	01 d0                	add    %edx,%eax
  80c613:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c617:	66 c1 fb 03          	sar    $0x3,%bx
  80c61b:	01 d8                	add    %ebx,%eax
  80c61d:	66 89 47 44          	mov    %ax,0x44(%edi)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  80c621:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  80c628:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80c62f:	66 85 c0             	test   %ax,%ax
  80c632:	0f 84 8e 07 00 00    	je     80cdc6 <tcp_receive+0xbfc>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80c638:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c63b:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c641:	89 d9                	mov    %ebx,%ecx
  80c643:	29 d1                	sub    %edx,%ecx
  80c645:	89 ce                	mov    %ecx,%esi
  80c647:	83 ee 01             	sub    $0x1,%esi
  80c64a:	0f 88 27 01 00 00    	js     80c777 <tcp_receive+0x5ad>
  80c650:	8d 73 01             	lea    0x1(%ebx),%esi
  80c653:	29 d6                	sub    %edx,%esi
  80c655:	0f b7 c0             	movzwl %ax,%eax
  80c658:	29 c6                	sub    %eax,%esi
  80c65a:	85 f6                	test   %esi,%esi
  80c65c:	0f 8f 15 01 00 00    	jg     80c777 <tcp_receive+0x5ad>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  80c662:	89 c8                	mov    %ecx,%eax
      p = inseg.p;
  80c664:	8b 1d b8 b1 b3 00    	mov    0xb3b1b8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c66a:	85 db                	test   %ebx,%ebx
  80c66c:	75 17                	jne    80c685 <tcp_receive+0x4bb>
  80c66e:	83 ec 04             	sub    $0x4,%esp
  80c671:	68 a7 2e 81 00       	push   $0x812ea7
  80c676:	68 e5 03 00 00       	push   $0x3e5
  80c67b:	68 90 2e 81 00       	push   $0x812e90
  80c680:	e8 09 1d 00 00       	call   80e38e <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c685:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80c68b:	7e 17                	jle    80c6a4 <tcp_receive+0x4da>
  80c68d:	83 ec 04             	sub    $0x4,%esp
  80c690:	68 b7 2e 81 00       	push   $0x812eb7
  80c695:	68 e6 03 00 00       	push   $0x3e6
  80c69a:	68 90 2e 81 00       	push   $0x812e90
  80c69f:	e8 ea 1c 00 00       	call   80e38e <_panic>
      if (inseg.p->len < off) {
  80c6a4:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c6a8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80c6ab:	39 d1                	cmp    %edx,%ecx
  80c6ad:	7e 6a                	jle    80c719 <tcp_receive+0x54f>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c6af:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80c6b3:	0f b7 d6             	movzwl %si,%edx
  80c6b6:	39 d1                	cmp    %edx,%ecx
  80c6b8:	7e 17                	jle    80c6d1 <tcp_receive+0x507>
  80c6ba:	83 ec 04             	sub    $0x4,%esp
  80c6bd:	68 c6 2e 81 00       	push   $0x812ec6
  80c6c2:	68 e8 03 00 00       	push   $0x3e8
  80c6c7:	68 90 2e 81 00       	push   $0x812e90
  80c6cc:	e8 bd 1c 00 00       	call   80e38e <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80c6d1:	29 ce                	sub    %ecx,%esi
  80c6d3:	89 f1                	mov    %esi,%ecx
  80c6d5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
        while (p->len < off) {
          off -= p->len;
  80c6d8:	29 d0                	sub    %edx,%eax
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  80c6da:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80c6de:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80c6e4:	8b 1b                	mov    (%ebx),%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  80c6e6:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c6ea:	39 c2                	cmp    %eax,%edx
  80c6ec:	7c ea                	jl     80c6d8 <tcp_receive+0x50e>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  80c6ee:	83 ec 08             	sub    $0x8,%esp
  80c6f1:	f7 d8                	neg    %eax
  80c6f3:	98                   	cwtl   
  80c6f4:	50                   	push   %eax
  80c6f5:	53                   	push   %ebx
  80c6f6:	e8 9a 7f ff ff       	call   804695 <pbuf_header>
  80c6fb:	83 c4 10             	add    $0x10,%esp
  80c6fe:	84 c0                	test   %al,%al
  80c700:	74 44                	je     80c746 <tcp_receive+0x57c>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80c702:	83 ec 04             	sub    $0x4,%esp
  80c705:	68 d6 2e 81 00       	push   $0x812ed6
  80c70a:	68 f5 03 00 00       	push   $0x3f5
  80c70f:	68 90 2e 81 00       	push   $0x812e90
  80c714:	e8 75 1c 00 00       	call   80e38e <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80c719:	83 ec 08             	sub    $0x8,%esp
  80c71c:	f7 d9                	neg    %ecx
  80c71e:	0f bf c1             	movswl %cx,%eax
  80c721:	50                   	push   %eax
  80c722:	53                   	push   %ebx
  80c723:	e8 6d 7f ff ff       	call   804695 <pbuf_header>
  80c728:	83 c4 10             	add    $0x10,%esp
  80c72b:	84 c0                	test   %al,%al
  80c72d:	74 17                	je     80c746 <tcp_receive+0x57c>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80c72f:	83 ec 04             	sub    $0x4,%esp
  80c732:	68 d6 2e 81 00       	push   $0x812ed6
  80c737:	68 fa 03 00 00       	push   $0x3fa
  80c73c:	68 90 2e 81 00       	push   $0x812e90
  80c741:	e8 48 1c 00 00       	call   80e38e <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  80c746:	8b 43 04             	mov    0x4(%ebx),%eax
  80c749:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80c74e:	8b 57 24             	mov    0x24(%edi),%edx
  80c751:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80c758:	66 03 05 a8 b1 b3 00 	add    0xb3b1a8,%ax
  80c75f:	29 d0                	sub    %edx,%eax
  80c761:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80c767:	89 15 a8 b1 b3 00    	mov    %edx,0xb3b1a8
  80c76d:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c772:	89 50 04             	mov    %edx,0x4(%eax)
  80c775:	eb 14                	jmp    80c78b <tcp_receive+0x5c1>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80c777:	39 da                	cmp    %ebx,%edx
  80c779:	79 21                	jns    80c79c <tcp_receive+0x5d2>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  80c77b:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c77f:	83 ec 0c             	sub    $0xc,%esp
  80c782:	57                   	push   %edi
  80c783:	e8 b4 b7 ff ff       	call   807f3c <tcp_output>
  80c788:	83 c4 10             	add    $0x10,%esp
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c78b:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c791:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c794:	39 da                	cmp    %ebx,%edx
  80c796:	0f 88 13 06 00 00    	js     80cdaf <tcp_receive+0xbe5>
  80c79c:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80c7a0:	89 d1                	mov    %edx,%ecx
  80c7a2:	29 c1                	sub    %eax,%ecx
  80c7a4:	8d 41 01             	lea    0x1(%ecx),%eax
  80c7a7:	29 d8                	sub    %ebx,%eax
  80c7a9:	85 c0                	test   %eax,%eax
  80c7ab:	0f 8f fe 05 00 00    	jg     80cdaf <tcp_receive+0xbe5>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  80c7b1:	39 da                	cmp    %ebx,%edx
  80c7b3:	0f 85 77 03 00 00    	jne    80cb30 <tcp_receive+0x966>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80c7b9:	8b 4f 7c             	mov    0x7c(%edi),%ecx
  80c7bc:	85 c9                	test   %ecx,%ecx
  80c7be:	0f 84 85 00 00 00    	je     80c849 <tcp_receive+0x67f>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80c7c4:	8b 41 10             	mov    0x10(%ecx),%eax
  80c7c7:	8b 58 04             	mov    0x4(%eax),%ebx
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80c7ca:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80c7d1:	89 de                	mov    %ebx,%esi
  80c7d3:	29 c6                	sub    %eax,%esi
  80c7d5:	89 f0                	mov    %esi,%eax
  80c7d7:	29 d0                	sub    %edx,%eax
  80c7d9:	85 c0                	test   %eax,%eax
  80c7db:	7f 6c                	jg     80c849 <tcp_receive+0x67f>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  80c7dd:	66 83 79 0c 00       	cmpw   $0x0,0xc(%ecx)
  80c7e2:	74 20                	je     80c804 <tcp_receive+0x63a>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80c7e4:	29 d3                	sub    %edx,%ebx
  80c7e6:	66 89 1d c0 b1 b3 00 	mov    %bx,0xb3b1c0
            pbuf_realloc(inseg.p, inseg.len);
  80c7ed:	83 ec 08             	sub    $0x8,%esp
  80c7f0:	0f b7 db             	movzwl %bx,%ebx
  80c7f3:	53                   	push   %ebx
  80c7f4:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80c7fa:	e8 b1 82 ff ff       	call   804ab0 <pbuf_realloc>
  80c7ff:	83 c4 10             	add    $0x10,%esp
  80c802:	eb 45                	jmp    80c849 <tcp_receive+0x67f>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80c804:	83 ec 0c             	sub    $0xc,%esp
  80c807:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c80c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c810:	50                   	push   %eax
  80c811:	e8 0f ae ff ff       	call   807625 <ntohs>
  80c816:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80c818:	8b 47 7c             	mov    0x7c(%edi),%eax
  80c81b:	8b 40 10             	mov    0x10(%eax),%eax
  80c81e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c822:	89 04 24             	mov    %eax,(%esp)
  80c825:	e8 fb ad ff ff       	call   807625 <ntohs>
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80c82a:	31 d8                	xor    %ebx,%eax
  80c82c:	83 c4 10             	add    $0x10,%esp
  80c82f:	a8 03                	test   $0x3,%al
  80c831:	75 16                	jne    80c849 <tcp_receive+0x67f>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80c833:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80c836:	8b 10                	mov    (%eax),%edx
  80c838:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80c83b:	83 ec 08             	sub    $0x8,%esp
  80c83e:	50                   	push   %eax
  80c83f:	6a 04                	push   $0x4
  80c841:	e8 ae 7b ff ff       	call   8043f4 <memp_free>
  80c846:	83 c4 10             	add    $0x10,%esp
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  80c849:	0f b7 1d c0 b1 b3 00 	movzwl 0xb3b1c0,%ebx
  80c850:	83 ec 0c             	sub    $0xc,%esp
  80c853:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c858:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c85c:	50                   	push   %eax
  80c85d:	e8 c3 ad ff ff       	call   807625 <ntohs>
  80c862:	83 c4 10             	add    $0x10,%esp
  80c865:	ba 01 00 00 00       	mov    $0x1,%edx
  80c86a:	a8 01                	test   $0x1,%al
  80c86c:	75 1d                	jne    80c88b <tcp_receive+0x6c1>
  80c86e:	83 ec 0c             	sub    $0xc,%esp
  80c871:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c876:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c87a:	50                   	push   %eax
  80c87b:	e8 a5 ad ff ff       	call   807625 <ntohs>
  80c880:	66 d1 e8             	shr    %ax
  80c883:	89 c2                	mov    %eax,%edx
  80c885:	83 e2 01             	and    $0x1,%edx
  80c888:	83 c4 10             	add    $0x10,%esp
  80c88b:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80c88e:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  80c894:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80c898:	74 06                	je     80c8a0 <tcp_receive+0x6d6>
          pcb->rcv_nxt += tcplen;
  80c89a:	0f b7 d0             	movzwl %ax,%edx
  80c89d:	01 57 24             	add    %edx,0x24(%edi)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  80c8a0:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80c8a4:	66 39 d0             	cmp    %dx,%ax
  80c8a7:	76 08                	jbe    80c8b1 <tcp_receive+0x6e7>
          pcb->rcv_wnd = 0;
  80c8a9:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80c8af:	eb 06                	jmp    80c8b7 <tcp_receive+0x6ed>
        } else {
          pcb->rcv_wnd -= tcplen;
  80c8b1:	29 c2                	sub    %eax,%edx
  80c8b3:	66 89 57 28          	mov    %dx,0x28(%edi)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  80c8b7:	0f b7 57 2a          	movzwl 0x2a(%edi),%edx
  80c8bb:	66 39 d0             	cmp    %dx,%ax
  80c8be:	76 08                	jbe    80c8c8 <tcp_receive+0x6fe>
          pcb->rcv_ann_wnd = 0;
  80c8c0:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80c8c6:	eb 06                	jmp    80c8ce <tcp_receive+0x704>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  80c8c8:	29 c2                	sub    %eax,%edx
  80c8ca:	66 89 57 2a          	mov    %dx,0x2a(%edi)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  80c8ce:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80c8d3:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80c8d8:	74 0f                	je     80c8e9 <tcp_receive+0x71f>
          recv_data = inseg.p;
  80c8da:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  80c8df:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80c8e6:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80c8e9:	83 ec 0c             	sub    $0xc,%esp
  80c8ec:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c8f1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c8f5:	50                   	push   %eax
  80c8f6:	e8 2a ad ff ff       	call   807625 <ntohs>
  80c8fb:	83 c4 10             	add    $0x10,%esp
  80c8fe:	a8 01                	test   $0x1,%al
  80c900:	0f 84 dd 01 00 00    	je     80cae3 <tcp_receive+0x919>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  80c906:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
  80c90d:	e9 d1 01 00 00       	jmp    80cae3 <tcp_receive+0x919>
           is now in sequence. */
        while (pcb->ooseq != NULL &&
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  80c912:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80c917:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80c91b:	83 ec 0c             	sub    $0xc,%esp
  80c91e:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80c922:	50                   	push   %eax
  80c923:	e8 fd ac ff ff       	call   807625 <ntohs>
  80c928:	83 c4 10             	add    $0x10,%esp
  80c92b:	ba 01 00 00 00       	mov    $0x1,%edx
  80c930:	a8 01                	test   $0x1,%al
  80c932:	75 1b                	jne    80c94f <tcp_receive+0x785>
  80c934:	83 ec 0c             	sub    $0xc,%esp
  80c937:	8b 43 10             	mov    0x10(%ebx),%eax
  80c93a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c93e:	50                   	push   %eax
  80c93f:	e8 e1 ac ff ff       	call   807625 <ntohs>
  80c944:	66 d1 e8             	shr    %ax
  80c947:	89 c2                	mov    %eax,%edx
  80c949:	83 e2 01             	and    $0x1,%edx
  80c94c:	83 c4 10             	add    $0x10,%esp
  80c94f:	01 d6                	add    %edx,%esi
  80c951:	01 77 24             	add    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80c954:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80c958:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c95b:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80c95f:	83 ec 0c             	sub    $0xc,%esp
  80c962:	8b 43 10             	mov    0x10(%ebx),%eax
  80c965:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c969:	50                   	push   %eax
  80c96a:	e8 b6 ac ff ff       	call   807625 <ntohs>
  80c96f:	83 c4 10             	add    $0x10,%esp
  80c972:	ba 01 00 00 00       	mov    $0x1,%edx
  80c977:	a8 01                	test   $0x1,%al
  80c979:	75 1b                	jne    80c996 <tcp_receive+0x7cc>
  80c97b:	83 ec 0c             	sub    $0xc,%esp
  80c97e:	8b 43 10             	mov    0x10(%ebx),%eax
  80c981:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c985:	50                   	push   %eax
  80c986:	e8 9a ac ff ff       	call   807625 <ntohs>
  80c98b:	66 d1 e8             	shr    %ax
  80c98e:	89 c2                	mov    %eax,%edx
  80c990:	83 e2 01             	and    $0x1,%edx
  80c993:	83 c4 10             	add    $0x10,%esp
  80c996:	01 d6                	add    %edx,%esi
  80c998:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80c99b:	7d 08                	jge    80c9a5 <tcp_receive+0x7db>
            pcb->rcv_wnd = 0;
  80c99d:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80c9a3:	eb 41                	jmp    80c9e6 <tcp_receive+0x81c>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80c9a5:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80c9a9:	83 ec 0c             	sub    $0xc,%esp
  80c9ac:	8b 43 10             	mov    0x10(%ebx),%eax
  80c9af:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9b3:	50                   	push   %eax
  80c9b4:	e8 6c ac ff ff       	call   807625 <ntohs>
  80c9b9:	83 c4 10             	add    $0x10,%esp
  80c9bc:	ba 01 00 00 00       	mov    $0x1,%edx
  80c9c1:	a8 01                	test   $0x1,%al
  80c9c3:	75 1b                	jne    80c9e0 <tcp_receive+0x816>
  80c9c5:	83 ec 0c             	sub    $0xc,%esp
  80c9c8:	8b 43 10             	mov    0x10(%ebx),%eax
  80c9cb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9cf:	50                   	push   %eax
  80c9d0:	e8 50 ac ff ff       	call   807625 <ntohs>
  80c9d5:	66 d1 e8             	shr    %ax
  80c9d8:	89 c2                	mov    %eax,%edx
  80c9da:	83 e2 01             	and    $0x1,%edx
  80c9dd:	83 c4 10             	add    $0x10,%esp
  80c9e0:	01 d6                	add    %edx,%esi
  80c9e2:	66 29 77 28          	sub    %si,0x28(%edi)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80c9e6:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80c9ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c9ed:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80c9f1:	83 ec 0c             	sub    $0xc,%esp
  80c9f4:	8b 43 10             	mov    0x10(%ebx),%eax
  80c9f7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9fb:	50                   	push   %eax
  80c9fc:	e8 24 ac ff ff       	call   807625 <ntohs>
  80ca01:	83 c4 10             	add    $0x10,%esp
  80ca04:	ba 01 00 00 00       	mov    $0x1,%edx
  80ca09:	a8 01                	test   $0x1,%al
  80ca0b:	75 1b                	jne    80ca28 <tcp_receive+0x85e>
  80ca0d:	83 ec 0c             	sub    $0xc,%esp
  80ca10:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca13:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca17:	50                   	push   %eax
  80ca18:	e8 08 ac ff ff       	call   807625 <ntohs>
  80ca1d:	66 d1 e8             	shr    %ax
  80ca20:	89 c2                	mov    %eax,%edx
  80ca22:	83 e2 01             	and    $0x1,%edx
  80ca25:	83 c4 10             	add    $0x10,%esp
  80ca28:	01 d6                	add    %edx,%esi
  80ca2a:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80ca2d:	7d 08                	jge    80ca37 <tcp_receive+0x86d>
            pcb->rcv_ann_wnd = 0;
  80ca2f:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80ca35:	eb 41                	jmp    80ca78 <tcp_receive+0x8ae>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80ca37:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ca3b:	83 ec 0c             	sub    $0xc,%esp
  80ca3e:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca41:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca45:	50                   	push   %eax
  80ca46:	e8 da ab ff ff       	call   807625 <ntohs>
  80ca4b:	83 c4 10             	add    $0x10,%esp
  80ca4e:	ba 01 00 00 00       	mov    $0x1,%edx
  80ca53:	a8 01                	test   $0x1,%al
  80ca55:	75 1b                	jne    80ca72 <tcp_receive+0x8a8>
  80ca57:	83 ec 0c             	sub    $0xc,%esp
  80ca5a:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca5d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca61:	50                   	push   %eax
  80ca62:	e8 be ab ff ff       	call   807625 <ntohs>
  80ca67:	66 d1 e8             	shr    %ax
  80ca6a:	89 c2                	mov    %eax,%edx
  80ca6c:	83 e2 01             	and    $0x1,%edx
  80ca6f:	83 c4 10             	add    $0x10,%esp
  80ca72:	01 d6                	add    %edx,%esi
  80ca74:	66 29 77 2a          	sub    %si,0x2a(%edi)
          }

          if (cseg->p->tot_len > 0) {
  80ca78:	8b 43 04             	mov    0x4(%ebx),%eax
  80ca7b:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80ca80:	74 25                	je     80caa7 <tcp_receive+0x8dd>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  80ca82:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80ca88:	85 d2                	test   %edx,%edx
  80ca8a:	74 0f                	je     80ca9b <tcp_receive+0x8d1>
              pbuf_cat(recv_data, cseg->p);
  80ca8c:	83 ec 08             	sub    $0x8,%esp
  80ca8f:	50                   	push   %eax
  80ca90:	52                   	push   %edx
  80ca91:	e8 59 81 ff ff       	call   804bef <pbuf_cat>
  80ca96:	83 c4 10             	add    $0x10,%esp
  80ca99:	eb 05                	jmp    80caa0 <tcp_receive+0x8d6>
            } else {
              recv_data = cseg->p;
  80ca9b:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
            }
            cseg->p = NULL;
  80caa0:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80caa7:	83 ec 0c             	sub    $0xc,%esp
  80caaa:	8b 43 10             	mov    0x10(%ebx),%eax
  80caad:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cab1:	50                   	push   %eax
  80cab2:	e8 6e ab ff ff       	call   807625 <ntohs>
  80cab7:	83 c4 10             	add    $0x10,%esp
  80caba:	a8 01                	test   $0x1,%al
  80cabc:	74 14                	je     80cad2 <tcp_receive+0x908>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  80cabe:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80cac5:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80cac9:	75 07                	jne    80cad2 <tcp_receive+0x908>
              pcb->state = CLOSE_WAIT;
  80cacb:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
            } 
          }


          pcb->ooseq = cseg->next;
  80cad2:	8b 03                	mov    (%ebx),%eax
  80cad4:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80cad7:	83 ec 0c             	sub    $0xc,%esp
  80cada:	53                   	push   %ebx
  80cadb:	e8 cd 8b ff ff       	call   8056ad <tcp_seg_free>
  80cae0:	83 c4 10             	add    $0x10,%esp
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80cae3:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cae6:	85 db                	test   %ebx,%ebx
  80cae8:	74 0f                	je     80caf9 <tcp_receive+0x92f>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80caea:	8b 53 10             	mov    0x10(%ebx),%edx
  80caed:	8b 42 04             	mov    0x4(%edx),%eax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80caf0:	3b 47 24             	cmp    0x24(%edi),%eax
  80caf3:	0f 84 19 fe ff ff    	je     80c912 <tcp_receive+0x748>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80caf9:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80cafd:	a8 01                	test   $0x1,%al
  80caff:	74 1f                	je     80cb20 <tcp_receive+0x956>
  80cb01:	83 e0 fe             	and    $0xfffffffe,%eax
  80cb04:	83 c8 02             	or     $0x2,%eax
  80cb07:	88 47 20             	mov    %al,0x20(%edi)
  80cb0a:	83 ec 0c             	sub    $0xc,%esp
  80cb0d:	57                   	push   %edi
  80cb0e:	e8 29 b4 ff ff       	call   807f3c <tcp_output>
  80cb13:	83 c4 10             	add    $0x10,%esp
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80cb16:	b8 01 00 00 00       	mov    $0x1,%eax
  80cb1b:	e9 07 03 00 00       	jmp    80ce27 <tcp_receive+0xc5d>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80cb20:	83 c8 01             	or     $0x1,%eax
  80cb23:	88 47 20             	mov    %al,0x20(%edi)
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80cb26:	b8 01 00 00 00       	mov    $0x1,%eax
  80cb2b:	e9 f7 02 00 00       	jmp    80ce27 <tcp_receive+0xc5d>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  80cb30:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cb34:	83 ec 0c             	sub    $0xc,%esp
  80cb37:	57                   	push   %edi
  80cb38:	e8 ff b3 ff ff       	call   807f3c <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  80cb3d:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cb40:	83 c4 10             	add    $0x10,%esp
  80cb43:	85 db                	test   %ebx,%ebx
  80cb45:	75 1d                	jne    80cb64 <tcp_receive+0x99a>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80cb47:	83 ec 0c             	sub    $0xc,%esp
  80cb4a:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cb4f:	e8 d9 8b ff ff       	call   80572d <tcp_seg_copy>
  80cb54:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cb57:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cb5a:	b8 00 00 00 00       	mov    $0x0,%eax
  80cb5f:	e9 c3 02 00 00       	jmp    80ce27 <tcp_receive+0xc5d>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80cb64:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80cb6a:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80cb6d:	8d 51 01             	lea    0x1(%ecx),%edx
  80cb70:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80cb73:	be 00 00 00 00       	mov    $0x0,%esi
  80cb78:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80cb7b:	89 c7                	mov    %eax,%edi
  80cb7d:	eb 02                	jmp    80cb81 <tcp_receive+0x9b7>
  80cb7f:	89 d3                	mov    %edx,%ebx
  80cb81:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb84:	8b 40 04             	mov    0x4(%eax),%eax
  80cb87:	39 c8                	cmp    %ecx,%eax
  80cb89:	0f 85 a6 00 00 00    	jne    80cc35 <tcp_receive+0xa6b>
  80cb8f:	8b 7d e0             	mov    -0x20(%ebp),%edi
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cb92:	b8 00 00 00 00       	mov    $0x0,%eax
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  80cb97:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80cb9b:	66 39 0d c0 b1 b3 00 	cmp    %cx,0xb3b1c0
  80cba2:	0f 86 7f 02 00 00    	jbe    80ce27 <tcp_receive+0xc5d>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  80cba8:	83 ec 0c             	sub    $0xc,%esp
  80cbab:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cbb0:	e8 78 8b ff ff       	call   80572d <tcp_seg_copy>
  80cbb5:	89 c1                	mov    %eax,%ecx
  80cbb7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (cseg != NULL) {
  80cbba:	83 c4 10             	add    $0x10,%esp
  80cbbd:	85 c0                	test   %eax,%eax
  80cbbf:	0f 84 33 02 00 00    	je     80cdf8 <tcp_receive+0xc2e>
                  cseg->next = next->next;
  80cbc5:	8b 03                	mov    (%ebx),%eax
  80cbc7:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80cbc9:	85 f6                	test   %esi,%esi
  80cbcb:	74 04                	je     80cbd1 <tcp_receive+0xa07>
                    prev->next = cseg;
  80cbcd:	89 0e                	mov    %ecx,(%esi)
  80cbcf:	eb 06                	jmp    80cbd7 <tcp_receive+0xa0d>
                  } else {
                    pcb->ooseq = cseg;
  80cbd1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80cbd4:	89 47 7c             	mov    %eax,0x7c(%edi)
                  }
                  tcp_seg_free(next);
  80cbd7:	83 ec 0c             	sub    $0xc,%esp
  80cbda:	53                   	push   %ebx
  80cbdb:	e8 cd 8a ff ff       	call   8056ad <tcp_seg_free>
                  if (cseg->next != NULL) {
  80cbe0:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80cbe3:	8b 06                	mov    (%esi),%eax
  80cbe5:	83 c4 10             	add    $0x10,%esp
  80cbe8:	85 c0                	test   %eax,%eax
  80cbea:	0f 84 0f 02 00 00    	je     80cdff <tcp_receive+0xc35>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80cbf0:	8b 1d a8 b1 b3 00    	mov    0xb3b1a8,%ebx
  80cbf6:	8b 40 10             	mov    0x10(%eax),%eax
  80cbf9:	8b 50 04             	mov    0x4(%eax),%edx
  80cbfc:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80cc00:	29 d1                	sub    %edx,%ecx
  80cc02:	01 d9                	add    %ebx,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cc04:	b8 00 00 00 00       	mov    $0x0,%eax
                    pcb->ooseq = cseg;
                  }
                  tcp_seg_free(next);
                  if (cseg->next != NULL) {
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80cc09:	85 c9                	test   %ecx,%ecx
  80cc0b:	0f 8e 16 02 00 00    	jle    80ce27 <tcp_receive+0xc5d>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80cc11:	89 d0                	mov    %edx,%eax
  80cc13:	29 d8                	sub    %ebx,%eax
  80cc15:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80cc19:	83 ec 08             	sub    $0x8,%esp
  80cc1c:	0f b7 c0             	movzwl %ax,%eax
  80cc1f:	50                   	push   %eax
  80cc20:	ff 76 04             	pushl  0x4(%esi)
  80cc23:	e8 88 7e ff ff       	call   804ab0 <pbuf_realloc>
  80cc28:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cc2b:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc30:	e9 f2 01 00 00       	jmp    80ce27 <tcp_receive+0xc5d>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  80cc35:	85 f6                	test   %esi,%esi
  80cc37:	75 5e                	jne    80cc97 <tcp_receive+0xacd>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80cc39:	39 c1                	cmp    %eax,%ecx
  80cc3b:	0f 89 fc 00 00 00    	jns    80cd3d <tcp_receive+0xb73>
  80cc41:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cc44:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80cc4b:	01 ca                	add    %ecx,%edx
  80cc4d:	29 c2                	sub    %eax,%edx
  80cc4f:	85 d2                	test   %edx,%edx
  80cc51:	7e 1d                	jle    80cc70 <tcp_receive+0xaa6>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cc53:	29 c8                	sub    %ecx,%eax
  80cc55:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                    pbuf_realloc(inseg.p, inseg.len);
  80cc5b:	83 ec 08             	sub    $0x8,%esp
  80cc5e:	0f b7 c0             	movzwl %ax,%eax
  80cc61:	50                   	push   %eax
  80cc62:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cc68:	e8 43 7e ff ff       	call   804ab0 <pbuf_realloc>
  80cc6d:	83 c4 10             	add    $0x10,%esp
                  }
                  cseg = tcp_seg_copy(&inseg);
  80cc70:	83 ec 0c             	sub    $0xc,%esp
  80cc73:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cc78:	e8 b0 8a ff ff       	call   80572d <tcp_seg_copy>
                  if (cseg != NULL) {
  80cc7d:	83 c4 10             	add    $0x10,%esp
  80cc80:	85 c0                	test   %eax,%eax
  80cc82:	0f 84 7e 01 00 00    	je     80ce06 <tcp_receive+0xc3c>
                    cseg->next = next;
  80cc88:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80cc8a:	89 47 7c             	mov    %eax,0x7c(%edi)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cc8d:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc92:	e9 90 01 00 00       	jmp    80ce27 <tcp_receive+0xc5d>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80cc97:	8b 56 10             	mov    0x10(%esi),%edx
  80cc9a:	3b 7a 04             	cmp    0x4(%edx),%edi
  80cc9d:	0f 88 9a 00 00 00    	js     80cd3d <tcp_receive+0xb73>
  80cca3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80cca6:	29 c2                	sub    %eax,%edx
  80cca8:	85 d2                	test   %edx,%edx
  80ccaa:	0f 8f 8d 00 00 00    	jg     80cd3d <tcp_receive+0xb73>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80ccb0:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80ccb7:	01 ca                	add    %ecx,%edx
  80ccb9:	29 c2                	sub    %eax,%edx
  80ccbb:	85 d2                	test   %edx,%edx
  80ccbd:	7e 1d                	jle    80ccdc <tcp_receive+0xb12>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80ccbf:	29 c8                	sub    %ecx,%eax
  80ccc1:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                  pbuf_realloc(inseg.p, inseg.len);
  80ccc7:	83 ec 08             	sub    $0x8,%esp
  80ccca:	0f b7 c0             	movzwl %ax,%eax
  80cccd:	50                   	push   %eax
  80ccce:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80ccd4:	e8 d7 7d ff ff       	call   804ab0 <pbuf_realloc>
  80ccd9:	83 c4 10             	add    $0x10,%esp
                }

                cseg = tcp_seg_copy(&inseg);
  80ccdc:	83 ec 0c             	sub    $0xc,%esp
  80ccdf:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cce4:	e8 44 8a ff ff       	call   80572d <tcp_seg_copy>
                if (cseg != NULL) {
  80cce9:	83 c4 10             	add    $0x10,%esp
  80ccec:	85 c0                	test   %eax,%eax
  80ccee:	0f 84 19 01 00 00    	je     80ce0d <tcp_receive+0xc43>
                  cseg->next = next;
  80ccf4:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80ccf6:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80ccf8:	8b 46 10             	mov    0x10(%esi),%eax
  80ccfb:	8b 58 04             	mov    0x4(%eax),%ebx
  80ccfe:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80cd04:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80cd08:	29 d1                	sub    %edx,%ecx
  80cd0a:	01 d9                	add    %ebx,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cd0c:	b8 00 00 00 00       	mov    $0x0,%eax

                cseg = tcp_seg_copy(&inseg);
                if (cseg != NULL) {
                  cseg->next = next;
                  prev->next = cseg;
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80cd11:	85 c9                	test   %ecx,%ecx
  80cd13:	0f 8e 0e 01 00 00    	jle    80ce27 <tcp_receive+0xc5d>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80cd19:	89 d0                	mov    %edx,%eax
  80cd1b:	29 d8                	sub    %ebx,%eax
  80cd1d:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80cd21:	83 ec 08             	sub    $0x8,%esp
  80cd24:	0f b7 c0             	movzwl %ax,%eax
  80cd27:	50                   	push   %eax
  80cd28:	ff 76 04             	pushl  0x4(%esi)
  80cd2b:	e8 80 7d ff ff       	call   804ab0 <pbuf_realloc>
  80cd30:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cd33:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd38:	e9 ea 00 00 00       	jmp    80ce27 <tcp_receive+0xc5d>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80cd3d:	8b 13                	mov    (%ebx),%edx
  80cd3f:	89 de                	mov    %ebx,%esi
  80cd41:	85 d2                	test   %edx,%edx
  80cd43:	0f 85 36 fe ff ff    	jne    80cb7f <tcp_receive+0x9b5>
  80cd49:	29 c1                	sub    %eax,%ecx
  80cd4b:	85 c9                	test   %ecx,%ecx
  80cd4d:	0f 8e c1 00 00 00    	jle    80ce14 <tcp_receive+0xc4a>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  80cd53:	83 ec 0c             	sub    $0xc,%esp
  80cd56:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cd5b:	e8 cd 89 ff ff       	call   80572d <tcp_seg_copy>
  80cd60:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80cd62:	83 c4 10             	add    $0x10,%esp
  80cd65:	85 c0                	test   %eax,%eax
  80cd67:	0f 84 ae 00 00 00    	je     80ce1b <tcp_receive+0xc51>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80cd6d:	8b 43 10             	mov    0x10(%ebx),%eax
  80cd70:	8b 70 04             	mov    0x4(%eax),%esi
  80cd73:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80cd79:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80cd7d:	29 d1                	sub    %edx,%ecx
  80cd7f:	01 f1                	add    %esi,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cd81:	b8 00 00 00 00       	mov    $0x0,%eax
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
                if (next->next != NULL) {
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80cd86:	85 c9                	test   %ecx,%ecx
  80cd88:	0f 8e 99 00 00 00    	jle    80ce27 <tcp_receive+0xc5d>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80cd8e:	89 d0                	mov    %edx,%eax
  80cd90:	29 f0                	sub    %esi,%eax
  80cd92:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80cd96:	83 ec 08             	sub    $0x8,%esp
  80cd99:	0f b7 c0             	movzwl %ax,%eax
  80cd9c:	50                   	push   %eax
  80cd9d:	ff 73 04             	pushl  0x4(%ebx)
  80cda0:	e8 0b 7d ff ff       	call   804ab0 <pbuf_realloc>
  80cda5:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cda8:	b8 00 00 00 00       	mov    $0x0,%eax
  80cdad:	eb 78                	jmp    80ce27 <tcp_receive+0xc5d>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  80cdaf:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cdb3:	83 ec 0c             	sub    $0xc,%esp
  80cdb6:	57                   	push   %edi
  80cdb7:	e8 80 b1 ff ff       	call   807f3c <tcp_output>
  80cdbc:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cdbf:	b8 00 00 00 00       	mov    $0x0,%eax
  80cdc4:	eb 61                	jmp    80ce27 <tcp_receive+0xc5d>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80cdc6:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80cdcb:	8b 57 24             	mov    0x24(%edi),%edx
  80cdce:	39 d0                	cmp    %edx,%eax
  80cdd0:	78 0f                	js     80cde1 <tcp_receive+0xc17>
  80cdd2:	83 c0 01             	add    $0x1,%eax
  80cdd5:	29 d0                	sub    %edx,%eax
  80cdd7:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80cddb:	29 d0                	sub    %edx,%eax
  80cddd:	85 c0                	test   %eax,%eax
  80cddf:	7e 41                	jle    80ce22 <tcp_receive+0xc58>
      tcp_ack_now(pcb);
  80cde1:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cde5:	83 ec 0c             	sub    $0xc,%esp
  80cde8:	57                   	push   %edi
  80cde9:	e8 4e b1 ff ff       	call   807f3c <tcp_output>
  80cdee:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cdf1:	b8 00 00 00 00       	mov    $0x0,%eax
  80cdf6:	eb 2f                	jmp    80ce27 <tcp_receive+0xc5d>
  80cdf8:	b8 00 00 00 00       	mov    $0x0,%eax
  80cdfd:	eb 28                	jmp    80ce27 <tcp_receive+0xc5d>
  80cdff:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce04:	eb 21                	jmp    80ce27 <tcp_receive+0xc5d>
  80ce06:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce0b:	eb 1a                	jmp    80ce27 <tcp_receive+0xc5d>
  80ce0d:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce12:	eb 13                	jmp    80ce27 <tcp_receive+0xc5d>
  80ce14:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce19:	eb 0c                	jmp    80ce27 <tcp_receive+0xc5d>
  80ce1b:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce20:	eb 05                	jmp    80ce27 <tcp_receive+0xc5d>
  80ce22:	b8 00 00 00 00       	mov    $0x0,%eax
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
  return accepted_inseq;
}
  80ce27:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ce2a:	5b                   	pop    %ebx
  80ce2b:	5e                   	pop    %esi
  80ce2c:	5f                   	pop    %edi
  80ce2d:	5d                   	pop    %ebp
  80ce2e:	c3                   	ret    

0080ce2f <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  80ce2f:	55                   	push   %ebp
  80ce30:	89 e5                	mov    %esp,%ebp
  80ce32:	57                   	push   %edi
  80ce33:	56                   	push   %esi
  80ce34:	53                   	push   %ebx
  80ce35:	83 ec 38             	sub    $0x38,%esp
  80ce38:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  80ce3b:	8b 5e 04             	mov    0x4(%esi),%ebx
  80ce3e:	89 1d ac b1 b3 00    	mov    %ebx,0xb3b1ac
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80ce44:	0f b7 03             	movzwl (%ebx),%eax
  80ce47:	50                   	push   %eax
  80ce48:	e8 d8 a7 ff ff       	call   807625 <ntohs>
  80ce4d:	66 c1 e8 08          	shr    $0x8,%ax
  80ce51:	83 e0 0f             	and    $0xf,%eax
  80ce54:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80ce57:	a3 b0 b1 b3 00       	mov    %eax,0xb3b1b0
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80ce5c:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80ce61:	0f b7 00             	movzwl (%eax),%eax
  80ce64:	89 04 24             	mov    %eax,(%esp)
  80ce67:	e8 b9 a7 ff ff       	call   807625 <ntohs>
  80ce6c:	83 c4 08             	add    $0x8,%esp
  80ce6f:	66 c1 e8 06          	shr    $0x6,%ax
  80ce73:	83 e0 3c             	and    $0x3c,%eax
  80ce76:	f7 d8                	neg    %eax
  80ce78:	98                   	cwtl   
  80ce79:	50                   	push   %eax
  80ce7a:	56                   	push   %esi
  80ce7b:	e8 15 78 ff ff       	call   804695 <pbuf_header>
  80ce80:	83 c4 10             	add    $0x10,%esp
  80ce83:	84 c0                	test   %al,%al
  80ce85:	75 07                	jne    80ce8e <tcp_input+0x5f>
  80ce87:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80ce8c:	77 11                	ja     80ce9f <tcp_input+0x70>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80ce8e:	83 ec 0c             	sub    $0xc,%esp
  80ce91:	56                   	push   %esi
  80ce92:	e8 d0 78 ff ff       	call   804767 <pbuf_free>
    return;
  80ce97:	83 c4 10             	add    $0x10,%esp
  80ce9a:	e9 fb 0c 00 00       	jmp    80db9a <tcp_input+0xd6b>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80ce9f:	83 ec 08             	sub    $0x8,%esp
  80cea2:	ff 75 0c             	pushl  0xc(%ebp)
  80cea5:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80ceaa:	83 c0 10             	add    $0x10,%eax
  80cead:	50                   	push   %eax
  80ceae:	e8 5d 95 ff ff       	call   806410 <ip_addr_isbroadcast>
  80ceb3:	83 c4 10             	add    $0x10,%esp
  80ceb6:	84 c0                	test   %al,%al
  80ceb8:	75 2a                	jne    80cee4 <tcp_input+0xb5>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80ceba:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80cebf:	8b 58 10             	mov    0x10(%eax),%ebx
  80cec2:	83 ec 0c             	sub    $0xc,%esp
  80cec5:	68 00 00 00 f0       	push   $0xf0000000
  80ceca:	e8 84 a9 ff ff       	call   807853 <ntohl>
  80cecf:	21 c3                	and    %eax,%ebx
  80ced1:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80ced8:	e8 76 a9 ff ff       	call   807853 <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80cedd:	83 c4 10             	add    $0x10,%esp
  80cee0:	39 c3                	cmp    %eax,%ebx
  80cee2:	75 11                	jne    80cef5 <tcp_input+0xc6>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cee4:	83 ec 0c             	sub    $0xc,%esp
  80cee7:	56                   	push   %esi
  80cee8:	e8 7a 78 ff ff       	call   804767 <pbuf_free>
    return;
  80ceed:	83 c4 10             	add    $0x10,%esp
  80cef0:	e9 a5 0c 00 00       	jmp    80db9a <tcp_input+0xd6b>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  80cef5:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80cefa:	83 ec 0c             	sub    $0xc,%esp
  80cefd:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80cf01:	52                   	push   %edx
  80cf02:	6a 06                	push   $0x6
  80cf04:	8d 50 10             	lea    0x10(%eax),%edx
  80cf07:	52                   	push   %edx
  80cf08:	83 c0 0c             	add    $0xc,%eax
  80cf0b:	50                   	push   %eax
  80cf0c:	56                   	push   %esi
  80cf0d:	e8 ed a3 ff ff       	call   8072ff <inet_chksum_pseudo>
  80cf12:	83 c4 20             	add    $0x20,%esp
  80cf15:	66 85 c0             	test   %ax,%ax
  80cf18:	74 11                	je     80cf2b <tcp_input+0xfc>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cf1a:	83 ec 0c             	sub    $0xc,%esp
  80cf1d:	56                   	push   %esi
  80cf1e:	e8 44 78 ff ff       	call   804767 <pbuf_free>
    return;
  80cf23:	83 c4 10             	add    $0x10,%esp
  80cf26:	e9 6f 0c 00 00       	jmp    80db9a <tcp_input+0xd6b>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  80cf2b:	83 ec 0c             	sub    $0xc,%esp
  80cf2e:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80cf33:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf37:	50                   	push   %eax
  80cf38:	e8 e8 a6 ff ff       	call   807625 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80cf3d:	83 c4 08             	add    $0x8,%esp
  80cf40:	66 c1 e8 0c          	shr    $0xc,%ax
  80cf44:	f7 d8                	neg    %eax
  80cf46:	c1 e0 02             	shl    $0x2,%eax
  80cf49:	98                   	cwtl   
  80cf4a:	50                   	push   %eax
  80cf4b:	56                   	push   %esi
  80cf4c:	e8 44 77 ff ff       	call   804695 <pbuf_header>
  80cf51:	83 c4 10             	add    $0x10,%esp
  80cf54:	84 c0                	test   %al,%al
  80cf56:	74 11                	je     80cf69 <tcp_input+0x13a>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cf58:	83 ec 0c             	sub    $0xc,%esp
  80cf5b:	56                   	push   %esi
  80cf5c:	e8 06 78 ff ff       	call   804767 <pbuf_free>
    return;
  80cf61:	83 c4 10             	add    $0x10,%esp
  80cf64:	e9 31 0c 00 00       	jmp    80db9a <tcp_input+0xd6b>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  80cf69:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80cf6f:	83 ec 0c             	sub    $0xc,%esp
  80cf72:	0f b7 03             	movzwl (%ebx),%eax
  80cf75:	50                   	push   %eax
  80cf76:	e8 aa a6 ff ff       	call   807625 <ntohs>
  80cf7b:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80cf7e:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80cf84:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80cf88:	89 04 24             	mov    %eax,(%esp)
  80cf8b:	e8 95 a6 ff ff       	call   807625 <ntohs>
  80cf90:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80cf94:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80cf9a:	83 c4 04             	add    $0x4,%esp
  80cf9d:	ff 73 04             	pushl  0x4(%ebx)
  80cfa0:	e8 ae a8 ff ff       	call   807853 <ntohl>
  80cfa5:	89 43 04             	mov    %eax,0x4(%ebx)
  80cfa8:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80cfad:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80cfb3:	83 c4 04             	add    $0x4,%esp
  80cfb6:	ff 73 08             	pushl  0x8(%ebx)
  80cfb9:	e8 95 a8 ff ff       	call   807853 <ntohl>
  80cfbe:	89 43 08             	mov    %eax,0x8(%ebx)
  80cfc1:	a3 a4 b1 b3 00       	mov    %eax,0xb3b1a4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80cfc6:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80cfcc:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80cfd0:	89 04 24             	mov    %eax,(%esp)
  80cfd3:	e8 4d a6 ff ff       	call   807625 <ntohs>
  80cfd8:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80cfdc:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80cfe1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cfe5:	89 04 24             	mov    %eax,(%esp)
  80cfe8:	e8 38 a6 ff ff       	call   807625 <ntohs>
  80cfed:	89 c1                	mov    %eax,%ecx
  80cfef:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80cff3:	83 e0 3f             	and    $0x3f,%eax
  80cff6:	a2 a0 b1 b3 00       	mov    %al,0xb3b1a0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80cffb:	83 c4 10             	add    $0x10,%esp
  80cffe:	89 c8                	mov    %ecx,%eax
  80d000:	a8 03                	test   $0x3,%al
  80d002:	0f 95 c0             	setne  %al
  80d005:	0f b6 c0             	movzbl %al,%eax
  80d008:	66 03 46 08          	add    0x8(%esi),%ax
  80d00c:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80d010:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d016:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d01b:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  80d01e:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d024:	8b 0d ac b1 b3 00    	mov    0xb3b1ac,%ecx
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d02a:	89 c3                	mov    %eax,%ebx
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  80d02c:	bf 00 00 00 00       	mov    $0x0,%edi

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d031:	e9 d1 00 00 00       	jmp    80d107 <tcp_input+0x2d8>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d036:	8b 43 10             	mov    0x10(%ebx),%eax
  80d039:	85 c0                	test   %eax,%eax
  80d03b:	75 17                	jne    80d054 <tcp_input+0x225>
  80d03d:	83 ec 04             	sub    $0x4,%esp
  80d040:	68 6c 2d 81 00       	push   $0x812d6c
  80d045:	68 b5 00 00 00       	push   $0xb5
  80d04a:	68 90 2e 81 00       	push   $0x812e90
  80d04f:	e8 3a 13 00 00       	call   80e38e <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d054:	83 f8 0a             	cmp    $0xa,%eax
  80d057:	75 17                	jne    80d070 <tcp_input+0x241>
  80d059:	83 ec 04             	sub    $0x4,%esp
  80d05c:	68 94 2d 81 00       	push   $0x812d94
  80d061:	68 b6 00 00 00       	push   $0xb6
  80d066:	68 90 2e 81 00       	push   $0x812e90
  80d06b:	e8 1e 13 00 00       	call   80e38e <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d070:	83 f8 01             	cmp    $0x1,%eax
  80d073:	75 17                	jne    80d08c <tcp_input+0x25d>
  80d075:	83 ec 04             	sub    $0x4,%esp
  80d078:	68 c0 2d 81 00       	push   $0x812dc0
  80d07d:	68 b7 00 00 00       	push   $0xb7
  80d082:	68 90 2e 81 00       	push   $0x812e90
  80d087:	e8 02 13 00 00       	call   80e38e <_panic>
    if (pcb->remote_port == tcphdr->src &&
  80d08c:	0f b7 02             	movzwl (%edx),%eax
  80d08f:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d093:	75 6d                	jne    80d102 <tcp_input+0x2d3>
  80d095:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d099:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d09d:	75 63                	jne    80d102 <tcp_input+0x2d3>
       pcb->local_port == tcphdr->dest &&
  80d09f:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d0a2:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d0a5:	75 5b                	jne    80d102 <tcp_input+0x2d3>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d0a7:	8b 41 10             	mov    0x10(%ecx),%eax
  80d0aa:	39 03                	cmp    %eax,(%ebx)
  80d0ac:	75 54                	jne    80d102 <tcp_input+0x2d3>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d0ae:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d0b1:	39 c3                	cmp    %eax,%ebx
  80d0b3:	75 17                	jne    80d0cc <tcp_input+0x29d>
  80d0b5:	83 ec 04             	sub    $0x4,%esp
  80d0b8:	68 e8 2d 81 00       	push   $0x812de8
  80d0bd:	68 c0 00 00 00       	push   $0xc0
  80d0c2:	68 90 2e 81 00       	push   $0x812e90
  80d0c7:	e8 c2 12 00 00       	call   80e38e <_panic>
      if (prev != NULL) {
  80d0cc:	85 ff                	test   %edi,%edi
  80d0ce:	0f 84 80 02 00 00    	je     80d354 <tcp_input+0x525>
        prev->next = pcb->next;
  80d0d4:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d0d7:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d0da:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80d0dd:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d0e3:	39 c3                	cmp    %eax,%ebx
  80d0e5:	0f 85 69 02 00 00    	jne    80d354 <tcp_input+0x525>
  80d0eb:	83 ec 04             	sub    $0x4,%esp
  80d0ee:	68 14 2e 81 00       	push   $0x812e14
  80d0f3:	68 c6 00 00 00       	push   $0xc6
  80d0f8:	68 90 2e 81 00       	push   $0x812e90
  80d0fd:	e8 8c 12 00 00       	call   80e38e <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d102:	89 df                	mov    %ebx,%edi
  80d104:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d107:	85 db                	test   %ebx,%ebx
  80d109:	0f 85 27 ff ff ff    	jne    80d036 <tcp_input+0x207>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d10f:	8b 1d 50 b2 b3 00    	mov    0xb3b250,%ebx
  80d115:	e9 88 00 00 00       	jmp    80d1a2 <tcp_input+0x373>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d11a:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80d11e:	74 17                	je     80d137 <tcp_input+0x308>
  80d120:	83 ec 04             	sub    $0x4,%esp
  80d123:	68 40 2e 81 00       	push   $0x812e40
  80d128:	68 d0 00 00 00       	push   $0xd0
  80d12d:	68 90 2e 81 00       	push   $0x812e90
  80d132:	e8 57 12 00 00       	call   80e38e <_panic>
      if (pcb->remote_port == tcphdr->src &&
  80d137:	0f b7 02             	movzwl (%edx),%eax
  80d13a:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d13e:	75 5f                	jne    80d19f <tcp_input+0x370>
  80d140:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d144:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d148:	75 55                	jne    80d19f <tcp_input+0x370>
         pcb->local_port == tcphdr->dest &&
  80d14a:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d14d:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d150:	75 4d                	jne    80d19f <tcp_input+0x370>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d152:	8b 41 10             	mov    0x10(%ecx),%eax
  80d155:	39 03                	cmp    %eax,(%ebx)
  80d157:	75 46                	jne    80d19f <tcp_input+0x370>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d159:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80d15d:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d163:	89 c2                	mov    %eax,%edx
  80d165:	2b 53 24             	sub    0x24(%ebx),%edx
  80d168:	85 d2                	test   %edx,%edx
  80d16a:	7e 03                	jle    80d16f <tcp_input+0x340>
    pcb->rcv_nxt = seqno + tcplen;
  80d16c:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  80d16f:	66 83 7d d6 00       	cmpw   $0x0,-0x2a(%ebp)
  80d174:	74 10                	je     80d186 <tcp_input+0x357>
    tcp_ack_now(pcb);
  80d176:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d17a:	83 ec 0c             	sub    $0xc,%esp
  80d17d:	53                   	push   %ebx
  80d17e:	e8 b9 ad ff ff       	call   807f3c <tcp_output>
  80d183:	83 c4 10             	add    $0x10,%esp
  }
  return tcp_output(pcb);
  80d186:	83 ec 0c             	sub    $0xc,%esp
  80d189:	53                   	push   %ebx
  80d18a:	e8 ad ad ff ff       	call   807f3c <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  80d18f:	89 34 24             	mov    %esi,(%esp)
  80d192:	e8 d0 75 ff ff       	call   804767 <pbuf_free>
        return;
  80d197:	83 c4 10             	add    $0x10,%esp
  80d19a:	e9 fb 09 00 00       	jmp    80db9a <tcp_input+0xd6b>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d19f:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d1a2:	85 db                	test   %ebx,%ebx
  80d1a4:	0f 85 70 ff ff ff    	jne    80d11a <tcp_input+0x2eb>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d1aa:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80d1af:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d1b2:	89 c3                	mov    %eax,%ebx
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  80d1b4:	bf 00 00 00 00       	mov    $0x0,%edi
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d1b9:	e9 89 01 00 00       	jmp    80d347 <tcp_input+0x518>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d1be:	85 db                	test   %ebx,%ebx
  80d1c0:	74 0f                	je     80d1d1 <tcp_input+0x3a2>
  80d1c2:	8b 03                	mov    (%ebx),%eax
  80d1c4:	85 c0                	test   %eax,%eax
  80d1c6:	74 09                	je     80d1d1 <tcp_input+0x3a2>
  80d1c8:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d1cb:	0f 85 71 01 00 00    	jne    80d342 <tcp_input+0x513>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d1d1:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d1d5:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d1d9:	0f 85 63 01 00 00    	jne    80d342 <tcp_input+0x513>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  80d1df:	85 ff                	test   %edi,%edi
  80d1e1:	74 12                	je     80d1f5 <tcp_input+0x3c6>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d1e3:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d1e6:	89 47 0c             	mov    %eax,0xc(%edi)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d1e9:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d1ec:	89 43 0c             	mov    %eax,0xc(%ebx)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d1ef:	89 1d 44 b2 b3 00    	mov    %ebx,0xb3b244
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  80d1f5:	f6 45 d4 10          	testb  $0x10,-0x2c(%ebp)
  80d1f9:	74 35                	je     80d230 <tcp_input+0x401>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  80d1fb:	83 ec 08             	sub    $0x8,%esp
  80d1fe:	0f b7 02             	movzwl (%edx),%eax
  80d201:	50                   	push   %eax
  80d202:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d206:	50                   	push   %eax
  80d207:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d20a:	50                   	push   %eax
  80d20b:	83 c1 10             	add    $0x10,%ecx
  80d20e:	51                   	push   %ecx
  80d20f:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80d213:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d219:	50                   	push   %eax
  80d21a:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d21f:	83 c0 01             	add    $0x1,%eax
  80d222:	50                   	push   %eax
  80d223:	e8 8b b1 ff ff       	call   8083b3 <tcp_rst>
  80d228:	83 c4 20             	add    $0x20,%esp
  80d22b:	e9 01 01 00 00       	jmp    80d331 <tcp_input+0x502>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  80d230:	f6 45 d4 02          	testb  $0x2,-0x2c(%ebp)
  80d234:	0f 84 f7 00 00 00    	je     80d331 <tcp_input+0x502>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  80d23a:	83 ec 0c             	sub    $0xc,%esp
  80d23d:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  80d241:	50                   	push   %eax
  80d242:	e8 73 8e ff ff       	call   8060ba <tcp_alloc>
  80d247:	89 c7                	mov    %eax,%edi
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  80d249:	83 c4 10             	add    $0x10,%esp
  80d24c:	85 c0                	test   %eax,%eax
  80d24e:	0f 84 dd 00 00 00    	je     80d331 <tcp_input+0x502>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d254:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d259:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80d25c:	74 05                	je     80d263 <tcp_input+0x434>
  80d25e:	8b 50 10             	mov    0x10(%eax),%edx
  80d261:	eb 05                	jmp    80d268 <tcp_input+0x439>
  80d263:	ba 00 00 00 00       	mov    $0x0,%edx
  80d268:	89 17                	mov    %edx,(%edi)
    npcb->local_port = pcb->local_port;
  80d26a:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  80d26e:	66 89 57 1c          	mov    %dx,0x1c(%edi)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d272:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80d275:	74 05                	je     80d27c <tcp_input+0x44d>
  80d277:	8b 40 0c             	mov    0xc(%eax),%eax
  80d27a:	eb 05                	jmp    80d281 <tcp_input+0x452>
  80d27c:	b8 00 00 00 00       	mov    $0x0,%eax
  80d281:	89 47 04             	mov    %eax,0x4(%edi)
    npcb->remote_port = tcphdr->src;
  80d284:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d28a:	0f b7 02             	movzwl (%edx),%eax
  80d28d:	66 89 47 1e          	mov    %ax,0x1e(%edi)
    npcb->state = SYN_RCVD;
  80d291:	c7 47 10 03 00 00 00 	movl   $0x3,0x10(%edi)
    npcb->rcv_nxt = seqno + 1;
  80d298:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d29d:	8d 48 01             	lea    0x1(%eax),%ecx
  80d2a0:	89 4f 24             	mov    %ecx,0x24(%edi)
    npcb->snd_wnd = tcphdr->wnd;
  80d2a3:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d2a7:	66 89 57 5c          	mov    %dx,0x5c(%edi)
    npcb->ssthresh = npcb->snd_wnd;
  80d2ab:	66 89 57 50          	mov    %dx,0x50(%edi)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d2af:	83 e8 01             	sub    $0x1,%eax
  80d2b2:	89 47 60             	mov    %eax,0x60(%edi)
    npcb->callback_arg = pcb->callback_arg;
  80d2b5:	8b 43 18             	mov    0x18(%ebx),%eax
  80d2b8:	89 47 18             	mov    %eax,0x18(%edi)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  80d2bb:	8b 43 20             	mov    0x20(%ebx),%eax
  80d2be:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d2c4:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80d2c8:	66 25 99 01          	and    $0x199,%ax
  80d2cc:	66 89 47 08          	mov    %ax,0x8(%edi)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  80d2d0:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d2d5:	89 47 0c             	mov    %eax,0xc(%edi)
  80d2d8:	89 3d 3c b2 b3 00    	mov    %edi,0xb3b23c
  80d2de:	e8 c3 4e ff ff       	call   8021a6 <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  80d2e3:	89 f8                	mov    %edi,%eax
  80d2e5:	e8 2d ee ff ff       	call   80c117 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d2ea:	83 ec 08             	sub    $0x8,%esp
  80d2ed:	8d 47 04             	lea    0x4(%edi),%eax
  80d2f0:	50                   	push   %eax
  80d2f1:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80d2f5:	50                   	push   %eax
  80d2f6:	e8 4c 8f ff ff       	call   806247 <tcp_eff_send_mss>
  80d2fb:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  80d2ff:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80d306:	e8 27 a3 ff ff       	call   807632 <htonl>
  80d30b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80d30e:	83 c4 0c             	add    $0xc,%esp
  80d311:	6a 04                	push   $0x4
  80d313:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d316:	50                   	push   %eax
  80d317:	6a 00                	push   $0x0
  80d319:	6a 12                	push   $0x12
  80d31b:	6a 00                	push   $0x0
  80d31d:	6a 00                	push   $0x0
  80d31f:	57                   	push   %edi
  80d320:	e8 3e a5 ff ff       	call   807863 <tcp_enqueue>
    return tcp_output(npcb);
  80d325:	83 c4 14             	add    $0x14,%esp
  80d328:	57                   	push   %edi
  80d329:	e8 0e ac ff ff       	call   807f3c <tcp_output>
  80d32e:	83 c4 10             	add    $0x10,%esp
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  80d331:	83 ec 0c             	sub    $0xc,%esp
  80d334:	56                   	push   %esi
  80d335:	e8 2d 74 ff ff       	call   804767 <pbuf_free>
        return;
  80d33a:	83 c4 10             	add    $0x10,%esp
  80d33d:	e9 58 08 00 00       	jmp    80db9a <tcp_input+0xd6b>
  80d342:	89 df                	mov    %ebx,%edi
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d344:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d347:	85 db                	test   %ebx,%ebx
  80d349:	0f 85 6f fe ff ff    	jne    80d1be <tcp_input+0x38f>
  80d34f:	e9 b5 07 00 00       	jmp    80db09 <tcp_input+0xcda>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  80d354:	c7 05 b4 b1 b3 00 00 	movl   $0x0,0xb3b1b4
  80d35b:	00 00 00 
    inseg.len = p->tot_len;
  80d35e:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d362:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
    inseg.dataptr = p->payload;
  80d368:	8b 46 04             	mov    0x4(%esi),%eax
  80d36b:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
    inseg.p = p;
  80d370:	89 35 b8 b1 b3 00    	mov    %esi,0xb3b1b8
    inseg.tcphdr = tcphdr;
  80d376:	89 15 c4 b1 b3 00    	mov    %edx,0xb3b1c4

    recv_data = NULL;
  80d37c:	c7 05 98 b1 b3 00 00 	movl   $0x0,0xb3b198
  80d383:	00 00 00 
    recv_flags = 0;
  80d386:	c6 05 9c b1 b3 00 00 	movb   $0x0,0xb3b19c

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80d38d:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80d393:	85 c0                	test   %eax,%eax
  80d395:	74 45                	je     80d3dc <tcp_input+0x5ad>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d397:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80d39d:	85 d2                	test   %edx,%edx
  80d39f:	74 12                	je     80d3b3 <tcp_input+0x584>
  80d3a1:	6a 00                	push   $0x0
  80d3a3:	50                   	push   %eax
  80d3a4:	53                   	push   %ebx
  80d3a5:	ff 73 18             	pushl  0x18(%ebx)
  80d3a8:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d3aa:	83 c4 10             	add    $0x10,%esp
  80d3ad:	84 c0                	test   %al,%al
  80d3af:	74 0e                	je     80d3bf <tcp_input+0x590>
  80d3b1:	eb 18                	jmp    80d3cb <tcp_input+0x59c>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d3b3:	83 ec 0c             	sub    $0xc,%esp
  80d3b6:	50                   	push   %eax
  80d3b7:	e8 ab 73 ff ff       	call   804767 <pbuf_free>
  80d3bc:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80d3bf:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80d3c6:	00 00 00 
  80d3c9:	eb 11                	jmp    80d3dc <tcp_input+0x5ad>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  80d3cb:	83 ec 0c             	sub    $0xc,%esp
  80d3ce:	56                   	push   %esi
  80d3cf:	e8 93 73 ff ff       	call   804767 <pbuf_free>
        return;
  80d3d4:	83 c4 10             	add    $0x10,%esp
  80d3d7:	e9 be 07 00 00       	jmp    80db9a <tcp_input+0xd6b>
      }
    }

    tcp_input_pcb = pcb;
  80d3dc:	89 1d 58 b2 b3 00    	mov    %ebx,0xb3b258
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  80d3e2:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d3e9:	a8 04                	test   $0x4,%al
  80d3eb:	74 5e                	je     80d44b <tcp_input+0x61c>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  80d3ed:	8b 53 10             	mov    0x10(%ebx),%edx
  80d3f0:	83 fa 02             	cmp    $0x2,%edx
  80d3f3:	75 0f                	jne    80d404 <tcp_input+0x5d5>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80d3f5:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d3fa:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d3fd:	74 3c                	je     80d43b <tcp_input+0x60c>
  80d3ff:	e9 b1 05 00 00       	jmp    80d9b5 <tcp_input+0xb86>
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d404:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d409:	2b 43 24             	sub    0x24(%ebx),%eax
  80d40c:	0f 88 a3 05 00 00    	js     80d9b5 <tcp_input+0xb86>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80d412:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d416:	29 c8                	sub    %ecx,%eax
  80d418:	85 c0                	test   %eax,%eax
  80d41a:	0f 8f 46 07 00 00    	jg     80db66 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d420:	85 d2                	test   %edx,%edx
  80d422:	75 17                	jne    80d43b <tcp_input+0x60c>
  80d424:	83 ec 04             	sub    $0x4,%esp
  80d427:	68 70 2e 81 00       	push   $0x812e70
  80d42c:	68 09 02 00 00       	push   $0x209
  80d431:	68 90 2e 81 00       	push   $0x812e90
  80d436:	e8 53 0f 00 00       	call   80e38e <_panic>
      recv_flags = TF_RESET;
  80d43b:	c6 05 9c b1 b3 00 08 	movb   $0x8,0xb3b19c
      pcb->flags &= ~TF_ACK_DELAY;
  80d442:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  80d446:	e9 1b 07 00 00       	jmp    80db66 <tcp_input+0xd37>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  80d44b:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  80d451:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80d454:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  80d45b:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80d45f:	0f 87 50 05 00 00    	ja     80d9b5 <tcp_input+0xb86>
  80d465:	8b 53 10             	mov    0x10(%ebx),%edx
  80d468:	ff 24 95 14 2f 81 00 	jmp    *0x812f14(,%edx,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80d46f:	83 e0 12             	and    $0x12,%eax
  80d472:	3c 12                	cmp    $0x12,%al
  80d474:	0f 85 04 01 00 00    	jne    80d57e <tcp_input+0x74f>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80d47a:	83 ec 0c             	sub    $0xc,%esp
  80d47d:	8b 43 78             	mov    0x78(%ebx),%eax
  80d480:	8b 40 10             	mov    0x10(%eax),%eax
  80d483:	ff 70 04             	pushl  0x4(%eax)
  80d486:	e8 c8 a3 ff ff       	call   807853 <ntohl>
  80d48b:	8d 50 01             	lea    0x1(%eax),%edx
  80d48e:	83 c4 10             	add    $0x10,%esp
  80d491:	3b 15 a4 b1 b3 00    	cmp    0xb3b1a4,%edx
  80d497:	0f 85 e1 00 00 00    	jne    80d57e <tcp_input+0x74f>
      pcb->snd_buf++;
  80d49d:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80d4a2:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d4a7:	8d 48 01             	lea    0x1(%eax),%ecx
  80d4aa:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80d4ad:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80d4b0:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d4b6:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d4ba:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80d4be:	83 e8 01             	sub    $0x1,%eax
  80d4c1:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80d4c4:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  80d4cb:	89 d8                	mov    %ebx,%eax
  80d4cd:	e8 45 ec ff ff       	call   80c117 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80d4d2:	83 ec 08             	sub    $0x8,%esp
  80d4d5:	8d 43 04             	lea    0x4(%ebx),%eax
  80d4d8:	50                   	push   %eax
  80d4d9:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d4dd:	50                   	push   %eax
  80d4de:	e8 64 8d ff ff       	call   806247 <tcp_eff_send_mss>
  80d4e3:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  80d4e7:	6b d0 0a             	imul   $0xa,%eax,%edx
  80d4ea:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d4ee:	83 c4 10             	add    $0x10,%esp
  80d4f1:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80d4f4:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80d4f9:	0f 44 c2             	cmove  %edx,%eax
  80d4fc:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d500:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80d504:	66 85 c0             	test   %ax,%ax
  80d507:	75 17                	jne    80d520 <tcp_input+0x6f1>
  80d509:	83 ec 04             	sub    $0x4,%esp
  80d50c:	68 e9 2e 81 00       	push   $0x812ee9
  80d511:	68 35 02 00 00       	push   $0x235
  80d516:	68 90 2e 81 00       	push   $0x812e90
  80d51b:	e8 6e 0e 00 00       	call   80e38e <_panic>
      --pcb->snd_queuelen;
  80d520:	83 e8 01             	sub    $0x1,%eax
  80d523:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  80d527:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80d52a:	8b 10                	mov    (%eax),%edx
  80d52c:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80d52f:	85 d2                	test   %edx,%edx
  80d531:	75 08                	jne    80d53b <tcp_input+0x70c>
        pcb->rtime = -1;
  80d533:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80d539:	eb 0a                	jmp    80d545 <tcp_input+0x716>
      else {
        pcb->rtime = 0;
  80d53b:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80d541:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  80d545:	83 ec 0c             	sub    $0xc,%esp
  80d548:	50                   	push   %eax
  80d549:	e8 5f 81 ff ff       	call   8056ad <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80d54e:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80d554:	83 c4 10             	add    $0x10,%esp
  80d557:	85 c0                	test   %eax,%eax
  80d559:	74 0e                	je     80d569 <tcp_input+0x73a>
  80d55b:	83 ec 04             	sub    $0x4,%esp
  80d55e:	6a 00                	push   $0x0
  80d560:	53                   	push   %ebx
  80d561:	ff 73 18             	pushl  0x18(%ebx)
  80d564:	ff d0                	call   *%eax
  80d566:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80d569:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d56d:	83 ec 0c             	sub    $0xc,%esp
  80d570:	53                   	push   %ebx
  80d571:	e8 c6 a9 ff ff       	call   807f3c <tcp_output>
  80d576:	83 c4 10             	add    $0x10,%esp
  80d579:	e9 e8 05 00 00       	jmp    80db66 <tcp_input+0xd37>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  80d57e:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d585:	0f 84 db 05 00 00    	je     80db66 <tcp_input+0xd37>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80d58b:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d591:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d596:	83 ec 08             	sub    $0x8,%esp
  80d599:	0f b7 0a             	movzwl (%edx),%ecx
  80d59c:	51                   	push   %ecx
  80d59d:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80d5a1:	52                   	push   %edx
  80d5a2:	8d 50 0c             	lea    0xc(%eax),%edx
  80d5a5:	52                   	push   %edx
  80d5a6:	83 c0 10             	add    $0x10,%eax
  80d5a9:	50                   	push   %eax
  80d5aa:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d5b1:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d5b7:	50                   	push   %eax
  80d5b8:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80d5be:	e8 f0 ad ff ff       	call   8083b3 <tcp_rst>
  80d5c3:	83 c4 20             	add    $0x20,%esp
  80d5c6:	e9 9b 05 00 00       	jmp    80db66 <tcp_input+0xd37>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  80d5cb:	83 e0 14             	and    $0x14,%eax
  80d5ce:	3c 10                	cmp    $0x10,%al
  80d5d0:	0f 85 90 05 00 00    	jne    80db66 <tcp_input+0xd37>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80d5d6:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80d5dc:	8d 42 ff             	lea    -0x1(%edx),%eax
  80d5df:	3b 43 48             	cmp    0x48(%ebx),%eax
  80d5e2:	0f 88 b5 00 00 00    	js     80d69d <tcp_input+0x86e>
  80d5e8:	89 d0                	mov    %edx,%eax
  80d5ea:	2b 43 54             	sub    0x54(%ebx),%eax
  80d5ed:	85 c0                	test   %eax,%eax
  80d5ef:	0f 8f a8 00 00 00    	jg     80d69d <tcp_input+0x86e>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  80d5f5:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d5fc:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80d602:	85 c0                	test   %eax,%eax
  80d604:	75 17                	jne    80d61d <tcp_input+0x7ee>
  80d606:	83 ec 04             	sub    $0x4,%esp
  80d609:	68 ff 2e 81 00       	push   $0x812eff
  80d60e:	68 5b 02 00 00       	push   $0x25b
  80d613:	68 90 2e 81 00       	push   $0x812e90
  80d618:	e8 71 0d 00 00       	call   80e38e <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80d61d:	83 ec 04             	sub    $0x4,%esp
  80d620:	6a 00                	push   $0x0
  80d622:	53                   	push   %ebx
  80d623:	ff 73 18             	pushl  0x18(%ebx)
  80d626:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80d628:	83 c4 10             	add    $0x10,%esp
  80d62b:	84 c0                	test   %al,%al
  80d62d:	74 1b                	je     80d64a <tcp_input+0x81b>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  80d62f:	83 ec 0c             	sub    $0xc,%esp
  80d632:	53                   	push   %ebx
  80d633:	e8 ee 84 ff ff       	call   805b26 <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80d638:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d63f:	00 00 00 
  80d642:	83 c4 10             	add    $0x10,%esp
  80d645:	e9 97 04 00 00       	jmp    80dae1 <tcp_input+0xcb2>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  80d64a:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  80d64e:	89 d8                	mov    %ebx,%eax
  80d650:	e8 75 eb ff ff       	call   80c1ca <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d655:	66 83 fe 01          	cmp    $0x1,%si
  80d659:	75 09                	jne    80d664 <tcp_input+0x835>
  80d65b:	0f b7 4b 34          	movzwl 0x34(%ebx),%ecx
  80d65f:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  80d662:	eb 04                	jmp    80d668 <tcp_input+0x839>
  80d664:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80d668:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  80d66c:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d673:	0f 84 ed 04 00 00    	je     80db66 <tcp_input+0xd37>
  80d679:	84 c0                	test   %al,%al
  80d67b:	0f 84 e5 04 00 00    	je     80db66 <tcp_input+0xd37>
          tcp_ack_now(pcb);
  80d681:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d685:	83 ec 0c             	sub    $0xc,%esp
  80d688:	53                   	push   %ebx
  80d689:	e8 ae a8 ff ff       	call   807f3c <tcp_output>
          pcb->state = CLOSE_WAIT;
  80d68e:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d695:	83 c4 10             	add    $0x10,%esp
  80d698:	e9 c9 04 00 00       	jmp    80db66 <tcp_input+0xd37>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  80d69d:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d6a3:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d6a8:	83 ec 08             	sub    $0x8,%esp
  80d6ab:	0f b7 31             	movzwl (%ecx),%esi
  80d6ae:	56                   	push   %esi
  80d6af:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80d6b3:	51                   	push   %ecx
  80d6b4:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d6b7:	51                   	push   %ecx
  80d6b8:	83 c0 10             	add    $0x10,%eax
  80d6bb:	50                   	push   %eax
  80d6bc:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d6c3:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d6c9:	50                   	push   %eax
  80d6ca:	52                   	push   %edx
  80d6cb:	e8 e3 ac ff ff       	call   8083b3 <tcp_rst>
  80d6d0:	83 c4 20             	add    $0x20,%esp
  80d6d3:	e9 8e 04 00 00       	jmp    80db66 <tcp_input+0xd37>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  80d6d8:	89 d8                	mov    %ebx,%eax
  80d6da:	e8 eb ea ff ff       	call   80c1ca <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80d6df:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d6e6:	0f 84 7a 04 00 00    	je     80db66 <tcp_input+0xd37>
  80d6ec:	84 c0                	test   %al,%al
  80d6ee:	0f 84 72 04 00 00    	je     80db66 <tcp_input+0xd37>
      tcp_ack_now(pcb);
  80d6f4:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d6f8:	83 ec 0c             	sub    $0xc,%esp
  80d6fb:	53                   	push   %ebx
  80d6fc:	e8 3b a8 ff ff       	call   807f3c <tcp_output>
      pcb->state = CLOSE_WAIT;
  80d701:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d708:	83 c4 10             	add    $0x10,%esp
  80d70b:	e9 56 04 00 00       	jmp    80db66 <tcp_input+0xd37>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  80d710:	89 d8                	mov    %ebx,%eax
  80d712:	e8 b3 ea ff ff       	call   80c1ca <tcp_receive>
    if (flags & TCP_FIN) {
  80d717:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d71e:	a8 01                	test   $0x1,%al
  80d720:	0f 84 cf 00 00 00    	je     80d7f5 <tcp_input+0x9c6>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d726:	a8 10                	test   $0x10,%al
  80d728:	0f 84 ab 00 00 00    	je     80d7d9 <tcp_input+0x9aa>
  80d72e:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d733:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d736:	0f 85 9d 00 00 00    	jne    80d7d9 <tcp_input+0x9aa>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  80d73c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d740:	83 ec 0c             	sub    $0xc,%esp
  80d743:	53                   	push   %ebx
  80d744:	e8 f3 a7 ff ff       	call   807f3c <tcp_output>
        tcp_pcb_purge(pcb);
  80d749:	89 1c 24             	mov    %ebx,(%esp)
  80d74c:	e8 7c 80 ff ff       	call   8057cd <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80d751:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d756:	83 c4 10             	add    $0x10,%esp
  80d759:	39 c3                	cmp    %eax,%ebx
  80d75b:	75 0a                	jne    80d767 <tcp_input+0x938>
  80d75d:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d760:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80d765:	eb 53                	jmp    80d7ba <tcp_input+0x98b>
  80d767:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d76c:	ba 00 00 00 00       	mov    $0x0,%edx
  80d771:	89 de                	mov    %ebx,%esi
  80d773:	89 d7                	mov    %edx,%edi
  80d775:	eb 2d                	jmp    80d7a4 <tcp_input+0x975>
  80d777:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d77a:	39 ce                	cmp    %ecx,%esi
  80d77c:	0f 94 c3             	sete   %bl
  80d77f:	85 c9                	test   %ecx,%ecx
  80d781:	0f 95 c2             	setne  %dl
  80d784:	84 d3                	test   %dl,%bl
  80d786:	74 15                	je     80d79d <tcp_input+0x96e>
  80d788:	89 f3                	mov    %esi,%ebx
  80d78a:	89 fa                	mov    %edi,%edx
  80d78c:	84 d2                	test   %dl,%dl
  80d78e:	74 05                	je     80d795 <tcp_input+0x966>
  80d790:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d795:	8b 53 0c             	mov    0xc(%ebx),%edx
  80d798:	89 50 0c             	mov    %edx,0xc(%eax)
  80d79b:	eb 1d                	jmp    80d7ba <tcp_input+0x98b>
  80d79d:	bf 01 00 00 00       	mov    $0x1,%edi
  80d7a2:	89 c8                	mov    %ecx,%eax
  80d7a4:	85 c0                	test   %eax,%eax
  80d7a6:	75 cf                	jne    80d777 <tcp_input+0x948>
  80d7a8:	89 f3                	mov    %esi,%ebx
  80d7aa:	89 fa                	mov    %edi,%edx
  80d7ac:	84 d2                	test   %dl,%dl
  80d7ae:	74 0a                	je     80d7ba <tcp_input+0x98b>
  80d7b0:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80d7b7:	00 00 00 
        pcb->state = TIME_WAIT;
  80d7ba:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80d7c1:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80d7c6:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d7c9:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80d7cf:	e8 d2 49 ff ff       	call   8021a6 <tcp_timer_needed>
  80d7d4:	e9 8d 03 00 00       	jmp    80db66 <tcp_input+0xd37>
      } else {
        tcp_ack_now(pcb);
  80d7d9:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d7dd:	83 ec 0c             	sub    $0xc,%esp
  80d7e0:	53                   	push   %ebx
  80d7e1:	e8 56 a7 ff ff       	call   807f3c <tcp_output>
        pcb->state = CLOSING;
  80d7e6:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80d7ed:	83 c4 10             	add    $0x10,%esp
  80d7f0:	e9 71 03 00 00       	jmp    80db66 <tcp_input+0xd37>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d7f5:	a8 10                	test   $0x10,%al
  80d7f7:	0f 84 69 03 00 00    	je     80db66 <tcp_input+0xd37>
  80d7fd:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d802:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d805:	0f 85 5b 03 00 00    	jne    80db66 <tcp_input+0xd37>
      pcb->state = FIN_WAIT_2;
  80d80b:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80d812:	e9 4f 03 00 00       	jmp    80db66 <tcp_input+0xd37>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  80d817:	89 d8                	mov    %ebx,%eax
  80d819:	e8 ac e9 ff ff       	call   80c1ca <tcp_receive>
    if (flags & TCP_FIN) {
  80d81e:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d825:	0f 84 3b 03 00 00    	je     80db66 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80d82b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d82f:	83 ec 0c             	sub    $0xc,%esp
  80d832:	53                   	push   %ebx
  80d833:	e8 04 a7 ff ff       	call   807f3c <tcp_output>
      tcp_pcb_purge(pcb);
  80d838:	89 1c 24             	mov    %ebx,(%esp)
  80d83b:	e8 8d 7f ff ff       	call   8057cd <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80d840:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d845:	83 c4 10             	add    $0x10,%esp
  80d848:	39 c3                	cmp    %eax,%ebx
  80d84a:	75 0a                	jne    80d856 <tcp_input+0xa27>
  80d84c:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d84f:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80d854:	eb 53                	jmp    80d8a9 <tcp_input+0xa7a>
  80d856:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d85b:	b9 00 00 00 00       	mov    $0x0,%ecx
  80d860:	89 de                	mov    %ebx,%esi
  80d862:	89 cf                	mov    %ecx,%edi
  80d864:	eb 2d                	jmp    80d893 <tcp_input+0xa64>
  80d866:	8b 50 0c             	mov    0xc(%eax),%edx
  80d869:	85 d2                	test   %edx,%edx
  80d86b:	0f 95 c3             	setne  %bl
  80d86e:	39 d6                	cmp    %edx,%esi
  80d870:	0f 94 c1             	sete   %cl
  80d873:	84 cb                	test   %cl,%bl
  80d875:	74 15                	je     80d88c <tcp_input+0xa5d>
  80d877:	89 f3                	mov    %esi,%ebx
  80d879:	89 f9                	mov    %edi,%ecx
  80d87b:	84 c9                	test   %cl,%cl
  80d87d:	74 05                	je     80d884 <tcp_input+0xa55>
  80d87f:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d884:	8b 53 0c             	mov    0xc(%ebx),%edx
  80d887:	89 50 0c             	mov    %edx,0xc(%eax)
  80d88a:	eb 1d                	jmp    80d8a9 <tcp_input+0xa7a>
  80d88c:	bf 01 00 00 00       	mov    $0x1,%edi
  80d891:	89 d0                	mov    %edx,%eax
  80d893:	85 c0                	test   %eax,%eax
  80d895:	75 cf                	jne    80d866 <tcp_input+0xa37>
  80d897:	89 f3                	mov    %esi,%ebx
  80d899:	89 f9                	mov    %edi,%ecx
  80d89b:	84 c9                	test   %cl,%cl
  80d89d:	74 0a                	je     80d8a9 <tcp_input+0xa7a>
  80d89f:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80d8a6:	00 00 00 
      pcb->state = TIME_WAIT;
  80d8a9:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80d8b0:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80d8b5:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d8b8:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80d8be:	e8 e3 48 ff ff       	call   8021a6 <tcp_timer_needed>
  80d8c3:	e9 9e 02 00 00       	jmp    80db66 <tcp_input+0xd37>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  80d8c8:	89 d8                	mov    %ebx,%eax
  80d8ca:	e8 fb e8 ff ff       	call   80c1ca <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d8cf:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d8d6:	0f 84 8a 02 00 00    	je     80db66 <tcp_input+0xd37>
  80d8dc:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d8e1:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d8e4:	0f 85 7c 02 00 00    	jne    80db66 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80d8ea:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d8ee:	83 ec 0c             	sub    $0xc,%esp
  80d8f1:	53                   	push   %ebx
  80d8f2:	e8 45 a6 ff ff       	call   807f3c <tcp_output>
      tcp_pcb_purge(pcb);
  80d8f7:	89 1c 24             	mov    %ebx,(%esp)
  80d8fa:	e8 ce 7e ff ff       	call   8057cd <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80d8ff:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d904:	83 c4 10             	add    $0x10,%esp
  80d907:	39 c3                	cmp    %eax,%ebx
  80d909:	75 0a                	jne    80d915 <tcp_input+0xae6>
  80d90b:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d90e:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80d913:	eb 53                	jmp    80d968 <tcp_input+0xb39>
  80d915:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d91a:	ba 00 00 00 00       	mov    $0x0,%edx
  80d91f:	89 de                	mov    %ebx,%esi
  80d921:	89 d7                	mov    %edx,%edi
  80d923:	eb 2d                	jmp    80d952 <tcp_input+0xb23>
  80d925:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d928:	39 ce                	cmp    %ecx,%esi
  80d92a:	0f 94 c3             	sete   %bl
  80d92d:	85 c9                	test   %ecx,%ecx
  80d92f:	0f 95 c2             	setne  %dl
  80d932:	84 d3                	test   %dl,%bl
  80d934:	74 15                	je     80d94b <tcp_input+0xb1c>
  80d936:	89 f3                	mov    %esi,%ebx
  80d938:	89 fa                	mov    %edi,%edx
  80d93a:	84 d2                	test   %dl,%dl
  80d93c:	74 05                	je     80d943 <tcp_input+0xb14>
  80d93e:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d943:	8b 53 0c             	mov    0xc(%ebx),%edx
  80d946:	89 50 0c             	mov    %edx,0xc(%eax)
  80d949:	eb 1d                	jmp    80d968 <tcp_input+0xb39>
  80d94b:	bf 01 00 00 00       	mov    $0x1,%edi
  80d950:	89 c8                	mov    %ecx,%eax
  80d952:	85 c0                	test   %eax,%eax
  80d954:	75 cf                	jne    80d925 <tcp_input+0xaf6>
  80d956:	89 f3                	mov    %esi,%ebx
  80d958:	89 fa                	mov    %edi,%edx
  80d95a:	84 d2                	test   %dl,%dl
  80d95c:	74 0a                	je     80d968 <tcp_input+0xb39>
  80d95e:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80d965:	00 00 00 
      pcb->state = TIME_WAIT;
  80d968:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80d96f:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80d974:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d977:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80d97d:	e8 24 48 ff ff       	call   8021a6 <tcp_timer_needed>
  80d982:	e9 df 01 00 00       	jmp    80db66 <tcp_input+0xd37>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  80d987:	89 d8                	mov    %ebx,%eax
  80d989:	e8 3c e8 ff ff       	call   80c1ca <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d98e:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d995:	0f 84 cb 01 00 00    	je     80db66 <tcp_input+0xd37>
  80d99b:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d9a0:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d9a3:	0f 85 bd 01 00 00    	jne    80db66 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  80d9a9:	c6 05 9c b1 b3 00 10 	movb   $0x10,0xb3b19c
  80d9b0:	e9 b1 01 00 00       	jmp    80db66 <tcp_input+0xd37>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80d9b5:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d9bc:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  80d9bf:	0f b6 05 9c b1 b3 00 	movzbl 0xb3b19c,%eax
  80d9c6:	a8 08                	test   $0x8,%al
  80d9c8:	74 38                	je     80da02 <tcp_input+0xbd3>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80d9ca:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80d9d0:	85 c0                	test   %eax,%eax
  80d9d2:	74 0d                	je     80d9e1 <tcp_input+0xbb2>
  80d9d4:	83 ec 08             	sub    $0x8,%esp
  80d9d7:	6a fa                	push   $0xfffffffa
  80d9d9:	ff 73 18             	pushl  0x18(%ebx)
  80d9dc:	ff d0                	call   *%eax
  80d9de:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80d9e1:	83 ec 08             	sub    $0x8,%esp
  80d9e4:	53                   	push   %ebx
  80d9e5:	68 3c b2 b3 00       	push   $0xb3b23c
  80d9ea:	e8 59 7e ff ff       	call   805848 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80d9ef:	83 c4 08             	add    $0x8,%esp
  80d9f2:	53                   	push   %ebx
  80d9f3:	6a 02                	push   $0x2
  80d9f5:	e8 fa 69 ff ff       	call   8043f4 <memp_free>
  80d9fa:	83 c4 10             	add    $0x10,%esp
  80d9fd:	e9 df 00 00 00       	jmp    80dae1 <tcp_input+0xcb2>
      } else if (recv_flags & TF_CLOSED) {
  80da02:	a8 10                	test   $0x10,%al
  80da04:	74 21                	je     80da27 <tcp_input+0xbf8>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80da06:	83 ec 08             	sub    $0x8,%esp
  80da09:	53                   	push   %ebx
  80da0a:	68 3c b2 b3 00       	push   $0xb3b23c
  80da0f:	e8 34 7e ff ff       	call   805848 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80da14:	83 c4 08             	add    $0x8,%esp
  80da17:	53                   	push   %ebx
  80da18:	6a 02                	push   $0x2
  80da1a:	e8 d5 69 ff ff       	call   8043f4 <memp_free>
  80da1f:	83 c4 10             	add    $0x10,%esp
  80da22:	e9 ba 00 00 00       	jmp    80dae1 <tcp_input+0xcb2>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80da27:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else {
        err = ERR_OK;
  80da2b:	b8 00 00 00 00       	mov    $0x0,%eax
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80da30:	66 85 d2             	test   %dx,%dx
  80da33:	74 1a                	je     80da4f <tcp_input+0xc20>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80da35:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80da3b:	85 c9                	test   %ecx,%ecx
  80da3d:	74 10                	je     80da4f <tcp_input+0xc20>
  80da3f:	83 ec 04             	sub    $0x4,%esp
  80da42:	0f b7 d2             	movzwl %dx,%edx
  80da45:	52                   	push   %edx
  80da46:	53                   	push   %ebx
  80da47:	ff 73 18             	pushl  0x18(%ebx)
  80da4a:	ff d1                	call   *%ecx
  80da4c:	83 c4 10             	add    $0x10,%esp
        }
      
        if (recv_data != NULL) {
  80da4f:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80da55:	85 d2                	test   %edx,%edx
  80da57:	74 58                	je     80dab1 <tcp_input+0xc82>
          if(flags & TCP_PSH) {
  80da59:	f6 05 a0 b1 b3 00 08 	testb  $0x8,0xb3b1a0
  80da60:	0f 84 0f 01 00 00    	je     80db75 <tcp_input+0xd46>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80da66:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
  80da6a:	e9 06 01 00 00       	jmp    80db75 <tcp_input+0xd46>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80da6f:	6a 00                	push   $0x0
  80da71:	52                   	push   %edx
  80da72:	53                   	push   %ebx
  80da73:	ff 73 18             	pushl  0x18(%ebx)
  80da76:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  80da78:	83 c4 10             	add    $0x10,%esp
  80da7b:	84 c0                	test   %al,%al
  80da7d:	75 1c                	jne    80da9b <tcp_input+0xc6c>
  80da7f:	e9 04 01 00 00       	jmp    80db88 <tcp_input+0xd59>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80da84:	83 ec 0c             	sub    $0xc,%esp
  80da87:	52                   	push   %edx
  80da88:	e8 da 6c ff ff       	call   804767 <pbuf_free>
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80da8d:	83 c4 10             	add    $0x10,%esp
  80da90:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80da97:	75 21                	jne    80daba <tcp_input+0xc8b>
  80da99:	eb 3a                	jmp    80dad5 <tcp_input+0xca6>
          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  80da9b:	a1 98 b1 b3 00       	mov    0xb3b198,%eax
  80daa0:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80daa6:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80daad:	74 32                	je     80dae1 <tcp_input+0xcb2>
  80daaf:	eb 09                	jmp    80daba <tcp_input+0xc8b>
  80dab1:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dab8:	74 17                	je     80dad1 <tcp_input+0xca2>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80daba:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80dac0:	85 c0                	test   %eax,%eax
  80dac2:	74 11                	je     80dad5 <tcp_input+0xca6>
  80dac4:	6a 00                	push   $0x0
  80dac6:	6a 00                	push   $0x0
  80dac8:	53                   	push   %ebx
  80dac9:	ff 73 18             	pushl  0x18(%ebx)
  80dacc:	ff d0                	call   *%eax
  80dace:	83 c4 10             	add    $0x10,%esp
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  80dad1:	84 c0                	test   %al,%al
  80dad3:	75 0c                	jne    80dae1 <tcp_input+0xcb2>
          tcp_output(pcb);
  80dad5:	83 ec 0c             	sub    $0xc,%esp
  80dad8:	53                   	push   %ebx
  80dad9:	e8 5e a4 ff ff       	call   807f3c <tcp_output>
  80dade:	83 c4 10             	add    $0x10,%esp
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  80dae1:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80dae6:	85 c0                	test   %eax,%eax
  80dae8:	0f 84 ac 00 00 00    	je     80db9a <tcp_input+0xd6b>
    {
      pbuf_free(inseg.p);
  80daee:	83 ec 0c             	sub    $0xc,%esp
  80daf1:	50                   	push   %eax
  80daf2:	e8 70 6c ff ff       	call   804767 <pbuf_free>
      inseg.p = NULL;
  80daf7:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80dafe:	00 00 00 
  80db01:	83 c4 10             	add    $0x10,%esp
  80db04:	e9 91 00 00 00       	jmp    80db9a <tcp_input+0xd6b>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80db09:	83 ec 0c             	sub    $0xc,%esp
  80db0c:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80db10:	50                   	push   %eax
  80db11:	e8 0f 9b ff ff       	call   807625 <ntohs>
  80db16:	83 c4 10             	add    $0x10,%esp
  80db19:	a8 04                	test   $0x4,%al
  80db1b:	75 3b                	jne    80db58 <tcp_input+0xd29>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80db1d:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  80db23:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  80db28:	83 ec 08             	sub    $0x8,%esp
  80db2b:	0f b7 0a             	movzwl (%edx),%ecx
  80db2e:	51                   	push   %ecx
  80db2f:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80db33:	52                   	push   %edx
  80db34:	8d 50 0c             	lea    0xc(%eax),%edx
  80db37:	52                   	push   %edx
  80db38:	83 c0 10             	add    $0x10,%eax
  80db3b:	50                   	push   %eax
  80db3c:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80db43:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80db49:	50                   	push   %eax
  80db4a:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80db50:	e8 5e a8 ff ff       	call   8083b3 <tcp_rst>
  80db55:	83 c4 20             	add    $0x20,%esp
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  80db58:	83 ec 0c             	sub    $0xc,%esp
  80db5b:	56                   	push   %esi
  80db5c:	e8 06 6c ff ff       	call   804767 <pbuf_free>
  80db61:	83 c4 10             	add    $0x10,%esp
  80db64:	eb 34                	jmp    80db9a <tcp_input+0xd6b>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80db66:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80db6d:	00 00 00 
  80db70:	e9 4a fe ff ff       	jmp    80d9bf <tcp_input+0xb90>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80db75:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80db7b:	85 c0                	test   %eax,%eax
  80db7d:	0f 85 ec fe ff ff    	jne    80da6f <tcp_input+0xc40>
  80db83:	e9 fc fe ff ff       	jmp    80da84 <tcp_input+0xc55>
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80db88:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80db8f:	0f 85 25 ff ff ff    	jne    80daba <tcp_input+0xc8b>
  80db95:	e9 3b ff ff ff       	jmp    80dad5 <tcp_input+0xca6>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  80db9a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80db9d:	5b                   	pop    %ebx
  80db9e:	5e                   	pop    %esi
  80db9f:	5f                   	pop    %edi
  80dba0:	5d                   	pop    %ebp
  80dba1:	c3                   	ret    

0080dba2 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80dba2:	55                   	push   %ebp
  80dba3:	89 e5                	mov    %esp,%ebp
  80dba5:	57                   	push   %edi
  80dba6:	56                   	push   %esi
  80dba7:	53                   	push   %ebx
  80dba8:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80dbab:	8b 45 08             	mov    0x8(%ebp),%eax
  80dbae:	8b 40 04             	mov    0x4(%eax),%eax
  proto = IPH_PROTO(iphdr);
  80dbb1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80dbb4:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80dbb8:	50                   	push   %eax
  80dbb9:	e8 67 9a ff ff       	call   807625 <ntohs>

  prev = NULL;
  pcb = raw_pcbs;
  80dbbe:	8b 1d c8 b1 b3 00    	mov    0xb3b1c8,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dbc4:	83 c4 10             	add    $0x10,%esp
raw_input(struct pbuf *p, struct netif *inp)
{
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  80dbc7:	be 00 00 00 00       	mov    $0x0,%esi
  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  80dbcc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  80dbd3:	0f b6 f8             	movzbl %al,%edi
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80dbd6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80dbd9:	83 c0 0c             	add    $0xc,%eax
  80dbdc:	89 45 e0             	mov    %eax,-0x20(%ebp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dbdf:	eb 5d                	jmp    80dc3e <raw_input+0x9c>
    if (pcb->protocol == proto) {
  80dbe1:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80dbe5:	39 f8                	cmp    %edi,%eax
  80dbe7:	75 4f                	jne    80dc38 <raw_input+0x96>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  80dbe9:	8b 43 14             	mov    0x14(%ebx),%eax
  80dbec:	85 c0                	test   %eax,%eax
  80dbee:	74 48                	je     80dc38 <raw_input+0x96>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80dbf0:	ff 75 e0             	pushl  -0x20(%ebp)
  80dbf3:	ff 75 08             	pushl  0x8(%ebp)
  80dbf6:	53                   	push   %ebx
  80dbf7:	ff 73 18             	pushl  0x18(%ebx)
  80dbfa:	ff d0                	call   *%eax
  80dbfc:	83 c4 10             	add    $0x10,%esp
  80dbff:	84 c0                	test   %al,%al
  80dc01:	74 35                	je     80dc38 <raw_input+0x96>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  80dc03:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80dc06:	85 d2                	test   %edx,%edx
  80dc08:	74 22                	je     80dc2c <raw_input+0x8a>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  80dc0a:	8b 43 0c             	mov    0xc(%ebx),%eax
  80dc0d:	89 42 0c             	mov    %eax,0xc(%edx)
            pcb->next = raw_pcbs;
  80dc10:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80dc15:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80dc18:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
  80dc1e:	be 01 00 00 00       	mov    $0x1,%esi
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80dc23:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80dc2a:	eb 0c                	jmp    80dc38 <raw_input+0x96>
          eaten = 1;
  80dc2c:	be 01 00 00 00       	mov    $0x1,%esi
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80dc31:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80dc38:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    pcb = pcb->next;
  80dc3b:	8b 5b 0c             	mov    0xc(%ebx),%ebx

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dc3e:	89 f0                	mov    %esi,%eax
  80dc40:	84 c0                	test   %al,%al
  80dc42:	75 04                	jne    80dc48 <raw_input+0xa6>
  80dc44:	85 db                	test   %ebx,%ebx
  80dc46:	75 99                	jne    80dbe1 <raw_input+0x3f>
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  80dc48:	89 f0                	mov    %esi,%eax
  80dc4a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80dc4d:	5b                   	pop    %ebx
  80dc4e:	5e                   	pop    %esi
  80dc4f:	5f                   	pop    %edi
  80dc50:	5d                   	pop    %ebp
  80dc51:	c3                   	ret    

0080dc52 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80dc52:	55                   	push   %ebp
  80dc53:	89 e5                	mov    %esp,%ebp
  80dc55:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->local_ip, ipaddr);
  80dc58:	85 c0                	test   %eax,%eax
  80dc5a:	74 04                	je     80dc60 <raw_bind+0xe>
  80dc5c:	8b 10                	mov    (%eax),%edx
  80dc5e:	eb 05                	jmp    80dc65 <raw_bind+0x13>
  80dc60:	ba 00 00 00 00       	mov    $0x0,%edx
  80dc65:	8b 45 08             	mov    0x8(%ebp),%eax
  80dc68:	89 10                	mov    %edx,(%eax)
  return ERR_OK;
}
  80dc6a:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc6f:	5d                   	pop    %ebp
  80dc70:	c3                   	ret    

0080dc71 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80dc71:	55                   	push   %ebp
  80dc72:	89 e5                	mov    %esp,%ebp
  80dc74:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80dc77:	85 c0                	test   %eax,%eax
  80dc79:	74 04                	je     80dc7f <raw_connect+0xe>
  80dc7b:	8b 10                	mov    (%eax),%edx
  80dc7d:	eb 05                	jmp    80dc84 <raw_connect+0x13>
  80dc7f:	ba 00 00 00 00       	mov    $0x0,%edx
  80dc84:	8b 45 08             	mov    0x8(%ebp),%eax
  80dc87:	89 50 04             	mov    %edx,0x4(%eax)
  return ERR_OK;
}
  80dc8a:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc8f:	5d                   	pop    %ebp
  80dc90:	c3                   	ret    

0080dc91 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80dc91:	55                   	push   %ebp
  80dc92:	89 e5                	mov    %esp,%ebp
  80dc94:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80dc97:	8b 55 0c             	mov    0xc(%ebp),%edx
  80dc9a:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80dc9d:	8b 55 10             	mov    0x10(%ebp),%edx
  80dca0:	89 50 18             	mov    %edx,0x18(%eax)
}
  80dca3:	5d                   	pop    %ebp
  80dca4:	c3                   	ret    

0080dca5 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80dca5:	55                   	push   %ebp
  80dca6:	89 e5                	mov    %esp,%ebp
  80dca8:	57                   	push   %edi
  80dca9:	56                   	push   %esi
  80dcaa:	53                   	push   %ebx
  80dcab:	83 ec 14             	sub    $0x14,%esp
  80dcae:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dcb1:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80dcb4:	6a 14                	push   $0x14
  80dcb6:	57                   	push   %edi
  80dcb7:	e8 d9 69 ff ff       	call   804695 <pbuf_header>
  80dcbc:	83 c4 10             	add    $0x10,%esp
  80dcbf:	84 c0                	test   %al,%al
  80dcc1:	74 39                	je     80dcfc <raw_sendto+0x57>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80dcc3:	83 ec 04             	sub    $0x4,%esp
  80dcc6:	6a 00                	push   $0x0
  80dcc8:	6a 00                	push   $0x0
  80dcca:	6a 01                	push   $0x1
  80dccc:	e8 5c 6b ff ff       	call   80482d <pbuf_alloc>
  80dcd1:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80dcd3:	83 c4 10             	add    $0x10,%esp
  80dcd6:	85 c0                	test   %eax,%eax
  80dcd8:	0f 84 a6 00 00 00    	je     80dd84 <raw_sendto+0xdf>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80dcde:	83 ec 08             	sub    $0x8,%esp
  80dce1:	57                   	push   %edi
  80dce2:	50                   	push   %eax
  80dce3:	e8 73 6f ff ff       	call   804c5b <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80dce8:	83 c4 04             	add    $0x4,%esp
  80dceb:	ff 75 10             	pushl  0x10(%ebp)
  80dcee:	e8 69 87 ff ff       	call   80645c <ip_route>
  80dcf3:	83 c4 10             	add    $0x10,%esp
  80dcf6:	85 c0                	test   %eax,%eax
  80dcf8:	75 46                	jne    80dd40 <raw_sendto+0x9b>
  80dcfa:	eb 2d                	jmp    80dd29 <raw_sendto+0x84>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  80dcfc:	83 ec 08             	sub    $0x8,%esp
  80dcff:	6a ec                	push   $0xffffffec
  80dd01:	57                   	push   %edi
  80dd02:	e8 8e 69 ff ff       	call   804695 <pbuf_header>
  80dd07:	83 c4 10             	add    $0x10,%esp
  80dd0a:	84 c0                	test   %al,%al
  80dd0c:	0f 84 87 00 00 00    	je     80dd99 <raw_sendto+0xf4>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80dd12:	83 ec 04             	sub    $0x4,%esp
  80dd15:	68 3c 2f 81 00       	push   $0x812f3c
  80dd1a:	68 e3 00 00 00       	push   $0xe3
  80dd1f:	68 62 2f 81 00       	push   $0x812f62
  80dd24:	e8 65 06 00 00       	call   80e38e <_panic>
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80dd29:	39 f7                	cmp    %esi,%edi
  80dd2b:	74 5e                	je     80dd8b <raw_sendto+0xe6>
      pbuf_free(q);
  80dd2d:	83 ec 0c             	sub    $0xc,%esp
  80dd30:	56                   	push   %esi
  80dd31:	e8 31 6a ff ff       	call   804767 <pbuf_free>
  80dd36:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80dd39:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80dd3e:	eb 6f                	jmp    80ddaf <raw_sendto+0x10a>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80dd40:	89 da                	mov    %ebx,%edx
  80dd42:	85 db                	test   %ebx,%ebx
  80dd44:	74 05                	je     80dd4b <raw_sendto+0xa6>
  80dd46:	83 3b 00             	cmpl   $0x0,(%ebx)
  80dd49:	75 03                	jne    80dd4e <raw_sendto+0xa9>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80dd4b:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80dd4e:	83 ec 04             	sub    $0x4,%esp
  80dd51:	50                   	push   %eax
  80dd52:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80dd56:	50                   	push   %eax
  80dd57:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80dd5b:	50                   	push   %eax
  80dd5c:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80dd60:	50                   	push   %eax
  80dd61:	ff 75 10             	pushl  0x10(%ebp)
  80dd64:	52                   	push   %edx
  80dd65:	56                   	push   %esi
  80dd66:	e8 53 8a ff ff       	call   8067be <ip_output_if>
  80dd6b:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80dd6d:	83 c4 20             	add    $0x20,%esp
  80dd70:	39 f7                	cmp    %esi,%edi
  80dd72:	74 3b                	je     80ddaf <raw_sendto+0x10a>
    /* free the header */
    pbuf_free(q);
  80dd74:	83 ec 0c             	sub    $0xc,%esp
  80dd77:	56                   	push   %esi
  80dd78:	e8 ea 69 ff ff       	call   804767 <pbuf_free>
  80dd7d:	83 c4 10             	add    $0x10,%esp
  }
  return err;
  80dd80:	89 d8                	mov    %ebx,%eax
  80dd82:	eb 2b                	jmp    80ddaf <raw_sendto+0x10a>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  80dd84:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80dd89:	eb 24                	jmp    80ddaf <raw_sendto+0x10a>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  80dd8b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80dd90:	eb 1d                	jmp    80ddaf <raw_sendto+0x10a>
  80dd92:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80dd97:	eb 16                	jmp    80ddaf <raw_sendto+0x10a>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80dd99:	83 ec 0c             	sub    $0xc,%esp
  80dd9c:	ff 75 10             	pushl  0x10(%ebp)
  80dd9f:	e8 b8 86 ff ff       	call   80645c <ip_route>
  80dda4:	83 c4 10             	add    $0x10,%esp
  80dda7:	85 c0                	test   %eax,%eax
  80dda9:	74 e7                	je     80dd92 <raw_sendto+0xed>
    pbuf_chain(q, p);
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  80ddab:	89 fe                	mov    %edi,%esi
  80ddad:	eb 91                	jmp    80dd40 <raw_sendto+0x9b>
  if (q != p) {
    /* free the header */
    pbuf_free(q);
  }
  return err;
}
  80ddaf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ddb2:	5b                   	pop    %ebx
  80ddb3:	5e                   	pop    %esi
  80ddb4:	5f                   	pop    %edi
  80ddb5:	5d                   	pop    %ebp
  80ddb6:	c3                   	ret    

0080ddb7 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80ddb7:	55                   	push   %ebp
  80ddb8:	89 e5                	mov    %esp,%ebp
  80ddba:	83 ec 0c             	sub    $0xc,%esp
  80ddbd:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80ddc0:	8d 50 04             	lea    0x4(%eax),%edx
  80ddc3:	52                   	push   %edx
  80ddc4:	ff 75 0c             	pushl  0xc(%ebp)
  80ddc7:	50                   	push   %eax
  80ddc8:	e8 d8 fe ff ff       	call   80dca5 <raw_sendto>
}
  80ddcd:	c9                   	leave  
  80ddce:	c3                   	ret    

0080ddcf <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80ddcf:	55                   	push   %ebp
  80ddd0:	89 e5                	mov    %esp,%ebp
  80ddd2:	83 ec 08             	sub    $0x8,%esp
  80ddd5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80ddd8:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80dddd:	39 c8                	cmp    %ecx,%eax
  80dddf:	75 1e                	jne    80ddff <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80dde1:	8b 40 0c             	mov    0xc(%eax),%eax
  80dde4:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
  80dde9:	eb 18                	jmp    80de03 <raw_remove+0x34>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80ddeb:	8b 50 0c             	mov    0xc(%eax),%edx
  80ddee:	39 d1                	cmp    %edx,%ecx
  80ddf0:	75 0a                	jne    80ddfc <raw_remove+0x2d>
  80ddf2:	85 d2                	test   %edx,%edx
  80ddf4:	74 06                	je     80ddfc <raw_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80ddf6:	8b 51 0c             	mov    0xc(%ecx),%edx
  80ddf9:	89 50 0c             	mov    %edx,0xc(%eax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80ddfc:	8b 40 0c             	mov    0xc(%eax),%eax
  80ddff:	85 c0                	test   %eax,%eax
  80de01:	75 e8                	jne    80ddeb <raw_remove+0x1c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80de03:	83 ec 08             	sub    $0x8,%esp
  80de06:	51                   	push   %ecx
  80de07:	6a 00                	push   $0x0
  80de09:	e8 e6 65 ff ff       	call   8043f4 <memp_free>
}
  80de0e:	83 c4 10             	add    $0x10,%esp
  80de11:	c9                   	leave  
  80de12:	c3                   	ret    

0080de13 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80de13:	55                   	push   %ebp
  80de14:	89 e5                	mov    %esp,%ebp
  80de16:	56                   	push   %esi
  80de17:	53                   	push   %ebx
  80de18:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80de1b:	83 ec 0c             	sub    $0xc,%esp
  80de1e:	6a 00                	push   $0x0
  80de20:	e8 79 65 ff ff       	call   80439e <memp_malloc>
  80de25:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80de27:	83 c4 10             	add    $0x10,%esp
  80de2a:	85 c0                	test   %eax,%eax
  80de2c:	74 27                	je     80de55 <raw_new+0x42>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80de2e:	83 ec 04             	sub    $0x4,%esp
  80de31:	6a 1c                	push   $0x1c
  80de33:	6a 00                	push   $0x0
  80de35:	50                   	push   %eax
  80de36:	e8 f6 0c 00 00       	call   80eb31 <memset>
    pcb->protocol = proto;
  80de3b:	89 f0                	mov    %esi,%eax
  80de3d:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80de40:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80de44:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80de49:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80de4c:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
  80de52:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80de55:	89 d8                	mov    %ebx,%eax
  80de57:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80de5a:	5b                   	pop    %ebx
  80de5b:	5e                   	pop    %esi
  80de5c:	5d                   	pop    %ebp
  80de5d:	c3                   	ret    

0080de5e <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80de5e:	55                   	push   %ebp
  80de5f:	89 e5                	mov    %esp,%ebp
  80de61:	57                   	push   %edi
  80de62:	56                   	push   %esi
  80de63:	53                   	push   %ebx
  80de64:	83 ec 28             	sub    $0x28,%esp
  80de67:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80de6a:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80de6d:	0f b7 07             	movzwl (%edi),%eax
  80de70:	50                   	push   %eax
  80de71:	e8 af 97 ff ff       	call   807625 <ntohs>
  80de76:	66 c1 e8 06          	shr    $0x6,%ax
  80de7a:	83 e0 3c             	and    $0x3c,%eax
  80de7d:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80de81:	89 c6                	mov    %eax,%esi
  80de83:	f7 de                	neg    %esi
  80de85:	0f bf f6             	movswl %si,%esi
  80de88:	83 c4 08             	add    $0x8,%esp
  80de8b:	56                   	push   %esi
  80de8c:	53                   	push   %ebx
  80de8d:	e8 03 68 ff ff       	call   804695 <pbuf_header>
  80de92:	83 c4 10             	add    $0x10,%esp
  80de95:	84 c0                	test   %al,%al
  80de97:	0f 85 b1 02 00 00    	jne    80e14e <icmp_input+0x2f0>
  80de9d:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80dea2:	0f 86 a6 02 00 00    	jbe    80e14e <icmp_input+0x2f0>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80dea8:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80deab:	80 38 08             	cmpb   $0x8,(%eax)
  80deae:	0f 85 8c 02 00 00    	jne    80e140 <icmp_input+0x2e2>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80deb4:	83 ec 08             	sub    $0x8,%esp
  80deb7:	ff 75 0c             	pushl  0xc(%ebp)
  80deba:	8d 47 10             	lea    0x10(%edi),%eax
  80debd:	50                   	push   %eax
  80debe:	e8 4d 85 ff ff       	call   806410 <ip_addr_isbroadcast>
  80dec3:	83 c4 10             	add    $0x10,%esp
  80dec6:	84 c0                	test   %al,%al
  80dec8:	75 2d                	jne    80def7 <icmp_input+0x99>
  80deca:	8b 47 10             	mov    0x10(%edi),%eax
  80decd:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ded0:	83 ec 0c             	sub    $0xc,%esp
  80ded3:	68 00 00 00 f0       	push   $0xf0000000
  80ded8:	e8 76 99 ff ff       	call   807853 <ntohl>
  80dedd:	23 45 e0             	and    -0x20(%ebp),%eax
  80dee0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80dee3:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80deea:	e8 64 99 ff ff       	call   807853 <ntohl>
  80deef:	83 c4 10             	add    $0x10,%esp
  80def2:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80def5:	75 11                	jne    80df08 <icmp_input+0xaa>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  80def7:	83 ec 0c             	sub    $0xc,%esp
  80defa:	53                   	push   %ebx
  80defb:	e8 67 68 ff ff       	call   804767 <pbuf_free>
      return;
  80df00:	83 c4 10             	add    $0x10,%esp
  80df03:	e9 60 02 00 00       	jmp    80e168 <icmp_input+0x30a>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80df08:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80df0d:	0f 86 3b 02 00 00    	jbe    80e14e <icmp_input+0x2f0>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  80df13:	83 ec 0c             	sub    $0xc,%esp
  80df16:	53                   	push   %ebx
  80df17:	e8 ed 95 ff ff       	call   807509 <inet_chksum_pbuf>
  80df1c:	83 c4 10             	add    $0x10,%esp
  80df1f:	66 85 c0             	test   %ax,%ax
  80df22:	74 11                	je     80df35 <icmp_input+0xd7>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  80df24:	83 ec 0c             	sub    $0xc,%esp
  80df27:	53                   	push   %ebx
  80df28:	e8 3a 68 ff ff       	call   804767 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  80df2d:	83 c4 10             	add    $0x10,%esp
  80df30:	e9 33 02 00 00       	jmp    80e168 <icmp_input+0x30a>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80df35:	83 ec 08             	sub    $0x8,%esp
  80df38:	6a 22                	push   $0x22
  80df3a:	53                   	push   %ebx
  80df3b:	e8 55 67 ff ff       	call   804695 <pbuf_header>
  80df40:	83 c4 10             	add    $0x10,%esp
  80df43:	84 c0                	test   %al,%al
  80df45:	0f 84 d7 00 00 00    	je     80e022 <icmp_input+0x1c4>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  80df4b:	83 ec 08             	sub    $0x8,%esp
  80df4e:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80df52:	50                   	push   %eax
  80df53:	53                   	push   %ebx
  80df54:	e8 3c 67 ff ff       	call   804695 <pbuf_header>
  80df59:	83 c4 10             	add    $0x10,%esp
  80df5c:	84 c0                	test   %al,%al
  80df5e:	74 14                	je     80df74 <icmp_input+0x116>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80df60:	83 ec 04             	sub    $0x4,%esp
  80df63:	68 78 2f 81 00       	push   $0x812f78
  80df68:	6a 7b                	push   $0x7b
  80df6a:	68 6c 30 81 00       	push   $0x81306c
  80df6f:	e8 1a 04 00 00       	call   80e38e <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80df74:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80df78:	83 ec 04             	sub    $0x4,%esp
  80df7b:	6a 00                	push   $0x0
  80df7d:	50                   	push   %eax
  80df7e:	6a 02                	push   $0x2
  80df80:	e8 a8 68 ff ff       	call   80482d <pbuf_alloc>
  80df85:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80df88:	83 c4 10             	add    $0x10,%esp
  80df8b:	85 c0                	test   %eax,%eax
  80df8d:	0f 84 c9 01 00 00    	je     80e15c <icmp_input+0x2fe>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80df93:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80df97:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80df9b:	83 c0 08             	add    $0x8,%eax
  80df9e:	39 c2                	cmp    %eax,%edx
  80dfa0:	73 17                	jae    80dfb9 <icmp_input+0x15b>
  80dfa2:	83 ec 04             	sub    $0x4,%esp
  80dfa5:	68 ac 2f 81 00       	push   $0x812fac
  80dfaa:	68 85 00 00 00       	push   $0x85
  80dfaf:	68 6c 30 81 00       	push   $0x81306c
  80dfb4:	e8 d5 03 00 00       	call   80e38e <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  80dfb9:	83 ec 08             	sub    $0x8,%esp
  80dfbc:	53                   	push   %ebx
  80dfbd:	ff 75 e0             	pushl  -0x20(%ebp)
  80dfc0:	e8 66 6d ff ff       	call   804d2b <pbuf_copy>
  80dfc5:	83 c4 10             	add    $0x10,%esp
  80dfc8:	84 c0                	test   %al,%al
  80dfca:	74 17                	je     80dfe3 <icmp_input+0x185>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80dfcc:	83 ec 04             	sub    $0x4,%esp
  80dfcf:	68 e4 2f 81 00       	push   $0x812fe4
  80dfd4:	68 88 00 00 00       	push   $0x88
  80dfd9:	68 6c 30 81 00       	push   $0x81306c
  80dfde:	e8 ab 03 00 00       	call   80e38e <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  80dfe3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80dfe6:	8b 78 04             	mov    0x4(%eax),%edi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  80dfe9:	83 ec 08             	sub    $0x8,%esp
  80dfec:	56                   	push   %esi
  80dfed:	50                   	push   %eax
  80dfee:	e8 a2 66 ff ff       	call   804695 <pbuf_header>
  80dff3:	83 c4 10             	add    $0x10,%esp
  80dff6:	84 c0                	test   %al,%al
  80dff8:	74 17                	je     80e011 <icmp_input+0x1b3>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80dffa:	83 ec 04             	sub    $0x4,%esp
  80dffd:	68 0c 30 81 00       	push   $0x81300c
  80e002:	68 8e 00 00 00       	push   $0x8e
  80e007:	68 6c 30 81 00       	push   $0x81306c
  80e00c:	e8 7d 03 00 00       	call   80e38e <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  80e011:	83 ec 0c             	sub    $0xc,%esp
  80e014:	53                   	push   %ebx
  80e015:	e8 4d 67 ff ff       	call   804767 <pbuf_free>
  80e01a:	83 c4 10             	add    $0x10,%esp
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  80e01d:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e020:	eb 29                	jmp    80e04b <icmp_input+0x1ed>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e022:	83 ec 08             	sub    $0x8,%esp
  80e025:	6a de                	push   $0xffffffde
  80e027:	53                   	push   %ebx
  80e028:	e8 68 66 ff ff       	call   804695 <pbuf_header>
  80e02d:	83 c4 10             	add    $0x10,%esp
  80e030:	84 c0                	test   %al,%al
  80e032:	74 17                	je     80e04b <icmp_input+0x1ed>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e034:	83 ec 04             	sub    $0x4,%esp
  80e037:	68 0c 30 81 00       	push   $0x81300c
  80e03c:	68 98 00 00 00       	push   $0x98
  80e041:	68 6c 30 81 00       	push   $0x81306c
  80e046:	e8 43 03 00 00       	call   80e38e <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  80e04b:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e04e:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e051:	8b 57 10             	mov    0x10(%edi),%edx
  80e054:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e057:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e05a:	83 ec 0c             	sub    $0xc,%esp
  80e05d:	0f b7 06             	movzwl (%esi),%eax
  80e060:	50                   	push   %eax
  80e061:	e8 bf 95 ff ff       	call   807625 <ntohs>
  80e066:	0f b6 c0             	movzbl %al,%eax
  80e069:	89 04 24             	mov    %eax,(%esp)
  80e06c:	e8 a7 95 ff ff       	call   807618 <htons>
  80e071:	66 89 06             	mov    %ax,(%esi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e074:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e078:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e07c:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e083:	e8 90 95 ff ff       	call   807618 <htons>
  80e088:	83 c4 10             	add    $0x10,%esp
  80e08b:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e08f:	72 1c                	jb     80e0ad <icmp_input+0x24f>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e091:	83 ec 0c             	sub    $0xc,%esp
  80e094:	68 00 08 00 00       	push   $0x800
  80e099:	e8 7a 95 ff ff       	call   807618 <htons>
  80e09e:	0f b7 c0             	movzwl %ax,%eax
  80e0a1:	83 c0 01             	add    $0x1,%eax
  80e0a4:	66 01 46 02          	add    %ax,0x2(%esi)
  80e0a8:	83 c4 10             	add    $0x10,%esp
  80e0ab:	eb 14                	jmp    80e0c1 <icmp_input+0x263>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e0ad:	83 ec 0c             	sub    $0xc,%esp
  80e0b0:	68 00 08 00 00       	push   $0x800
  80e0b5:	e8 5e 95 ff ff       	call   807618 <htons>
  80e0ba:	66 01 46 02          	add    %ax,0x2(%esi)
  80e0be:	83 c4 10             	add    $0x10,%esp
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e0c1:	83 ec 0c             	sub    $0xc,%esp
  80e0c4:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e0c8:	50                   	push   %eax
  80e0c9:	e8 57 95 ff ff       	call   807625 <ntohs>
  80e0ce:	66 0d 00 ff          	or     $0xff00,%ax
  80e0d2:	0f b7 c0             	movzwl %ax,%eax
  80e0d5:	89 04 24             	mov    %eax,(%esp)
  80e0d8:	e8 3b 95 ff ff       	call   807618 <htons>
  80e0dd:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e0e1:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e0e7:	83 c4 08             	add    $0x8,%esp
  80e0ea:	6a 14                	push   $0x14
  80e0ec:	57                   	push   %edi
  80e0ed:	e8 01 94 ff ff       	call   8074f3 <inet_chksum>
  80e0f2:	66 89 47 0a          	mov    %ax,0xa(%edi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  80e0f6:	83 c4 08             	add    $0x8,%esp
  80e0f9:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e0fd:	50                   	push   %eax
  80e0fe:	53                   	push   %ebx
  80e0ff:	e8 91 65 ff ff       	call   804695 <pbuf_header>
  80e104:	83 c4 10             	add    $0x10,%esp
  80e107:	84 c0                	test   %al,%al
  80e109:	74 17                	je     80e122 <icmp_input+0x2c4>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e10b:	83 ec 04             	sub    $0x4,%esp
  80e10e:	68 d4 20 81 00       	push   $0x8120d4
  80e113:	68 b9 00 00 00       	push   $0xb9
  80e118:	68 6c 30 81 00       	push   $0x81306c
  80e11d:	e8 6c 02 00 00       	call   80e38e <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e122:	83 ec 04             	sub    $0x4,%esp
  80e125:	ff 75 0c             	pushl  0xc(%ebp)
  80e128:	6a 01                	push   $0x1
  80e12a:	6a 00                	push   $0x0
  80e12c:	68 ff 00 00 00       	push   $0xff
  80e131:	6a 00                	push   $0x0
  80e133:	83 c7 0c             	add    $0xc,%edi
  80e136:	57                   	push   %edi
  80e137:	53                   	push   %ebx
  80e138:	e8 81 86 ff ff       	call   8067be <ip_output_if>
  80e13d:	83 c4 20             	add    $0x20,%esp
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80e140:	83 ec 0c             	sub    $0xc,%esp
  80e143:	53                   	push   %ebx
  80e144:	e8 1e 66 ff ff       	call   804767 <pbuf_free>
  return;
  80e149:	83 c4 10             	add    $0x10,%esp
  80e14c:	eb 1a                	jmp    80e168 <icmp_input+0x30a>
lenerr:
  pbuf_free(p);
  80e14e:	83 ec 0c             	sub    $0xc,%esp
  80e151:	53                   	push   %ebx
  80e152:	e8 10 66 ff ff       	call   804767 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e157:	83 c4 10             	add    $0x10,%esp
  80e15a:	eb 0c                	jmp    80e168 <icmp_input+0x30a>
memerr:
  pbuf_free(p);
  80e15c:	83 ec 0c             	sub    $0xc,%esp
  80e15f:	53                   	push   %ebx
  80e160:	e8 02 66 ff ff       	call   804767 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
  80e165:	83 c4 10             	add    $0x10,%esp
}
  80e168:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e16b:	5b                   	pop    %ebx
  80e16c:	5e                   	pop    %esi
  80e16d:	5f                   	pop    %edi
  80e16e:	5d                   	pop    %ebp
  80e16f:	c3                   	ret    

0080e170 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e170:	55                   	push   %ebp
  80e171:	89 e5                	mov    %esp,%ebp
  80e173:	57                   	push   %edi
  80e174:	56                   	push   %esi
  80e175:	53                   	push   %ebx
  80e176:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e179:	6a 00                	push   $0x0
  80e17b:	6a 24                	push   $0x24
  80e17d:	6a 01                	push   $0x1
  80e17f:	e8 a9 66 ff ff       	call   80482d <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e184:	83 c4 10             	add    $0x10,%esp
  80e187:	85 c0                	test   %eax,%eax
  80e189:	0f 84 b8 00 00 00    	je     80e247 <icmp_dest_unreach+0xd7>
  80e18f:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e191:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e196:	77 17                	ja     80e1af <icmp_dest_unreach+0x3f>
  80e198:	83 ec 04             	sub    $0x4,%esp
  80e19b:	68 40 30 81 00       	push   $0x813040
  80e1a0:	68 ef 00 00 00       	push   $0xef
  80e1a5:	68 6c 30 81 00       	push   $0x81306c
  80e1aa:	e8 df 01 00 00       	call   80e38e <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e1af:	8b 45 08             	mov    0x8(%ebp),%eax
  80e1b2:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e1b5:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e1b8:	83 ec 0c             	sub    $0xc,%esp
  80e1bb:	0f b7 06             	movzwl (%esi),%eax
  80e1be:	50                   	push   %eax
  80e1bf:	e8 61 94 ff ff       	call   807625 <ntohs>
  80e1c4:	0f b6 c0             	movzbl %al,%eax
  80e1c7:	80 cc 03             	or     $0x3,%ah
  80e1ca:	89 04 24             	mov    %eax,(%esp)
  80e1cd:	e8 46 94 ff ff       	call   807618 <htons>
  80e1d2:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e1d5:	0f b7 c0             	movzwl %ax,%eax
  80e1d8:	89 04 24             	mov    %eax,(%esp)
  80e1db:	e8 45 94 ff ff       	call   807625 <ntohs>
  80e1e0:	b0 00                	mov    $0x0,%al
  80e1e2:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e1e6:	0f b7 c0             	movzwl %ax,%eax
  80e1e9:	89 04 24             	mov    %eax,(%esp)
  80e1ec:	e8 27 94 ff ff       	call   807618 <htons>
  80e1f1:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e1f4:	83 c4 0c             	add    $0xc,%esp
  80e1f7:	6a 1c                	push   $0x1c
  80e1f9:	8b 45 08             	mov    0x8(%ebp),%eax
  80e1fc:	ff 70 04             	pushl  0x4(%eax)
  80e1ff:	8b 43 04             	mov    0x4(%ebx),%eax
  80e202:	83 c0 08             	add    $0x8,%eax
  80e205:	50                   	push   %eax
  80e206:	e8 db 09 00 00       	call   80ebe6 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e20b:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e211:	83 c4 08             	add    $0x8,%esp
  80e214:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e218:	50                   	push   %eax
  80e219:	56                   	push   %esi
  80e21a:	e8 d4 92 ff ff       	call   8074f3 <inet_chksum>
  80e21f:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e223:	83 c4 08             	add    $0x8,%esp
  80e226:	6a 01                	push   $0x1
  80e228:	6a 00                	push   $0x0
  80e22a:	68 ff 00 00 00       	push   $0xff
  80e22f:	83 c7 0c             	add    $0xc,%edi
  80e232:	57                   	push   %edi
  80e233:	6a 00                	push   $0x0
  80e235:	53                   	push   %ebx
  80e236:	e8 0b 87 ff ff       	call   806946 <ip_output>
  pbuf_free(q);
  80e23b:	83 c4 14             	add    $0x14,%esp
  80e23e:	53                   	push   %ebx
  80e23f:	e8 23 65 ff ff       	call   804767 <pbuf_free>
  80e244:	83 c4 10             	add    $0x10,%esp
}
  80e247:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e24a:	5b                   	pop    %ebx
  80e24b:	5e                   	pop    %esi
  80e24c:	5f                   	pop    %edi
  80e24d:	5d                   	pop    %ebp
  80e24e:	c3                   	ret    

0080e24f <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e24f:	55                   	push   %ebp
  80e250:	89 e5                	mov    %esp,%ebp
  80e252:	57                   	push   %edi
  80e253:	56                   	push   %esi
  80e254:	53                   	push   %ebx
  80e255:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e258:	6a 00                	push   $0x0
  80e25a:	6a 24                	push   $0x24
  80e25c:	6a 01                	push   $0x1
  80e25e:	e8 ca 65 ff ff       	call   80482d <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e263:	83 c4 10             	add    $0x10,%esp
  80e266:	85 c0                	test   %eax,%eax
  80e268:	0f 84 b8 00 00 00    	je     80e326 <icmp_time_exceeded+0xd7>
  80e26e:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e270:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e275:	77 17                	ja     80e28e <icmp_time_exceeded+0x3f>
  80e277:	83 ec 04             	sub    $0x4,%esp
  80e27a:	68 40 30 81 00       	push   $0x813040
  80e27f:	68 1e 01 00 00       	push   $0x11e
  80e284:	68 6c 30 81 00       	push   $0x81306c
  80e289:	e8 00 01 00 00       	call   80e38e <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e28e:	8b 45 08             	mov    0x8(%ebp),%eax
  80e291:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e294:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e297:	83 ec 0c             	sub    $0xc,%esp
  80e29a:	0f b7 06             	movzwl (%esi),%eax
  80e29d:	50                   	push   %eax
  80e29e:	e8 82 93 ff ff       	call   807625 <ntohs>
  80e2a3:	0f b6 c0             	movzbl %al,%eax
  80e2a6:	80 cc 0b             	or     $0xb,%ah
  80e2a9:	89 04 24             	mov    %eax,(%esp)
  80e2ac:	e8 67 93 ff ff       	call   807618 <htons>
  80e2b1:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e2b4:	0f b7 c0             	movzwl %ax,%eax
  80e2b7:	89 04 24             	mov    %eax,(%esp)
  80e2ba:	e8 66 93 ff ff       	call   807625 <ntohs>
  80e2bf:	b0 00                	mov    $0x0,%al
  80e2c1:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e2c5:	0f b7 c0             	movzwl %ax,%eax
  80e2c8:	89 04 24             	mov    %eax,(%esp)
  80e2cb:	e8 48 93 ff ff       	call   807618 <htons>
  80e2d0:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e2d3:	83 c4 0c             	add    $0xc,%esp
  80e2d6:	6a 1c                	push   $0x1c
  80e2d8:	8b 45 08             	mov    0x8(%ebp),%eax
  80e2db:	ff 70 04             	pushl  0x4(%eax)
  80e2de:	8b 43 04             	mov    0x4(%ebx),%eax
  80e2e1:	83 c0 08             	add    $0x8,%eax
  80e2e4:	50                   	push   %eax
  80e2e5:	e8 fc 08 00 00       	call   80ebe6 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e2ea:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e2f0:	83 c4 08             	add    $0x8,%esp
  80e2f3:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e2f7:	50                   	push   %eax
  80e2f8:	56                   	push   %esi
  80e2f9:	e8 f5 91 ff ff       	call   8074f3 <inet_chksum>
  80e2fe:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e302:	83 c4 08             	add    $0x8,%esp
  80e305:	6a 01                	push   $0x1
  80e307:	6a 00                	push   $0x0
  80e309:	68 ff 00 00 00       	push   $0xff
  80e30e:	83 c7 0c             	add    $0xc,%edi
  80e311:	57                   	push   %edi
  80e312:	6a 00                	push   $0x0
  80e314:	53                   	push   %ebx
  80e315:	e8 2c 86 ff ff       	call   806946 <ip_output>
  pbuf_free(q);
  80e31a:	83 c4 14             	add    $0x14,%esp
  80e31d:	53                   	push   %ebx
  80e31e:	e8 44 64 ff ff       	call   804767 <pbuf_free>
  80e323:	83 c4 10             	add    $0x10,%esp
}
  80e326:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e329:	5b                   	pop    %ebx
  80e32a:	5e                   	pop    %esi
  80e32b:	5f                   	pop    %edi
  80e32c:	5d                   	pop    %ebp
  80e32d:	c3                   	ret    

0080e32e <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80e32e:	55                   	push   %ebp
  80e32f:	89 e5                	mov    %esp,%ebp
  80e331:	56                   	push   %esi
  80e332:	53                   	push   %ebx
  80e333:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e336:	8b 75 0c             	mov    0xc(%ebp),%esi
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = &envs[ENVX(sys_getenvid())];
  80e339:	e8 73 0a 00 00       	call   80edb1 <sys_getenvid>
  80e33e:	25 ff 03 00 00       	and    $0x3ff,%eax
  80e343:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80e346:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80e34b:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e350:	85 db                	test   %ebx,%ebx
  80e352:	7e 07                	jle    80e35b <libmain+0x2d>
		binaryname = argv[0];
  80e354:	8b 06                	mov    (%esi),%eax
  80e356:	a3 e8 42 81 00       	mov    %eax,0x8142e8

	// call user main routine
	umain(argc, argv);
  80e35b:	83 ec 08             	sub    $0x8,%esp
  80e35e:	56                   	push   %esi
  80e35f:	53                   	push   %ebx
  80e360:	e8 f4 21 ff ff       	call   800559 <umain>

	// exit gracefully
	exit();
  80e365:	e8 0a 00 00 00       	call   80e374 <exit>
}
  80e36a:	83 c4 10             	add    $0x10,%esp
  80e36d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e370:	5b                   	pop    %ebx
  80e371:	5e                   	pop    %esi
  80e372:	5d                   	pop    %ebp
  80e373:	c3                   	ret    

0080e374 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e374:	55                   	push   %ebp
  80e375:	89 e5                	mov    %esp,%ebp
  80e377:	83 ec 08             	sub    $0x8,%esp
	close_all();
  80e37a:	e8 11 12 00 00       	call   80f590 <close_all>
	sys_env_destroy(0);
  80e37f:	83 ec 0c             	sub    $0xc,%esp
  80e382:	6a 00                	push   $0x0
  80e384:	e8 e7 09 00 00       	call   80ed70 <sys_env_destroy>
}
  80e389:	83 c4 10             	add    $0x10,%esp
  80e38c:	c9                   	leave  
  80e38d:	c3                   	ret    

0080e38e <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e38e:	55                   	push   %ebp
  80e38f:	89 e5                	mov    %esp,%ebp
  80e391:	56                   	push   %esi
  80e392:	53                   	push   %ebx
	va_list ap;

	va_start(ap, fmt);
  80e393:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e396:	8b 35 e8 42 81 00    	mov    0x8142e8,%esi
  80e39c:	e8 10 0a 00 00       	call   80edb1 <sys_getenvid>
  80e3a1:	83 ec 0c             	sub    $0xc,%esp
  80e3a4:	ff 75 0c             	pushl  0xc(%ebp)
  80e3a7:	ff 75 08             	pushl  0x8(%ebp)
  80e3aa:	56                   	push   %esi
  80e3ab:	50                   	push   %eax
  80e3ac:	68 90 30 81 00       	push   $0x813090
  80e3b1:	e8 b1 00 00 00       	call   80e467 <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e3b6:	83 c4 18             	add    $0x18,%esp
  80e3b9:	53                   	push   %ebx
  80e3ba:	ff 75 10             	pushl  0x10(%ebp)
  80e3bd:	e8 54 00 00 00       	call   80e416 <vcprintf>
	cprintf("\n");
  80e3c2:	c7 04 24 68 0c 81 00 	movl   $0x810c68,(%esp)
  80e3c9:	e8 99 00 00 00       	call   80e467 <cprintf>
  80e3ce:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e3d1:	cc                   	int3   
  80e3d2:	eb fd                	jmp    80e3d1 <_panic+0x43>

0080e3d4 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e3d4:	55                   	push   %ebp
  80e3d5:	89 e5                	mov    %esp,%ebp
  80e3d7:	53                   	push   %ebx
  80e3d8:	83 ec 04             	sub    $0x4,%esp
  80e3db:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e3de:	8b 13                	mov    (%ebx),%edx
  80e3e0:	8d 42 01             	lea    0x1(%edx),%eax
  80e3e3:	89 03                	mov    %eax,(%ebx)
  80e3e5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e3e8:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e3ec:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e3f1:	75 1a                	jne    80e40d <putch+0x39>
		sys_cputs(b->buf, b->idx);
  80e3f3:	83 ec 08             	sub    $0x8,%esp
  80e3f6:	68 ff 00 00 00       	push   $0xff
  80e3fb:	8d 43 08             	lea    0x8(%ebx),%eax
  80e3fe:	50                   	push   %eax
  80e3ff:	e8 2f 09 00 00       	call   80ed33 <sys_cputs>
		b->idx = 0;
  80e404:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e40a:	83 c4 10             	add    $0x10,%esp
	}
	b->cnt++;
  80e40d:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e411:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e414:	c9                   	leave  
  80e415:	c3                   	ret    

0080e416 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e416:	55                   	push   %ebp
  80e417:	89 e5                	mov    %esp,%ebp
  80e419:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e41f:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e426:	00 00 00 
	b.cnt = 0;
  80e429:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e430:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e433:	ff 75 0c             	pushl  0xc(%ebp)
  80e436:	ff 75 08             	pushl  0x8(%ebp)
  80e439:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80e43f:	50                   	push   %eax
  80e440:	68 d4 e3 80 00       	push   $0x80e3d4
  80e445:	e8 54 01 00 00       	call   80e59e <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80e44a:	83 c4 08             	add    $0x8,%esp
  80e44d:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
  80e453:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80e459:	50                   	push   %eax
  80e45a:	e8 d4 08 00 00       	call   80ed33 <sys_cputs>

	return b.cnt;
}
  80e45f:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80e465:	c9                   	leave  
  80e466:	c3                   	ret    

0080e467 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80e467:	55                   	push   %ebp
  80e468:	89 e5                	mov    %esp,%ebp
  80e46a:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80e46d:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80e470:	50                   	push   %eax
  80e471:	ff 75 08             	pushl  0x8(%ebp)
  80e474:	e8 9d ff ff ff       	call   80e416 <vcprintf>
	va_end(ap);

	return cnt;
}
  80e479:	c9                   	leave  
  80e47a:	c3                   	ret    

0080e47b <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80e47b:	55                   	push   %ebp
  80e47c:	89 e5                	mov    %esp,%ebp
  80e47e:	57                   	push   %edi
  80e47f:	56                   	push   %esi
  80e480:	53                   	push   %ebx
  80e481:	83 ec 1c             	sub    $0x1c,%esp
  80e484:	89 c7                	mov    %eax,%edi
  80e486:	89 d6                	mov    %edx,%esi
  80e488:	8b 45 08             	mov    0x8(%ebp),%eax
  80e48b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e48e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e491:	89 55 dc             	mov    %edx,-0x24(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80e494:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80e497:	bb 00 00 00 00       	mov    $0x0,%ebx
  80e49c:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80e49f:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80e4a2:	39 d3                	cmp    %edx,%ebx
  80e4a4:	72 05                	jb     80e4ab <printnum+0x30>
  80e4a6:	39 45 10             	cmp    %eax,0x10(%ebp)
  80e4a9:	77 45                	ja     80e4f0 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80e4ab:	83 ec 0c             	sub    $0xc,%esp
  80e4ae:	ff 75 18             	pushl  0x18(%ebp)
  80e4b1:	8b 45 14             	mov    0x14(%ebp),%eax
  80e4b4:	8d 58 ff             	lea    -0x1(%eax),%ebx
  80e4b7:	53                   	push   %ebx
  80e4b8:	ff 75 10             	pushl  0x10(%ebp)
  80e4bb:	83 ec 08             	sub    $0x8,%esp
  80e4be:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e4c1:	ff 75 e0             	pushl  -0x20(%ebp)
  80e4c4:	ff 75 dc             	pushl  -0x24(%ebp)
  80e4c7:	ff 75 d8             	pushl  -0x28(%ebp)
  80e4ca:	e8 71 23 00 00       	call   810840 <__udivdi3>
  80e4cf:	83 c4 18             	add    $0x18,%esp
  80e4d2:	52                   	push   %edx
  80e4d3:	50                   	push   %eax
  80e4d4:	89 f2                	mov    %esi,%edx
  80e4d6:	89 f8                	mov    %edi,%eax
  80e4d8:	e8 9e ff ff ff       	call   80e47b <printnum>
  80e4dd:	83 c4 20             	add    $0x20,%esp
  80e4e0:	eb 18                	jmp    80e4fa <printnum+0x7f>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80e4e2:	83 ec 08             	sub    $0x8,%esp
  80e4e5:	56                   	push   %esi
  80e4e6:	ff 75 18             	pushl  0x18(%ebp)
  80e4e9:	ff d7                	call   *%edi
  80e4eb:	83 c4 10             	add    $0x10,%esp
  80e4ee:	eb 03                	jmp    80e4f3 <printnum+0x78>
  80e4f0:	8b 5d 14             	mov    0x14(%ebp),%ebx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80e4f3:	83 eb 01             	sub    $0x1,%ebx
  80e4f6:	85 db                	test   %ebx,%ebx
  80e4f8:	7f e8                	jg     80e4e2 <printnum+0x67>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80e4fa:	83 ec 08             	sub    $0x8,%esp
  80e4fd:	56                   	push   %esi
  80e4fe:	83 ec 04             	sub    $0x4,%esp
  80e501:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e504:	ff 75 e0             	pushl  -0x20(%ebp)
  80e507:	ff 75 dc             	pushl  -0x24(%ebp)
  80e50a:	ff 75 d8             	pushl  -0x28(%ebp)
  80e50d:	e8 5e 24 00 00       	call   810970 <__umoddi3>
  80e512:	83 c4 14             	add    $0x14,%esp
  80e515:	0f be 80 b3 30 81 00 	movsbl 0x8130b3(%eax),%eax
  80e51c:	50                   	push   %eax
  80e51d:	ff d7                	call   *%edi
}
  80e51f:	83 c4 10             	add    $0x10,%esp
  80e522:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e525:	5b                   	pop    %ebx
  80e526:	5e                   	pop    %esi
  80e527:	5f                   	pop    %edi
  80e528:	5d                   	pop    %ebp
  80e529:	c3                   	ret    

0080e52a <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  80e52a:	55                   	push   %ebp
  80e52b:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  80e52d:	83 fa 01             	cmp    $0x1,%edx
  80e530:	7e 0e                	jle    80e540 <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  80e532:	8b 10                	mov    (%eax),%edx
  80e534:	8d 4a 08             	lea    0x8(%edx),%ecx
  80e537:	89 08                	mov    %ecx,(%eax)
  80e539:	8b 02                	mov    (%edx),%eax
  80e53b:	8b 52 04             	mov    0x4(%edx),%edx
  80e53e:	eb 22                	jmp    80e562 <getuint+0x38>
	else if (lflag)
  80e540:	85 d2                	test   %edx,%edx
  80e542:	74 10                	je     80e554 <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  80e544:	8b 10                	mov    (%eax),%edx
  80e546:	8d 4a 04             	lea    0x4(%edx),%ecx
  80e549:	89 08                	mov    %ecx,(%eax)
  80e54b:	8b 02                	mov    (%edx),%eax
  80e54d:	ba 00 00 00 00       	mov    $0x0,%edx
  80e552:	eb 0e                	jmp    80e562 <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  80e554:	8b 10                	mov    (%eax),%edx
  80e556:	8d 4a 04             	lea    0x4(%edx),%ecx
  80e559:	89 08                	mov    %ecx,(%eax)
  80e55b:	8b 02                	mov    (%edx),%eax
  80e55d:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80e562:	5d                   	pop    %ebp
  80e563:	c3                   	ret    

0080e564 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80e564:	55                   	push   %ebp
  80e565:	89 e5                	mov    %esp,%ebp
  80e567:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80e56a:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80e56e:	8b 10                	mov    (%eax),%edx
  80e570:	3b 50 04             	cmp    0x4(%eax),%edx
  80e573:	73 0a                	jae    80e57f <sprintputch+0x1b>
		*b->buf++ = ch;
  80e575:	8d 4a 01             	lea    0x1(%edx),%ecx
  80e578:	89 08                	mov    %ecx,(%eax)
  80e57a:	8b 45 08             	mov    0x8(%ebp),%eax
  80e57d:	88 02                	mov    %al,(%edx)
}
  80e57f:	5d                   	pop    %ebp
  80e580:	c3                   	ret    

0080e581 <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  80e581:	55                   	push   %ebp
  80e582:	89 e5                	mov    %esp,%ebp
  80e584:	83 ec 08             	sub    $0x8,%esp
	va_list ap;

	va_start(ap, fmt);
  80e587:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80e58a:	50                   	push   %eax
  80e58b:	ff 75 10             	pushl  0x10(%ebp)
  80e58e:	ff 75 0c             	pushl  0xc(%ebp)
  80e591:	ff 75 08             	pushl  0x8(%ebp)
  80e594:	e8 05 00 00 00       	call   80e59e <vprintfmt>
	va_end(ap);
}
  80e599:	83 c4 10             	add    $0x10,%esp
  80e59c:	c9                   	leave  
  80e59d:	c3                   	ret    

0080e59e <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80e59e:	55                   	push   %ebp
  80e59f:	89 e5                	mov    %esp,%ebp
  80e5a1:	57                   	push   %edi
  80e5a2:	56                   	push   %esi
  80e5a3:	53                   	push   %ebx
  80e5a4:	83 ec 2c             	sub    $0x2c,%esp
  80e5a7:	8b 75 08             	mov    0x8(%ebp),%esi
  80e5aa:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e5ad:	8b 7d 10             	mov    0x10(%ebp),%edi
  80e5b0:	eb 12                	jmp    80e5c4 <vprintfmt+0x26>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  80e5b2:	85 c0                	test   %eax,%eax
  80e5b4:	0f 84 89 03 00 00    	je     80e943 <vprintfmt+0x3a5>
				return;
			putch(ch, putdat);
  80e5ba:	83 ec 08             	sub    $0x8,%esp
  80e5bd:	53                   	push   %ebx
  80e5be:	50                   	push   %eax
  80e5bf:	ff d6                	call   *%esi
  80e5c1:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80e5c4:	83 c7 01             	add    $0x1,%edi
  80e5c7:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e5cb:	83 f8 25             	cmp    $0x25,%eax
  80e5ce:	75 e2                	jne    80e5b2 <vprintfmt+0x14>
  80e5d0:	c6 45 d4 20          	movb   $0x20,-0x2c(%ebp)
  80e5d4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80e5db:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  80e5e2:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
  80e5e9:	ba 00 00 00 00       	mov    $0x0,%edx
  80e5ee:	eb 07                	jmp    80e5f7 <vprintfmt+0x59>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e5f0:	8b 7d e4             	mov    -0x1c(%ebp),%edi

		// flag to pad on the right
		case '-':
			padc = '-';
  80e5f3:	c6 45 d4 2d          	movb   $0x2d,-0x2c(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e5f7:	8d 47 01             	lea    0x1(%edi),%eax
  80e5fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80e5fd:	0f b6 07             	movzbl (%edi),%eax
  80e600:	0f b6 c8             	movzbl %al,%ecx
  80e603:	83 e8 23             	sub    $0x23,%eax
  80e606:	3c 55                	cmp    $0x55,%al
  80e608:	0f 87 1a 03 00 00    	ja     80e928 <vprintfmt+0x38a>
  80e60e:	0f b6 c0             	movzbl %al,%eax
  80e611:	ff 24 85 00 32 81 00 	jmp    *0x813200(,%eax,4)
  80e618:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
			goto reswitch;

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  80e61b:	c6 45 d4 30          	movb   $0x30,-0x2c(%ebp)
  80e61f:	eb d6                	jmp    80e5f7 <vprintfmt+0x59>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e621:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e624:	b8 00 00 00 00       	mov    $0x0,%eax
  80e629:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  80e62c:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80e62f:	8d 44 41 d0          	lea    -0x30(%ecx,%eax,2),%eax
				ch = *fmt;
  80e633:	0f be 0f             	movsbl (%edi),%ecx
				if (ch < '0' || ch > '9')
  80e636:	8d 51 d0             	lea    -0x30(%ecx),%edx
  80e639:	83 fa 09             	cmp    $0x9,%edx
  80e63c:	77 39                	ja     80e677 <vprintfmt+0xd9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80e63e:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80e641:	eb e9                	jmp    80e62c <vprintfmt+0x8e>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  80e643:	8b 45 14             	mov    0x14(%ebp),%eax
  80e646:	8d 48 04             	lea    0x4(%eax),%ecx
  80e649:	89 4d 14             	mov    %ecx,0x14(%ebp)
  80e64c:	8b 00                	mov    (%eax),%eax
  80e64e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e651:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
			goto process_precision;
  80e654:	eb 27                	jmp    80e67d <vprintfmt+0xdf>
  80e656:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e659:	85 c0                	test   %eax,%eax
  80e65b:	b9 00 00 00 00       	mov    $0x0,%ecx
  80e660:	0f 49 c8             	cmovns %eax,%ecx
  80e663:	89 4d e0             	mov    %ecx,-0x20(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e666:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e669:	eb 8c                	jmp    80e5f7 <vprintfmt+0x59>
  80e66b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
  80e66e:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
			goto reswitch;
  80e675:	eb 80                	jmp    80e5f7 <vprintfmt+0x59>
  80e677:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80e67a:	89 45 d0             	mov    %eax,-0x30(%ebp)

		process_precision:
			if (width < 0)
  80e67d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e681:	0f 89 70 ff ff ff    	jns    80e5f7 <vprintfmt+0x59>
				width = precision, precision = -1;
  80e687:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80e68a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e68d:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  80e694:	e9 5e ff ff ff       	jmp    80e5f7 <vprintfmt+0x59>
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  80e699:	83 c2 01             	add    $0x1,%edx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e69c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
			goto reswitch;
  80e69f:	e9 53 ff ff ff       	jmp    80e5f7 <vprintfmt+0x59>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  80e6a4:	8b 45 14             	mov    0x14(%ebp),%eax
  80e6a7:	8d 50 04             	lea    0x4(%eax),%edx
  80e6aa:	89 55 14             	mov    %edx,0x14(%ebp)
  80e6ad:	83 ec 08             	sub    $0x8,%esp
  80e6b0:	53                   	push   %ebx
  80e6b1:	ff 30                	pushl  (%eax)
  80e6b3:	ff d6                	call   *%esi
			break;
  80e6b5:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e6b8:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
			break;
  80e6bb:	e9 04 ff ff ff       	jmp    80e5c4 <vprintfmt+0x26>

		// error message
		case 'e':
			err = va_arg(ap, int);
  80e6c0:	8b 45 14             	mov    0x14(%ebp),%eax
  80e6c3:	8d 50 04             	lea    0x4(%eax),%edx
  80e6c6:	89 55 14             	mov    %edx,0x14(%ebp)
  80e6c9:	8b 00                	mov    (%eax),%eax
  80e6cb:	99                   	cltd   
  80e6cc:	31 d0                	xor    %edx,%eax
  80e6ce:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80e6d0:	83 f8 0f             	cmp    $0xf,%eax
  80e6d3:	7f 0b                	jg     80e6e0 <vprintfmt+0x142>
  80e6d5:	8b 14 85 60 33 81 00 	mov    0x813360(,%eax,4),%edx
  80e6dc:	85 d2                	test   %edx,%edx
  80e6de:	75 18                	jne    80e6f8 <vprintfmt+0x15a>
				printfmt(putch, putdat, "error %d", err);
  80e6e0:	50                   	push   %eax
  80e6e1:	68 cb 30 81 00       	push   $0x8130cb
  80e6e6:	53                   	push   %ebx
  80e6e7:	56                   	push   %esi
  80e6e8:	e8 94 fe ff ff       	call   80e581 <printfmt>
  80e6ed:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e6f0:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		case 'e':
			err = va_arg(ap, int);
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
  80e6f3:	e9 cc fe ff ff       	jmp    80e5c4 <vprintfmt+0x26>
			else
				printfmt(putch, putdat, "%s", p);
  80e6f8:	52                   	push   %edx
  80e6f9:	68 99 22 81 00       	push   $0x812299
  80e6fe:	53                   	push   %ebx
  80e6ff:	56                   	push   %esi
  80e700:	e8 7c fe ff ff       	call   80e581 <printfmt>
  80e705:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e708:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e70b:	e9 b4 fe ff ff       	jmp    80e5c4 <vprintfmt+0x26>
				printfmt(putch, putdat, "%s", p);
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  80e710:	8b 45 14             	mov    0x14(%ebp),%eax
  80e713:	8d 50 04             	lea    0x4(%eax),%edx
  80e716:	89 55 14             	mov    %edx,0x14(%ebp)
  80e719:	8b 38                	mov    (%eax),%edi
				p = "(null)";
  80e71b:	85 ff                	test   %edi,%edi
  80e71d:	b8 c4 30 81 00       	mov    $0x8130c4,%eax
  80e722:	0f 44 f8             	cmove  %eax,%edi
			if (width > 0 && padc != '-')
  80e725:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e729:	0f 8e 94 00 00 00    	jle    80e7c3 <vprintfmt+0x225>
  80e72f:	80 7d d4 2d          	cmpb   $0x2d,-0x2c(%ebp)
  80e733:	0f 84 98 00 00 00    	je     80e7d1 <vprintfmt+0x233>
				for (width -= strnlen(p, precision); width > 0; width--)
  80e739:	83 ec 08             	sub    $0x8,%esp
  80e73c:	ff 75 d0             	pushl  -0x30(%ebp)
  80e73f:	57                   	push   %edi
  80e740:	e8 86 02 00 00       	call   80e9cb <strnlen>
  80e745:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80e748:	29 c1                	sub    %eax,%ecx
  80e74a:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  80e74d:	83 c4 10             	add    $0x10,%esp
					putch(padc, putdat);
  80e750:	0f be 45 d4          	movsbl -0x2c(%ebp),%eax
  80e754:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e757:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  80e75a:	89 cf                	mov    %ecx,%edi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80e75c:	eb 0f                	jmp    80e76d <vprintfmt+0x1cf>
					putch(padc, putdat);
  80e75e:	83 ec 08             	sub    $0x8,%esp
  80e761:	53                   	push   %ebx
  80e762:	ff 75 e0             	pushl  -0x20(%ebp)
  80e765:	ff d6                	call   *%esi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80e767:	83 ef 01             	sub    $0x1,%edi
  80e76a:	83 c4 10             	add    $0x10,%esp
  80e76d:	85 ff                	test   %edi,%edi
  80e76f:	7f ed                	jg     80e75e <vprintfmt+0x1c0>
  80e771:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  80e774:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  80e777:	85 c9                	test   %ecx,%ecx
  80e779:	b8 00 00 00 00       	mov    $0x0,%eax
  80e77e:	0f 49 c1             	cmovns %ecx,%eax
  80e781:	29 c1                	sub    %eax,%ecx
  80e783:	89 75 08             	mov    %esi,0x8(%ebp)
  80e786:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e789:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e78c:	89 cb                	mov    %ecx,%ebx
  80e78e:	eb 4d                	jmp    80e7dd <vprintfmt+0x23f>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  80e790:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80e794:	74 1b                	je     80e7b1 <vprintfmt+0x213>
  80e796:	0f be c0             	movsbl %al,%eax
  80e799:	83 e8 20             	sub    $0x20,%eax
  80e79c:	83 f8 5e             	cmp    $0x5e,%eax
  80e79f:	76 10                	jbe    80e7b1 <vprintfmt+0x213>
					putch('?', putdat);
  80e7a1:	83 ec 08             	sub    $0x8,%esp
  80e7a4:	ff 75 0c             	pushl  0xc(%ebp)
  80e7a7:	6a 3f                	push   $0x3f
  80e7a9:	ff 55 08             	call   *0x8(%ebp)
  80e7ac:	83 c4 10             	add    $0x10,%esp
  80e7af:	eb 0d                	jmp    80e7be <vprintfmt+0x220>
				else
					putch(ch, putdat);
  80e7b1:	83 ec 08             	sub    $0x8,%esp
  80e7b4:	ff 75 0c             	pushl  0xc(%ebp)
  80e7b7:	52                   	push   %edx
  80e7b8:	ff 55 08             	call   *0x8(%ebp)
  80e7bb:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80e7be:	83 eb 01             	sub    $0x1,%ebx
  80e7c1:	eb 1a                	jmp    80e7dd <vprintfmt+0x23f>
  80e7c3:	89 75 08             	mov    %esi,0x8(%ebp)
  80e7c6:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e7c9:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e7cc:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e7cf:	eb 0c                	jmp    80e7dd <vprintfmt+0x23f>
  80e7d1:	89 75 08             	mov    %esi,0x8(%ebp)
  80e7d4:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e7d7:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e7da:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e7dd:	83 c7 01             	add    $0x1,%edi
  80e7e0:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e7e4:	0f be d0             	movsbl %al,%edx
  80e7e7:	85 d2                	test   %edx,%edx
  80e7e9:	74 23                	je     80e80e <vprintfmt+0x270>
  80e7eb:	85 f6                	test   %esi,%esi
  80e7ed:	78 a1                	js     80e790 <vprintfmt+0x1f2>
  80e7ef:	83 ee 01             	sub    $0x1,%esi
  80e7f2:	79 9c                	jns    80e790 <vprintfmt+0x1f2>
  80e7f4:	89 df                	mov    %ebx,%edi
  80e7f6:	8b 75 08             	mov    0x8(%ebp),%esi
  80e7f9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e7fc:	eb 18                	jmp    80e816 <vprintfmt+0x278>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  80e7fe:	83 ec 08             	sub    $0x8,%esp
  80e801:	53                   	push   %ebx
  80e802:	6a 20                	push   $0x20
  80e804:	ff d6                	call   *%esi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  80e806:	83 ef 01             	sub    $0x1,%edi
  80e809:	83 c4 10             	add    $0x10,%esp
  80e80c:	eb 08                	jmp    80e816 <vprintfmt+0x278>
  80e80e:	89 df                	mov    %ebx,%edi
  80e810:	8b 75 08             	mov    0x8(%ebp),%esi
  80e813:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e816:	85 ff                	test   %edi,%edi
  80e818:	7f e4                	jg     80e7fe <vprintfmt+0x260>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e81a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e81d:	e9 a2 fd ff ff       	jmp    80e5c4 <vprintfmt+0x26>
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  80e822:	83 fa 01             	cmp    $0x1,%edx
  80e825:	7e 16                	jle    80e83d <vprintfmt+0x29f>
		return va_arg(*ap, long long);
  80e827:	8b 45 14             	mov    0x14(%ebp),%eax
  80e82a:	8d 50 08             	lea    0x8(%eax),%edx
  80e82d:	89 55 14             	mov    %edx,0x14(%ebp)
  80e830:	8b 50 04             	mov    0x4(%eax),%edx
  80e833:	8b 00                	mov    (%eax),%eax
  80e835:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e838:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80e83b:	eb 32                	jmp    80e86f <vprintfmt+0x2d1>
	else if (lflag)
  80e83d:	85 d2                	test   %edx,%edx
  80e83f:	74 18                	je     80e859 <vprintfmt+0x2bb>
		return va_arg(*ap, long);
  80e841:	8b 45 14             	mov    0x14(%ebp),%eax
  80e844:	8d 50 04             	lea    0x4(%eax),%edx
  80e847:	89 55 14             	mov    %edx,0x14(%ebp)
  80e84a:	8b 00                	mov    (%eax),%eax
  80e84c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e84f:	89 c1                	mov    %eax,%ecx
  80e851:	c1 f9 1f             	sar    $0x1f,%ecx
  80e854:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80e857:	eb 16                	jmp    80e86f <vprintfmt+0x2d1>
	else
		return va_arg(*ap, int);
  80e859:	8b 45 14             	mov    0x14(%ebp),%eax
  80e85c:	8d 50 04             	lea    0x4(%eax),%edx
  80e85f:	89 55 14             	mov    %edx,0x14(%ebp)
  80e862:	8b 00                	mov    (%eax),%eax
  80e864:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e867:	89 c1                	mov    %eax,%ecx
  80e869:	c1 f9 1f             	sar    $0x1f,%ecx
  80e86c:	89 4d dc             	mov    %ecx,-0x24(%ebp)
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  80e86f:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80e872:	8b 55 dc             	mov    -0x24(%ebp),%edx
			if ((long long) num < 0) {
				putch('-', putdat);
				num = -(long long) num;
			}
			base = 10;
  80e875:	b9 0a 00 00 00       	mov    $0xa,%ecx
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
			if ((long long) num < 0) {
  80e87a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80e87e:	79 74                	jns    80e8f4 <vprintfmt+0x356>
				putch('-', putdat);
  80e880:	83 ec 08             	sub    $0x8,%esp
  80e883:	53                   	push   %ebx
  80e884:	6a 2d                	push   $0x2d
  80e886:	ff d6                	call   *%esi
				num = -(long long) num;
  80e888:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80e88b:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e88e:	f7 d8                	neg    %eax
  80e890:	83 d2 00             	adc    $0x0,%edx
  80e893:	f7 da                	neg    %edx
  80e895:	83 c4 10             	add    $0x10,%esp
			}
			base = 10;
  80e898:	b9 0a 00 00 00       	mov    $0xa,%ecx
  80e89d:	eb 55                	jmp    80e8f4 <vprintfmt+0x356>
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  80e89f:	8d 45 14             	lea    0x14(%ebp),%eax
  80e8a2:	e8 83 fc ff ff       	call   80e52a <getuint>
			base = 10;
  80e8a7:	b9 0a 00 00 00       	mov    $0xa,%ecx
			goto number;
  80e8ac:	eb 46                	jmp    80e8f4 <vprintfmt+0x356>
		case 'o':
			// Replace this with your code.
			// putch('X', putdat);
			// putch('X', putdat);
			// putch('X', putdat);
			num = getuint(&ap, lflag);
  80e8ae:	8d 45 14             	lea    0x14(%ebp),%eax
  80e8b1:	e8 74 fc ff ff       	call   80e52a <getuint>
			base = 8;
  80e8b6:	b9 08 00 00 00       	mov    $0x8,%ecx
			goto number;
  80e8bb:	eb 37                	jmp    80e8f4 <vprintfmt+0x356>

		// pointer
		case 'p':
			putch('0', putdat);
  80e8bd:	83 ec 08             	sub    $0x8,%esp
  80e8c0:	53                   	push   %ebx
  80e8c1:	6a 30                	push   $0x30
  80e8c3:	ff d6                	call   *%esi
			putch('x', putdat);
  80e8c5:	83 c4 08             	add    $0x8,%esp
  80e8c8:	53                   	push   %ebx
  80e8c9:	6a 78                	push   $0x78
  80e8cb:	ff d6                	call   *%esi
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
  80e8cd:	8b 45 14             	mov    0x14(%ebp),%eax
  80e8d0:	8d 50 04             	lea    0x4(%eax),%edx
  80e8d3:	89 55 14             	mov    %edx,0x14(%ebp)

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  80e8d6:	8b 00                	mov    (%eax),%eax
  80e8d8:	ba 00 00 00 00       	mov    $0x0,%edx
				(uintptr_t) va_arg(ap, void *);
			base = 16;
			goto number;
  80e8dd:	83 c4 10             	add    $0x10,%esp
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
			base = 16;
  80e8e0:	b9 10 00 00 00       	mov    $0x10,%ecx
			goto number;
  80e8e5:	eb 0d                	jmp    80e8f4 <vprintfmt+0x356>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  80e8e7:	8d 45 14             	lea    0x14(%ebp),%eax
  80e8ea:	e8 3b fc ff ff       	call   80e52a <getuint>
			base = 16;
  80e8ef:	b9 10 00 00 00       	mov    $0x10,%ecx
		number:
			printnum(putch, putdat, num, base, width, padc);
  80e8f4:	83 ec 0c             	sub    $0xc,%esp
  80e8f7:	0f be 7d d4          	movsbl -0x2c(%ebp),%edi
  80e8fb:	57                   	push   %edi
  80e8fc:	ff 75 e0             	pushl  -0x20(%ebp)
  80e8ff:	51                   	push   %ecx
  80e900:	52                   	push   %edx
  80e901:	50                   	push   %eax
  80e902:	89 da                	mov    %ebx,%edx
  80e904:	89 f0                	mov    %esi,%eax
  80e906:	e8 70 fb ff ff       	call   80e47b <printnum>
			break;
  80e90b:	83 c4 20             	add    $0x20,%esp
  80e90e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e911:	e9 ae fc ff ff       	jmp    80e5c4 <vprintfmt+0x26>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  80e916:	83 ec 08             	sub    $0x8,%esp
  80e919:	53                   	push   %ebx
  80e91a:	51                   	push   %ecx
  80e91b:	ff d6                	call   *%esi
			break;
  80e91d:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e920:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			break;

		// escaped '%' character
		case '%':
			putch(ch, putdat);
			break;
  80e923:	e9 9c fc ff ff       	jmp    80e5c4 <vprintfmt+0x26>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  80e928:	83 ec 08             	sub    $0x8,%esp
  80e92b:	53                   	push   %ebx
  80e92c:	6a 25                	push   $0x25
  80e92e:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80e930:	83 c4 10             	add    $0x10,%esp
  80e933:	eb 03                	jmp    80e938 <vprintfmt+0x39a>
  80e935:	83 ef 01             	sub    $0x1,%edi
  80e938:	80 7f ff 25          	cmpb   $0x25,-0x1(%edi)
  80e93c:	75 f7                	jne    80e935 <vprintfmt+0x397>
  80e93e:	e9 81 fc ff ff       	jmp    80e5c4 <vprintfmt+0x26>
				/* do nothing */;
			break;
		}
	}
}
  80e943:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e946:	5b                   	pop    %ebx
  80e947:	5e                   	pop    %esi
  80e948:	5f                   	pop    %edi
  80e949:	5d                   	pop    %ebp
  80e94a:	c3                   	ret    

0080e94b <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80e94b:	55                   	push   %ebp
  80e94c:	89 e5                	mov    %esp,%ebp
  80e94e:	83 ec 18             	sub    $0x18,%esp
  80e951:	8b 45 08             	mov    0x8(%ebp),%eax
  80e954:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80e957:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80e95a:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80e95e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80e961:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80e968:	85 c0                	test   %eax,%eax
  80e96a:	74 26                	je     80e992 <vsnprintf+0x47>
  80e96c:	85 d2                	test   %edx,%edx
  80e96e:	7e 22                	jle    80e992 <vsnprintf+0x47>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80e970:	ff 75 14             	pushl  0x14(%ebp)
  80e973:	ff 75 10             	pushl  0x10(%ebp)
  80e976:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80e979:	50                   	push   %eax
  80e97a:	68 64 e5 80 00       	push   $0x80e564
  80e97f:	e8 1a fc ff ff       	call   80e59e <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80e984:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80e987:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80e98a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80e98d:	83 c4 10             	add    $0x10,%esp
  80e990:	eb 05                	jmp    80e997 <vsnprintf+0x4c>
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
		return -E_INVAL;
  80e992:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

	// null terminate the buffer
	*b.buf = '\0';

	return b.cnt;
}
  80e997:	c9                   	leave  
  80e998:	c3                   	ret    

0080e999 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80e999:	55                   	push   %ebp
  80e99a:	89 e5                	mov    %esp,%ebp
  80e99c:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80e99f:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80e9a2:	50                   	push   %eax
  80e9a3:	ff 75 10             	pushl  0x10(%ebp)
  80e9a6:	ff 75 0c             	pushl  0xc(%ebp)
  80e9a9:	ff 75 08             	pushl  0x8(%ebp)
  80e9ac:	e8 9a ff ff ff       	call   80e94b <vsnprintf>
	va_end(ap);

	return rc;
}
  80e9b1:	c9                   	leave  
  80e9b2:	c3                   	ret    

0080e9b3 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80e9b3:	55                   	push   %ebp
  80e9b4:	89 e5                	mov    %esp,%ebp
  80e9b6:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80e9b9:	b8 00 00 00 00       	mov    $0x0,%eax
  80e9be:	eb 03                	jmp    80e9c3 <strlen+0x10>
		n++;
  80e9c0:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  80e9c3:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80e9c7:	75 f7                	jne    80e9c0 <strlen+0xd>
		n++;
	return n;
}
  80e9c9:	5d                   	pop    %ebp
  80e9ca:	c3                   	ret    

0080e9cb <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80e9cb:	55                   	push   %ebp
  80e9cc:	89 e5                	mov    %esp,%ebp
  80e9ce:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e9d1:	8b 45 0c             	mov    0xc(%ebp),%eax
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80e9d4:	ba 00 00 00 00       	mov    $0x0,%edx
  80e9d9:	eb 03                	jmp    80e9de <strnlen+0x13>
		n++;
  80e9db:	83 c2 01             	add    $0x1,%edx
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80e9de:	39 c2                	cmp    %eax,%edx
  80e9e0:	74 08                	je     80e9ea <strnlen+0x1f>
  80e9e2:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
  80e9e6:	75 f3                	jne    80e9db <strnlen+0x10>
  80e9e8:	89 d0                	mov    %edx,%eax
		n++;
	return n;
}
  80e9ea:	5d                   	pop    %ebp
  80e9eb:	c3                   	ret    

0080e9ec <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80e9ec:	55                   	push   %ebp
  80e9ed:	89 e5                	mov    %esp,%ebp
  80e9ef:	53                   	push   %ebx
  80e9f0:	8b 45 08             	mov    0x8(%ebp),%eax
  80e9f3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80e9f6:	89 c2                	mov    %eax,%edx
  80e9f8:	83 c2 01             	add    $0x1,%edx
  80e9fb:	83 c1 01             	add    $0x1,%ecx
  80e9fe:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
  80ea02:	88 5a ff             	mov    %bl,-0x1(%edx)
  80ea05:	84 db                	test   %bl,%bl
  80ea07:	75 ef                	jne    80e9f8 <strcpy+0xc>
		/* do nothing */;
	return ret;
}
  80ea09:	5b                   	pop    %ebx
  80ea0a:	5d                   	pop    %ebp
  80ea0b:	c3                   	ret    

0080ea0c <strcat>:

char *
strcat(char *dst, const char *src)
{
  80ea0c:	55                   	push   %ebp
  80ea0d:	89 e5                	mov    %esp,%ebp
  80ea0f:	53                   	push   %ebx
  80ea10:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80ea13:	53                   	push   %ebx
  80ea14:	e8 9a ff ff ff       	call   80e9b3 <strlen>
  80ea19:	83 c4 04             	add    $0x4,%esp
	strcpy(dst + len, src);
  80ea1c:	ff 75 0c             	pushl  0xc(%ebp)
  80ea1f:	01 d8                	add    %ebx,%eax
  80ea21:	50                   	push   %eax
  80ea22:	e8 c5 ff ff ff       	call   80e9ec <strcpy>
	return dst;
}
  80ea27:	89 d8                	mov    %ebx,%eax
  80ea29:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ea2c:	c9                   	leave  
  80ea2d:	c3                   	ret    

0080ea2e <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80ea2e:	55                   	push   %ebp
  80ea2f:	89 e5                	mov    %esp,%ebp
  80ea31:	56                   	push   %esi
  80ea32:	53                   	push   %ebx
  80ea33:	8b 75 08             	mov    0x8(%ebp),%esi
  80ea36:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ea39:	89 f3                	mov    %esi,%ebx
  80ea3b:	03 5d 10             	add    0x10(%ebp),%ebx
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80ea3e:	89 f2                	mov    %esi,%edx
  80ea40:	eb 0f                	jmp    80ea51 <strncpy+0x23>
		*dst++ = *src;
  80ea42:	83 c2 01             	add    $0x1,%edx
  80ea45:	0f b6 01             	movzbl (%ecx),%eax
  80ea48:	88 42 ff             	mov    %al,-0x1(%edx)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80ea4b:	80 39 01             	cmpb   $0x1,(%ecx)
  80ea4e:	83 d9 ff             	sbb    $0xffffffff,%ecx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80ea51:	39 da                	cmp    %ebx,%edx
  80ea53:	75 ed                	jne    80ea42 <strncpy+0x14>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  80ea55:	89 f0                	mov    %esi,%eax
  80ea57:	5b                   	pop    %ebx
  80ea58:	5e                   	pop    %esi
  80ea59:	5d                   	pop    %ebp
  80ea5a:	c3                   	ret    

0080ea5b <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80ea5b:	55                   	push   %ebp
  80ea5c:	89 e5                	mov    %esp,%ebp
  80ea5e:	56                   	push   %esi
  80ea5f:	53                   	push   %ebx
  80ea60:	8b 75 08             	mov    0x8(%ebp),%esi
  80ea63:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ea66:	8b 55 10             	mov    0x10(%ebp),%edx
  80ea69:	89 f0                	mov    %esi,%eax
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80ea6b:	85 d2                	test   %edx,%edx
  80ea6d:	74 21                	je     80ea90 <strlcpy+0x35>
  80ea6f:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
  80ea73:	89 f2                	mov    %esi,%edx
  80ea75:	eb 09                	jmp    80ea80 <strlcpy+0x25>
		while (--size > 0 && *src != '\0')
			*dst++ = *src++;
  80ea77:	83 c2 01             	add    $0x1,%edx
  80ea7a:	83 c1 01             	add    $0x1,%ecx
  80ea7d:	88 5a ff             	mov    %bl,-0x1(%edx)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  80ea80:	39 c2                	cmp    %eax,%edx
  80ea82:	74 09                	je     80ea8d <strlcpy+0x32>
  80ea84:	0f b6 19             	movzbl (%ecx),%ebx
  80ea87:	84 db                	test   %bl,%bl
  80ea89:	75 ec                	jne    80ea77 <strlcpy+0x1c>
  80ea8b:	89 d0                	mov    %edx,%eax
			*dst++ = *src++;
		*dst = '\0';
  80ea8d:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80ea90:	29 f0                	sub    %esi,%eax
}
  80ea92:	5b                   	pop    %ebx
  80ea93:	5e                   	pop    %esi
  80ea94:	5d                   	pop    %ebp
  80ea95:	c3                   	ret    

0080ea96 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80ea96:	55                   	push   %ebp
  80ea97:	89 e5                	mov    %esp,%ebp
  80ea99:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ea9c:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80ea9f:	eb 06                	jmp    80eaa7 <strcmp+0x11>
		p++, q++;
  80eaa1:	83 c1 01             	add    $0x1,%ecx
  80eaa4:	83 c2 01             	add    $0x1,%edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  80eaa7:	0f b6 01             	movzbl (%ecx),%eax
  80eaaa:	84 c0                	test   %al,%al
  80eaac:	74 04                	je     80eab2 <strcmp+0x1c>
  80eaae:	3a 02                	cmp    (%edx),%al
  80eab0:	74 ef                	je     80eaa1 <strcmp+0xb>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80eab2:	0f b6 c0             	movzbl %al,%eax
  80eab5:	0f b6 12             	movzbl (%edx),%edx
  80eab8:	29 d0                	sub    %edx,%eax
}
  80eaba:	5d                   	pop    %ebp
  80eabb:	c3                   	ret    

0080eabc <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80eabc:	55                   	push   %ebp
  80eabd:	89 e5                	mov    %esp,%ebp
  80eabf:	53                   	push   %ebx
  80eac0:	8b 45 08             	mov    0x8(%ebp),%eax
  80eac3:	8b 55 0c             	mov    0xc(%ebp),%edx
  80eac6:	89 c3                	mov    %eax,%ebx
  80eac8:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80eacb:	eb 06                	jmp    80ead3 <strncmp+0x17>
		n--, p++, q++;
  80eacd:	83 c0 01             	add    $0x1,%eax
  80ead0:	83 c2 01             	add    $0x1,%edx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80ead3:	39 d8                	cmp    %ebx,%eax
  80ead5:	74 15                	je     80eaec <strncmp+0x30>
  80ead7:	0f b6 08             	movzbl (%eax),%ecx
  80eada:	84 c9                	test   %cl,%cl
  80eadc:	74 04                	je     80eae2 <strncmp+0x26>
  80eade:	3a 0a                	cmp    (%edx),%cl
  80eae0:	74 eb                	je     80eacd <strncmp+0x11>
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80eae2:	0f b6 00             	movzbl (%eax),%eax
  80eae5:	0f b6 12             	movzbl (%edx),%edx
  80eae8:	29 d0                	sub    %edx,%eax
  80eaea:	eb 05                	jmp    80eaf1 <strncmp+0x35>
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
  80eaec:	b8 00 00 00 00       	mov    $0x0,%eax
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  80eaf1:	5b                   	pop    %ebx
  80eaf2:	5d                   	pop    %ebp
  80eaf3:	c3                   	ret    

0080eaf4 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80eaf4:	55                   	push   %ebp
  80eaf5:	89 e5                	mov    %esp,%ebp
  80eaf7:	8b 45 08             	mov    0x8(%ebp),%eax
  80eafa:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80eafe:	eb 07                	jmp    80eb07 <strchr+0x13>
		if (*s == c)
  80eb00:	38 ca                	cmp    %cl,%dl
  80eb02:	74 0f                	je     80eb13 <strchr+0x1f>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80eb04:	83 c0 01             	add    $0x1,%eax
  80eb07:	0f b6 10             	movzbl (%eax),%edx
  80eb0a:	84 d2                	test   %dl,%dl
  80eb0c:	75 f2                	jne    80eb00 <strchr+0xc>
		if (*s == c)
			return (char *) s;
	return 0;
  80eb0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80eb13:	5d                   	pop    %ebp
  80eb14:	c3                   	ret    

0080eb15 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80eb15:	55                   	push   %ebp
  80eb16:	89 e5                	mov    %esp,%ebp
  80eb18:	8b 45 08             	mov    0x8(%ebp),%eax
  80eb1b:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80eb1f:	eb 03                	jmp    80eb24 <strfind+0xf>
  80eb21:	83 c0 01             	add    $0x1,%eax
  80eb24:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80eb27:	38 ca                	cmp    %cl,%dl
  80eb29:	74 04                	je     80eb2f <strfind+0x1a>
  80eb2b:	84 d2                	test   %dl,%dl
  80eb2d:	75 f2                	jne    80eb21 <strfind+0xc>
			break;
	return (char *) s;
}
  80eb2f:	5d                   	pop    %ebp
  80eb30:	c3                   	ret    

0080eb31 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80eb31:	55                   	push   %ebp
  80eb32:	89 e5                	mov    %esp,%ebp
  80eb34:	57                   	push   %edi
  80eb35:	56                   	push   %esi
  80eb36:	53                   	push   %ebx
  80eb37:	8b 7d 08             	mov    0x8(%ebp),%edi
  80eb3a:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80eb3d:	85 c9                	test   %ecx,%ecx
  80eb3f:	74 36                	je     80eb77 <memset+0x46>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80eb41:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80eb47:	75 28                	jne    80eb71 <memset+0x40>
  80eb49:	f6 c1 03             	test   $0x3,%cl
  80eb4c:	75 23                	jne    80eb71 <memset+0x40>
		c &= 0xFF;
  80eb4e:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80eb52:	89 d3                	mov    %edx,%ebx
  80eb54:	c1 e3 08             	shl    $0x8,%ebx
  80eb57:	89 d6                	mov    %edx,%esi
  80eb59:	c1 e6 18             	shl    $0x18,%esi
  80eb5c:	89 d0                	mov    %edx,%eax
  80eb5e:	c1 e0 10             	shl    $0x10,%eax
  80eb61:	09 f0                	or     %esi,%eax
  80eb63:	09 c2                	or     %eax,%edx
		asm volatile("cld; rep stosl\n"
  80eb65:	89 d8                	mov    %ebx,%eax
  80eb67:	09 d0                	or     %edx,%eax
  80eb69:	c1 e9 02             	shr    $0x2,%ecx
  80eb6c:	fc                   	cld    
  80eb6d:	f3 ab                	rep stos %eax,%es:(%edi)
  80eb6f:	eb 06                	jmp    80eb77 <memset+0x46>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80eb71:	8b 45 0c             	mov    0xc(%ebp),%eax
  80eb74:	fc                   	cld    
  80eb75:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80eb77:	89 f8                	mov    %edi,%eax
  80eb79:	5b                   	pop    %ebx
  80eb7a:	5e                   	pop    %esi
  80eb7b:	5f                   	pop    %edi
  80eb7c:	5d                   	pop    %ebp
  80eb7d:	c3                   	ret    

0080eb7e <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80eb7e:	55                   	push   %ebp
  80eb7f:	89 e5                	mov    %esp,%ebp
  80eb81:	57                   	push   %edi
  80eb82:	56                   	push   %esi
  80eb83:	8b 45 08             	mov    0x8(%ebp),%eax
  80eb86:	8b 75 0c             	mov    0xc(%ebp),%esi
  80eb89:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80eb8c:	39 c6                	cmp    %eax,%esi
  80eb8e:	73 35                	jae    80ebc5 <memmove+0x47>
  80eb90:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80eb93:	39 d0                	cmp    %edx,%eax
  80eb95:	73 2e                	jae    80ebc5 <memmove+0x47>
		s += n;
		d += n;
  80eb97:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80eb9a:	89 d6                	mov    %edx,%esi
  80eb9c:	09 fe                	or     %edi,%esi
  80eb9e:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80eba4:	75 13                	jne    80ebb9 <memmove+0x3b>
  80eba6:	f6 c1 03             	test   $0x3,%cl
  80eba9:	75 0e                	jne    80ebb9 <memmove+0x3b>
			asm volatile("std; rep movsl\n"
  80ebab:	83 ef 04             	sub    $0x4,%edi
  80ebae:	8d 72 fc             	lea    -0x4(%edx),%esi
  80ebb1:	c1 e9 02             	shr    $0x2,%ecx
  80ebb4:	fd                   	std    
  80ebb5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80ebb7:	eb 09                	jmp    80ebc2 <memmove+0x44>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80ebb9:	83 ef 01             	sub    $0x1,%edi
  80ebbc:	8d 72 ff             	lea    -0x1(%edx),%esi
  80ebbf:	fd                   	std    
  80ebc0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80ebc2:	fc                   	cld    
  80ebc3:	eb 1d                	jmp    80ebe2 <memmove+0x64>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80ebc5:	89 f2                	mov    %esi,%edx
  80ebc7:	09 c2                	or     %eax,%edx
  80ebc9:	f6 c2 03             	test   $0x3,%dl
  80ebcc:	75 0f                	jne    80ebdd <memmove+0x5f>
  80ebce:	f6 c1 03             	test   $0x3,%cl
  80ebd1:	75 0a                	jne    80ebdd <memmove+0x5f>
			asm volatile("cld; rep movsl\n"
  80ebd3:	c1 e9 02             	shr    $0x2,%ecx
  80ebd6:	89 c7                	mov    %eax,%edi
  80ebd8:	fc                   	cld    
  80ebd9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80ebdb:	eb 05                	jmp    80ebe2 <memmove+0x64>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80ebdd:	89 c7                	mov    %eax,%edi
  80ebdf:	fc                   	cld    
  80ebe0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80ebe2:	5e                   	pop    %esi
  80ebe3:	5f                   	pop    %edi
  80ebe4:	5d                   	pop    %ebp
  80ebe5:	c3                   	ret    

0080ebe6 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80ebe6:	55                   	push   %ebp
  80ebe7:	89 e5                	mov    %esp,%ebp
	return memmove(dst, src, n);
  80ebe9:	ff 75 10             	pushl  0x10(%ebp)
  80ebec:	ff 75 0c             	pushl  0xc(%ebp)
  80ebef:	ff 75 08             	pushl  0x8(%ebp)
  80ebf2:	e8 87 ff ff ff       	call   80eb7e <memmove>
}
  80ebf7:	c9                   	leave  
  80ebf8:	c3                   	ret    

0080ebf9 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80ebf9:	55                   	push   %ebp
  80ebfa:	89 e5                	mov    %esp,%ebp
  80ebfc:	56                   	push   %esi
  80ebfd:	53                   	push   %ebx
  80ebfe:	8b 45 08             	mov    0x8(%ebp),%eax
  80ec01:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ec04:	89 c6                	mov    %eax,%esi
  80ec06:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80ec09:	eb 1a                	jmp    80ec25 <memcmp+0x2c>
		if (*s1 != *s2)
  80ec0b:	0f b6 08             	movzbl (%eax),%ecx
  80ec0e:	0f b6 1a             	movzbl (%edx),%ebx
  80ec11:	38 d9                	cmp    %bl,%cl
  80ec13:	74 0a                	je     80ec1f <memcmp+0x26>
			return (int) *s1 - (int) *s2;
  80ec15:	0f b6 c1             	movzbl %cl,%eax
  80ec18:	0f b6 db             	movzbl %bl,%ebx
  80ec1b:	29 d8                	sub    %ebx,%eax
  80ec1d:	eb 0f                	jmp    80ec2e <memcmp+0x35>
		s1++, s2++;
  80ec1f:	83 c0 01             	add    $0x1,%eax
  80ec22:	83 c2 01             	add    $0x1,%edx
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80ec25:	39 f0                	cmp    %esi,%eax
  80ec27:	75 e2                	jne    80ec0b <memcmp+0x12>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80ec29:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ec2e:	5b                   	pop    %ebx
  80ec2f:	5e                   	pop    %esi
  80ec30:	5d                   	pop    %ebp
  80ec31:	c3                   	ret    

0080ec32 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80ec32:	55                   	push   %ebp
  80ec33:	89 e5                	mov    %esp,%ebp
  80ec35:	53                   	push   %ebx
  80ec36:	8b 45 08             	mov    0x8(%ebp),%eax
	const void *ends = (const char *) s + n;
  80ec39:	89 c1                	mov    %eax,%ecx
  80ec3b:	03 4d 10             	add    0x10(%ebp),%ecx
	for (; s < ends; s++)
		if (*(const unsigned char *) s == (unsigned char) c)
  80ec3e:	0f b6 5d 0c          	movzbl 0xc(%ebp),%ebx

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80ec42:	eb 0a                	jmp    80ec4e <memfind+0x1c>
		if (*(const unsigned char *) s == (unsigned char) c)
  80ec44:	0f b6 10             	movzbl (%eax),%edx
  80ec47:	39 da                	cmp    %ebx,%edx
  80ec49:	74 07                	je     80ec52 <memfind+0x20>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80ec4b:	83 c0 01             	add    $0x1,%eax
  80ec4e:	39 c8                	cmp    %ecx,%eax
  80ec50:	72 f2                	jb     80ec44 <memfind+0x12>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  80ec52:	5b                   	pop    %ebx
  80ec53:	5d                   	pop    %ebp
  80ec54:	c3                   	ret    

0080ec55 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80ec55:	55                   	push   %ebp
  80ec56:	89 e5                	mov    %esp,%ebp
  80ec58:	57                   	push   %edi
  80ec59:	56                   	push   %esi
  80ec5a:	53                   	push   %ebx
  80ec5b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ec5e:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80ec61:	eb 03                	jmp    80ec66 <strtol+0x11>
		s++;
  80ec63:	83 c1 01             	add    $0x1,%ecx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80ec66:	0f b6 01             	movzbl (%ecx),%eax
  80ec69:	3c 20                	cmp    $0x20,%al
  80ec6b:	74 f6                	je     80ec63 <strtol+0xe>
  80ec6d:	3c 09                	cmp    $0x9,%al
  80ec6f:	74 f2                	je     80ec63 <strtol+0xe>
		s++;

	// plus/minus sign
	if (*s == '+')
  80ec71:	3c 2b                	cmp    $0x2b,%al
  80ec73:	75 0a                	jne    80ec7f <strtol+0x2a>
		s++;
  80ec75:	83 c1 01             	add    $0x1,%ecx
}

long
strtol(const char *s, char **endptr, int base)
{
	int neg = 0;
  80ec78:	bf 00 00 00 00       	mov    $0x0,%edi
  80ec7d:	eb 11                	jmp    80ec90 <strtol+0x3b>
  80ec7f:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;

	// plus/minus sign
	if (*s == '+')
		s++;
	else if (*s == '-')
  80ec84:	3c 2d                	cmp    $0x2d,%al
  80ec86:	75 08                	jne    80ec90 <strtol+0x3b>
		s++, neg = 1;
  80ec88:	83 c1 01             	add    $0x1,%ecx
  80ec8b:	bf 01 00 00 00       	mov    $0x1,%edi

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80ec90:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80ec96:	75 15                	jne    80ecad <strtol+0x58>
  80ec98:	80 39 30             	cmpb   $0x30,(%ecx)
  80ec9b:	75 10                	jne    80ecad <strtol+0x58>
  80ec9d:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  80eca1:	75 7c                	jne    80ed1f <strtol+0xca>
		s += 2, base = 16;
  80eca3:	83 c1 02             	add    $0x2,%ecx
  80eca6:	bb 10 00 00 00       	mov    $0x10,%ebx
  80ecab:	eb 16                	jmp    80ecc3 <strtol+0x6e>
	else if (base == 0 && s[0] == '0')
  80ecad:	85 db                	test   %ebx,%ebx
  80ecaf:	75 12                	jne    80ecc3 <strtol+0x6e>
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80ecb1:	bb 0a 00 00 00       	mov    $0xa,%ebx
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80ecb6:	80 39 30             	cmpb   $0x30,(%ecx)
  80ecb9:	75 08                	jne    80ecc3 <strtol+0x6e>
		s++, base = 8;
  80ecbb:	83 c1 01             	add    $0x1,%ecx
  80ecbe:	bb 08 00 00 00       	mov    $0x8,%ebx
	else if (base == 0)
		base = 10;
  80ecc3:	b8 00 00 00 00       	mov    $0x0,%eax
  80ecc8:	89 5d 10             	mov    %ebx,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  80eccb:	0f b6 11             	movzbl (%ecx),%edx
  80ecce:	8d 72 d0             	lea    -0x30(%edx),%esi
  80ecd1:	89 f3                	mov    %esi,%ebx
  80ecd3:	80 fb 09             	cmp    $0x9,%bl
  80ecd6:	77 08                	ja     80ece0 <strtol+0x8b>
			dig = *s - '0';
  80ecd8:	0f be d2             	movsbl %dl,%edx
  80ecdb:	83 ea 30             	sub    $0x30,%edx
  80ecde:	eb 22                	jmp    80ed02 <strtol+0xad>
		else if (*s >= 'a' && *s <= 'z')
  80ece0:	8d 72 9f             	lea    -0x61(%edx),%esi
  80ece3:	89 f3                	mov    %esi,%ebx
  80ece5:	80 fb 19             	cmp    $0x19,%bl
  80ece8:	77 08                	ja     80ecf2 <strtol+0x9d>
			dig = *s - 'a' + 10;
  80ecea:	0f be d2             	movsbl %dl,%edx
  80eced:	83 ea 57             	sub    $0x57,%edx
  80ecf0:	eb 10                	jmp    80ed02 <strtol+0xad>
		else if (*s >= 'A' && *s <= 'Z')
  80ecf2:	8d 72 bf             	lea    -0x41(%edx),%esi
  80ecf5:	89 f3                	mov    %esi,%ebx
  80ecf7:	80 fb 19             	cmp    $0x19,%bl
  80ecfa:	77 16                	ja     80ed12 <strtol+0xbd>
			dig = *s - 'A' + 10;
  80ecfc:	0f be d2             	movsbl %dl,%edx
  80ecff:	83 ea 37             	sub    $0x37,%edx
		else
			break;
		if (dig >= base)
  80ed02:	3b 55 10             	cmp    0x10(%ebp),%edx
  80ed05:	7d 0b                	jge    80ed12 <strtol+0xbd>
			break;
		s++, val = (val * base) + dig;
  80ed07:	83 c1 01             	add    $0x1,%ecx
  80ed0a:	0f af 45 10          	imul   0x10(%ebp),%eax
  80ed0e:	01 d0                	add    %edx,%eax
		// we don't properly detect overflow!
	}
  80ed10:	eb b9                	jmp    80eccb <strtol+0x76>

	if (endptr)
  80ed12:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80ed16:	74 0d                	je     80ed25 <strtol+0xd0>
		*endptr = (char *) s;
  80ed18:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ed1b:	89 0e                	mov    %ecx,(%esi)
  80ed1d:	eb 06                	jmp    80ed25 <strtol+0xd0>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80ed1f:	85 db                	test   %ebx,%ebx
  80ed21:	74 98                	je     80ecbb <strtol+0x66>
  80ed23:	eb 9e                	jmp    80ecc3 <strtol+0x6e>
		// we don't properly detect overflow!
	}

	if (endptr)
		*endptr = (char *) s;
	return (neg ? -val : val);
  80ed25:	89 c2                	mov    %eax,%edx
  80ed27:	f7 da                	neg    %edx
  80ed29:	85 ff                	test   %edi,%edi
  80ed2b:	0f 45 c2             	cmovne %edx,%eax
}
  80ed2e:	5b                   	pop    %ebx
  80ed2f:	5e                   	pop    %esi
  80ed30:	5f                   	pop    %edi
  80ed31:	5d                   	pop    %ebp
  80ed32:	c3                   	ret    

0080ed33 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80ed33:	55                   	push   %ebp
  80ed34:	89 e5                	mov    %esp,%ebp
  80ed36:	57                   	push   %edi
  80ed37:	56                   	push   %esi
  80ed38:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ed39:	b8 00 00 00 00       	mov    $0x0,%eax
  80ed3e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ed41:	8b 55 08             	mov    0x8(%ebp),%edx
  80ed44:	89 c3                	mov    %eax,%ebx
  80ed46:	89 c7                	mov    %eax,%edi
  80ed48:	89 c6                	mov    %eax,%esi
  80ed4a:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80ed4c:	5b                   	pop    %ebx
  80ed4d:	5e                   	pop    %esi
  80ed4e:	5f                   	pop    %edi
  80ed4f:	5d                   	pop    %ebp
  80ed50:	c3                   	ret    

0080ed51 <sys_cgetc>:

int
sys_cgetc(void)
{
  80ed51:	55                   	push   %ebp
  80ed52:	89 e5                	mov    %esp,%ebp
  80ed54:	57                   	push   %edi
  80ed55:	56                   	push   %esi
  80ed56:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ed57:	ba 00 00 00 00       	mov    $0x0,%edx
  80ed5c:	b8 01 00 00 00       	mov    $0x1,%eax
  80ed61:	89 d1                	mov    %edx,%ecx
  80ed63:	89 d3                	mov    %edx,%ebx
  80ed65:	89 d7                	mov    %edx,%edi
  80ed67:	89 d6                	mov    %edx,%esi
  80ed69:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80ed6b:	5b                   	pop    %ebx
  80ed6c:	5e                   	pop    %esi
  80ed6d:	5f                   	pop    %edi
  80ed6e:	5d                   	pop    %ebp
  80ed6f:	c3                   	ret    

0080ed70 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80ed70:	55                   	push   %ebp
  80ed71:	89 e5                	mov    %esp,%ebp
  80ed73:	57                   	push   %edi
  80ed74:	56                   	push   %esi
  80ed75:	53                   	push   %ebx
  80ed76:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ed79:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ed7e:	b8 03 00 00 00       	mov    $0x3,%eax
  80ed83:	8b 55 08             	mov    0x8(%ebp),%edx
  80ed86:	89 cb                	mov    %ecx,%ebx
  80ed88:	89 cf                	mov    %ecx,%edi
  80ed8a:	89 ce                	mov    %ecx,%esi
  80ed8c:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80ed8e:	85 c0                	test   %eax,%eax
  80ed90:	7e 17                	jle    80eda9 <sys_env_destroy+0x39>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ed92:	83 ec 0c             	sub    $0xc,%esp
  80ed95:	50                   	push   %eax
  80ed96:	6a 03                	push   $0x3
  80ed98:	68 bf 33 81 00       	push   $0x8133bf
  80ed9d:	6a 23                	push   $0x23
  80ed9f:	68 dc 33 81 00       	push   $0x8133dc
  80eda4:	e8 e5 f5 ff ff       	call   80e38e <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80eda9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80edac:	5b                   	pop    %ebx
  80edad:	5e                   	pop    %esi
  80edae:	5f                   	pop    %edi
  80edaf:	5d                   	pop    %ebp
  80edb0:	c3                   	ret    

0080edb1 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80edb1:	55                   	push   %ebp
  80edb2:	89 e5                	mov    %esp,%ebp
  80edb4:	57                   	push   %edi
  80edb5:	56                   	push   %esi
  80edb6:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80edb7:	ba 00 00 00 00       	mov    $0x0,%edx
  80edbc:	b8 02 00 00 00       	mov    $0x2,%eax
  80edc1:	89 d1                	mov    %edx,%ecx
  80edc3:	89 d3                	mov    %edx,%ebx
  80edc5:	89 d7                	mov    %edx,%edi
  80edc7:	89 d6                	mov    %edx,%esi
  80edc9:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80edcb:	5b                   	pop    %ebx
  80edcc:	5e                   	pop    %esi
  80edcd:	5f                   	pop    %edi
  80edce:	5d                   	pop    %ebp
  80edcf:	c3                   	ret    

0080edd0 <sys_yield>:

void
sys_yield(void)
{
  80edd0:	55                   	push   %ebp
  80edd1:	89 e5                	mov    %esp,%ebp
  80edd3:	57                   	push   %edi
  80edd4:	56                   	push   %esi
  80edd5:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80edd6:	ba 00 00 00 00       	mov    $0x0,%edx
  80eddb:	b8 0b 00 00 00       	mov    $0xb,%eax
  80ede0:	89 d1                	mov    %edx,%ecx
  80ede2:	89 d3                	mov    %edx,%ebx
  80ede4:	89 d7                	mov    %edx,%edi
  80ede6:	89 d6                	mov    %edx,%esi
  80ede8:	cd 30                	int    $0x30

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80edea:	5b                   	pop    %ebx
  80edeb:	5e                   	pop    %esi
  80edec:	5f                   	pop    %edi
  80eded:	5d                   	pop    %ebp
  80edee:	c3                   	ret    

0080edef <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80edef:	55                   	push   %ebp
  80edf0:	89 e5                	mov    %esp,%ebp
  80edf2:	57                   	push   %edi
  80edf3:	56                   	push   %esi
  80edf4:	53                   	push   %ebx
  80edf5:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80edf8:	be 00 00 00 00       	mov    $0x0,%esi
  80edfd:	b8 04 00 00 00       	mov    $0x4,%eax
  80ee02:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ee05:	8b 55 08             	mov    0x8(%ebp),%edx
  80ee08:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80ee0b:	89 f7                	mov    %esi,%edi
  80ee0d:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80ee0f:	85 c0                	test   %eax,%eax
  80ee11:	7e 17                	jle    80ee2a <sys_page_alloc+0x3b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ee13:	83 ec 0c             	sub    $0xc,%esp
  80ee16:	50                   	push   %eax
  80ee17:	6a 04                	push   $0x4
  80ee19:	68 bf 33 81 00       	push   $0x8133bf
  80ee1e:	6a 23                	push   $0x23
  80ee20:	68 dc 33 81 00       	push   $0x8133dc
  80ee25:	e8 64 f5 ff ff       	call   80e38e <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80ee2a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ee2d:	5b                   	pop    %ebx
  80ee2e:	5e                   	pop    %esi
  80ee2f:	5f                   	pop    %edi
  80ee30:	5d                   	pop    %ebp
  80ee31:	c3                   	ret    

0080ee32 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80ee32:	55                   	push   %ebp
  80ee33:	89 e5                	mov    %esp,%ebp
  80ee35:	57                   	push   %edi
  80ee36:	56                   	push   %esi
  80ee37:	53                   	push   %ebx
  80ee38:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ee3b:	b8 05 00 00 00       	mov    $0x5,%eax
  80ee40:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ee43:	8b 55 08             	mov    0x8(%ebp),%edx
  80ee46:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80ee49:	8b 7d 14             	mov    0x14(%ebp),%edi
  80ee4c:	8b 75 18             	mov    0x18(%ebp),%esi
  80ee4f:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80ee51:	85 c0                	test   %eax,%eax
  80ee53:	7e 17                	jle    80ee6c <sys_page_map+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ee55:	83 ec 0c             	sub    $0xc,%esp
  80ee58:	50                   	push   %eax
  80ee59:	6a 05                	push   $0x5
  80ee5b:	68 bf 33 81 00       	push   $0x8133bf
  80ee60:	6a 23                	push   $0x23
  80ee62:	68 dc 33 81 00       	push   $0x8133dc
  80ee67:	e8 22 f5 ff ff       	call   80e38e <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80ee6c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ee6f:	5b                   	pop    %ebx
  80ee70:	5e                   	pop    %esi
  80ee71:	5f                   	pop    %edi
  80ee72:	5d                   	pop    %ebp
  80ee73:	c3                   	ret    

0080ee74 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80ee74:	55                   	push   %ebp
  80ee75:	89 e5                	mov    %esp,%ebp
  80ee77:	57                   	push   %edi
  80ee78:	56                   	push   %esi
  80ee79:	53                   	push   %ebx
  80ee7a:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ee7d:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ee82:	b8 06 00 00 00       	mov    $0x6,%eax
  80ee87:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ee8a:	8b 55 08             	mov    0x8(%ebp),%edx
  80ee8d:	89 df                	mov    %ebx,%edi
  80ee8f:	89 de                	mov    %ebx,%esi
  80ee91:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80ee93:	85 c0                	test   %eax,%eax
  80ee95:	7e 17                	jle    80eeae <sys_page_unmap+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ee97:	83 ec 0c             	sub    $0xc,%esp
  80ee9a:	50                   	push   %eax
  80ee9b:	6a 06                	push   $0x6
  80ee9d:	68 bf 33 81 00       	push   $0x8133bf
  80eea2:	6a 23                	push   $0x23
  80eea4:	68 dc 33 81 00       	push   $0x8133dc
  80eea9:	e8 e0 f4 ff ff       	call   80e38e <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80eeae:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80eeb1:	5b                   	pop    %ebx
  80eeb2:	5e                   	pop    %esi
  80eeb3:	5f                   	pop    %edi
  80eeb4:	5d                   	pop    %ebp
  80eeb5:	c3                   	ret    

0080eeb6 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80eeb6:	55                   	push   %ebp
  80eeb7:	89 e5                	mov    %esp,%ebp
  80eeb9:	57                   	push   %edi
  80eeba:	56                   	push   %esi
  80eebb:	53                   	push   %ebx
  80eebc:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80eebf:	bb 00 00 00 00       	mov    $0x0,%ebx
  80eec4:	b8 08 00 00 00       	mov    $0x8,%eax
  80eec9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80eecc:	8b 55 08             	mov    0x8(%ebp),%edx
  80eecf:	89 df                	mov    %ebx,%edi
  80eed1:	89 de                	mov    %ebx,%esi
  80eed3:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80eed5:	85 c0                	test   %eax,%eax
  80eed7:	7e 17                	jle    80eef0 <sys_env_set_status+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80eed9:	83 ec 0c             	sub    $0xc,%esp
  80eedc:	50                   	push   %eax
  80eedd:	6a 08                	push   $0x8
  80eedf:	68 bf 33 81 00       	push   $0x8133bf
  80eee4:	6a 23                	push   $0x23
  80eee6:	68 dc 33 81 00       	push   $0x8133dc
  80eeeb:	e8 9e f4 ff ff       	call   80e38e <_panic>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80eef0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80eef3:	5b                   	pop    %ebx
  80eef4:	5e                   	pop    %esi
  80eef5:	5f                   	pop    %edi
  80eef6:	5d                   	pop    %ebp
  80eef7:	c3                   	ret    

0080eef8 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80eef8:	55                   	push   %ebp
  80eef9:	89 e5                	mov    %esp,%ebp
  80eefb:	57                   	push   %edi
  80eefc:	56                   	push   %esi
  80eefd:	53                   	push   %ebx
  80eefe:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ef01:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ef06:	b8 09 00 00 00       	mov    $0x9,%eax
  80ef0b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef0e:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef11:	89 df                	mov    %ebx,%edi
  80ef13:	89 de                	mov    %ebx,%esi
  80ef15:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80ef17:	85 c0                	test   %eax,%eax
  80ef19:	7e 17                	jle    80ef32 <sys_env_set_trapframe+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ef1b:	83 ec 0c             	sub    $0xc,%esp
  80ef1e:	50                   	push   %eax
  80ef1f:	6a 09                	push   $0x9
  80ef21:	68 bf 33 81 00       	push   $0x8133bf
  80ef26:	6a 23                	push   $0x23
  80ef28:	68 dc 33 81 00       	push   $0x8133dc
  80ef2d:	e8 5c f4 ff ff       	call   80e38e <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80ef32:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ef35:	5b                   	pop    %ebx
  80ef36:	5e                   	pop    %esi
  80ef37:	5f                   	pop    %edi
  80ef38:	5d                   	pop    %ebp
  80ef39:	c3                   	ret    

0080ef3a <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80ef3a:	55                   	push   %ebp
  80ef3b:	89 e5                	mov    %esp,%ebp
  80ef3d:	57                   	push   %edi
  80ef3e:	56                   	push   %esi
  80ef3f:	53                   	push   %ebx
  80ef40:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ef43:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ef48:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ef4d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef50:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef53:	89 df                	mov    %ebx,%edi
  80ef55:	89 de                	mov    %ebx,%esi
  80ef57:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80ef59:	85 c0                	test   %eax,%eax
  80ef5b:	7e 17                	jle    80ef74 <sys_env_set_pgfault_upcall+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ef5d:	83 ec 0c             	sub    $0xc,%esp
  80ef60:	50                   	push   %eax
  80ef61:	6a 0a                	push   $0xa
  80ef63:	68 bf 33 81 00       	push   $0x8133bf
  80ef68:	6a 23                	push   $0x23
  80ef6a:	68 dc 33 81 00       	push   $0x8133dc
  80ef6f:	e8 1a f4 ff ff       	call   80e38e <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80ef74:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ef77:	5b                   	pop    %ebx
  80ef78:	5e                   	pop    %esi
  80ef79:	5f                   	pop    %edi
  80ef7a:	5d                   	pop    %ebp
  80ef7b:	c3                   	ret    

0080ef7c <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80ef7c:	55                   	push   %ebp
  80ef7d:	89 e5                	mov    %esp,%ebp
  80ef7f:	57                   	push   %edi
  80ef80:	56                   	push   %esi
  80ef81:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ef82:	be 00 00 00 00       	mov    $0x0,%esi
  80ef87:	b8 0c 00 00 00       	mov    $0xc,%eax
  80ef8c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef8f:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef92:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80ef95:	8b 7d 14             	mov    0x14(%ebp),%edi
  80ef98:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80ef9a:	5b                   	pop    %ebx
  80ef9b:	5e                   	pop    %esi
  80ef9c:	5f                   	pop    %edi
  80ef9d:	5d                   	pop    %ebp
  80ef9e:	c3                   	ret    

0080ef9f <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80ef9f:	55                   	push   %ebp
  80efa0:	89 e5                	mov    %esp,%ebp
  80efa2:	57                   	push   %edi
  80efa3:	56                   	push   %esi
  80efa4:	53                   	push   %ebx
  80efa5:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80efa8:	b9 00 00 00 00       	mov    $0x0,%ecx
  80efad:	b8 0d 00 00 00       	mov    $0xd,%eax
  80efb2:	8b 55 08             	mov    0x8(%ebp),%edx
  80efb5:	89 cb                	mov    %ecx,%ebx
  80efb7:	89 cf                	mov    %ecx,%edi
  80efb9:	89 ce                	mov    %ecx,%esi
  80efbb:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80efbd:	85 c0                	test   %eax,%eax
  80efbf:	7e 17                	jle    80efd8 <sys_ipc_recv+0x39>
		panic("syscall %d returned %d (> 0)", num, ret);
  80efc1:	83 ec 0c             	sub    $0xc,%esp
  80efc4:	50                   	push   %eax
  80efc5:	6a 0d                	push   $0xd
  80efc7:	68 bf 33 81 00       	push   $0x8133bf
  80efcc:	6a 23                	push   $0x23
  80efce:	68 dc 33 81 00       	push   $0x8133dc
  80efd3:	e8 b6 f3 ff ff       	call   80e38e <_panic>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80efd8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80efdb:	5b                   	pop    %ebx
  80efdc:	5e                   	pop    %esi
  80efdd:	5f                   	pop    %edi
  80efde:	5d                   	pop    %ebp
  80efdf:	c3                   	ret    

0080efe0 <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80efe0:	55                   	push   %ebp
  80efe1:	89 e5                	mov    %esp,%ebp
  80efe3:	57                   	push   %edi
  80efe4:	56                   	push   %esi
  80efe5:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80efe6:	ba 00 00 00 00       	mov    $0x0,%edx
  80efeb:	b8 0e 00 00 00       	mov    $0xe,%eax
  80eff0:	89 d1                	mov    %edx,%ecx
  80eff2:	89 d3                	mov    %edx,%ebx
  80eff4:	89 d7                	mov    %edx,%edi
  80eff6:	89 d6                	mov    %edx,%esi
  80eff8:	cd 30                	int    $0x30

unsigned int
sys_time_msec(void)
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80effa:	5b                   	pop    %ebx
  80effb:	5e                   	pop    %esi
  80effc:	5f                   	pop    %edi
  80effd:	5d                   	pop    %ebp
  80effe:	c3                   	ret    

0080efff <sys_e1000_try_send>:

int
sys_e1000_try_send(void *data, uint32_t len)
{
  80efff:	55                   	push   %ebp
  80f000:	89 e5                	mov    %esp,%ebp
  80f002:	57                   	push   %edi
  80f003:	56                   	push   %esi
  80f004:	53                   	push   %ebx
  80f005:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f008:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f00d:	b8 0f 00 00 00       	mov    $0xf,%eax
  80f012:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f015:	8b 55 08             	mov    0x8(%ebp),%edx
  80f018:	89 df                	mov    %ebx,%edi
  80f01a:	89 de                	mov    %ebx,%esi
  80f01c:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80f01e:	85 c0                	test   %eax,%eax
  80f020:	7e 17                	jle    80f039 <sys_e1000_try_send+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f022:	83 ec 0c             	sub    $0xc,%esp
  80f025:	50                   	push   %eax
  80f026:	6a 0f                	push   $0xf
  80f028:	68 bf 33 81 00       	push   $0x8133bf
  80f02d:	6a 23                	push   $0x23
  80f02f:	68 dc 33 81 00       	push   $0x8133dc
  80f034:	e8 55 f3 ff ff       	call   80e38e <_panic>

int
sys_e1000_try_send(void *data, uint32_t len)
{
	return syscall(SYS_e1000_try_send, 1, (uint32_t)data, len, 0, 0, 0);
}
  80f039:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f03c:	5b                   	pop    %ebx
  80f03d:	5e                   	pop    %esi
  80f03e:	5f                   	pop    %edi
  80f03f:	5d                   	pop    %ebp
  80f040:	c3                   	ret    

0080f041 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80f041:	55                   	push   %ebp
  80f042:	89 e5                	mov    %esp,%ebp
  80f044:	56                   	push   %esi
  80f045:	53                   	push   %ebx
  80f046:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  80f049:	8b 18                	mov    (%eax),%ebx
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.

	if ((err & FEC_WR) != FEC_WR && ((uvpt[PGNUM(addr)] & PTE_COW) != PTE_COW)) {
  80f04b:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  80f04f:	75 25                	jne    80f076 <pgfault+0x35>
  80f051:	89 d8                	mov    %ebx,%eax
  80f053:	c1 e8 0c             	shr    $0xc,%eax
  80f056:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f05d:	f6 c4 08             	test   $0x8,%ah
  80f060:	75 14                	jne    80f076 <pgfault+0x35>
		panic("pgfault: not due to a write or a COW page");
  80f062:	83 ec 04             	sub    $0x4,%esp
  80f065:	68 ec 33 81 00       	push   $0x8133ec
  80f06a:	6a 1e                	push   $0x1e
  80f06c:	68 80 34 81 00       	push   $0x813480
  80f071:	e8 18 f3 ff ff       	call   80e38e <_panic>

	// LAB 4: Your code here.

	// panic("pgfault not implemented");

	addr = ROUNDDOWN(addr, PGSIZE);
  80f076:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	envid_t envid = sys_getenvid();
  80f07c:	e8 30 fd ff ff       	call   80edb1 <sys_getenvid>
  80f081:	89 c6                	mov    %eax,%esi

	// envid = 0;

	// Allocate a new page, map it at a temporary location (PFTEMP)
	r = sys_page_alloc(envid, (void *)PFTEMP, PTE_U | PTE_P | PTE_W);
  80f083:	83 ec 04             	sub    $0x4,%esp
  80f086:	6a 07                	push   $0x7
  80f088:	68 00 f0 7f 00       	push   $0x7ff000
  80f08d:	50                   	push   %eax
  80f08e:	e8 5c fd ff ff       	call   80edef <sys_page_alloc>
	if (r < 0)
  80f093:	83 c4 10             	add    $0x10,%esp
  80f096:	85 c0                	test   %eax,%eax
  80f098:	79 12                	jns    80f0ac <pgfault+0x6b>
		panic("pgfault: sys_page_alloc failed: %e\n", r);
  80f09a:	50                   	push   %eax
  80f09b:	68 18 34 81 00       	push   $0x813418
  80f0a0:	6a 33                	push   $0x33
  80f0a2:	68 80 34 81 00       	push   $0x813480
  80f0a7:	e8 e2 f2 ff ff       	call   80e38e <_panic>
	
	// copy the data from the old page to the new page
	memcpy((void *) PFTEMP, (const void *) addr, PGSIZE);
  80f0ac:	83 ec 04             	sub    $0x4,%esp
  80f0af:	68 00 10 00 00       	push   $0x1000
  80f0b4:	53                   	push   %ebx
  80f0b5:	68 00 f0 7f 00       	push   $0x7ff000
  80f0ba:	e8 27 fb ff ff       	call   80ebe6 <memcpy>

	// move the new page to the old page's address
	r = sys_page_map(envid, (void *) PFTEMP, envid, addr, PTE_U | PTE_P | PTE_W);
  80f0bf:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f0c6:	53                   	push   %ebx
  80f0c7:	56                   	push   %esi
  80f0c8:	68 00 f0 7f 00       	push   $0x7ff000
  80f0cd:	56                   	push   %esi
  80f0ce:	e8 5f fd ff ff       	call   80ee32 <sys_page_map>
	if (r < 0)
  80f0d3:	83 c4 20             	add    $0x20,%esp
  80f0d6:	85 c0                	test   %eax,%eax
  80f0d8:	79 12                	jns    80f0ec <pgfault+0xab>
		panic("pgfault: sys_page_map failed: %e\n", r);
  80f0da:	50                   	push   %eax
  80f0db:	68 3c 34 81 00       	push   $0x81343c
  80f0e0:	6a 3b                	push   $0x3b
  80f0e2:	68 80 34 81 00       	push   $0x813480
  80f0e7:	e8 a2 f2 ff ff       	call   80e38e <_panic>

	// unmap temporary region
	r = sys_page_unmap(envid, (void *) PFTEMP);
  80f0ec:	83 ec 08             	sub    $0x8,%esp
  80f0ef:	68 00 f0 7f 00       	push   $0x7ff000
  80f0f4:	56                   	push   %esi
  80f0f5:	e8 7a fd ff ff       	call   80ee74 <sys_page_unmap>
	if (r < 0)
  80f0fa:	83 c4 10             	add    $0x10,%esp
  80f0fd:	85 c0                	test   %eax,%eax
  80f0ff:	79 12                	jns    80f113 <pgfault+0xd2>
        panic("pgfault: page unmap failed: %e\n", r);
  80f101:	50                   	push   %eax
  80f102:	68 60 34 81 00       	push   $0x813460
  80f107:	6a 40                	push   $0x40
  80f109:	68 80 34 81 00       	push   $0x813480
  80f10e:	e8 7b f2 ff ff       	call   80e38e <_panic>
}
  80f113:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f116:	5b                   	pop    %ebx
  80f117:	5e                   	pop    %esi
  80f118:	5d                   	pop    %ebp
  80f119:	c3                   	ret    

0080f11a <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f11a:	55                   	push   %ebp
  80f11b:	89 e5                	mov    %esp,%ebp
  80f11d:	57                   	push   %edi
  80f11e:	56                   	push   %esi
  80f11f:	53                   	push   %ebx
  80f120:	83 ec 28             	sub    $0x28,%esp
	// LAB 4: Your code here.
	// cprintf("[fork]\n");
	int r;

	set_pgfault_handler(pgfault);
  80f123:	68 41 f0 80 00       	push   $0x80f041
  80f128:	e8 6a 16 00 00       	call   810797 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  80f12d:	b8 07 00 00 00       	mov    $0x7,%eax
  80f132:	cd 30                	int    $0x30

	envid_t envid = sys_exofork();
	if (envid < 0)
  80f134:	83 c4 10             	add    $0x10,%esp
  80f137:	85 c0                	test   %eax,%eax
  80f139:	0f 88 64 01 00 00    	js     80f2a3 <fork+0x189>
  80f13f:	bb 00 00 80 00       	mov    $0x800000,%ebx
  80f144:	be 00 08 00 00       	mov    $0x800,%esi
		return envid;

	// fix "thisenv" in the child process
	if (envid == 0) {
  80f149:	85 c0                	test   %eax,%eax
  80f14b:	75 21                	jne    80f16e <fork+0x54>
		thisenv = &envs[ENVX(sys_getenvid())];
  80f14d:	e8 5f fc ff ff       	call   80edb1 <sys_getenvid>
  80f152:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f157:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f15a:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f15f:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
        return 0;
  80f164:	ba 00 00 00 00       	mov    $0x0,%edx
  80f169:	e9 3f 01 00 00       	jmp    80f2ad <fork+0x193>
  80f16e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80f171:	89 c7                	mov    %eax,%edi
	for (uint32_t pn = PGNUM(UTEXT); pn < PGNUM(USTACKTOP); pn++) {

		addr = pn * PGSIZE;

		// if level-2 page exists
		if ((uvpd[PDX(addr)] & PTE_P) == PTE_P) {
  80f173:	89 d8                	mov    %ebx,%eax
  80f175:	c1 e8 16             	shr    $0x16,%eax
  80f178:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f17f:	a8 01                	test   $0x1,%al
  80f181:	0f 84 bd 00 00 00    	je     80f244 <fork+0x12a>
			
			// if real PTE exists
			if ((uvpt[PGNUM(addr)] & PTE_P) == PTE_P) {
  80f187:	89 d8                	mov    %ebx,%eax
  80f189:	c1 e8 0c             	shr    $0xc,%eax
  80f18c:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f193:	f6 c2 01             	test   $0x1,%dl
  80f196:	0f 84 a8 00 00 00    	je     80f244 <fork+0x12a>

				// For each writable or copy-on-write page
				// if ((uvpt[PGNUM(addr)] & (PTE_W | PTE_COW)) != 0) {
				if ((uvpt[PGNUM(addr)] & PTE_U) != 0) {
  80f19c:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f1a3:	a8 04                	test   $0x4,%al
  80f1a5:	0f 84 99 00 00 00    	je     80f244 <fork+0x12a>
	// r = envid2env(envid, &env, 1);
	// if (r < 0)
	// 	return r;	// E_BAD_ENV
	// envid_t parent_envid = env->env_parent_id;

	if (uvpt[pn] & PTE_SHARE) {
  80f1ab:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f1b2:	f6 c4 04             	test   $0x4,%ah
  80f1b5:	74 17                	je     80f1ce <fork+0xb4>
		sys_page_map(0, (void *)va, envid, (void *)va, PTE_SYSCALL);
  80f1b7:	83 ec 0c             	sub    $0xc,%esp
  80f1ba:	68 07 0e 00 00       	push   $0xe07
  80f1bf:	53                   	push   %ebx
  80f1c0:	57                   	push   %edi
  80f1c1:	53                   	push   %ebx
  80f1c2:	6a 00                	push   $0x0
  80f1c4:	e8 69 fc ff ff       	call   80ee32 <sys_page_map>
  80f1c9:	83 c4 20             	add    $0x20,%esp
  80f1cc:	eb 76                	jmp    80f244 <fork+0x12a>
	}
	else if ((uvpt[pn] & PTE_W) == PTE_W || (uvpt[pn] & PTE_COW) == PTE_COW) {
  80f1ce:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f1d5:	a8 02                	test   $0x2,%al
  80f1d7:	75 0c                	jne    80f1e5 <fork+0xcb>
  80f1d9:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f1e0:	f6 c4 08             	test   $0x8,%ah
  80f1e3:	74 3f                	je     80f224 <fork+0x10a>

		// map the page copy-on-write into the address space of the child
        r = sys_page_map(0, (void *)va, envid, (void *)va, PTE_P|PTE_U|PTE_COW);
  80f1e5:	83 ec 0c             	sub    $0xc,%esp
  80f1e8:	68 05 08 00 00       	push   $0x805
  80f1ed:	53                   	push   %ebx
  80f1ee:	57                   	push   %edi
  80f1ef:	53                   	push   %ebx
  80f1f0:	6a 00                	push   $0x0
  80f1f2:	e8 3b fc ff ff       	call   80ee32 <sys_page_map>
		if (r < 0)
  80f1f7:	83 c4 20             	add    $0x20,%esp
  80f1fa:	85 c0                	test   %eax,%eax
  80f1fc:	0f 88 a5 00 00 00    	js     80f2a7 <fork+0x18d>
            return r;

		// remap the page copy-on-write in its own(parent) address space
        r = sys_page_map(0, (void *)va, 0, (void *)va, PTE_P|PTE_U|PTE_COW);
  80f202:	83 ec 0c             	sub    $0xc,%esp
  80f205:	68 05 08 00 00       	push   $0x805
  80f20a:	53                   	push   %ebx
  80f20b:	6a 00                	push   $0x0
  80f20d:	53                   	push   %ebx
  80f20e:	6a 00                	push   $0x0
  80f210:	e8 1d fc ff ff       	call   80ee32 <sys_page_map>
  80f215:	83 c4 20             	add    $0x20,%esp
  80f218:	85 c0                	test   %eax,%eax
  80f21a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f21f:	0f 4f c1             	cmovg  %ecx,%eax
  80f222:	eb 1c                	jmp    80f240 <fork+0x126>
		if (r < 0)
            return r;
    }
    else {
        r = sys_page_map(0, (void *)va, envid, (void *)va, PTE_P|PTE_U);
  80f224:	83 ec 0c             	sub    $0xc,%esp
  80f227:	6a 05                	push   $0x5
  80f229:	53                   	push   %ebx
  80f22a:	57                   	push   %edi
  80f22b:	53                   	push   %ebx
  80f22c:	6a 00                	push   $0x0
  80f22e:	e8 ff fb ff ff       	call   80ee32 <sys_page_map>
  80f233:	83 c4 20             	add    $0x20,%esp
  80f236:	85 c0                	test   %eax,%eax
  80f238:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f23d:	0f 4f c1             	cmovg  %ecx,%eax

				// For each writable or copy-on-write page
				// if ((uvpt[PGNUM(addr)] & (PTE_W | PTE_COW)) != 0) {
				if ((uvpt[PGNUM(addr)] & PTE_U) != 0) {
					r = duppage(envid, pn);
					if (r < 0)
  80f240:	85 c0                	test   %eax,%eax
  80f242:	78 67                	js     80f2ab <fork+0x191>
        return 0;
	}

	// For each writable or copy-on-write page in its address space below UTOP, the parent calls duppage
	uint32_t addr;
	for (uint32_t pn = PGNUM(UTEXT); pn < PGNUM(USTACKTOP); pn++) {
  80f244:	83 c6 01             	add    $0x1,%esi
  80f247:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f24d:	81 fe fe eb 0e 00    	cmp    $0xeebfe,%esi
  80f253:	0f 85 1a ff ff ff    	jne    80f173 <fork+0x59>
  80f259:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			}
		}
	}

	// allocate a fresh page in the child for the exception stack
	r = sys_page_alloc(envid, (void *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_P | PTE_W);
  80f25c:	83 ec 04             	sub    $0x4,%esp
  80f25f:	6a 07                	push   $0x7
  80f261:	68 00 f0 bf ee       	push   $0xeebff000
  80f266:	57                   	push   %edi
  80f267:	e8 83 fb ff ff       	call   80edef <sys_page_alloc>
	if (r < 0)
  80f26c:	83 c4 10             	add    $0x10,%esp
		return r;
  80f26f:	89 c2                	mov    %eax,%edx
		}
	}

	// allocate a fresh page in the child for the exception stack
	r = sys_page_alloc(envid, (void *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_P | PTE_W);
	if (r < 0)
  80f271:	85 c0                	test   %eax,%eax
  80f273:	78 38                	js     80f2ad <fork+0x193>
		return r;

	// The parent sets the user page fault entrypoint for the child to look like its own
	extern void _pgfault_upcall(void);
	r = sys_env_set_pgfault_upcall(envid, _pgfault_upcall);
  80f275:	83 ec 08             	sub    $0x8,%esp
  80f278:	68 de 07 81 00       	push   $0x8107de
  80f27d:	57                   	push   %edi
  80f27e:	e8 b7 fc ff ff       	call   80ef3a <sys_env_set_pgfault_upcall>
	if (r < 0)
  80f283:	83 c4 10             	add    $0x10,%esp
		return r;
  80f286:	89 c2                	mov    %eax,%edx
		return r;

	// The parent sets the user page fault entrypoint for the child to look like its own
	extern void _pgfault_upcall(void);
	r = sys_env_set_pgfault_upcall(envid, _pgfault_upcall);
	if (r < 0)
  80f288:	85 c0                	test   %eax,%eax
  80f28a:	78 21                	js     80f2ad <fork+0x193>
		return r;

	// The child is now ready to run, so the parent marks it runnable
	r = sys_env_set_status(envid, ENV_RUNNABLE);
  80f28c:	83 ec 08             	sub    $0x8,%esp
  80f28f:	6a 02                	push   $0x2
  80f291:	57                   	push   %edi
  80f292:	e8 1f fc ff ff       	call   80eeb6 <sys_env_set_status>
	if (r < 0)
  80f297:	83 c4 10             	add    $0x10,%esp
		return r;

	return envid;
  80f29a:	85 c0                	test   %eax,%eax
  80f29c:	0f 48 f8             	cmovs  %eax,%edi
  80f29f:	89 fa                	mov    %edi,%edx
  80f2a1:	eb 0a                	jmp    80f2ad <fork+0x193>

	set_pgfault_handler(pgfault);

	envid_t envid = sys_exofork();
	if (envid < 0)
		return envid;
  80f2a3:	89 c2                	mov    %eax,%edx
  80f2a5:	eb 06                	jmp    80f2ad <fork+0x193>
		sys_page_map(0, (void *)va, envid, (void *)va, PTE_SYSCALL);
	}
	else if ((uvpt[pn] & PTE_W) == PTE_W || (uvpt[pn] & PTE_COW) == PTE_COW) {

		// map the page copy-on-write into the address space of the child
        r = sys_page_map(0, (void *)va, envid, (void *)va, PTE_P|PTE_U|PTE_COW);
  80f2a7:	89 c2                	mov    %eax,%edx
  80f2a9:	eb 02                	jmp    80f2ad <fork+0x193>
  80f2ab:	89 c2                	mov    %eax,%edx
	if (r < 0)
		return r;

	return envid;
	// panic("fork not implemented");
}
  80f2ad:	89 d0                	mov    %edx,%eax
  80f2af:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f2b2:	5b                   	pop    %ebx
  80f2b3:	5e                   	pop    %esi
  80f2b4:	5f                   	pop    %edi
  80f2b5:	5d                   	pop    %ebp
  80f2b6:	c3                   	ret    

0080f2b7 <sfork>:

// Challenge!
int
sfork(void)
{
  80f2b7:	55                   	push   %ebp
  80f2b8:	89 e5                	mov    %esp,%ebp
  80f2ba:	83 ec 0c             	sub    $0xc,%esp
	panic("sfork not implemented");
  80f2bd:	68 8b 34 81 00       	push   $0x81348b
  80f2c2:	68 c9 00 00 00       	push   $0xc9
  80f2c7:	68 80 34 81 00       	push   $0x813480
  80f2cc:	e8 bd f0 ff ff       	call   80e38e <_panic>

0080f2d1 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80f2d1:	55                   	push   %ebp
  80f2d2:	89 e5                	mov    %esp,%ebp
  80f2d4:	56                   	push   %esi
  80f2d5:	53                   	push   %ebx
  80f2d6:	8b 75 08             	mov    0x8(%ebp),%esi
  80f2d9:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f2dc:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	// panic("ipc_recv not implemented");

	// don't want to recv page
	if (pg == NULL)
  80f2df:	85 c0                	test   %eax,%eax
		pg = (void *)UTOP;
  80f2e1:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
  80f2e6:	0f 44 c2             	cmove  %edx,%eax

	int err = sys_ipc_recv(pg);
  80f2e9:	83 ec 0c             	sub    $0xc,%esp
  80f2ec:	50                   	push   %eax
  80f2ed:	e8 ad fc ff ff       	call   80ef9f <sys_ipc_recv>

	if (from_env_store != NULL)
  80f2f2:	83 c4 10             	add    $0x10,%esp
  80f2f5:	85 f6                	test   %esi,%esi
  80f2f7:	74 14                	je     80f30d <ipc_recv+0x3c>
		*from_env_store = err < 0? 0 : thisenv->env_ipc_from;
  80f2f9:	ba 00 00 00 00       	mov    $0x0,%edx
  80f2fe:	85 c0                	test   %eax,%eax
  80f300:	78 09                	js     80f30b <ipc_recv+0x3a>
  80f302:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  80f308:	8b 52 74             	mov    0x74(%edx),%edx
  80f30b:	89 16                	mov    %edx,(%esi)
	
	if (perm_store != NULL)
  80f30d:	85 db                	test   %ebx,%ebx
  80f30f:	74 14                	je     80f325 <ipc_recv+0x54>
		*perm_store = err < 0? 0 : thisenv->env_ipc_perm;
  80f311:	ba 00 00 00 00       	mov    $0x0,%edx
  80f316:	85 c0                	test   %eax,%eax
  80f318:	78 09                	js     80f323 <ipc_recv+0x52>
  80f31a:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  80f320:	8b 52 78             	mov    0x78(%edx),%edx
  80f323:	89 13                	mov    %edx,(%ebx)

	if (err < 0)
  80f325:	85 c0                	test   %eax,%eax
  80f327:	78 08                	js     80f331 <ipc_recv+0x60>
		return err;
	return thisenv->env_ipc_value;
  80f329:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f32e:	8b 40 70             	mov    0x70(%eax),%eax
}
  80f331:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f334:	5b                   	pop    %ebx
  80f335:	5e                   	pop    %esi
  80f336:	5d                   	pop    %ebp
  80f337:	c3                   	ret    

0080f338 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  80f338:	55                   	push   %ebp
  80f339:	89 e5                	mov    %esp,%ebp
  80f33b:	57                   	push   %edi
  80f33c:	56                   	push   %esi
  80f33d:	53                   	push   %ebx
  80f33e:	83 ec 0c             	sub    $0xc,%esp
  80f341:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f344:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f347:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	// panic("ipc_send not implemented");

	// don't want to send page
	if (pg == NULL)
  80f34a:	85 db                	test   %ebx,%ebx
		pg = (void *)UTOP;
  80f34c:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  80f351:	0f 44 d8             	cmove  %eax,%ebx
	
	int err = 0;
	
	do {

		err = sys_ipc_try_send(to_env, val, pg, perm);
  80f354:	ff 75 14             	pushl  0x14(%ebp)
  80f357:	53                   	push   %ebx
  80f358:	56                   	push   %esi
  80f359:	57                   	push   %edi
  80f35a:	e8 1d fc ff ff       	call   80ef7c <sys_ipc_try_send>

		if (err < 0) {
  80f35f:	83 c4 10             	add    $0x10,%esp
  80f362:	85 c0                	test   %eax,%eax
  80f364:	79 1e                	jns    80f384 <ipc_send+0x4c>
			if (err == -E_IPC_NOT_RECV)
  80f366:	83 f8 f9             	cmp    $0xfffffff9,%eax
  80f369:	75 07                	jne    80f372 <ipc_send+0x3a>
				sys_yield();
  80f36b:	e8 60 fa ff ff       	call   80edd0 <sys_yield>
  80f370:	eb e2                	jmp    80f354 <ipc_send+0x1c>
			else 
				panic("ipc_send: %e", err);
  80f372:	50                   	push   %eax
  80f373:	68 a1 34 81 00       	push   $0x8134a1
  80f378:	6a 49                	push   $0x49
  80f37a:	68 ae 34 81 00       	push   $0x8134ae
  80f37f:	e8 0a f0 ff ff       	call   80e38e <_panic>
		}

	} while (err < 0);

}
  80f384:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f387:	5b                   	pop    %ebx
  80f388:	5e                   	pop    %esi
  80f389:	5f                   	pop    %edi
  80f38a:	5d                   	pop    %ebp
  80f38b:	c3                   	ret    

0080f38c <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80f38c:	55                   	push   %ebp
  80f38d:	89 e5                	mov    %esp,%ebp
  80f38f:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80f392:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80f397:	6b d0 7c             	imul   $0x7c,%eax,%edx
  80f39a:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80f3a0:	8b 52 50             	mov    0x50(%edx),%edx
  80f3a3:	39 ca                	cmp    %ecx,%edx
  80f3a5:	75 0d                	jne    80f3b4 <ipc_find_env+0x28>
			return envs[i].env_id;
  80f3a7:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f3aa:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f3af:	8b 40 48             	mov    0x48(%eax),%eax
  80f3b2:	eb 0f                	jmp    80f3c3 <ipc_find_env+0x37>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  80f3b4:	83 c0 01             	add    $0x1,%eax
  80f3b7:	3d 00 04 00 00       	cmp    $0x400,%eax
  80f3bc:	75 d9                	jne    80f397 <ipc_find_env+0xb>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
  80f3be:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f3c3:	5d                   	pop    %ebp
  80f3c4:	c3                   	ret    

0080f3c5 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80f3c5:	55                   	push   %ebp
  80f3c6:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f3c8:	8b 45 08             	mov    0x8(%ebp),%eax
  80f3cb:	05 00 00 00 30       	add    $0x30000000,%eax
  80f3d0:	c1 e8 0c             	shr    $0xc,%eax
}
  80f3d3:	5d                   	pop    %ebp
  80f3d4:	c3                   	ret    

0080f3d5 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80f3d5:	55                   	push   %ebp
  80f3d6:	89 e5                	mov    %esp,%ebp
	return INDEX2DATA(fd2num(fd));
  80f3d8:	8b 45 08             	mov    0x8(%ebp),%eax
  80f3db:	05 00 00 00 30       	add    $0x30000000,%eax
  80f3e0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f3e5:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80f3ea:	5d                   	pop    %ebp
  80f3eb:	c3                   	ret    

0080f3ec <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80f3ec:	55                   	push   %ebp
  80f3ed:	89 e5                	mov    %esp,%ebp
  80f3ef:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f3f2:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80f3f7:	89 c2                	mov    %eax,%edx
  80f3f9:	c1 ea 16             	shr    $0x16,%edx
  80f3fc:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f403:	f6 c2 01             	test   $0x1,%dl
  80f406:	74 11                	je     80f419 <fd_alloc+0x2d>
  80f408:	89 c2                	mov    %eax,%edx
  80f40a:	c1 ea 0c             	shr    $0xc,%edx
  80f40d:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f414:	f6 c2 01             	test   $0x1,%dl
  80f417:	75 09                	jne    80f422 <fd_alloc+0x36>
			*fd_store = fd;
  80f419:	89 01                	mov    %eax,(%ecx)
			return 0;
  80f41b:	b8 00 00 00 00       	mov    $0x0,%eax
  80f420:	eb 17                	jmp    80f439 <fd_alloc+0x4d>
  80f422:	05 00 10 00 00       	add    $0x1000,%eax
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  80f427:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80f42c:	75 c9                	jne    80f3f7 <fd_alloc+0xb>
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80f42e:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	return -E_MAX_OPEN;
  80f434:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
  80f439:	5d                   	pop    %ebp
  80f43a:	c3                   	ret    

0080f43b <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80f43b:	55                   	push   %ebp
  80f43c:	89 e5                	mov    %esp,%ebp
  80f43e:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80f441:	83 f8 1f             	cmp    $0x1f,%eax
  80f444:	77 36                	ja     80f47c <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80f446:	c1 e0 0c             	shl    $0xc,%eax
  80f449:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80f44e:	89 c2                	mov    %eax,%edx
  80f450:	c1 ea 16             	shr    $0x16,%edx
  80f453:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f45a:	f6 c2 01             	test   $0x1,%dl
  80f45d:	74 24                	je     80f483 <fd_lookup+0x48>
  80f45f:	89 c2                	mov    %eax,%edx
  80f461:	c1 ea 0c             	shr    $0xc,%edx
  80f464:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f46b:	f6 c2 01             	test   $0x1,%dl
  80f46e:	74 1a                	je     80f48a <fd_lookup+0x4f>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80f470:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f473:	89 02                	mov    %eax,(%edx)
	return 0;
  80f475:	b8 00 00 00 00       	mov    $0x0,%eax
  80f47a:	eb 13                	jmp    80f48f <fd_lookup+0x54>
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  80f47c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f481:	eb 0c                	jmp    80f48f <fd_lookup+0x54>
	}
	fd = INDEX2FD(fdnum);
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  80f483:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f488:	eb 05                	jmp    80f48f <fd_lookup+0x54>
  80f48a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	}
	*fd_store = fd;
	return 0;
}
  80f48f:	5d                   	pop    %ebp
  80f490:	c3                   	ret    

0080f491 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80f491:	55                   	push   %ebp
  80f492:	89 e5                	mov    %esp,%ebp
  80f494:	83 ec 08             	sub    $0x8,%esp
  80f497:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f49a:	ba 34 35 81 00       	mov    $0x813534,%edx
	int i;
	for (i = 0; devtab[i]; i++)
  80f49f:	eb 13                	jmp    80f4b4 <dev_lookup+0x23>
  80f4a1:	83 c2 04             	add    $0x4,%edx
		if (devtab[i]->dev_id == dev_id) {
  80f4a4:	39 08                	cmp    %ecx,(%eax)
  80f4a6:	75 0c                	jne    80f4b4 <dev_lookup+0x23>
			*dev = devtab[i];
  80f4a8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f4ab:	89 01                	mov    %eax,(%ecx)
			return 0;
  80f4ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80f4b2:	eb 2e                	jmp    80f4e2 <dev_lookup+0x51>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  80f4b4:	8b 02                	mov    (%edx),%eax
  80f4b6:	85 c0                	test   %eax,%eax
  80f4b8:	75 e7                	jne    80f4a1 <dev_lookup+0x10>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80f4ba:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f4bf:	8b 40 48             	mov    0x48(%eax),%eax
  80f4c2:	83 ec 04             	sub    $0x4,%esp
  80f4c5:	51                   	push   %ecx
  80f4c6:	50                   	push   %eax
  80f4c7:	68 b8 34 81 00       	push   $0x8134b8
  80f4cc:	e8 96 ef ff ff       	call   80e467 <cprintf>
	*dev = 0;
  80f4d1:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f4d4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  80f4da:	83 c4 10             	add    $0x10,%esp
  80f4dd:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80f4e2:	c9                   	leave  
  80f4e3:	c3                   	ret    

0080f4e4 <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  80f4e4:	55                   	push   %ebp
  80f4e5:	89 e5                	mov    %esp,%ebp
  80f4e7:	56                   	push   %esi
  80f4e8:	53                   	push   %ebx
  80f4e9:	83 ec 10             	sub    $0x10,%esp
  80f4ec:	8b 75 08             	mov    0x8(%ebp),%esi
  80f4ef:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80f4f2:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f4f5:	50                   	push   %eax
  80f4f6:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80f4fc:	c1 e8 0c             	shr    $0xc,%eax
  80f4ff:	50                   	push   %eax
  80f500:	e8 36 ff ff ff       	call   80f43b <fd_lookup>
  80f505:	83 c4 08             	add    $0x8,%esp
  80f508:	85 c0                	test   %eax,%eax
  80f50a:	78 05                	js     80f511 <fd_close+0x2d>
	    || fd != fd2)
  80f50c:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  80f50f:	74 0c                	je     80f51d <fd_close+0x39>
		return (must_exist ? r : 0);
  80f511:	84 db                	test   %bl,%bl
  80f513:	ba 00 00 00 00       	mov    $0x0,%edx
  80f518:	0f 44 c2             	cmove  %edx,%eax
  80f51b:	eb 41                	jmp    80f55e <fd_close+0x7a>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80f51d:	83 ec 08             	sub    $0x8,%esp
  80f520:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f523:	50                   	push   %eax
  80f524:	ff 36                	pushl  (%esi)
  80f526:	e8 66 ff ff ff       	call   80f491 <dev_lookup>
  80f52b:	89 c3                	mov    %eax,%ebx
  80f52d:	83 c4 10             	add    $0x10,%esp
  80f530:	85 c0                	test   %eax,%eax
  80f532:	78 1a                	js     80f54e <fd_close+0x6a>
		if (dev->dev_close)
  80f534:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f537:	8b 40 10             	mov    0x10(%eax),%eax
			r = (*dev->dev_close)(fd);
		else
			r = 0;
  80f53a:	bb 00 00 00 00       	mov    $0x0,%ebx
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
	    || fd != fd2)
		return (must_exist ? r : 0);
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
		if (dev->dev_close)
  80f53f:	85 c0                	test   %eax,%eax
  80f541:	74 0b                	je     80f54e <fd_close+0x6a>
			r = (*dev->dev_close)(fd);
  80f543:	83 ec 0c             	sub    $0xc,%esp
  80f546:	56                   	push   %esi
  80f547:	ff d0                	call   *%eax
  80f549:	89 c3                	mov    %eax,%ebx
  80f54b:	83 c4 10             	add    $0x10,%esp
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  80f54e:	83 ec 08             	sub    $0x8,%esp
  80f551:	56                   	push   %esi
  80f552:	6a 00                	push   $0x0
  80f554:	e8 1b f9 ff ff       	call   80ee74 <sys_page_unmap>
	return r;
  80f559:	83 c4 10             	add    $0x10,%esp
  80f55c:	89 d8                	mov    %ebx,%eax
}
  80f55e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f561:	5b                   	pop    %ebx
  80f562:	5e                   	pop    %esi
  80f563:	5d                   	pop    %ebp
  80f564:	c3                   	ret    

0080f565 <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  80f565:	55                   	push   %ebp
  80f566:	89 e5                	mov    %esp,%ebp
  80f568:	83 ec 18             	sub    $0x18,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80f56b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f56e:	50                   	push   %eax
  80f56f:	ff 75 08             	pushl  0x8(%ebp)
  80f572:	e8 c4 fe ff ff       	call   80f43b <fd_lookup>
  80f577:	83 c4 08             	add    $0x8,%esp
  80f57a:	85 c0                	test   %eax,%eax
  80f57c:	78 10                	js     80f58e <close+0x29>
		return r;
	else
		return fd_close(fd, 1);
  80f57e:	83 ec 08             	sub    $0x8,%esp
  80f581:	6a 01                	push   $0x1
  80f583:	ff 75 f4             	pushl  -0xc(%ebp)
  80f586:	e8 59 ff ff ff       	call   80f4e4 <fd_close>
  80f58b:	83 c4 10             	add    $0x10,%esp
}
  80f58e:	c9                   	leave  
  80f58f:	c3                   	ret    

0080f590 <close_all>:

void
close_all(void)
{
  80f590:	55                   	push   %ebp
  80f591:	89 e5                	mov    %esp,%ebp
  80f593:	53                   	push   %ebx
  80f594:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80f597:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80f59c:	83 ec 0c             	sub    $0xc,%esp
  80f59f:	53                   	push   %ebx
  80f5a0:	e8 c0 ff ff ff       	call   80f565 <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  80f5a5:	83 c3 01             	add    $0x1,%ebx
  80f5a8:	83 c4 10             	add    $0x10,%esp
  80f5ab:	83 fb 20             	cmp    $0x20,%ebx
  80f5ae:	75 ec                	jne    80f59c <close_all+0xc>
		close(i);
}
  80f5b0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f5b3:	c9                   	leave  
  80f5b4:	c3                   	ret    

0080f5b5 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80f5b5:	55                   	push   %ebp
  80f5b6:	89 e5                	mov    %esp,%ebp
  80f5b8:	57                   	push   %edi
  80f5b9:	56                   	push   %esi
  80f5ba:	53                   	push   %ebx
  80f5bb:	83 ec 2c             	sub    $0x2c,%esp
  80f5be:	8b 75 0c             	mov    0xc(%ebp),%esi
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80f5c1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80f5c4:	50                   	push   %eax
  80f5c5:	ff 75 08             	pushl  0x8(%ebp)
  80f5c8:	e8 6e fe ff ff       	call   80f43b <fd_lookup>
  80f5cd:	83 c4 08             	add    $0x8,%esp
  80f5d0:	85 c0                	test   %eax,%eax
  80f5d2:	0f 88 c1 00 00 00    	js     80f699 <dup+0xe4>
		return r;
	close(newfdnum);
  80f5d8:	83 ec 0c             	sub    $0xc,%esp
  80f5db:	56                   	push   %esi
  80f5dc:	e8 84 ff ff ff       	call   80f565 <close>

	newfd = INDEX2FD(newfdnum);
  80f5e1:	89 f3                	mov    %esi,%ebx
  80f5e3:	c1 e3 0c             	shl    $0xc,%ebx
  80f5e6:	81 eb 00 00 00 30    	sub    $0x30000000,%ebx
	ova = fd2data(oldfd);
  80f5ec:	83 c4 04             	add    $0x4,%esp
  80f5ef:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f5f2:	e8 de fd ff ff       	call   80f3d5 <fd2data>
  80f5f7:	89 c7                	mov    %eax,%edi
	nva = fd2data(newfd);
  80f5f9:	89 1c 24             	mov    %ebx,(%esp)
  80f5fc:	e8 d4 fd ff ff       	call   80f3d5 <fd2data>
  80f601:	83 c4 10             	add    $0x10,%esp
  80f604:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80f607:	89 f8                	mov    %edi,%eax
  80f609:	c1 e8 16             	shr    $0x16,%eax
  80f60c:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f613:	a8 01                	test   $0x1,%al
  80f615:	74 37                	je     80f64e <dup+0x99>
  80f617:	89 f8                	mov    %edi,%eax
  80f619:	c1 e8 0c             	shr    $0xc,%eax
  80f61c:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f623:	f6 c2 01             	test   $0x1,%dl
  80f626:	74 26                	je     80f64e <dup+0x99>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80f628:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f62f:	83 ec 0c             	sub    $0xc,%esp
  80f632:	25 07 0e 00 00       	and    $0xe07,%eax
  80f637:	50                   	push   %eax
  80f638:	ff 75 d4             	pushl  -0x2c(%ebp)
  80f63b:	6a 00                	push   $0x0
  80f63d:	57                   	push   %edi
  80f63e:	6a 00                	push   $0x0
  80f640:	e8 ed f7 ff ff       	call   80ee32 <sys_page_map>
  80f645:	89 c7                	mov    %eax,%edi
  80f647:	83 c4 20             	add    $0x20,%esp
  80f64a:	85 c0                	test   %eax,%eax
  80f64c:	78 2e                	js     80f67c <dup+0xc7>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80f64e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80f651:	89 d0                	mov    %edx,%eax
  80f653:	c1 e8 0c             	shr    $0xc,%eax
  80f656:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f65d:	83 ec 0c             	sub    $0xc,%esp
  80f660:	25 07 0e 00 00       	and    $0xe07,%eax
  80f665:	50                   	push   %eax
  80f666:	53                   	push   %ebx
  80f667:	6a 00                	push   $0x0
  80f669:	52                   	push   %edx
  80f66a:	6a 00                	push   $0x0
  80f66c:	e8 c1 f7 ff ff       	call   80ee32 <sys_page_map>
  80f671:	89 c7                	mov    %eax,%edi
  80f673:	83 c4 20             	add    $0x20,%esp
		goto err;

	return newfdnum;
  80f676:	89 f0                	mov    %esi,%eax
	nva = fd2data(newfd);

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80f678:	85 ff                	test   %edi,%edi
  80f67a:	79 1d                	jns    80f699 <dup+0xe4>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  80f67c:	83 ec 08             	sub    $0x8,%esp
  80f67f:	53                   	push   %ebx
  80f680:	6a 00                	push   $0x0
  80f682:	e8 ed f7 ff ff       	call   80ee74 <sys_page_unmap>
	sys_page_unmap(0, nva);
  80f687:	83 c4 08             	add    $0x8,%esp
  80f68a:	ff 75 d4             	pushl  -0x2c(%ebp)
  80f68d:	6a 00                	push   $0x0
  80f68f:	e8 e0 f7 ff ff       	call   80ee74 <sys_page_unmap>
	return r;
  80f694:	83 c4 10             	add    $0x10,%esp
  80f697:	89 f8                	mov    %edi,%eax
}
  80f699:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f69c:	5b                   	pop    %ebx
  80f69d:	5e                   	pop    %esi
  80f69e:	5f                   	pop    %edi
  80f69f:	5d                   	pop    %ebp
  80f6a0:	c3                   	ret    

0080f6a1 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80f6a1:	55                   	push   %ebp
  80f6a2:	89 e5                	mov    %esp,%ebp
  80f6a4:	53                   	push   %ebx
  80f6a5:	83 ec 14             	sub    $0x14,%esp
  80f6a8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f6ab:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f6ae:	50                   	push   %eax
  80f6af:	53                   	push   %ebx
  80f6b0:	e8 86 fd ff ff       	call   80f43b <fd_lookup>
  80f6b5:	83 c4 08             	add    $0x8,%esp
  80f6b8:	89 c2                	mov    %eax,%edx
  80f6ba:	85 c0                	test   %eax,%eax
  80f6bc:	78 6d                	js     80f72b <read+0x8a>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f6be:	83 ec 08             	sub    $0x8,%esp
  80f6c1:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f6c4:	50                   	push   %eax
  80f6c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f6c8:	ff 30                	pushl  (%eax)
  80f6ca:	e8 c2 fd ff ff       	call   80f491 <dev_lookup>
  80f6cf:	83 c4 10             	add    $0x10,%esp
  80f6d2:	85 c0                	test   %eax,%eax
  80f6d4:	78 4c                	js     80f722 <read+0x81>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80f6d6:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80f6d9:	8b 42 08             	mov    0x8(%edx),%eax
  80f6dc:	83 e0 03             	and    $0x3,%eax
  80f6df:	83 f8 01             	cmp    $0x1,%eax
  80f6e2:	75 21                	jne    80f705 <read+0x64>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80f6e4:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f6e9:	8b 40 48             	mov    0x48(%eax),%eax
  80f6ec:	83 ec 04             	sub    $0x4,%esp
  80f6ef:	53                   	push   %ebx
  80f6f0:	50                   	push   %eax
  80f6f1:	68 f9 34 81 00       	push   $0x8134f9
  80f6f6:	e8 6c ed ff ff       	call   80e467 <cprintf>
		return -E_INVAL;
  80f6fb:	83 c4 10             	add    $0x10,%esp
  80f6fe:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f703:	eb 26                	jmp    80f72b <read+0x8a>
	}
	if (!dev->dev_read)
  80f705:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f708:	8b 40 08             	mov    0x8(%eax),%eax
  80f70b:	85 c0                	test   %eax,%eax
  80f70d:	74 17                	je     80f726 <read+0x85>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80f70f:	83 ec 04             	sub    $0x4,%esp
  80f712:	ff 75 10             	pushl  0x10(%ebp)
  80f715:	ff 75 0c             	pushl  0xc(%ebp)
  80f718:	52                   	push   %edx
  80f719:	ff d0                	call   *%eax
  80f71b:	89 c2                	mov    %eax,%edx
  80f71d:	83 c4 10             	add    $0x10,%esp
  80f720:	eb 09                	jmp    80f72b <read+0x8a>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f722:	89 c2                	mov    %eax,%edx
  80f724:	eb 05                	jmp    80f72b <read+0x8a>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
		return -E_NOT_SUPP;
  80f726:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_read)(fd, buf, n);
}
  80f72b:	89 d0                	mov    %edx,%eax
  80f72d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f730:	c9                   	leave  
  80f731:	c3                   	ret    

0080f732 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80f732:	55                   	push   %ebp
  80f733:	89 e5                	mov    %esp,%ebp
  80f735:	57                   	push   %edi
  80f736:	56                   	push   %esi
  80f737:	53                   	push   %ebx
  80f738:	83 ec 0c             	sub    $0xc,%esp
  80f73b:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f73e:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80f741:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f746:	eb 21                	jmp    80f769 <readn+0x37>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80f748:	83 ec 04             	sub    $0x4,%esp
  80f74b:	89 f0                	mov    %esi,%eax
  80f74d:	29 d8                	sub    %ebx,%eax
  80f74f:	50                   	push   %eax
  80f750:	89 d8                	mov    %ebx,%eax
  80f752:	03 45 0c             	add    0xc(%ebp),%eax
  80f755:	50                   	push   %eax
  80f756:	57                   	push   %edi
  80f757:	e8 45 ff ff ff       	call   80f6a1 <read>
		if (m < 0)
  80f75c:	83 c4 10             	add    $0x10,%esp
  80f75f:	85 c0                	test   %eax,%eax
  80f761:	78 10                	js     80f773 <readn+0x41>
			return m;
		if (m == 0)
  80f763:	85 c0                	test   %eax,%eax
  80f765:	74 0a                	je     80f771 <readn+0x3f>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80f767:	01 c3                	add    %eax,%ebx
  80f769:	39 f3                	cmp    %esi,%ebx
  80f76b:	72 db                	jb     80f748 <readn+0x16>
  80f76d:	89 d8                	mov    %ebx,%eax
  80f76f:	eb 02                	jmp    80f773 <readn+0x41>
  80f771:	89 d8                	mov    %ebx,%eax
			return m;
		if (m == 0)
			break;
	}
	return tot;
}
  80f773:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f776:	5b                   	pop    %ebx
  80f777:	5e                   	pop    %esi
  80f778:	5f                   	pop    %edi
  80f779:	5d                   	pop    %ebp
  80f77a:	c3                   	ret    

0080f77b <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80f77b:	55                   	push   %ebp
  80f77c:	89 e5                	mov    %esp,%ebp
  80f77e:	53                   	push   %ebx
  80f77f:	83 ec 14             	sub    $0x14,%esp
  80f782:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f785:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f788:	50                   	push   %eax
  80f789:	53                   	push   %ebx
  80f78a:	e8 ac fc ff ff       	call   80f43b <fd_lookup>
  80f78f:	83 c4 08             	add    $0x8,%esp
  80f792:	89 c2                	mov    %eax,%edx
  80f794:	85 c0                	test   %eax,%eax
  80f796:	78 68                	js     80f800 <write+0x85>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f798:	83 ec 08             	sub    $0x8,%esp
  80f79b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f79e:	50                   	push   %eax
  80f79f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f7a2:	ff 30                	pushl  (%eax)
  80f7a4:	e8 e8 fc ff ff       	call   80f491 <dev_lookup>
  80f7a9:	83 c4 10             	add    $0x10,%esp
  80f7ac:	85 c0                	test   %eax,%eax
  80f7ae:	78 47                	js     80f7f7 <write+0x7c>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80f7b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f7b3:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80f7b7:	75 21                	jne    80f7da <write+0x5f>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  80f7b9:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f7be:	8b 40 48             	mov    0x48(%eax),%eax
  80f7c1:	83 ec 04             	sub    $0x4,%esp
  80f7c4:	53                   	push   %ebx
  80f7c5:	50                   	push   %eax
  80f7c6:	68 15 35 81 00       	push   $0x813515
  80f7cb:	e8 97 ec ff ff       	call   80e467 <cprintf>
		return -E_INVAL;
  80f7d0:	83 c4 10             	add    $0x10,%esp
  80f7d3:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f7d8:	eb 26                	jmp    80f800 <write+0x85>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80f7da:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80f7dd:	8b 52 0c             	mov    0xc(%edx),%edx
  80f7e0:	85 d2                	test   %edx,%edx
  80f7e2:	74 17                	je     80f7fb <write+0x80>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80f7e4:	83 ec 04             	sub    $0x4,%esp
  80f7e7:	ff 75 10             	pushl  0x10(%ebp)
  80f7ea:	ff 75 0c             	pushl  0xc(%ebp)
  80f7ed:	50                   	push   %eax
  80f7ee:	ff d2                	call   *%edx
  80f7f0:	89 c2                	mov    %eax,%edx
  80f7f2:	83 c4 10             	add    $0x10,%esp
  80f7f5:	eb 09                	jmp    80f800 <write+0x85>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f7f7:	89 c2                	mov    %eax,%edx
  80f7f9:	eb 05                	jmp    80f800 <write+0x85>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
		return -E_NOT_SUPP;
  80f7fb:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_write)(fd, buf, n);
}
  80f800:	89 d0                	mov    %edx,%eax
  80f802:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f805:	c9                   	leave  
  80f806:	c3                   	ret    

0080f807 <seek>:

int
seek(int fdnum, off_t offset)
{
  80f807:	55                   	push   %ebp
  80f808:	89 e5                	mov    %esp,%ebp
  80f80a:	83 ec 10             	sub    $0x10,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80f80d:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80f810:	50                   	push   %eax
  80f811:	ff 75 08             	pushl  0x8(%ebp)
  80f814:	e8 22 fc ff ff       	call   80f43b <fd_lookup>
  80f819:	83 c4 08             	add    $0x8,%esp
  80f81c:	85 c0                	test   %eax,%eax
  80f81e:	78 0e                	js     80f82e <seek+0x27>
		return r;
	fd->fd_offset = offset;
  80f820:	8b 45 fc             	mov    -0x4(%ebp),%eax
  80f823:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f826:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  80f829:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f82e:	c9                   	leave  
  80f82f:	c3                   	ret    

0080f830 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  80f830:	55                   	push   %ebp
  80f831:	89 e5                	mov    %esp,%ebp
  80f833:	53                   	push   %ebx
  80f834:	83 ec 14             	sub    $0x14,%esp
  80f837:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f83a:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f83d:	50                   	push   %eax
  80f83e:	53                   	push   %ebx
  80f83f:	e8 f7 fb ff ff       	call   80f43b <fd_lookup>
  80f844:	83 c4 08             	add    $0x8,%esp
  80f847:	89 c2                	mov    %eax,%edx
  80f849:	85 c0                	test   %eax,%eax
  80f84b:	78 65                	js     80f8b2 <ftruncate+0x82>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f84d:	83 ec 08             	sub    $0x8,%esp
  80f850:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f853:	50                   	push   %eax
  80f854:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f857:	ff 30                	pushl  (%eax)
  80f859:	e8 33 fc ff ff       	call   80f491 <dev_lookup>
  80f85e:	83 c4 10             	add    $0x10,%esp
  80f861:	85 c0                	test   %eax,%eax
  80f863:	78 44                	js     80f8a9 <ftruncate+0x79>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80f865:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f868:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80f86c:	75 21                	jne    80f88f <ftruncate+0x5f>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  80f86e:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  80f873:	8b 40 48             	mov    0x48(%eax),%eax
  80f876:	83 ec 04             	sub    $0x4,%esp
  80f879:	53                   	push   %ebx
  80f87a:	50                   	push   %eax
  80f87b:	68 d8 34 81 00       	push   $0x8134d8
  80f880:	e8 e2 eb ff ff       	call   80e467 <cprintf>
			thisenv->env_id, fdnum);
		return -E_INVAL;
  80f885:	83 c4 10             	add    $0x10,%esp
  80f888:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f88d:	eb 23                	jmp    80f8b2 <ftruncate+0x82>
	}
	if (!dev->dev_trunc)
  80f88f:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80f892:	8b 52 18             	mov    0x18(%edx),%edx
  80f895:	85 d2                	test   %edx,%edx
  80f897:	74 14                	je     80f8ad <ftruncate+0x7d>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  80f899:	83 ec 08             	sub    $0x8,%esp
  80f89c:	ff 75 0c             	pushl  0xc(%ebp)
  80f89f:	50                   	push   %eax
  80f8a0:	ff d2                	call   *%edx
  80f8a2:	89 c2                	mov    %eax,%edx
  80f8a4:	83 c4 10             	add    $0x10,%esp
  80f8a7:	eb 09                	jmp    80f8b2 <ftruncate+0x82>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f8a9:	89 c2                	mov    %eax,%edx
  80f8ab:	eb 05                	jmp    80f8b2 <ftruncate+0x82>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
		return -E_NOT_SUPP;
  80f8ad:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_trunc)(fd, newsize);
}
  80f8b2:	89 d0                	mov    %edx,%eax
  80f8b4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f8b7:	c9                   	leave  
  80f8b8:	c3                   	ret    

0080f8b9 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  80f8b9:	55                   	push   %ebp
  80f8ba:	89 e5                	mov    %esp,%ebp
  80f8bc:	53                   	push   %ebx
  80f8bd:	83 ec 14             	sub    $0x14,%esp
  80f8c0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f8c3:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f8c6:	50                   	push   %eax
  80f8c7:	ff 75 08             	pushl  0x8(%ebp)
  80f8ca:	e8 6c fb ff ff       	call   80f43b <fd_lookup>
  80f8cf:	83 c4 08             	add    $0x8,%esp
  80f8d2:	89 c2                	mov    %eax,%edx
  80f8d4:	85 c0                	test   %eax,%eax
  80f8d6:	78 58                	js     80f930 <fstat+0x77>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f8d8:	83 ec 08             	sub    $0x8,%esp
  80f8db:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f8de:	50                   	push   %eax
  80f8df:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f8e2:	ff 30                	pushl  (%eax)
  80f8e4:	e8 a8 fb ff ff       	call   80f491 <dev_lookup>
  80f8e9:	83 c4 10             	add    $0x10,%esp
  80f8ec:	85 c0                	test   %eax,%eax
  80f8ee:	78 37                	js     80f927 <fstat+0x6e>
		return r;
	if (!dev->dev_stat)
  80f8f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f8f3:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  80f8f7:	74 32                	je     80f92b <fstat+0x72>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  80f8f9:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  80f8fc:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80f903:	00 00 00 
	stat->st_isdir = 0;
  80f906:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  80f90d:	00 00 00 
	stat->st_dev = dev;
  80f910:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  80f916:	83 ec 08             	sub    $0x8,%esp
  80f919:	53                   	push   %ebx
  80f91a:	ff 75 f0             	pushl  -0x10(%ebp)
  80f91d:	ff 50 14             	call   *0x14(%eax)
  80f920:	89 c2                	mov    %eax,%edx
  80f922:	83 c4 10             	add    $0x10,%esp
  80f925:	eb 09                	jmp    80f930 <fstat+0x77>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f927:	89 c2                	mov    %eax,%edx
  80f929:	eb 05                	jmp    80f930 <fstat+0x77>
		return r;
	if (!dev->dev_stat)
		return -E_NOT_SUPP;
  80f92b:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	stat->st_name[0] = 0;
	stat->st_size = 0;
	stat->st_isdir = 0;
	stat->st_dev = dev;
	return (*dev->dev_stat)(fd, stat);
}
  80f930:	89 d0                	mov    %edx,%eax
  80f932:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f935:	c9                   	leave  
  80f936:	c3                   	ret    

0080f937 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  80f937:	55                   	push   %ebp
  80f938:	89 e5                	mov    %esp,%ebp
  80f93a:	56                   	push   %esi
  80f93b:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  80f93c:	83 ec 08             	sub    $0x8,%esp
  80f93f:	6a 00                	push   $0x0
  80f941:	ff 75 08             	pushl  0x8(%ebp)
  80f944:	e8 d6 01 00 00       	call   80fb1f <open>
  80f949:	89 c3                	mov    %eax,%ebx
  80f94b:	83 c4 10             	add    $0x10,%esp
  80f94e:	85 c0                	test   %eax,%eax
  80f950:	78 1b                	js     80f96d <stat+0x36>
		return fd;
	r = fstat(fd, stat);
  80f952:	83 ec 08             	sub    $0x8,%esp
  80f955:	ff 75 0c             	pushl  0xc(%ebp)
  80f958:	50                   	push   %eax
  80f959:	e8 5b ff ff ff       	call   80f8b9 <fstat>
  80f95e:	89 c6                	mov    %eax,%esi
	close(fd);
  80f960:	89 1c 24             	mov    %ebx,(%esp)
  80f963:	e8 fd fb ff ff       	call   80f565 <close>
	return r;
  80f968:	83 c4 10             	add    $0x10,%esp
  80f96b:	89 f0                	mov    %esi,%eax
}
  80f96d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f970:	5b                   	pop    %ebx
  80f971:	5e                   	pop    %esi
  80f972:	5d                   	pop    %ebp
  80f973:	c3                   	ret    

0080f974 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  80f974:	55                   	push   %ebp
  80f975:	89 e5                	mov    %esp,%ebp
  80f977:	56                   	push   %esi
  80f978:	53                   	push   %ebx
  80f979:	89 c6                	mov    %eax,%esi
  80f97b:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  80f97d:	83 3d cc b1 b3 00 00 	cmpl   $0x0,0xb3b1cc
  80f984:	75 12                	jne    80f998 <fsipc+0x24>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  80f986:	83 ec 0c             	sub    $0xc,%esp
  80f989:	6a 01                	push   $0x1
  80f98b:	e8 fc f9 ff ff       	call   80f38c <ipc_find_env>
  80f990:	a3 cc b1 b3 00       	mov    %eax,0xb3b1cc
  80f995:	83 c4 10             	add    $0x10,%esp
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  80f998:	6a 07                	push   $0x7
  80f99a:	68 00 c0 b3 00       	push   $0xb3c000
  80f99f:	56                   	push   %esi
  80f9a0:	ff 35 cc b1 b3 00    	pushl  0xb3b1cc
  80f9a6:	e8 8d f9 ff ff       	call   80f338 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  80f9ab:	83 c4 0c             	add    $0xc,%esp
  80f9ae:	6a 00                	push   $0x0
  80f9b0:	53                   	push   %ebx
  80f9b1:	6a 00                	push   $0x0
  80f9b3:	e8 19 f9 ff ff       	call   80f2d1 <ipc_recv>
}
  80f9b8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f9bb:	5b                   	pop    %ebx
  80f9bc:	5e                   	pop    %esi
  80f9bd:	5d                   	pop    %ebp
  80f9be:	c3                   	ret    

0080f9bf <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  80f9bf:	55                   	push   %ebp
  80f9c0:	89 e5                	mov    %esp,%ebp
  80f9c2:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  80f9c5:	8b 45 08             	mov    0x8(%ebp),%eax
  80f9c8:	8b 40 0c             	mov    0xc(%eax),%eax
  80f9cb:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.set_size.req_size = newsize;
  80f9d0:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f9d3:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return fsipc(FSREQ_SET_SIZE, NULL);
  80f9d8:	ba 00 00 00 00       	mov    $0x0,%edx
  80f9dd:	b8 02 00 00 00       	mov    $0x2,%eax
  80f9e2:	e8 8d ff ff ff       	call   80f974 <fsipc>
}
  80f9e7:	c9                   	leave  
  80f9e8:	c3                   	ret    

0080f9e9 <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  80f9e9:	55                   	push   %ebp
  80f9ea:	89 e5                	mov    %esp,%ebp
  80f9ec:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  80f9ef:	8b 45 08             	mov    0x8(%ebp),%eax
  80f9f2:	8b 40 0c             	mov    0xc(%eax),%eax
  80f9f5:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	return fsipc(FSREQ_FLUSH, NULL);
  80f9fa:	ba 00 00 00 00       	mov    $0x0,%edx
  80f9ff:	b8 06 00 00 00       	mov    $0x6,%eax
  80fa04:	e8 6b ff ff ff       	call   80f974 <fsipc>
}
  80fa09:	c9                   	leave  
  80fa0a:	c3                   	ret    

0080fa0b <devfile_stat>:

}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  80fa0b:	55                   	push   %ebp
  80fa0c:	89 e5                	mov    %esp,%ebp
  80fa0e:	53                   	push   %ebx
  80fa0f:	83 ec 04             	sub    $0x4,%esp
  80fa12:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  80fa15:	8b 45 08             	mov    0x8(%ebp),%eax
  80fa18:	8b 40 0c             	mov    0xc(%eax),%eax
  80fa1b:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  80fa20:	ba 00 00 00 00       	mov    $0x0,%edx
  80fa25:	b8 05 00 00 00       	mov    $0x5,%eax
  80fa2a:	e8 45 ff ff ff       	call   80f974 <fsipc>
  80fa2f:	85 c0                	test   %eax,%eax
  80fa31:	78 2c                	js     80fa5f <devfile_stat+0x54>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  80fa33:	83 ec 08             	sub    $0x8,%esp
  80fa36:	68 00 c0 b3 00       	push   $0xb3c000
  80fa3b:	53                   	push   %ebx
  80fa3c:	e8 ab ef ff ff       	call   80e9ec <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  80fa41:	a1 80 c0 b3 00       	mov    0xb3c080,%eax
  80fa46:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  80fa4c:	a1 84 c0 b3 00       	mov    0xb3c084,%eax
  80fa51:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  80fa57:	83 c4 10             	add    $0x10,%esp
  80fa5a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fa5f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fa62:	c9                   	leave  
  80fa63:	c3                   	ret    

0080fa64 <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  80fa64:	55                   	push   %ebp
  80fa65:	89 e5                	mov    %esp,%ebp
  80fa67:	83 ec 0c             	sub    $0xc,%esp
  80fa6a:	8b 45 10             	mov    0x10(%ebp),%eax
	// remember that write is always allowed to write *fewer*
	// bytes than requested.
	// LAB 5: Your code here
	// panic("devfile_write not implemented");

	fsipcbuf.write.req_fileid = fd->fd_file.id;
  80fa6d:	8b 55 08             	mov    0x8(%ebp),%edx
  80fa70:	8b 52 0c             	mov    0xc(%edx),%edx
  80fa73:	89 15 00 c0 b3 00    	mov    %edx,0xb3c000
	fsipcbuf.write.req_n = n;
  80fa79:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	memmove(fsipcbuf.write.req_buf, buf, n);
  80fa7e:	50                   	push   %eax
  80fa7f:	ff 75 0c             	pushl  0xc(%ebp)
  80fa82:	68 08 c0 b3 00       	push   $0xb3c008
  80fa87:	e8 f2 f0 ff ff       	call   80eb7e <memmove>
	return fsipc(FSREQ_WRITE, NULL);
  80fa8c:	ba 00 00 00 00       	mov    $0x0,%edx
  80fa91:	b8 04 00 00 00       	mov    $0x4,%eax
  80fa96:	e8 d9 fe ff ff       	call   80f974 <fsipc>

}
  80fa9b:	c9                   	leave  
  80fa9c:	c3                   	ret    

0080fa9d <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  80fa9d:	55                   	push   %ebp
  80fa9e:	89 e5                	mov    %esp,%ebp
  80faa0:	56                   	push   %esi
  80faa1:	53                   	push   %ebx
  80faa2:	8b 75 10             	mov    0x10(%ebp),%esi
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	int r;

	fsipcbuf.read.req_fileid = fd->fd_file.id;
  80faa5:	8b 45 08             	mov    0x8(%ebp),%eax
  80faa8:	8b 40 0c             	mov    0xc(%eax),%eax
  80faab:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.read.req_n = n;
  80fab0:	89 35 04 c0 b3 00    	mov    %esi,0xb3c004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  80fab6:	ba 00 00 00 00       	mov    $0x0,%edx
  80fabb:	b8 03 00 00 00       	mov    $0x3,%eax
  80fac0:	e8 af fe ff ff       	call   80f974 <fsipc>
  80fac5:	89 c3                	mov    %eax,%ebx
  80fac7:	85 c0                	test   %eax,%eax
  80fac9:	78 4b                	js     80fb16 <devfile_read+0x79>
		return r;
	assert(r <= n);
  80facb:	39 c6                	cmp    %eax,%esi
  80facd:	73 16                	jae    80fae5 <devfile_read+0x48>
  80facf:	68 48 35 81 00       	push   $0x813548
  80fad4:	68 87 22 81 00       	push   $0x812287
  80fad9:	6a 7c                	push   $0x7c
  80fadb:	68 4f 35 81 00       	push   $0x81354f
  80fae0:	e8 a9 e8 ff ff       	call   80e38e <_panic>
	assert(r <= PGSIZE);
  80fae5:	3d 00 10 00 00       	cmp    $0x1000,%eax
  80faea:	7e 16                	jle    80fb02 <devfile_read+0x65>
  80faec:	68 5a 35 81 00       	push   $0x81355a
  80faf1:	68 87 22 81 00       	push   $0x812287
  80faf6:	6a 7d                	push   $0x7d
  80faf8:	68 4f 35 81 00       	push   $0x81354f
  80fafd:	e8 8c e8 ff ff       	call   80e38e <_panic>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  80fb02:	83 ec 04             	sub    $0x4,%esp
  80fb05:	50                   	push   %eax
  80fb06:	68 00 c0 b3 00       	push   $0xb3c000
  80fb0b:	ff 75 0c             	pushl  0xc(%ebp)
  80fb0e:	e8 6b f0 ff ff       	call   80eb7e <memmove>
	return r;
  80fb13:	83 c4 10             	add    $0x10,%esp
}
  80fb16:	89 d8                	mov    %ebx,%eax
  80fb18:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fb1b:	5b                   	pop    %ebx
  80fb1c:	5e                   	pop    %esi
  80fb1d:	5d                   	pop    %ebp
  80fb1e:	c3                   	ret    

0080fb1f <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  80fb1f:	55                   	push   %ebp
  80fb20:	89 e5                	mov    %esp,%ebp
  80fb22:	53                   	push   %ebx
  80fb23:	83 ec 20             	sub    $0x20,%esp
  80fb26:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// file descriptor.

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
  80fb29:	53                   	push   %ebx
  80fb2a:	e8 84 ee ff ff       	call   80e9b3 <strlen>
  80fb2f:	83 c4 10             	add    $0x10,%esp
  80fb32:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  80fb37:	7f 67                	jg     80fba0 <open+0x81>
		return -E_BAD_PATH;

	if ((r = fd_alloc(&fd)) < 0)
  80fb39:	83 ec 0c             	sub    $0xc,%esp
  80fb3c:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fb3f:	50                   	push   %eax
  80fb40:	e8 a7 f8 ff ff       	call   80f3ec <fd_alloc>
  80fb45:	83 c4 10             	add    $0x10,%esp
		return r;
  80fb48:	89 c2                	mov    %eax,%edx
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
		return -E_BAD_PATH;

	if ((r = fd_alloc(&fd)) < 0)
  80fb4a:	85 c0                	test   %eax,%eax
  80fb4c:	78 57                	js     80fba5 <open+0x86>
		return r;

	strcpy(fsipcbuf.open.req_path, path);
  80fb4e:	83 ec 08             	sub    $0x8,%esp
  80fb51:	53                   	push   %ebx
  80fb52:	68 00 c0 b3 00       	push   $0xb3c000
  80fb57:	e8 90 ee ff ff       	call   80e9ec <strcpy>
	fsipcbuf.open.req_omode = mode;
  80fb5c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fb5f:	a3 00 c4 b3 00       	mov    %eax,0xb3c400

	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  80fb64:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fb67:	b8 01 00 00 00       	mov    $0x1,%eax
  80fb6c:	e8 03 fe ff ff       	call   80f974 <fsipc>
  80fb71:	89 c3                	mov    %eax,%ebx
  80fb73:	83 c4 10             	add    $0x10,%esp
  80fb76:	85 c0                	test   %eax,%eax
  80fb78:	79 14                	jns    80fb8e <open+0x6f>
		fd_close(fd, 0);
  80fb7a:	83 ec 08             	sub    $0x8,%esp
  80fb7d:	6a 00                	push   $0x0
  80fb7f:	ff 75 f4             	pushl  -0xc(%ebp)
  80fb82:	e8 5d f9 ff ff       	call   80f4e4 <fd_close>
		return r;
  80fb87:	83 c4 10             	add    $0x10,%esp
  80fb8a:	89 da                	mov    %ebx,%edx
  80fb8c:	eb 17                	jmp    80fba5 <open+0x86>
	}

	return fd2num(fd);
  80fb8e:	83 ec 0c             	sub    $0xc,%esp
  80fb91:	ff 75 f4             	pushl  -0xc(%ebp)
  80fb94:	e8 2c f8 ff ff       	call   80f3c5 <fd2num>
  80fb99:	89 c2                	mov    %eax,%edx
  80fb9b:	83 c4 10             	add    $0x10,%esp
  80fb9e:	eb 05                	jmp    80fba5 <open+0x86>

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
		return -E_BAD_PATH;
  80fba0:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
		fd_close(fd, 0);
		return r;
	}

	return fd2num(fd);
}
  80fba5:	89 d0                	mov    %edx,%eax
  80fba7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fbaa:	c9                   	leave  
  80fbab:	c3                   	ret    

0080fbac <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  80fbac:	55                   	push   %ebp
  80fbad:	89 e5                	mov    %esp,%ebp
  80fbaf:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  80fbb2:	ba 00 00 00 00       	mov    $0x0,%edx
  80fbb7:	b8 08 00 00 00       	mov    $0x8,%eax
  80fbbc:	e8 b3 fd ff ff       	call   80f974 <fsipc>
}
  80fbc1:	c9                   	leave  
  80fbc2:	c3                   	ret    

0080fbc3 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  80fbc3:	55                   	push   %ebp
  80fbc4:	89 e5                	mov    %esp,%ebp
  80fbc6:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  80fbc9:	68 66 35 81 00       	push   $0x813566
  80fbce:	ff 75 0c             	pushl  0xc(%ebp)
  80fbd1:	e8 16 ee ff ff       	call   80e9ec <strcpy>
	return 0;
}
  80fbd6:	b8 00 00 00 00       	mov    $0x0,%eax
  80fbdb:	c9                   	leave  
  80fbdc:	c3                   	ret    

0080fbdd <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  80fbdd:	55                   	push   %ebp
  80fbde:	89 e5                	mov    %esp,%ebp
  80fbe0:	53                   	push   %ebx
  80fbe1:	83 ec 10             	sub    $0x10,%esp
  80fbe4:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  80fbe7:	53                   	push   %ebx
  80fbe8:	e8 15 0c 00 00       	call   810802 <pageref>
  80fbed:	83 c4 10             	add    $0x10,%esp
		return nsipc_close(fd->fd_sock.sockid);
	else
		return 0;
  80fbf0:	ba 00 00 00 00       	mov    $0x0,%edx
}

static int
devsock_close(struct Fd *fd)
{
	if (pageref(fd) == 1)
  80fbf5:	83 f8 01             	cmp    $0x1,%eax
  80fbf8:	75 10                	jne    80fc0a <devsock_close+0x2d>
		return nsipc_close(fd->fd_sock.sockid);
  80fbfa:	83 ec 0c             	sub    $0xc,%esp
  80fbfd:	ff 73 0c             	pushl  0xc(%ebx)
  80fc00:	e8 c0 02 00 00       	call   80fec5 <nsipc_close>
  80fc05:	89 c2                	mov    %eax,%edx
  80fc07:	83 c4 10             	add    $0x10,%esp
	else
		return 0;
}
  80fc0a:	89 d0                	mov    %edx,%eax
  80fc0c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fc0f:	c9                   	leave  
  80fc10:	c3                   	ret    

0080fc11 <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  80fc11:	55                   	push   %ebp
  80fc12:	89 e5                	mov    %esp,%ebp
  80fc14:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  80fc17:	6a 00                	push   $0x0
  80fc19:	ff 75 10             	pushl  0x10(%ebp)
  80fc1c:	ff 75 0c             	pushl  0xc(%ebp)
  80fc1f:	8b 45 08             	mov    0x8(%ebp),%eax
  80fc22:	ff 70 0c             	pushl  0xc(%eax)
  80fc25:	e8 78 03 00 00       	call   80ffa2 <nsipc_send>
}
  80fc2a:	c9                   	leave  
  80fc2b:	c3                   	ret    

0080fc2c <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  80fc2c:	55                   	push   %ebp
  80fc2d:	89 e5                	mov    %esp,%ebp
  80fc2f:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  80fc32:	6a 00                	push   $0x0
  80fc34:	ff 75 10             	pushl  0x10(%ebp)
  80fc37:	ff 75 0c             	pushl  0xc(%ebp)
  80fc3a:	8b 45 08             	mov    0x8(%ebp),%eax
  80fc3d:	ff 70 0c             	pushl  0xc(%eax)
  80fc40:	e8 f1 02 00 00       	call   80ff36 <nsipc_recv>
}
  80fc45:	c9                   	leave  
  80fc46:	c3                   	ret    

0080fc47 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  80fc47:	55                   	push   %ebp
  80fc48:	89 e5                	mov    %esp,%ebp
  80fc4a:	83 ec 20             	sub    $0x20,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  80fc4d:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80fc50:	52                   	push   %edx
  80fc51:	50                   	push   %eax
  80fc52:	e8 e4 f7 ff ff       	call   80f43b <fd_lookup>
  80fc57:	83 c4 10             	add    $0x10,%esp
  80fc5a:	85 c0                	test   %eax,%eax
  80fc5c:	78 17                	js     80fc75 <fd2sockid+0x2e>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  80fc5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fc61:	8b 0d 08 43 81 00    	mov    0x814308,%ecx
  80fc67:	39 08                	cmp    %ecx,(%eax)
  80fc69:	75 05                	jne    80fc70 <fd2sockid+0x29>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  80fc6b:	8b 40 0c             	mov    0xc(%eax),%eax
  80fc6e:	eb 05                	jmp    80fc75 <fd2sockid+0x2e>
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
		return -E_NOT_SUPP;
  80fc70:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return sfd->fd_sock.sockid;
}
  80fc75:	c9                   	leave  
  80fc76:	c3                   	ret    

0080fc77 <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  80fc77:	55                   	push   %ebp
  80fc78:	89 e5                	mov    %esp,%ebp
  80fc7a:	56                   	push   %esi
  80fc7b:	53                   	push   %ebx
  80fc7c:	83 ec 1c             	sub    $0x1c,%esp
  80fc7f:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  80fc81:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fc84:	50                   	push   %eax
  80fc85:	e8 62 f7 ff ff       	call   80f3ec <fd_alloc>
  80fc8a:	89 c3                	mov    %eax,%ebx
  80fc8c:	83 c4 10             	add    $0x10,%esp
  80fc8f:	85 c0                	test   %eax,%eax
  80fc91:	78 1b                	js     80fcae <alloc_sockfd+0x37>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  80fc93:	83 ec 04             	sub    $0x4,%esp
  80fc96:	68 07 04 00 00       	push   $0x407
  80fc9b:	ff 75 f4             	pushl  -0xc(%ebp)
  80fc9e:	6a 00                	push   $0x0
  80fca0:	e8 4a f1 ff ff       	call   80edef <sys_page_alloc>
  80fca5:	89 c3                	mov    %eax,%ebx
  80fca7:	83 c4 10             	add    $0x10,%esp
  80fcaa:	85 c0                	test   %eax,%eax
  80fcac:	79 10                	jns    80fcbe <alloc_sockfd+0x47>
		nsipc_close(sockid);
  80fcae:	83 ec 0c             	sub    $0xc,%esp
  80fcb1:	56                   	push   %esi
  80fcb2:	e8 0e 02 00 00       	call   80fec5 <nsipc_close>
		return r;
  80fcb7:	83 c4 10             	add    $0x10,%esp
  80fcba:	89 d8                	mov    %ebx,%eax
  80fcbc:	eb 24                	jmp    80fce2 <alloc_sockfd+0x6b>
	}

	sfd->fd_dev_id = devsock.dev_id;
  80fcbe:	8b 15 08 43 81 00    	mov    0x814308,%edx
  80fcc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fcc7:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  80fcc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fccc:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  80fcd3:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  80fcd6:	83 ec 0c             	sub    $0xc,%esp
  80fcd9:	50                   	push   %eax
  80fcda:	e8 e6 f6 ff ff       	call   80f3c5 <fd2num>
  80fcdf:	83 c4 10             	add    $0x10,%esp
}
  80fce2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fce5:	5b                   	pop    %ebx
  80fce6:	5e                   	pop    %esi
  80fce7:	5d                   	pop    %ebp
  80fce8:	c3                   	ret    

0080fce9 <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80fce9:	55                   	push   %ebp
  80fcea:	89 e5                	mov    %esp,%ebp
  80fcec:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fcef:	8b 45 08             	mov    0x8(%ebp),%eax
  80fcf2:	e8 50 ff ff ff       	call   80fc47 <fd2sockid>
		return r;
  80fcf7:	89 c1                	mov    %eax,%ecx

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fcf9:	85 c0                	test   %eax,%eax
  80fcfb:	78 1f                	js     80fd1c <accept+0x33>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80fcfd:	83 ec 04             	sub    $0x4,%esp
  80fd00:	ff 75 10             	pushl  0x10(%ebp)
  80fd03:	ff 75 0c             	pushl  0xc(%ebp)
  80fd06:	50                   	push   %eax
  80fd07:	e8 12 01 00 00       	call   80fe1e <nsipc_accept>
  80fd0c:	83 c4 10             	add    $0x10,%esp
		return r;
  80fd0f:	89 c1                	mov    %eax,%ecx
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80fd11:	85 c0                	test   %eax,%eax
  80fd13:	78 07                	js     80fd1c <accept+0x33>
		return r;
	return alloc_sockfd(r);
  80fd15:	e8 5d ff ff ff       	call   80fc77 <alloc_sockfd>
  80fd1a:	89 c1                	mov    %eax,%ecx
}
  80fd1c:	89 c8                	mov    %ecx,%eax
  80fd1e:	c9                   	leave  
  80fd1f:	c3                   	ret    

0080fd20 <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80fd20:	55                   	push   %ebp
  80fd21:	89 e5                	mov    %esp,%ebp
  80fd23:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fd26:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd29:	e8 19 ff ff ff       	call   80fc47 <fd2sockid>
  80fd2e:	85 c0                	test   %eax,%eax
  80fd30:	78 12                	js     80fd44 <bind+0x24>
		return r;
	return nsipc_bind(r, name, namelen);
  80fd32:	83 ec 04             	sub    $0x4,%esp
  80fd35:	ff 75 10             	pushl  0x10(%ebp)
  80fd38:	ff 75 0c             	pushl  0xc(%ebp)
  80fd3b:	50                   	push   %eax
  80fd3c:	e8 2d 01 00 00       	call   80fe6e <nsipc_bind>
  80fd41:	83 c4 10             	add    $0x10,%esp
}
  80fd44:	c9                   	leave  
  80fd45:	c3                   	ret    

0080fd46 <shutdown>:

int
shutdown(int s, int how)
{
  80fd46:	55                   	push   %ebp
  80fd47:	89 e5                	mov    %esp,%ebp
  80fd49:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fd4c:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd4f:	e8 f3 fe ff ff       	call   80fc47 <fd2sockid>
  80fd54:	85 c0                	test   %eax,%eax
  80fd56:	78 0f                	js     80fd67 <shutdown+0x21>
		return r;
	return nsipc_shutdown(r, how);
  80fd58:	83 ec 08             	sub    $0x8,%esp
  80fd5b:	ff 75 0c             	pushl  0xc(%ebp)
  80fd5e:	50                   	push   %eax
  80fd5f:	e8 3f 01 00 00       	call   80fea3 <nsipc_shutdown>
  80fd64:	83 c4 10             	add    $0x10,%esp
}
  80fd67:	c9                   	leave  
  80fd68:	c3                   	ret    

0080fd69 <connect>:
		return 0;
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80fd69:	55                   	push   %ebp
  80fd6a:	89 e5                	mov    %esp,%ebp
  80fd6c:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fd6f:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd72:	e8 d0 fe ff ff       	call   80fc47 <fd2sockid>
  80fd77:	85 c0                	test   %eax,%eax
  80fd79:	78 12                	js     80fd8d <connect+0x24>
		return r;
	return nsipc_connect(r, name, namelen);
  80fd7b:	83 ec 04             	sub    $0x4,%esp
  80fd7e:	ff 75 10             	pushl  0x10(%ebp)
  80fd81:	ff 75 0c             	pushl  0xc(%ebp)
  80fd84:	50                   	push   %eax
  80fd85:	e8 55 01 00 00       	call   80fedf <nsipc_connect>
  80fd8a:	83 c4 10             	add    $0x10,%esp
}
  80fd8d:	c9                   	leave  
  80fd8e:	c3                   	ret    

0080fd8f <listen>:

int
listen(int s, int backlog)
{
  80fd8f:	55                   	push   %ebp
  80fd90:	89 e5                	mov    %esp,%ebp
  80fd92:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fd95:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd98:	e8 aa fe ff ff       	call   80fc47 <fd2sockid>
  80fd9d:	85 c0                	test   %eax,%eax
  80fd9f:	78 0f                	js     80fdb0 <listen+0x21>
		return r;
	return nsipc_listen(r, backlog);
  80fda1:	83 ec 08             	sub    $0x8,%esp
  80fda4:	ff 75 0c             	pushl  0xc(%ebp)
  80fda7:	50                   	push   %eax
  80fda8:	e8 67 01 00 00       	call   80ff14 <nsipc_listen>
  80fdad:	83 c4 10             	add    $0x10,%esp
}
  80fdb0:	c9                   	leave  
  80fdb1:	c3                   	ret    

0080fdb2 <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  80fdb2:	55                   	push   %ebp
  80fdb3:	89 e5                	mov    %esp,%ebp
  80fdb5:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  80fdb8:	ff 75 10             	pushl  0x10(%ebp)
  80fdbb:	ff 75 0c             	pushl  0xc(%ebp)
  80fdbe:	ff 75 08             	pushl  0x8(%ebp)
  80fdc1:	e8 3a 02 00 00       	call   810000 <nsipc_socket>
  80fdc6:	83 c4 10             	add    $0x10,%esp
  80fdc9:	85 c0                	test   %eax,%eax
  80fdcb:	78 05                	js     80fdd2 <socket+0x20>
		return r;
	return alloc_sockfd(r);
  80fdcd:	e8 a5 fe ff ff       	call   80fc77 <alloc_sockfd>
}
  80fdd2:	c9                   	leave  
  80fdd3:	c3                   	ret    

0080fdd4 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  80fdd4:	55                   	push   %ebp
  80fdd5:	89 e5                	mov    %esp,%ebp
  80fdd7:	53                   	push   %ebx
  80fdd8:	83 ec 04             	sub    $0x4,%esp
  80fddb:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  80fddd:	83 3d d0 b1 b3 00 00 	cmpl   $0x0,0xb3b1d0
  80fde4:	75 12                	jne    80fdf8 <nsipc+0x24>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  80fde6:	83 ec 0c             	sub    $0xc,%esp
  80fde9:	6a 02                	push   $0x2
  80fdeb:	e8 9c f5 ff ff       	call   80f38c <ipc_find_env>
  80fdf0:	a3 d0 b1 b3 00       	mov    %eax,0xb3b1d0
  80fdf5:	83 c4 10             	add    $0x10,%esp
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  80fdf8:	6a 07                	push   $0x7
  80fdfa:	68 00 d0 b3 00       	push   $0xb3d000
  80fdff:	53                   	push   %ebx
  80fe00:	ff 35 d0 b1 b3 00    	pushl  0xb3b1d0
  80fe06:	e8 2d f5 ff ff       	call   80f338 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  80fe0b:	83 c4 0c             	add    $0xc,%esp
  80fe0e:	6a 00                	push   $0x0
  80fe10:	6a 00                	push   $0x0
  80fe12:	6a 00                	push   $0x0
  80fe14:	e8 b8 f4 ff ff       	call   80f2d1 <ipc_recv>
}
  80fe19:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fe1c:	c9                   	leave  
  80fe1d:	c3                   	ret    

0080fe1e <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80fe1e:	55                   	push   %ebp
  80fe1f:	89 e5                	mov    %esp,%ebp
  80fe21:	56                   	push   %esi
  80fe22:	53                   	push   %ebx
  80fe23:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  80fe26:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe29:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.accept.req_addrlen = *addrlen;
  80fe2e:	8b 06                	mov    (%esi),%eax
  80fe30:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  80fe35:	b8 01 00 00 00       	mov    $0x1,%eax
  80fe3a:	e8 95 ff ff ff       	call   80fdd4 <nsipc>
  80fe3f:	89 c3                	mov    %eax,%ebx
  80fe41:	85 c0                	test   %eax,%eax
  80fe43:	78 20                	js     80fe65 <nsipc_accept+0x47>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  80fe45:	83 ec 04             	sub    $0x4,%esp
  80fe48:	ff 35 10 d0 b3 00    	pushl  0xb3d010
  80fe4e:	68 00 d0 b3 00       	push   $0xb3d000
  80fe53:	ff 75 0c             	pushl  0xc(%ebp)
  80fe56:	e8 23 ed ff ff       	call   80eb7e <memmove>
		*addrlen = ret->ret_addrlen;
  80fe5b:	a1 10 d0 b3 00       	mov    0xb3d010,%eax
  80fe60:	89 06                	mov    %eax,(%esi)
  80fe62:	83 c4 10             	add    $0x10,%esp
	}
	return r;
}
  80fe65:	89 d8                	mov    %ebx,%eax
  80fe67:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fe6a:	5b                   	pop    %ebx
  80fe6b:	5e                   	pop    %esi
  80fe6c:	5d                   	pop    %ebp
  80fe6d:	c3                   	ret    

0080fe6e <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80fe6e:	55                   	push   %ebp
  80fe6f:	89 e5                	mov    %esp,%ebp
  80fe71:	53                   	push   %ebx
  80fe72:	83 ec 08             	sub    $0x8,%esp
  80fe75:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  80fe78:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe7b:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  80fe80:	53                   	push   %ebx
  80fe81:	ff 75 0c             	pushl  0xc(%ebp)
  80fe84:	68 04 d0 b3 00       	push   $0xb3d004
  80fe89:	e8 f0 ec ff ff       	call   80eb7e <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  80fe8e:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_BIND);
  80fe94:	b8 02 00 00 00       	mov    $0x2,%eax
  80fe99:	e8 36 ff ff ff       	call   80fdd4 <nsipc>
}
  80fe9e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fea1:	c9                   	leave  
  80fea2:	c3                   	ret    

0080fea3 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  80fea3:	55                   	push   %ebp
  80fea4:	89 e5                	mov    %esp,%ebp
  80fea6:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  80fea9:	8b 45 08             	mov    0x8(%ebp),%eax
  80feac:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.shutdown.req_how = how;
  80feb1:	8b 45 0c             	mov    0xc(%ebp),%eax
  80feb4:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_SHUTDOWN);
  80feb9:	b8 03 00 00 00       	mov    $0x3,%eax
  80febe:	e8 11 ff ff ff       	call   80fdd4 <nsipc>
}
  80fec3:	c9                   	leave  
  80fec4:	c3                   	ret    

0080fec5 <nsipc_close>:

int
nsipc_close(int s)
{
  80fec5:	55                   	push   %ebp
  80fec6:	89 e5                	mov    %esp,%ebp
  80fec8:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  80fecb:	8b 45 08             	mov    0x8(%ebp),%eax
  80fece:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return nsipc(NSREQ_CLOSE);
  80fed3:	b8 04 00 00 00       	mov    $0x4,%eax
  80fed8:	e8 f7 fe ff ff       	call   80fdd4 <nsipc>
}
  80fedd:	c9                   	leave  
  80fede:	c3                   	ret    

0080fedf <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80fedf:	55                   	push   %ebp
  80fee0:	89 e5                	mov    %esp,%ebp
  80fee2:	53                   	push   %ebx
  80fee3:	83 ec 08             	sub    $0x8,%esp
  80fee6:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  80fee9:	8b 45 08             	mov    0x8(%ebp),%eax
  80feec:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  80fef1:	53                   	push   %ebx
  80fef2:	ff 75 0c             	pushl  0xc(%ebp)
  80fef5:	68 04 d0 b3 00       	push   $0xb3d004
  80fefa:	e8 7f ec ff ff       	call   80eb7e <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  80feff:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_CONNECT);
  80ff05:	b8 05 00 00 00       	mov    $0x5,%eax
  80ff0a:	e8 c5 fe ff ff       	call   80fdd4 <nsipc>
}
  80ff0f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ff12:	c9                   	leave  
  80ff13:	c3                   	ret    

0080ff14 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  80ff14:	55                   	push   %ebp
  80ff15:	89 e5                	mov    %esp,%ebp
  80ff17:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  80ff1a:	8b 45 08             	mov    0x8(%ebp),%eax
  80ff1d:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.listen.req_backlog = backlog;
  80ff22:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ff25:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_LISTEN);
  80ff2a:	b8 06 00 00 00       	mov    $0x6,%eax
  80ff2f:	e8 a0 fe ff ff       	call   80fdd4 <nsipc>
}
  80ff34:	c9                   	leave  
  80ff35:	c3                   	ret    

0080ff36 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  80ff36:	55                   	push   %ebp
  80ff37:	89 e5                	mov    %esp,%ebp
  80ff39:	56                   	push   %esi
  80ff3a:	53                   	push   %ebx
  80ff3b:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  80ff3e:	8b 45 08             	mov    0x8(%ebp),%eax
  80ff41:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.recv.req_len = len;
  80ff46:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	nsipcbuf.recv.req_flags = flags;
  80ff4c:	8b 45 14             	mov    0x14(%ebp),%eax
  80ff4f:	a3 08 d0 b3 00       	mov    %eax,0xb3d008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  80ff54:	b8 07 00 00 00       	mov    $0x7,%eax
  80ff59:	e8 76 fe ff ff       	call   80fdd4 <nsipc>
  80ff5e:	89 c3                	mov    %eax,%ebx
  80ff60:	85 c0                	test   %eax,%eax
  80ff62:	78 35                	js     80ff99 <nsipc_recv+0x63>
		assert(r < 1600 && r <= len);
  80ff64:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  80ff69:	7f 04                	jg     80ff6f <nsipc_recv+0x39>
  80ff6b:	39 c6                	cmp    %eax,%esi
  80ff6d:	7d 16                	jge    80ff85 <nsipc_recv+0x4f>
  80ff6f:	68 72 35 81 00       	push   $0x813572
  80ff74:	68 87 22 81 00       	push   $0x812287
  80ff79:	6a 62                	push   $0x62
  80ff7b:	68 87 35 81 00       	push   $0x813587
  80ff80:	e8 09 e4 ff ff       	call   80e38e <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  80ff85:	83 ec 04             	sub    $0x4,%esp
  80ff88:	50                   	push   %eax
  80ff89:	68 00 d0 b3 00       	push   $0xb3d000
  80ff8e:	ff 75 0c             	pushl  0xc(%ebp)
  80ff91:	e8 e8 eb ff ff       	call   80eb7e <memmove>
  80ff96:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  80ff99:	89 d8                	mov    %ebx,%eax
  80ff9b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ff9e:	5b                   	pop    %ebx
  80ff9f:	5e                   	pop    %esi
  80ffa0:	5d                   	pop    %ebp
  80ffa1:	c3                   	ret    

0080ffa2 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  80ffa2:	55                   	push   %ebp
  80ffa3:	89 e5                	mov    %esp,%ebp
  80ffa5:	53                   	push   %ebx
  80ffa6:	83 ec 04             	sub    $0x4,%esp
  80ffa9:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  80ffac:	8b 45 08             	mov    0x8(%ebp),%eax
  80ffaf:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	assert(size < 1600);
  80ffb4:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  80ffba:	7e 16                	jle    80ffd2 <nsipc_send+0x30>
  80ffbc:	68 93 35 81 00       	push   $0x813593
  80ffc1:	68 87 22 81 00       	push   $0x812287
  80ffc6:	6a 6d                	push   $0x6d
  80ffc8:	68 87 35 81 00       	push   $0x813587
  80ffcd:	e8 bc e3 ff ff       	call   80e38e <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  80ffd2:	83 ec 04             	sub    $0x4,%esp
  80ffd5:	53                   	push   %ebx
  80ffd6:	ff 75 0c             	pushl  0xc(%ebp)
  80ffd9:	68 0c d0 b3 00       	push   $0xb3d00c
  80ffde:	e8 9b eb ff ff       	call   80eb7e <memmove>
	nsipcbuf.send.req_size = size;
  80ffe3:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	nsipcbuf.send.req_flags = flags;
  80ffe9:	8b 45 14             	mov    0x14(%ebp),%eax
  80ffec:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SEND);
  80fff1:	b8 08 00 00 00       	mov    $0x8,%eax
  80fff6:	e8 d9 fd ff ff       	call   80fdd4 <nsipc>
}
  80fffb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fffe:	c9                   	leave  
  80ffff:	c3                   	ret    

00810000 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  810000:	55                   	push   %ebp
  810001:	89 e5                	mov    %esp,%ebp
  810003:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  810006:	8b 45 08             	mov    0x8(%ebp),%eax
  810009:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.socket.req_type = type;
  81000e:	8b 45 0c             	mov    0xc(%ebp),%eax
  810011:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	nsipcbuf.socket.req_protocol = protocol;
  810016:	8b 45 10             	mov    0x10(%ebp),%eax
  810019:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SOCKET);
  81001e:	b8 09 00 00 00       	mov    $0x9,%eax
  810023:	e8 ac fd ff ff       	call   80fdd4 <nsipc>
}
  810028:	c9                   	leave  
  810029:	c3                   	ret    

0081002a <free>:
	return v;
}

void
free(void *v)
{
  81002a:	55                   	push   %ebp
  81002b:	89 e5                	mov    %esp,%ebp
  81002d:	53                   	push   %ebx
  81002e:	83 ec 04             	sub    $0x4,%esp
  810031:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  810034:	85 db                	test   %ebx,%ebx
  810036:	0f 84 97 00 00 00    	je     8100d3 <free+0xa9>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  81003c:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  810042:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  810047:	76 16                	jbe    81005f <free+0x35>
  810049:	68 a0 35 81 00       	push   $0x8135a0
  81004e:	68 87 22 81 00       	push   $0x812287
  810053:	6a 7a                	push   $0x7a
  810055:	68 d0 35 81 00       	push   $0x8135d0
  81005a:	e8 2f e3 ff ff       	call   80e38e <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  81005f:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  810065:	eb 3a                	jmp    8100a1 <free+0x77>
		sys_page_unmap(0, c);
  810067:	83 ec 08             	sub    $0x8,%esp
  81006a:	53                   	push   %ebx
  81006b:	6a 00                	push   $0x0
  81006d:	e8 02 ee ff ff       	call   80ee74 <sys_page_unmap>
		c += PGSIZE;
  810072:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  810078:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  81007e:	83 c4 10             	add    $0x10,%esp
  810081:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  810086:	76 19                	jbe    8100a1 <free+0x77>
  810088:	68 dd 35 81 00       	push   $0x8135dd
  81008d:	68 87 22 81 00       	push   $0x812287
  810092:	68 81 00 00 00       	push   $0x81
  810097:	68 d0 35 81 00       	push   $0x8135d0
  81009c:	e8 ed e2 ff ff       	call   80e38e <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8100a1:	89 d8                	mov    %ebx,%eax
  8100a3:	c1 e8 0c             	shr    $0xc,%eax
  8100a6:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  8100ad:	f6 c4 02             	test   $0x2,%ah
  8100b0:	75 b5                	jne    810067 <free+0x3d>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  8100b2:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  8100b8:	83 e8 01             	sub    $0x1,%eax
  8100bb:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  8100c1:	85 c0                	test   %eax,%eax
  8100c3:	75 0e                	jne    8100d3 <free+0xa9>
		sys_page_unmap(0, c);
  8100c5:	83 ec 08             	sub    $0x8,%esp
  8100c8:	53                   	push   %ebx
  8100c9:	6a 00                	push   $0x0
  8100cb:	e8 a4 ed ff ff       	call   80ee74 <sys_page_unmap>
  8100d0:	83 c4 10             	add    $0x10,%esp
}
  8100d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8100d6:	c9                   	leave  
  8100d7:	c3                   	ret    

008100d8 <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  8100d8:	55                   	push   %ebp
  8100d9:	89 e5                	mov    %esp,%ebp
  8100db:	57                   	push   %edi
  8100dc:	56                   	push   %esi
  8100dd:	53                   	push   %ebx
  8100de:	83 ec 1c             	sub    $0x1c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  8100e1:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  8100e6:	85 c0                	test   %eax,%eax
  8100e8:	75 22                	jne    81010c <malloc+0x34>
		mptr = mbegin;
  8100ea:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  8100f1:	00 00 08 

	n = ROUNDUP(n, 4);
  8100f4:	8b 45 08             	mov    0x8(%ebp),%eax
  8100f7:	83 c0 03             	add    $0x3,%eax
  8100fa:	83 e0 fc             	and    $0xfffffffc,%eax
  8100fd:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if (n >= MAXMALLOC)
  810100:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  810105:	76 74                	jbe    81017b <malloc+0xa3>
  810107:	e9 7a 01 00 00       	jmp    810286 <malloc+0x1ae>
	void *v;

	if (mptr == 0)
		mptr = mbegin;

	n = ROUNDUP(n, 4);
  81010c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  81010f:	8d 53 03             	lea    0x3(%ebx),%edx
  810112:	83 e2 fc             	and    $0xfffffffc,%edx
  810115:	89 55 dc             	mov    %edx,-0x24(%ebp)

	if (n >= MAXMALLOC)
  810118:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  81011e:	0f 87 69 01 00 00    	ja     81028d <malloc+0x1b5>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  810124:	a9 ff 0f 00 00       	test   $0xfff,%eax
  810129:	74 50                	je     81017b <malloc+0xa3>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  81012b:	89 c1                	mov    %eax,%ecx
  81012d:	c1 e9 0c             	shr    $0xc,%ecx
  810130:	8d 54 10 03          	lea    0x3(%eax,%edx,1),%edx
  810134:	c1 ea 0c             	shr    $0xc,%edx
  810137:	39 d1                	cmp    %edx,%ecx
  810139:	75 20                	jne    81015b <malloc+0x83>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  81013b:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
  810141:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  810147:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  81014b:	8b 55 dc             	mov    -0x24(%ebp),%edx
  81014e:	01 c2                	add    %eax,%edx
  810150:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
			return v;
  810156:	e9 55 01 00 00       	jmp    8102b0 <malloc+0x1d8>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  81015b:	83 ec 0c             	sub    $0xc,%esp
  81015e:	50                   	push   %eax
  81015f:	e8 c6 fe ff ff       	call   81002a <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  810164:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  810169:	05 00 10 00 00       	add    $0x1000,%eax
  81016e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  810173:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
  810178:	83 c4 10             	add    $0x10,%esp
  81017b:	8b 35 d4 b1 b3 00    	mov    0xb3b1d4,%esi
	return 1;
}

void*
malloc(size_t n)
{
  810181:	c7 45 d8 02 00 00 00 	movl   $0x2,-0x28(%ebp)
  810188:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  81018c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  81018f:	8d 78 04             	lea    0x4(%eax),%edi
  810192:	89 75 e0             	mov    %esi,-0x20(%ebp)
  810195:	89 fb                	mov    %edi,%ebx
  810197:	8d 0c 37             	lea    (%edi,%esi,1),%ecx
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  81019a:	89 f0                	mov    %esi,%eax
  81019c:	eb 36                	jmp    8101d4 <malloc+0xfc>
		if (va >= (uintptr_t) mend
  81019e:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  8101a3:	0f 87 eb 00 00 00    	ja     810294 <malloc+0x1bc>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  8101a9:	89 c2                	mov    %eax,%edx
  8101ab:	c1 ea 16             	shr    $0x16,%edx
  8101ae:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  8101b5:	f6 c2 01             	test   $0x1,%dl
  8101b8:	74 15                	je     8101cf <malloc+0xf7>
  8101ba:	89 c2                	mov    %eax,%edx
  8101bc:	c1 ea 0c             	shr    $0xc,%edx
  8101bf:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  8101c6:	f6 c2 01             	test   $0x1,%dl
  8101c9:	0f 85 c5 00 00 00    	jne    810294 <malloc+0x1bc>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8101cf:	05 00 10 00 00       	add    $0x1000,%eax
  8101d4:	39 c8                	cmp    %ecx,%eax
  8101d6:	72 c6                	jb     81019e <malloc+0xc6>
  8101d8:	eb 79                	jmp    810253 <malloc+0x17b>
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
  8101da:	be 00 00 00 08       	mov    $0x8000000,%esi
  8101df:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
			if (++nwrap == 2)
  8101e3:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  8101e7:	75 a9                	jne    810192 <malloc+0xba>
  8101e9:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  8101f0:	00 00 08 
				return 0;	/* out of address space */
  8101f3:	b8 00 00 00 00       	mov    $0x0,%eax
  8101f8:	e9 b3 00 00 00       	jmp    8102b0 <malloc+0x1d8>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  8101fd:	8d be 00 10 00 00    	lea    0x1000(%esi),%edi
  810203:	39 df                	cmp    %ebx,%edi
  810205:	19 c0                	sbb    %eax,%eax
  810207:	25 00 02 00 00       	and    $0x200,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  81020c:	83 ec 04             	sub    $0x4,%esp
  81020f:	83 c8 07             	or     $0x7,%eax
  810212:	50                   	push   %eax
  810213:	03 15 d4 b1 b3 00    	add    0xb3b1d4,%edx
  810219:	52                   	push   %edx
  81021a:	6a 00                	push   $0x0
  81021c:	e8 ce eb ff ff       	call   80edef <sys_page_alloc>
  810221:	83 c4 10             	add    $0x10,%esp
  810224:	85 c0                	test   %eax,%eax
  810226:	78 20                	js     810248 <malloc+0x170>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  810228:	89 fe                	mov    %edi,%esi
  81022a:	eb 3a                	jmp    810266 <malloc+0x18e>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
				sys_page_unmap(0, mptr + i);
  81022c:	83 ec 08             	sub    $0x8,%esp
  81022f:	89 f0                	mov    %esi,%eax
  810231:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  810237:	50                   	push   %eax
  810238:	6a 00                	push   $0x0
  81023a:	e8 35 ec ff ff       	call   80ee74 <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  81023f:	81 ee 00 10 00 00    	sub    $0x1000,%esi
  810245:	83 c4 10             	add    $0x10,%esp
  810248:	85 f6                	test   %esi,%esi
  81024a:	79 e0                	jns    81022c <malloc+0x154>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  81024c:	b8 00 00 00 00       	mov    $0x0,%eax
  810251:	eb 5d                	jmp    8102b0 <malloc+0x1d8>
  810253:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  810257:	74 08                	je     810261 <malloc+0x189>
  810259:	8b 45 e0             	mov    -0x20(%ebp),%eax
  81025c:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  810261:	be 00 00 00 00       	mov    $0x0,%esi
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  810266:	89 f2                	mov    %esi,%edx
  810268:	39 f3                	cmp    %esi,%ebx
  81026a:	77 91                	ja     8101fd <malloc+0x125>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  81026c:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  810271:	c7 44 30 fc 02 00 00 	movl   $0x2,-0x4(%eax,%esi,1)
  810278:	00 
	v = mptr;
	mptr += n;
  810279:	8b 55 dc             	mov    -0x24(%ebp),%edx
  81027c:	01 c2                	add    %eax,%edx
  81027e:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
	return v;
  810284:	eb 2a                	jmp    8102b0 <malloc+0x1d8>
		mptr = mbegin;

	n = ROUNDUP(n, 4);

	if (n >= MAXMALLOC)
		return 0;
  810286:	b8 00 00 00 00       	mov    $0x0,%eax
  81028b:	eb 23                	jmp    8102b0 <malloc+0x1d8>
  81028d:	b8 00 00 00 00       	mov    $0x0,%eax
  810292:	eb 1c                	jmp    8102b0 <malloc+0x1d8>
  810294:	8d 86 00 10 00 00    	lea    0x1000(%esi),%eax
  81029a:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
  81029e:	89 c6                	mov    %eax,%esi
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  8102a0:	3d 00 00 00 10       	cmp    $0x10000000,%eax
  8102a5:	0f 85 e7 fe ff ff    	jne    810192 <malloc+0xba>
  8102ab:	e9 2a ff ff ff       	jmp    8101da <malloc+0x102>
	ref = (uint32_t*) (mptr + i - 4);
	*ref = 2;	/* reference for mptr, reference for returned block */
	v = mptr;
	mptr += n;
	return v;
}
  8102b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8102b3:	5b                   	pop    %ebx
  8102b4:	5e                   	pop    %esi
  8102b5:	5f                   	pop    %edi
  8102b6:	5d                   	pop    %ebp
  8102b7:	c3                   	ret    

008102b8 <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  8102b8:	55                   	push   %ebp
  8102b9:	89 e5                	mov    %esp,%ebp
  8102bb:	56                   	push   %esi
  8102bc:	53                   	push   %ebx
  8102bd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  8102c0:	83 ec 0c             	sub    $0xc,%esp
  8102c3:	ff 75 08             	pushl  0x8(%ebp)
  8102c6:	e8 0a f1 ff ff       	call   80f3d5 <fd2data>
  8102cb:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  8102cd:	83 c4 08             	add    $0x8,%esp
  8102d0:	68 f5 35 81 00       	push   $0x8135f5
  8102d5:	53                   	push   %ebx
  8102d6:	e8 11 e7 ff ff       	call   80e9ec <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  8102db:	8b 46 04             	mov    0x4(%esi),%eax
  8102de:	2b 06                	sub    (%esi),%eax
  8102e0:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  8102e6:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  8102ed:	00 00 00 
	stat->st_dev = &devpipe;
  8102f0:	c7 83 88 00 00 00 24 	movl   $0x814324,0x88(%ebx)
  8102f7:	43 81 00 
	return 0;
}
  8102fa:	b8 00 00 00 00       	mov    $0x0,%eax
  8102ff:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810302:	5b                   	pop    %ebx
  810303:	5e                   	pop    %esi
  810304:	5d                   	pop    %ebp
  810305:	c3                   	ret    

00810306 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  810306:	55                   	push   %ebp
  810307:	89 e5                	mov    %esp,%ebp
  810309:	53                   	push   %ebx
  81030a:	83 ec 0c             	sub    $0xc,%esp
  81030d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  810310:	53                   	push   %ebx
  810311:	6a 00                	push   $0x0
  810313:	e8 5c eb ff ff       	call   80ee74 <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  810318:	89 1c 24             	mov    %ebx,(%esp)
  81031b:	e8 b5 f0 ff ff       	call   80f3d5 <fd2data>
  810320:	83 c4 08             	add    $0x8,%esp
  810323:	50                   	push   %eax
  810324:	6a 00                	push   $0x0
  810326:	e8 49 eb ff ff       	call   80ee74 <sys_page_unmap>
}
  81032b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81032e:	c9                   	leave  
  81032f:	c3                   	ret    

00810330 <_pipeisclosed>:
	return r;
}

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  810330:	55                   	push   %ebp
  810331:	89 e5                	mov    %esp,%ebp
  810333:	57                   	push   %edi
  810334:	56                   	push   %esi
  810335:	53                   	push   %ebx
  810336:	83 ec 1c             	sub    $0x1c,%esp
  810339:	89 45 e0             	mov    %eax,-0x20(%ebp)
  81033c:	89 d7                	mov    %edx,%edi
	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  81033e:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  810343:	8b 70 58             	mov    0x58(%eax),%esi
		ret = pageref(fd) == pageref(p);
  810346:	83 ec 0c             	sub    $0xc,%esp
  810349:	ff 75 e0             	pushl  -0x20(%ebp)
  81034c:	e8 b1 04 00 00       	call   810802 <pageref>
  810351:	89 c3                	mov    %eax,%ebx
  810353:	89 3c 24             	mov    %edi,(%esp)
  810356:	e8 a7 04 00 00       	call   810802 <pageref>
  81035b:	83 c4 10             	add    $0x10,%esp
  81035e:	39 c3                	cmp    %eax,%ebx
  810360:	0f 94 c1             	sete   %cl
  810363:	0f b6 c9             	movzbl %cl,%ecx
  810366:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		nn = thisenv->env_runs;
  810369:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  81036f:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  810372:	39 ce                	cmp    %ecx,%esi
  810374:	74 1b                	je     810391 <_pipeisclosed+0x61>
			return ret;
		if (n != nn && ret == 1)
  810376:	39 c3                	cmp    %eax,%ebx
  810378:	75 c4                	jne    81033e <_pipeisclosed+0xe>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  81037a:	8b 42 58             	mov    0x58(%edx),%eax
  81037d:	ff 75 e4             	pushl  -0x1c(%ebp)
  810380:	50                   	push   %eax
  810381:	56                   	push   %esi
  810382:	68 fc 35 81 00       	push   $0x8135fc
  810387:	e8 db e0 ff ff       	call   80e467 <cprintf>
  81038c:	83 c4 10             	add    $0x10,%esp
  81038f:	eb ad                	jmp    81033e <_pipeisclosed+0xe>
	}
}
  810391:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810394:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810397:	5b                   	pop    %ebx
  810398:	5e                   	pop    %esi
  810399:	5f                   	pop    %edi
  81039a:	5d                   	pop    %ebp
  81039b:	c3                   	ret    

0081039c <devpipe_write>:
	return i;
}

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  81039c:	55                   	push   %ebp
  81039d:	89 e5                	mov    %esp,%ebp
  81039f:	57                   	push   %edi
  8103a0:	56                   	push   %esi
  8103a1:	53                   	push   %ebx
  8103a2:	83 ec 28             	sub    $0x28,%esp
  8103a5:	8b 75 08             	mov    0x8(%ebp),%esi
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  8103a8:	56                   	push   %esi
  8103a9:	e8 27 f0 ff ff       	call   80f3d5 <fd2data>
  8103ae:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8103b0:	83 c4 10             	add    $0x10,%esp
  8103b3:	bf 00 00 00 00       	mov    $0x0,%edi
  8103b8:	eb 4b                	jmp    810405 <devpipe_write+0x69>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  8103ba:	89 da                	mov    %ebx,%edx
  8103bc:	89 f0                	mov    %esi,%eax
  8103be:	e8 6d ff ff ff       	call   810330 <_pipeisclosed>
  8103c3:	85 c0                	test   %eax,%eax
  8103c5:	75 48                	jne    81040f <devpipe_write+0x73>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  8103c7:	e8 04 ea ff ff       	call   80edd0 <sys_yield>
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  8103cc:	8b 43 04             	mov    0x4(%ebx),%eax
  8103cf:	8b 0b                	mov    (%ebx),%ecx
  8103d1:	8d 51 20             	lea    0x20(%ecx),%edx
  8103d4:	39 d0                	cmp    %edx,%eax
  8103d6:	73 e2                	jae    8103ba <devpipe_write+0x1e>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  8103d8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8103db:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  8103df:	88 4d e7             	mov    %cl,-0x19(%ebp)
  8103e2:	89 c2                	mov    %eax,%edx
  8103e4:	c1 fa 1f             	sar    $0x1f,%edx
  8103e7:	89 d1                	mov    %edx,%ecx
  8103e9:	c1 e9 1b             	shr    $0x1b,%ecx
  8103ec:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  8103ef:	83 e2 1f             	and    $0x1f,%edx
  8103f2:	29 ca                	sub    %ecx,%edx
  8103f4:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  8103f8:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  8103fc:	83 c0 01             	add    $0x1,%eax
  8103ff:	89 43 04             	mov    %eax,0x4(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  810402:	83 c7 01             	add    $0x1,%edi
  810405:	3b 7d 10             	cmp    0x10(%ebp),%edi
  810408:	75 c2                	jne    8103cc <devpipe_write+0x30>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  81040a:	8b 45 10             	mov    0x10(%ebp),%eax
  81040d:	eb 05                	jmp    810414 <devpipe_write+0x78>
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
				return 0;
  81040f:	b8 00 00 00 00       	mov    $0x0,%eax
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
}
  810414:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810417:	5b                   	pop    %ebx
  810418:	5e                   	pop    %esi
  810419:	5f                   	pop    %edi
  81041a:	5d                   	pop    %ebp
  81041b:	c3                   	ret    

0081041c <devpipe_read>:
	return _pipeisclosed(fd, p);
}

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  81041c:	55                   	push   %ebp
  81041d:	89 e5                	mov    %esp,%ebp
  81041f:	57                   	push   %edi
  810420:	56                   	push   %esi
  810421:	53                   	push   %ebx
  810422:	83 ec 18             	sub    $0x18,%esp
  810425:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  810428:	57                   	push   %edi
  810429:	e8 a7 ef ff ff       	call   80f3d5 <fd2data>
  81042e:	89 c6                	mov    %eax,%esi
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  810430:	83 c4 10             	add    $0x10,%esp
  810433:	bb 00 00 00 00       	mov    $0x0,%ebx
  810438:	eb 3d                	jmp    810477 <devpipe_read+0x5b>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  81043a:	85 db                	test   %ebx,%ebx
  81043c:	74 04                	je     810442 <devpipe_read+0x26>
				return i;
  81043e:	89 d8                	mov    %ebx,%eax
  810440:	eb 44                	jmp    810486 <devpipe_read+0x6a>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  810442:	89 f2                	mov    %esi,%edx
  810444:	89 f8                	mov    %edi,%eax
  810446:	e8 e5 fe ff ff       	call   810330 <_pipeisclosed>
  81044b:	85 c0                	test   %eax,%eax
  81044d:	75 32                	jne    810481 <devpipe_read+0x65>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  81044f:	e8 7c e9 ff ff       	call   80edd0 <sys_yield>
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  810454:	8b 06                	mov    (%esi),%eax
  810456:	3b 46 04             	cmp    0x4(%esi),%eax
  810459:	74 df                	je     81043a <devpipe_read+0x1e>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  81045b:	99                   	cltd   
  81045c:	c1 ea 1b             	shr    $0x1b,%edx
  81045f:	01 d0                	add    %edx,%eax
  810461:	83 e0 1f             	and    $0x1f,%eax
  810464:	29 d0                	sub    %edx,%eax
  810466:	0f b6 44 06 08       	movzbl 0x8(%esi,%eax,1),%eax
  81046b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  81046e:	88 04 19             	mov    %al,(%ecx,%ebx,1)
		p->p_rpos++;
  810471:	83 06 01             	addl   $0x1,(%esi)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  810474:	83 c3 01             	add    $0x1,%ebx
  810477:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  81047a:	75 d8                	jne    810454 <devpipe_read+0x38>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  81047c:	8b 45 10             	mov    0x10(%ebp),%eax
  81047f:	eb 05                	jmp    810486 <devpipe_read+0x6a>
			// if we got any data, return it
			if (i > 0)
				return i;
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
				return 0;
  810481:	b8 00 00 00 00       	mov    $0x0,%eax
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
}
  810486:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810489:	5b                   	pop    %ebx
  81048a:	5e                   	pop    %esi
  81048b:	5f                   	pop    %edi
  81048c:	5d                   	pop    %ebp
  81048d:	c3                   	ret    

0081048e <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  81048e:	55                   	push   %ebp
  81048f:	89 e5                	mov    %esp,%ebp
  810491:	56                   	push   %esi
  810492:	53                   	push   %ebx
  810493:	83 ec 1c             	sub    $0x1c,%esp
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  810496:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810499:	50                   	push   %eax
  81049a:	e8 4d ef ff ff       	call   80f3ec <fd_alloc>
  81049f:	83 c4 10             	add    $0x10,%esp
  8104a2:	89 c2                	mov    %eax,%edx
  8104a4:	85 c0                	test   %eax,%eax
  8104a6:	0f 88 2c 01 00 00    	js     8105d8 <pipe+0x14a>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8104ac:	83 ec 04             	sub    $0x4,%esp
  8104af:	68 07 04 00 00       	push   $0x407
  8104b4:	ff 75 f4             	pushl  -0xc(%ebp)
  8104b7:	6a 00                	push   $0x0
  8104b9:	e8 31 e9 ff ff       	call   80edef <sys_page_alloc>
  8104be:	83 c4 10             	add    $0x10,%esp
  8104c1:	89 c2                	mov    %eax,%edx
  8104c3:	85 c0                	test   %eax,%eax
  8104c5:	0f 88 0d 01 00 00    	js     8105d8 <pipe+0x14a>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  8104cb:	83 ec 0c             	sub    $0xc,%esp
  8104ce:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8104d1:	50                   	push   %eax
  8104d2:	e8 15 ef ff ff       	call   80f3ec <fd_alloc>
  8104d7:	89 c3                	mov    %eax,%ebx
  8104d9:	83 c4 10             	add    $0x10,%esp
  8104dc:	85 c0                	test   %eax,%eax
  8104de:	0f 88 e2 00 00 00    	js     8105c6 <pipe+0x138>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8104e4:	83 ec 04             	sub    $0x4,%esp
  8104e7:	68 07 04 00 00       	push   $0x407
  8104ec:	ff 75 f0             	pushl  -0x10(%ebp)
  8104ef:	6a 00                	push   $0x0
  8104f1:	e8 f9 e8 ff ff       	call   80edef <sys_page_alloc>
  8104f6:	89 c3                	mov    %eax,%ebx
  8104f8:	83 c4 10             	add    $0x10,%esp
  8104fb:	85 c0                	test   %eax,%eax
  8104fd:	0f 88 c3 00 00 00    	js     8105c6 <pipe+0x138>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  810503:	83 ec 0c             	sub    $0xc,%esp
  810506:	ff 75 f4             	pushl  -0xc(%ebp)
  810509:	e8 c7 ee ff ff       	call   80f3d5 <fd2data>
  81050e:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810510:	83 c4 0c             	add    $0xc,%esp
  810513:	68 07 04 00 00       	push   $0x407
  810518:	50                   	push   %eax
  810519:	6a 00                	push   $0x0
  81051b:	e8 cf e8 ff ff       	call   80edef <sys_page_alloc>
  810520:	89 c3                	mov    %eax,%ebx
  810522:	83 c4 10             	add    $0x10,%esp
  810525:	85 c0                	test   %eax,%eax
  810527:	0f 88 89 00 00 00    	js     8105b6 <pipe+0x128>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  81052d:	83 ec 0c             	sub    $0xc,%esp
  810530:	ff 75 f0             	pushl  -0x10(%ebp)
  810533:	e8 9d ee ff ff       	call   80f3d5 <fd2data>
  810538:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  81053f:	50                   	push   %eax
  810540:	6a 00                	push   $0x0
  810542:	56                   	push   %esi
  810543:	6a 00                	push   $0x0
  810545:	e8 e8 e8 ff ff       	call   80ee32 <sys_page_map>
  81054a:	89 c3                	mov    %eax,%ebx
  81054c:	83 c4 20             	add    $0x20,%esp
  81054f:	85 c0                	test   %eax,%eax
  810551:	78 55                	js     8105a8 <pipe+0x11a>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  810553:	8b 15 24 43 81 00    	mov    0x814324,%edx
  810559:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81055c:	89 10                	mov    %edx,(%eax)
	fd0->fd_omode = O_RDONLY;
  81055e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810561:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	fd1->fd_dev_id = devpipe.dev_id;
  810568:	8b 15 24 43 81 00    	mov    0x814324,%edx
  81056e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810571:	89 10                	mov    %edx,(%eax)
	fd1->fd_omode = O_WRONLY;
  810573:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810576:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  81057d:	83 ec 0c             	sub    $0xc,%esp
  810580:	ff 75 f4             	pushl  -0xc(%ebp)
  810583:	e8 3d ee ff ff       	call   80f3c5 <fd2num>
  810588:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81058b:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  81058d:	83 c4 04             	add    $0x4,%esp
  810590:	ff 75 f0             	pushl  -0x10(%ebp)
  810593:	e8 2d ee ff ff       	call   80f3c5 <fd2num>
  810598:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81059b:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  81059e:	83 c4 10             	add    $0x10,%esp
  8105a1:	ba 00 00 00 00       	mov    $0x0,%edx
  8105a6:	eb 30                	jmp    8105d8 <pipe+0x14a>

    err3:
	sys_page_unmap(0, va);
  8105a8:	83 ec 08             	sub    $0x8,%esp
  8105ab:	56                   	push   %esi
  8105ac:	6a 00                	push   $0x0
  8105ae:	e8 c1 e8 ff ff       	call   80ee74 <sys_page_unmap>
  8105b3:	83 c4 10             	add    $0x10,%esp
    err2:
	sys_page_unmap(0, fd1);
  8105b6:	83 ec 08             	sub    $0x8,%esp
  8105b9:	ff 75 f0             	pushl  -0x10(%ebp)
  8105bc:	6a 00                	push   $0x0
  8105be:	e8 b1 e8 ff ff       	call   80ee74 <sys_page_unmap>
  8105c3:	83 c4 10             	add    $0x10,%esp
    err1:
	sys_page_unmap(0, fd0);
  8105c6:	83 ec 08             	sub    $0x8,%esp
  8105c9:	ff 75 f4             	pushl  -0xc(%ebp)
  8105cc:	6a 00                	push   $0x0
  8105ce:	e8 a1 e8 ff ff       	call   80ee74 <sys_page_unmap>
  8105d3:	83 c4 10             	add    $0x10,%esp
  8105d6:	89 da                	mov    %ebx,%edx
    err:
	return r;
}
  8105d8:	89 d0                	mov    %edx,%eax
  8105da:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8105dd:	5b                   	pop    %ebx
  8105de:	5e                   	pop    %esi
  8105df:	5d                   	pop    %ebp
  8105e0:	c3                   	ret    

008105e1 <pipeisclosed>:
	}
}

int
pipeisclosed(int fdnum)
{
  8105e1:	55                   	push   %ebp
  8105e2:	89 e5                	mov    %esp,%ebp
  8105e4:	83 ec 20             	sub    $0x20,%esp
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8105e7:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8105ea:	50                   	push   %eax
  8105eb:	ff 75 08             	pushl  0x8(%ebp)
  8105ee:	e8 48 ee ff ff       	call   80f43b <fd_lookup>
  8105f3:	83 c4 10             	add    $0x10,%esp
  8105f6:	85 c0                	test   %eax,%eax
  8105f8:	78 18                	js     810612 <pipeisclosed+0x31>
		return r;
	p = (struct Pipe*) fd2data(fd);
  8105fa:	83 ec 0c             	sub    $0xc,%esp
  8105fd:	ff 75 f4             	pushl  -0xc(%ebp)
  810600:	e8 d0 ed ff ff       	call   80f3d5 <fd2data>
	return _pipeisclosed(fd, p);
  810605:	89 c2                	mov    %eax,%edx
  810607:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81060a:	e8 21 fd ff ff       	call   810330 <_pipeisclosed>
  81060f:	83 c4 10             	add    $0x10,%esp
}
  810612:	c9                   	leave  
  810613:	c3                   	ret    

00810614 <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  810614:	55                   	push   %ebp
  810615:	89 e5                	mov    %esp,%ebp
	USED(fd);

	return 0;
}
  810617:	b8 00 00 00 00       	mov    $0x0,%eax
  81061c:	5d                   	pop    %ebp
  81061d:	c3                   	ret    

0081061e <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  81061e:	55                   	push   %ebp
  81061f:	89 e5                	mov    %esp,%ebp
  810621:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  810624:	68 14 36 81 00       	push   $0x813614
  810629:	ff 75 0c             	pushl  0xc(%ebp)
  81062c:	e8 bb e3 ff ff       	call   80e9ec <strcpy>
	return 0;
}
  810631:	b8 00 00 00 00       	mov    $0x0,%eax
  810636:	c9                   	leave  
  810637:	c3                   	ret    

00810638 <devcons_write>:
	return 1;
}

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  810638:	55                   	push   %ebp
  810639:	89 e5                	mov    %esp,%ebp
  81063b:	57                   	push   %edi
  81063c:	56                   	push   %esi
  81063d:	53                   	push   %ebx
  81063e:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  810644:	be 00 00 00 00       	mov    $0x0,%esi
		m = n - tot;
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  810649:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  81064f:	eb 2d                	jmp    81067e <devcons_write+0x46>
		m = n - tot;
  810651:	8b 5d 10             	mov    0x10(%ebp),%ebx
  810654:	29 f3                	sub    %esi,%ebx
		if (m > sizeof(buf) - 1)
  810656:	83 fb 7f             	cmp    $0x7f,%ebx
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
		m = n - tot;
  810659:	ba 7f 00 00 00       	mov    $0x7f,%edx
  81065e:	0f 47 da             	cmova  %edx,%ebx
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  810661:	83 ec 04             	sub    $0x4,%esp
  810664:	53                   	push   %ebx
  810665:	03 45 0c             	add    0xc(%ebp),%eax
  810668:	50                   	push   %eax
  810669:	57                   	push   %edi
  81066a:	e8 0f e5 ff ff       	call   80eb7e <memmove>
		sys_cputs(buf, m);
  81066f:	83 c4 08             	add    $0x8,%esp
  810672:	53                   	push   %ebx
  810673:	57                   	push   %edi
  810674:	e8 ba e6 ff ff       	call   80ed33 <sys_cputs>
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  810679:	01 de                	add    %ebx,%esi
  81067b:	83 c4 10             	add    $0x10,%esp
  81067e:	89 f0                	mov    %esi,%eax
  810680:	3b 75 10             	cmp    0x10(%ebp),%esi
  810683:	72 cc                	jb     810651 <devcons_write+0x19>
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
}
  810685:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810688:	5b                   	pop    %ebx
  810689:	5e                   	pop    %esi
  81068a:	5f                   	pop    %edi
  81068b:	5d                   	pop    %ebp
  81068c:	c3                   	ret    

0081068d <devcons_read>:
	return fd2num(fd);
}

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  81068d:	55                   	push   %ebp
  81068e:	89 e5                	mov    %esp,%ebp
  810690:	83 ec 08             	sub    $0x8,%esp
  810693:	b8 00 00 00 00       	mov    $0x0,%eax
	int c;

	if (n == 0)
  810698:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  81069c:	74 2a                	je     8106c8 <devcons_read+0x3b>
  81069e:	eb 05                	jmp    8106a5 <devcons_read+0x18>
		return 0;

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  8106a0:	e8 2b e7 ff ff       	call   80edd0 <sys_yield>
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  8106a5:	e8 a7 e6 ff ff       	call   80ed51 <sys_cgetc>
  8106aa:	85 c0                	test   %eax,%eax
  8106ac:	74 f2                	je     8106a0 <devcons_read+0x13>
		sys_yield();
	if (c < 0)
  8106ae:	85 c0                	test   %eax,%eax
  8106b0:	78 16                	js     8106c8 <devcons_read+0x3b>
		return c;
	if (c == 0x04)	// ctl-d is eof
  8106b2:	83 f8 04             	cmp    $0x4,%eax
  8106b5:	74 0c                	je     8106c3 <devcons_read+0x36>
		return 0;
	*(char*)vbuf = c;
  8106b7:	8b 55 0c             	mov    0xc(%ebp),%edx
  8106ba:	88 02                	mov    %al,(%edx)
	return 1;
  8106bc:	b8 01 00 00 00       	mov    $0x1,%eax
  8106c1:	eb 05                	jmp    8106c8 <devcons_read+0x3b>
	while ((c = sys_cgetc()) == 0)
		sys_yield();
	if (c < 0)
		return c;
	if (c == 0x04)	// ctl-d is eof
		return 0;
  8106c3:	b8 00 00 00 00       	mov    $0x0,%eax
	*(char*)vbuf = c;
	return 1;
}
  8106c8:	c9                   	leave  
  8106c9:	c3                   	ret    

008106ca <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  8106ca:	55                   	push   %ebp
  8106cb:	89 e5                	mov    %esp,%ebp
  8106cd:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  8106d0:	8b 45 08             	mov    0x8(%ebp),%eax
  8106d3:	88 45 f7             	mov    %al,-0x9(%ebp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  8106d6:	6a 01                	push   $0x1
  8106d8:	8d 45 f7             	lea    -0x9(%ebp),%eax
  8106db:	50                   	push   %eax
  8106dc:	e8 52 e6 ff ff       	call   80ed33 <sys_cputs>
}
  8106e1:	83 c4 10             	add    $0x10,%esp
  8106e4:	c9                   	leave  
  8106e5:	c3                   	ret    

008106e6 <getchar>:

int
getchar(void)
{
  8106e6:	55                   	push   %ebp
  8106e7:	89 e5                	mov    %esp,%ebp
  8106e9:	83 ec 1c             	sub    $0x1c,%esp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  8106ec:	6a 01                	push   $0x1
  8106ee:	8d 45 f7             	lea    -0x9(%ebp),%eax
  8106f1:	50                   	push   %eax
  8106f2:	6a 00                	push   $0x0
  8106f4:	e8 a8 ef ff ff       	call   80f6a1 <read>
	if (r < 0)
  8106f9:	83 c4 10             	add    $0x10,%esp
  8106fc:	85 c0                	test   %eax,%eax
  8106fe:	78 0f                	js     81070f <getchar+0x29>
		return r;
	if (r < 1)
  810700:	85 c0                	test   %eax,%eax
  810702:	7e 06                	jle    81070a <getchar+0x24>
		return -E_EOF;
	return c;
  810704:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  810708:	eb 05                	jmp    81070f <getchar+0x29>
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
	if (r < 0)
		return r;
	if (r < 1)
		return -E_EOF;
  81070a:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
	return c;
}
  81070f:	c9                   	leave  
  810710:	c3                   	ret    

00810711 <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  810711:	55                   	push   %ebp
  810712:	89 e5                	mov    %esp,%ebp
  810714:	83 ec 20             	sub    $0x20,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810717:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81071a:	50                   	push   %eax
  81071b:	ff 75 08             	pushl  0x8(%ebp)
  81071e:	e8 18 ed ff ff       	call   80f43b <fd_lookup>
  810723:	83 c4 10             	add    $0x10,%esp
  810726:	85 c0                	test   %eax,%eax
  810728:	78 11                	js     81073b <iscons+0x2a>
		return r;
	return fd->fd_dev_id == devcons.dev_id;
  81072a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81072d:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810733:	39 10                	cmp    %edx,(%eax)
  810735:	0f 94 c0             	sete   %al
  810738:	0f b6 c0             	movzbl %al,%eax
}
  81073b:	c9                   	leave  
  81073c:	c3                   	ret    

0081073d <opencons>:

int
opencons(void)
{
  81073d:	55                   	push   %ebp
  81073e:	89 e5                	mov    %esp,%ebp
  810740:	83 ec 24             	sub    $0x24,%esp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  810743:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810746:	50                   	push   %eax
  810747:	e8 a0 ec ff ff       	call   80f3ec <fd_alloc>
  81074c:	83 c4 10             	add    $0x10,%esp
		return r;
  81074f:	89 c2                	mov    %eax,%edx
opencons(void)
{
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  810751:	85 c0                	test   %eax,%eax
  810753:	78 3e                	js     810793 <opencons+0x56>
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  810755:	83 ec 04             	sub    $0x4,%esp
  810758:	68 07 04 00 00       	push   $0x407
  81075d:	ff 75 f4             	pushl  -0xc(%ebp)
  810760:	6a 00                	push   $0x0
  810762:	e8 88 e6 ff ff       	call   80edef <sys_page_alloc>
  810767:	83 c4 10             	add    $0x10,%esp
		return r;
  81076a:	89 c2                	mov    %eax,%edx
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  81076c:	85 c0                	test   %eax,%eax
  81076e:	78 23                	js     810793 <opencons+0x56>
		return r;
	fd->fd_dev_id = devcons.dev_id;
  810770:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810776:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810779:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  81077b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81077e:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  810785:	83 ec 0c             	sub    $0xc,%esp
  810788:	50                   	push   %eax
  810789:	e8 37 ec ff ff       	call   80f3c5 <fd2num>
  81078e:	89 c2                	mov    %eax,%edx
  810790:	83 c4 10             	add    $0x10,%esp
}
  810793:	89 d0                	mov    %edx,%eax
  810795:	c9                   	leave  
  810796:	c3                   	ret    

00810797 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  810797:	55                   	push   %ebp
  810798:	89 e5                	mov    %esp,%ebp
  81079a:	83 ec 08             	sub    $0x8,%esp
	int r;

	if (_pgfault_handler == 0) {
  81079d:	83 3d 00 e0 b3 00 00 	cmpl   $0x0,0xb3e000
  8107a4:	75 2e                	jne    8107d4 <set_pgfault_handler+0x3d>
		// First time through!
		// LAB 4: Your code here.
		// panic("set_pgfault_handler not implemented");

		sys_page_alloc(sys_getenvid(), (void *) (UXSTACKTOP - PGSIZE), PTE_SYSCALL);
  8107a6:	e8 06 e6 ff ff       	call   80edb1 <sys_getenvid>
  8107ab:	83 ec 04             	sub    $0x4,%esp
  8107ae:	68 07 0e 00 00       	push   $0xe07
  8107b3:	68 00 f0 bf ee       	push   $0xeebff000
  8107b8:	50                   	push   %eax
  8107b9:	e8 31 e6 ff ff       	call   80edef <sys_page_alloc>
		sys_env_set_pgfault_upcall(sys_getenvid(), _pgfault_upcall);
  8107be:	e8 ee e5 ff ff       	call   80edb1 <sys_getenvid>
  8107c3:	83 c4 08             	add    $0x8,%esp
  8107c6:	68 de 07 81 00       	push   $0x8107de
  8107cb:	50                   	push   %eax
  8107cc:	e8 69 e7 ff ff       	call   80ef3a <sys_env_set_pgfault_upcall>
  8107d1:	83 c4 10             	add    $0x10,%esp
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  8107d4:	8b 45 08             	mov    0x8(%ebp),%eax
  8107d7:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
}
  8107dc:	c9                   	leave  
  8107dd:	c3                   	ret    

008107de <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  8107de:	54                   	push   %esp
	movl _pgfault_handler, %eax
  8107df:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
	call *%eax
  8107e4:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  8107e6:	83 c4 04             	add    $0x4,%esp
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.

	movl 48(%esp), %eax		// trap-time esp
  8107e9:	8b 44 24 30          	mov    0x30(%esp),%eax
	movl 40(%esp), %ebx		// trap-time eip
  8107ed:	8b 5c 24 28          	mov    0x28(%esp),%ebx

	// load eip into esp-4
	// in order to return to trap-time eip later, in the meantime not changing trap-time esp
	movl %ebx, -4(%eax)	
  8107f1:	89 58 fc             	mov    %ebx,-0x4(%eax)

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.

	addl $8, %esp 			// esp now points to trap-time registers
  8107f4:	83 c4 08             	add    $0x8,%esp
	popal					// pop to all registers
  8107f7:	61                   	popa   
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.

	addl $4, %esp			// esp now points to trap-time eflags
  8107f8:	83 c4 04             	add    $0x4,%esp
	popfl					// pop to eflags
  8107fb:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.

	popl %esp				// pop to esp
  8107fc:	5c                   	pop    %esp
	// subl $4, %esp		// arithmetic operation will change eflags!!!
	lea -4(%esp), %esp		// subl $4, %esp
  8107fd:	8d 64 24 fc          	lea    -0x4(%esp),%esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.

	ret
  810801:	c3                   	ret    

00810802 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  810802:	55                   	push   %ebp
  810803:	89 e5                	mov    %esp,%ebp
  810805:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  810808:	89 d0                	mov    %edx,%eax
  81080a:	c1 e8 16             	shr    $0x16,%eax
  81080d:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
		return 0;
  810814:	b8 00 00 00 00       	mov    $0x0,%eax
int
pageref(void *v)
{
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  810819:	f6 c1 01             	test   $0x1,%cl
  81081c:	74 1d                	je     81083b <pageref+0x39>
		return 0;
	pte = uvpt[PGNUM(v)];
  81081e:	c1 ea 0c             	shr    $0xc,%edx
  810821:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(pte & PTE_P))
  810828:	f6 c2 01             	test   $0x1,%dl
  81082b:	74 0e                	je     81083b <pageref+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  81082d:	c1 ea 0c             	shr    $0xc,%edx
  810830:	0f b7 04 d5 04 00 00 	movzwl -0x10fffffc(,%edx,8),%eax
  810837:	ef 
  810838:	0f b7 c0             	movzwl %ax,%eax
}
  81083b:	5d                   	pop    %ebp
  81083c:	c3                   	ret    
  81083d:	66 90                	xchg   %ax,%ax
  81083f:	90                   	nop

00810840 <__udivdi3>:
  810840:	55                   	push   %ebp
  810841:	57                   	push   %edi
  810842:	56                   	push   %esi
  810843:	53                   	push   %ebx
  810844:	83 ec 1c             	sub    $0x1c,%esp
  810847:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  81084b:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  81084f:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  810853:	8b 7c 24 38          	mov    0x38(%esp),%edi
  810857:	85 f6                	test   %esi,%esi
  810859:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  81085d:	89 ca                	mov    %ecx,%edx
  81085f:	89 f8                	mov    %edi,%eax
  810861:	75 3d                	jne    8108a0 <__udivdi3+0x60>
  810863:	39 cf                	cmp    %ecx,%edi
  810865:	0f 87 c5 00 00 00    	ja     810930 <__udivdi3+0xf0>
  81086b:	85 ff                	test   %edi,%edi
  81086d:	89 fd                	mov    %edi,%ebp
  81086f:	75 0b                	jne    81087c <__udivdi3+0x3c>
  810871:	b8 01 00 00 00       	mov    $0x1,%eax
  810876:	31 d2                	xor    %edx,%edx
  810878:	f7 f7                	div    %edi
  81087a:	89 c5                	mov    %eax,%ebp
  81087c:	89 c8                	mov    %ecx,%eax
  81087e:	31 d2                	xor    %edx,%edx
  810880:	f7 f5                	div    %ebp
  810882:	89 c1                	mov    %eax,%ecx
  810884:	89 d8                	mov    %ebx,%eax
  810886:	89 cf                	mov    %ecx,%edi
  810888:	f7 f5                	div    %ebp
  81088a:	89 c3                	mov    %eax,%ebx
  81088c:	89 d8                	mov    %ebx,%eax
  81088e:	89 fa                	mov    %edi,%edx
  810890:	83 c4 1c             	add    $0x1c,%esp
  810893:	5b                   	pop    %ebx
  810894:	5e                   	pop    %esi
  810895:	5f                   	pop    %edi
  810896:	5d                   	pop    %ebp
  810897:	c3                   	ret    
  810898:	90                   	nop
  810899:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8108a0:	39 ce                	cmp    %ecx,%esi
  8108a2:	77 74                	ja     810918 <__udivdi3+0xd8>
  8108a4:	0f bd fe             	bsr    %esi,%edi
  8108a7:	83 f7 1f             	xor    $0x1f,%edi
  8108aa:	0f 84 98 00 00 00    	je     810948 <__udivdi3+0x108>
  8108b0:	bb 20 00 00 00       	mov    $0x20,%ebx
  8108b5:	89 f9                	mov    %edi,%ecx
  8108b7:	89 c5                	mov    %eax,%ebp
  8108b9:	29 fb                	sub    %edi,%ebx
  8108bb:	d3 e6                	shl    %cl,%esi
  8108bd:	89 d9                	mov    %ebx,%ecx
  8108bf:	d3 ed                	shr    %cl,%ebp
  8108c1:	89 f9                	mov    %edi,%ecx
  8108c3:	d3 e0                	shl    %cl,%eax
  8108c5:	09 ee                	or     %ebp,%esi
  8108c7:	89 d9                	mov    %ebx,%ecx
  8108c9:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8108cd:	89 d5                	mov    %edx,%ebp
  8108cf:	8b 44 24 08          	mov    0x8(%esp),%eax
  8108d3:	d3 ed                	shr    %cl,%ebp
  8108d5:	89 f9                	mov    %edi,%ecx
  8108d7:	d3 e2                	shl    %cl,%edx
  8108d9:	89 d9                	mov    %ebx,%ecx
  8108db:	d3 e8                	shr    %cl,%eax
  8108dd:	09 c2                	or     %eax,%edx
  8108df:	89 d0                	mov    %edx,%eax
  8108e1:	89 ea                	mov    %ebp,%edx
  8108e3:	f7 f6                	div    %esi
  8108e5:	89 d5                	mov    %edx,%ebp
  8108e7:	89 c3                	mov    %eax,%ebx
  8108e9:	f7 64 24 0c          	mull   0xc(%esp)
  8108ed:	39 d5                	cmp    %edx,%ebp
  8108ef:	72 10                	jb     810901 <__udivdi3+0xc1>
  8108f1:	8b 74 24 08          	mov    0x8(%esp),%esi
  8108f5:	89 f9                	mov    %edi,%ecx
  8108f7:	d3 e6                	shl    %cl,%esi
  8108f9:	39 c6                	cmp    %eax,%esi
  8108fb:	73 07                	jae    810904 <__udivdi3+0xc4>
  8108fd:	39 d5                	cmp    %edx,%ebp
  8108ff:	75 03                	jne    810904 <__udivdi3+0xc4>
  810901:	83 eb 01             	sub    $0x1,%ebx
  810904:	31 ff                	xor    %edi,%edi
  810906:	89 d8                	mov    %ebx,%eax
  810908:	89 fa                	mov    %edi,%edx
  81090a:	83 c4 1c             	add    $0x1c,%esp
  81090d:	5b                   	pop    %ebx
  81090e:	5e                   	pop    %esi
  81090f:	5f                   	pop    %edi
  810910:	5d                   	pop    %ebp
  810911:	c3                   	ret    
  810912:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810918:	31 ff                	xor    %edi,%edi
  81091a:	31 db                	xor    %ebx,%ebx
  81091c:	89 d8                	mov    %ebx,%eax
  81091e:	89 fa                	mov    %edi,%edx
  810920:	83 c4 1c             	add    $0x1c,%esp
  810923:	5b                   	pop    %ebx
  810924:	5e                   	pop    %esi
  810925:	5f                   	pop    %edi
  810926:	5d                   	pop    %ebp
  810927:	c3                   	ret    
  810928:	90                   	nop
  810929:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810930:	89 d8                	mov    %ebx,%eax
  810932:	f7 f7                	div    %edi
  810934:	31 ff                	xor    %edi,%edi
  810936:	89 c3                	mov    %eax,%ebx
  810938:	89 d8                	mov    %ebx,%eax
  81093a:	89 fa                	mov    %edi,%edx
  81093c:	83 c4 1c             	add    $0x1c,%esp
  81093f:	5b                   	pop    %ebx
  810940:	5e                   	pop    %esi
  810941:	5f                   	pop    %edi
  810942:	5d                   	pop    %ebp
  810943:	c3                   	ret    
  810944:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810948:	39 ce                	cmp    %ecx,%esi
  81094a:	72 0c                	jb     810958 <__udivdi3+0x118>
  81094c:	31 db                	xor    %ebx,%ebx
  81094e:	3b 44 24 08          	cmp    0x8(%esp),%eax
  810952:	0f 87 34 ff ff ff    	ja     81088c <__udivdi3+0x4c>
  810958:	bb 01 00 00 00       	mov    $0x1,%ebx
  81095d:	e9 2a ff ff ff       	jmp    81088c <__udivdi3+0x4c>
  810962:	66 90                	xchg   %ax,%ax
  810964:	66 90                	xchg   %ax,%ax
  810966:	66 90                	xchg   %ax,%ax
  810968:	66 90                	xchg   %ax,%ax
  81096a:	66 90                	xchg   %ax,%ax
  81096c:	66 90                	xchg   %ax,%ax
  81096e:	66 90                	xchg   %ax,%ax

00810970 <__umoddi3>:
  810970:	55                   	push   %ebp
  810971:	57                   	push   %edi
  810972:	56                   	push   %esi
  810973:	53                   	push   %ebx
  810974:	83 ec 1c             	sub    $0x1c,%esp
  810977:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  81097b:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  81097f:	8b 74 24 34          	mov    0x34(%esp),%esi
  810983:	8b 7c 24 38          	mov    0x38(%esp),%edi
  810987:	85 d2                	test   %edx,%edx
  810989:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  81098d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810991:	89 f3                	mov    %esi,%ebx
  810993:	89 3c 24             	mov    %edi,(%esp)
  810996:	89 74 24 04          	mov    %esi,0x4(%esp)
  81099a:	75 1c                	jne    8109b8 <__umoddi3+0x48>
  81099c:	39 f7                	cmp    %esi,%edi
  81099e:	76 50                	jbe    8109f0 <__umoddi3+0x80>
  8109a0:	89 c8                	mov    %ecx,%eax
  8109a2:	89 f2                	mov    %esi,%edx
  8109a4:	f7 f7                	div    %edi
  8109a6:	89 d0                	mov    %edx,%eax
  8109a8:	31 d2                	xor    %edx,%edx
  8109aa:	83 c4 1c             	add    $0x1c,%esp
  8109ad:	5b                   	pop    %ebx
  8109ae:	5e                   	pop    %esi
  8109af:	5f                   	pop    %edi
  8109b0:	5d                   	pop    %ebp
  8109b1:	c3                   	ret    
  8109b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  8109b8:	39 f2                	cmp    %esi,%edx
  8109ba:	89 d0                	mov    %edx,%eax
  8109bc:	77 52                	ja     810a10 <__umoddi3+0xa0>
  8109be:	0f bd ea             	bsr    %edx,%ebp
  8109c1:	83 f5 1f             	xor    $0x1f,%ebp
  8109c4:	75 5a                	jne    810a20 <__umoddi3+0xb0>
  8109c6:	3b 54 24 04          	cmp    0x4(%esp),%edx
  8109ca:	0f 82 e0 00 00 00    	jb     810ab0 <__umoddi3+0x140>
  8109d0:	39 0c 24             	cmp    %ecx,(%esp)
  8109d3:	0f 86 d7 00 00 00    	jbe    810ab0 <__umoddi3+0x140>
  8109d9:	8b 44 24 08          	mov    0x8(%esp),%eax
  8109dd:	8b 54 24 04          	mov    0x4(%esp),%edx
  8109e1:	83 c4 1c             	add    $0x1c,%esp
  8109e4:	5b                   	pop    %ebx
  8109e5:	5e                   	pop    %esi
  8109e6:	5f                   	pop    %edi
  8109e7:	5d                   	pop    %ebp
  8109e8:	c3                   	ret    
  8109e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8109f0:	85 ff                	test   %edi,%edi
  8109f2:	89 fd                	mov    %edi,%ebp
  8109f4:	75 0b                	jne    810a01 <__umoddi3+0x91>
  8109f6:	b8 01 00 00 00       	mov    $0x1,%eax
  8109fb:	31 d2                	xor    %edx,%edx
  8109fd:	f7 f7                	div    %edi
  8109ff:	89 c5                	mov    %eax,%ebp
  810a01:	89 f0                	mov    %esi,%eax
  810a03:	31 d2                	xor    %edx,%edx
  810a05:	f7 f5                	div    %ebp
  810a07:	89 c8                	mov    %ecx,%eax
  810a09:	f7 f5                	div    %ebp
  810a0b:	89 d0                	mov    %edx,%eax
  810a0d:	eb 99                	jmp    8109a8 <__umoddi3+0x38>
  810a0f:	90                   	nop
  810a10:	89 c8                	mov    %ecx,%eax
  810a12:	89 f2                	mov    %esi,%edx
  810a14:	83 c4 1c             	add    $0x1c,%esp
  810a17:	5b                   	pop    %ebx
  810a18:	5e                   	pop    %esi
  810a19:	5f                   	pop    %edi
  810a1a:	5d                   	pop    %ebp
  810a1b:	c3                   	ret    
  810a1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810a20:	8b 34 24             	mov    (%esp),%esi
  810a23:	bf 20 00 00 00       	mov    $0x20,%edi
  810a28:	89 e9                	mov    %ebp,%ecx
  810a2a:	29 ef                	sub    %ebp,%edi
  810a2c:	d3 e0                	shl    %cl,%eax
  810a2e:	89 f9                	mov    %edi,%ecx
  810a30:	89 f2                	mov    %esi,%edx
  810a32:	d3 ea                	shr    %cl,%edx
  810a34:	89 e9                	mov    %ebp,%ecx
  810a36:	09 c2                	or     %eax,%edx
  810a38:	89 d8                	mov    %ebx,%eax
  810a3a:	89 14 24             	mov    %edx,(%esp)
  810a3d:	89 f2                	mov    %esi,%edx
  810a3f:	d3 e2                	shl    %cl,%edx
  810a41:	89 f9                	mov    %edi,%ecx
  810a43:	89 54 24 04          	mov    %edx,0x4(%esp)
  810a47:	8b 54 24 0c          	mov    0xc(%esp),%edx
  810a4b:	d3 e8                	shr    %cl,%eax
  810a4d:	89 e9                	mov    %ebp,%ecx
  810a4f:	89 c6                	mov    %eax,%esi
  810a51:	d3 e3                	shl    %cl,%ebx
  810a53:	89 f9                	mov    %edi,%ecx
  810a55:	89 d0                	mov    %edx,%eax
  810a57:	d3 e8                	shr    %cl,%eax
  810a59:	89 e9                	mov    %ebp,%ecx
  810a5b:	09 d8                	or     %ebx,%eax
  810a5d:	89 d3                	mov    %edx,%ebx
  810a5f:	89 f2                	mov    %esi,%edx
  810a61:	f7 34 24             	divl   (%esp)
  810a64:	89 d6                	mov    %edx,%esi
  810a66:	d3 e3                	shl    %cl,%ebx
  810a68:	f7 64 24 04          	mull   0x4(%esp)
  810a6c:	39 d6                	cmp    %edx,%esi
  810a6e:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810a72:	89 d1                	mov    %edx,%ecx
  810a74:	89 c3                	mov    %eax,%ebx
  810a76:	72 08                	jb     810a80 <__umoddi3+0x110>
  810a78:	75 11                	jne    810a8b <__umoddi3+0x11b>
  810a7a:	39 44 24 08          	cmp    %eax,0x8(%esp)
  810a7e:	73 0b                	jae    810a8b <__umoddi3+0x11b>
  810a80:	2b 44 24 04          	sub    0x4(%esp),%eax
  810a84:	1b 14 24             	sbb    (%esp),%edx
  810a87:	89 d1                	mov    %edx,%ecx
  810a89:	89 c3                	mov    %eax,%ebx
  810a8b:	8b 54 24 08          	mov    0x8(%esp),%edx
  810a8f:	29 da                	sub    %ebx,%edx
  810a91:	19 ce                	sbb    %ecx,%esi
  810a93:	89 f9                	mov    %edi,%ecx
  810a95:	89 f0                	mov    %esi,%eax
  810a97:	d3 e0                	shl    %cl,%eax
  810a99:	89 e9                	mov    %ebp,%ecx
  810a9b:	d3 ea                	shr    %cl,%edx
  810a9d:	89 e9                	mov    %ebp,%ecx
  810a9f:	d3 ee                	shr    %cl,%esi
  810aa1:	09 d0                	or     %edx,%eax
  810aa3:	89 f2                	mov    %esi,%edx
  810aa5:	83 c4 1c             	add    $0x1c,%esp
  810aa8:	5b                   	pop    %ebx
  810aa9:	5e                   	pop    %esi
  810aaa:	5f                   	pop    %edi
  810aab:	5d                   	pop    %ebp
  810aac:	c3                   	ret    
  810aad:	8d 76 00             	lea    0x0(%esi),%esi
  810ab0:	29 f9                	sub    %edi,%ecx
  810ab2:	19 d6                	sbb    %edx,%esi
  810ab4:	89 74 24 04          	mov    %esi,0x4(%esp)
  810ab8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810abc:	e9 18 ff ff ff       	jmp    8109d9 <__umoddi3+0x69>
